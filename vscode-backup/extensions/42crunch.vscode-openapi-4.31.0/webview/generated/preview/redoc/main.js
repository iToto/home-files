var JF = Object.defineProperty;
var ZF = (e, t, r) => t in e ? JF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var D_ = (e, t, r) => ZF(e, typeof t != "symbol" ? t + "" : t, r);
var pn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Hb(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Ri(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var nT = { exports: {} }, Cm = {}, iT = { exports: {} }, lt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var np = Symbol.for("react.element"), ez = Symbol.for("react.portal"), tz = Symbol.for("react.fragment"), rz = Symbol.for("react.strict_mode"), nz = Symbol.for("react.profiler"), iz = Symbol.for("react.provider"), oz = Symbol.for("react.context"), sz = Symbol.for("react.forward_ref"), az = Symbol.for("react.suspense"), lz = Symbol.for("react.memo"), uz = Symbol.for("react.lazy"), F_ = Symbol.iterator;
function cz(e) {
  return e === null || typeof e != "object" ? null : (e = F_ && e[F_] || e["@@iterator"], typeof e == "function" ? e : null);
}
var oT = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, sT = Object.assign, aT = {};
function Fl(e, t, r) {
  this.props = e, this.context = t, this.refs = aT, this.updater = r || oT;
}
Fl.prototype.isReactComponent = {};
Fl.prototype.setState = function(e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e, t, "setState");
};
Fl.prototype.forceUpdate = function(e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function lT() {
}
lT.prototype = Fl.prototype;
function Qb(e, t, r) {
  this.props = e, this.context = t, this.refs = aT, this.updater = r || oT;
}
var Yb = Qb.prototype = new lT();
Yb.constructor = Qb;
sT(Yb, Fl.prototype);
Yb.isPureReactComponent = !0;
var z_ = Array.isArray, uT = Object.prototype.hasOwnProperty, Gb = { current: null }, cT = { key: !0, ref: !0, __self: !0, __source: !0 };
function pT(e, t, r) {
  var n, i = {}, s = null, o = null;
  if (t != null) for (n in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (s = "" + t.key), t) uT.call(t, n) && !cT.hasOwnProperty(n) && (i[n] = t[n]);
  var a = arguments.length - 2;
  if (a === 1) i.children = r;
  else if (1 < a) {
    for (var l = Array(a), p = 0; p < a; p++) l[p] = arguments[p + 2];
    i.children = l;
  }
  if (e && e.defaultProps) for (n in a = e.defaultProps, a) i[n] === void 0 && (i[n] = a[n]);
  return { $$typeof: np, type: e, key: s, ref: o, props: i, _owner: Gb.current };
}
function pz(e, t) {
  return { $$typeof: np, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner };
}
function Kb(e) {
  return typeof e == "object" && e !== null && e.$$typeof === np;
}
function fz(e) {
  var t = { "=": "=0", ":": "=2" };
  return "$" + e.replace(/[=:]/g, function(r) {
    return t[r];
  });
}
var q_ = /\/+/g;
function cy(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? fz("" + e.key) : t.toString(36);
}
function sh(e, t, r, n, i) {
  var s = typeof e;
  (s === "undefined" || s === "boolean") && (e = null);
  var o = !1;
  if (e === null) o = !0;
  else switch (s) {
    case "string":
    case "number":
      o = !0;
      break;
    case "object":
      switch (e.$$typeof) {
        case np:
        case ez:
          o = !0;
      }
  }
  if (o) return o = e, i = i(o), e = n === "" ? "." + cy(o, 0) : n, z_(i) ? (r = "", e != null && (r = e.replace(q_, "$&/") + "/"), sh(i, t, r, "", function(p) {
    return p;
  })) : i != null && (Kb(i) && (i = pz(i, r + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(q_, "$&/") + "/") + e)), t.push(i)), 1;
  if (o = 0, n = n === "" ? "." : n + ":", z_(e)) for (var a = 0; a < e.length; a++) {
    s = e[a];
    var l = n + cy(s, a);
    o += sh(s, t, r, l, i);
  }
  else if (l = cz(e), typeof l == "function") for (e = l.call(e), a = 0; !(s = e.next()).done; ) s = s.value, l = n + cy(s, a++), o += sh(s, t, r, l, i);
  else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
  return o;
}
function kf(e, t, r) {
  if (e == null) return e;
  var n = [], i = 0;
  return sh(e, n, "", "", function(s) {
    return t.call(r, s, i++);
  }), n;
}
function dz(e) {
  if (e._status === -1) {
    var t = e._result;
    t = t(), t.then(function(r) {
      (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r);
    }, function(r) {
      (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r);
    }), e._status === -1 && (e._status = 0, e._result = t);
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var zr = { current: null }, ah = { transition: null }, hz = { ReactCurrentDispatcher: zr, ReactCurrentBatchConfig: ah, ReactCurrentOwner: Gb };
function fT() {
  throw Error("act(...) is not supported in production builds of React.");
}
lt.Children = { map: kf, forEach: function(e, t, r) {
  kf(e, function() {
    t.apply(this, arguments);
  }, r);
}, count: function(e) {
  var t = 0;
  return kf(e, function() {
    t++;
  }), t;
}, toArray: function(e) {
  return kf(e, function(t) {
    return t;
  }) || [];
}, only: function(e) {
  if (!Kb(e)) throw Error("React.Children.only expected to receive a single React element child.");
  return e;
} };
lt.Component = Fl;
lt.Fragment = tz;
lt.Profiler = nz;
lt.PureComponent = Qb;
lt.StrictMode = rz;
lt.Suspense = az;
lt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hz;
lt.act = fT;
lt.cloneElement = function(e, t, r) {
  if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
  var n = sT({}, e.props), i = e.key, s = e.ref, o = e._owner;
  if (t != null) {
    if (t.ref !== void 0 && (s = t.ref, o = Gb.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps;
    for (l in t) uT.call(t, l) && !cT.hasOwnProperty(l) && (n[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) n.children = r;
  else if (1 < l) {
    a = Array(l);
    for (var p = 0; p < l; p++) a[p] = arguments[p + 2];
    n.children = a;
  }
  return { $$typeof: np, type: e.type, key: i, ref: s, props: n, _owner: o };
};
lt.createContext = function(e) {
  return e = { $$typeof: oz, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: iz, _context: e }, e.Consumer = e;
};
lt.createElement = pT;
lt.createFactory = function(e) {
  var t = pT.bind(null, e);
  return t.type = e, t;
};
lt.createRef = function() {
  return { current: null };
};
lt.forwardRef = function(e) {
  return { $$typeof: sz, render: e };
};
lt.isValidElement = Kb;
lt.lazy = function(e) {
  return { $$typeof: uz, _payload: { _status: -1, _result: e }, _init: dz };
};
lt.memo = function(e, t) {
  return { $$typeof: lz, type: e, compare: t === void 0 ? null : t };
};
lt.startTransition = function(e) {
  var t = ah.transition;
  ah.transition = {};
  try {
    e();
  } finally {
    ah.transition = t;
  }
};
lt.unstable_act = fT;
lt.useCallback = function(e, t) {
  return zr.current.useCallback(e, t);
};
lt.useContext = function(e) {
  return zr.current.useContext(e);
};
lt.useDebugValue = function() {
};
lt.useDeferredValue = function(e) {
  return zr.current.useDeferredValue(e);
};
lt.useEffect = function(e, t) {
  return zr.current.useEffect(e, t);
};
lt.useId = function() {
  return zr.current.useId();
};
lt.useImperativeHandle = function(e, t, r) {
  return zr.current.useImperativeHandle(e, t, r);
};
lt.useInsertionEffect = function(e, t) {
  return zr.current.useInsertionEffect(e, t);
};
lt.useLayoutEffect = function(e, t) {
  return zr.current.useLayoutEffect(e, t);
};
lt.useMemo = function(e, t) {
  return zr.current.useMemo(e, t);
};
lt.useReducer = function(e, t, r) {
  return zr.current.useReducer(e, t, r);
};
lt.useRef = function(e) {
  return zr.current.useRef(e);
};
lt.useState = function(e) {
  return zr.current.useState(e);
};
lt.useSyncExternalStore = function(e, t, r) {
  return zr.current.useSyncExternalStore(e, t, r);
};
lt.useTransition = function() {
  return zr.current.useTransition();
};
lt.version = "18.3.1";
iT.exports = lt;
var et = iT.exports;
const at = /* @__PURE__ */ Hb(et);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mz = et, gz = Symbol.for("react.element"), yz = Symbol.for("react.fragment"), vz = Object.prototype.hasOwnProperty, bz = mz.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, wz = { key: !0, ref: !0, __self: !0, __source: !0 };
function dT(e, t, r) {
  var n, i = {}, s = null, o = null;
  r !== void 0 && (s = "" + r), t.key !== void 0 && (s = "" + t.key), t.ref !== void 0 && (o = t.ref);
  for (n in t) vz.call(t, n) && !wz.hasOwnProperty(n) && (i[n] = t[n]);
  if (e && e.defaultProps) for (n in t = e.defaultProps, t) i[n] === void 0 && (i[n] = t[n]);
  return { $$typeof: gz, type: e, key: s, ref: o, props: i, _owner: bz.current };
}
Cm.Fragment = yz;
Cm.jsx = dT;
Cm.jsxs = dT;
nT.exports = Cm;
var p0 = nT.exports, hT = { exports: {} }, yn = {}, mT = { exports: {} }, gT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
  function t(G, Z) {
    var K = G.length;
    G.push(Z);
    e: for (; 0 < K; ) {
      var z = K - 1 >>> 1, te = G[z];
      if (0 < i(te, Z)) G[z] = Z, G[K] = te, K = z;
      else break e;
    }
  }
  function r(G) {
    return G.length === 0 ? null : G[0];
  }
  function n(G) {
    if (G.length === 0) return null;
    var Z = G[0], K = G.pop();
    if (K !== Z) {
      G[0] = K;
      e: for (var z = 0, te = G.length, q = te >>> 1; z < q; ) {
        var j = 2 * (z + 1) - 1, H = G[j], F = j + 1, ue = G[F];
        if (0 > i(H, K)) F < te && 0 > i(ue, H) ? (G[z] = ue, G[F] = K, z = F) : (G[z] = H, G[j] = K, z = j);
        else if (F < te && 0 > i(ue, K)) G[z] = ue, G[F] = K, z = F;
        else break e;
      }
    }
    return Z;
  }
  function i(G, Z) {
    var K = G.sortIndex - Z.sortIndex;
    return K !== 0 ? K : G.id - Z.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    e.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, a = o.now();
    e.unstable_now = function() {
      return o.now() - a;
    };
  }
  var l = [], p = [], f = 1, d = null, m = 3, v = !1, g = !1, S = !1, _ = typeof setTimeout == "function" ? setTimeout : null, x = typeof clearTimeout == "function" ? clearTimeout : null, y = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function w(G) {
    for (var Z = r(p); Z !== null; ) {
      if (Z.callback === null) n(p);
      else if (Z.startTime <= G) n(p), Z.sortIndex = Z.expirationTime, t(l, Z);
      else break;
      Z = r(p);
    }
  }
  function k(G) {
    if (S = !1, w(G), !g) if (r(l) !== null) g = !0, pe(A);
    else {
      var Z = r(p);
      Z !== null && fe(k, Z.startTime - G);
    }
  }
  function A(G, Z) {
    g = !1, S && (S = !1, x(I), I = -1), v = !0;
    var K = m;
    try {
      for (w(Z), d = r(l); d !== null && (!(d.expirationTime > Z) || G && !Y()); ) {
        var z = d.callback;
        if (typeof z == "function") {
          d.callback = null, m = d.priorityLevel;
          var te = z(d.expirationTime <= Z);
          Z = e.unstable_now(), typeof te == "function" ? d.callback = te : d === r(l) && n(l), w(Z);
        } else n(l);
        d = r(l);
      }
      if (d !== null) var q = !0;
      else {
        var j = r(p);
        j !== null && fe(k, j.startTime - Z), q = !1;
      }
      return q;
    } finally {
      d = null, m = K, v = !1;
    }
  }
  var T = !1, R = null, I = -1, B = 5, L = -1;
  function Y() {
    return !(e.unstable_now() - L < B);
  }
  function Q() {
    if (R !== null) {
      var G = e.unstable_now();
      L = G;
      var Z = !0;
      try {
        Z = R(!0, G);
      } finally {
        Z ? re() : (T = !1, R = null);
      }
    } else T = !1;
  }
  var re;
  if (typeof y == "function") re = function() {
    y(Q);
  };
  else if (typeof MessageChannel < "u") {
    var oe = new MessageChannel(), ce = oe.port2;
    oe.port1.onmessage = Q, re = function() {
      ce.postMessage(null);
    };
  } else re = function() {
    _(Q, 0);
  };
  function pe(G) {
    R = G, T || (T = !0, re());
  }
  function fe(G, Z) {
    I = _(function() {
      G(e.unstable_now());
    }, Z);
  }
  e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(G) {
    G.callback = null;
  }, e.unstable_continueExecution = function() {
    g || v || (g = !0, pe(A));
  }, e.unstable_forceFrameRate = function(G) {
    0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < G ? Math.floor(1e3 / G) : 5;
  }, e.unstable_getCurrentPriorityLevel = function() {
    return m;
  }, e.unstable_getFirstCallbackNode = function() {
    return r(l);
  }, e.unstable_next = function(G) {
    switch (m) {
      case 1:
      case 2:
      case 3:
        var Z = 3;
        break;
      default:
        Z = m;
    }
    var K = m;
    m = Z;
    try {
      return G();
    } finally {
      m = K;
    }
  }, e.unstable_pauseExecution = function() {
  }, e.unstable_requestPaint = function() {
  }, e.unstable_runWithPriority = function(G, Z) {
    switch (G) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        G = 3;
    }
    var K = m;
    m = G;
    try {
      return Z();
    } finally {
      m = K;
    }
  }, e.unstable_scheduleCallback = function(G, Z, K) {
    var z = e.unstable_now();
    switch (typeof K == "object" && K !== null ? (K = K.delay, K = typeof K == "number" && 0 < K ? z + K : z) : K = z, G) {
      case 1:
        var te = -1;
        break;
      case 2:
        te = 250;
        break;
      case 5:
        te = 1073741823;
        break;
      case 4:
        te = 1e4;
        break;
      default:
        te = 5e3;
    }
    return te = K + te, G = { id: f++, callback: Z, priorityLevel: G, startTime: K, expirationTime: te, sortIndex: -1 }, K > z ? (G.sortIndex = K, t(p, G), r(l) === null && G === r(p) && (S ? (x(I), I = -1) : S = !0, fe(k, K - z))) : (G.sortIndex = te, t(l, G), g || v || (g = !0, pe(A))), G;
  }, e.unstable_shouldYield = Y, e.unstable_wrapCallback = function(G) {
    var Z = m;
    return function() {
      var K = m;
      m = Z;
      try {
        return G.apply(this, arguments);
      } finally {
        m = K;
      }
    };
  };
})(gT);
mT.exports = gT;
var Sz = mT.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xz = et, mn = Sz;
function je(e) {
  for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++) t += "&args[]=" + encodeURIComponent(arguments[r]);
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var yT = /* @__PURE__ */ new Set(), Oc = {};
function la(e, t) {
  bl(e, t), bl(e + "Capture", t);
}
function bl(e, t) {
  for (Oc[e] = t, e = 0; e < t.length; e++) yT.add(t[e]);
}
var so = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), f0 = Object.prototype.hasOwnProperty, _z = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, B_ = {}, U_ = {};
function Ez(e) {
  return f0.call(U_, e) ? !0 : f0.call(B_, e) ? !1 : _z.test(e) ? U_[e] = !0 : (B_[e] = !0, !1);
}
function Oz(e, t, r, n) {
  if (r !== null && r.type === 0) return !1;
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return n ? !1 : r !== null ? !r.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
    default:
      return !1;
  }
}
function kz(e, t, r, n) {
  if (t === null || typeof t > "u" || Oz(e, t, r, n)) return !0;
  if (n) return !1;
  if (r !== null) switch (r.type) {
    case 3:
      return !t;
    case 4:
      return t === !1;
    case 5:
      return isNaN(t);
    case 6:
      return isNaN(t) || 1 > t;
  }
  return !1;
}
function qr(e, t, r, n, i, s, o) {
  this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = n, this.attributeNamespace = i, this.mustUseProperty = r, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o;
}
var Sr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
  Sr[e] = new qr(e, 0, !1, e, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
  var t = e[0];
  Sr[t] = new qr(t, 1, !1, e[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
  Sr[e] = new qr(e, 2, !1, e.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
  Sr[e] = new qr(e, 2, !1, e, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
  Sr[e] = new qr(e, 3, !1, e.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
  Sr[e] = new qr(e, 3, !0, e, null, !1, !1);
});
["capture", "download"].forEach(function(e) {
  Sr[e] = new qr(e, 4, !1, e, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(e) {
  Sr[e] = new qr(e, 6, !1, e, null, !1, !1);
});
["rowSpan", "start"].forEach(function(e) {
  Sr[e] = new qr(e, 5, !1, e.toLowerCase(), null, !1, !1);
});
var Xb = /[\-:]([a-z])/g;
function Jb(e) {
  return e[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
  var t = e.replace(
    Xb,
    Jb
  );
  Sr[t] = new qr(t, 1, !1, e, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
  var t = e.replace(Xb, Jb);
  Sr[t] = new qr(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
  var t = e.replace(Xb, Jb);
  Sr[t] = new qr(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(e) {
  Sr[e] = new qr(e, 1, !1, e.toLowerCase(), null, !1, !1);
});
Sr.xlinkHref = new qr("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(e) {
  Sr[e] = new qr(e, 1, !1, e.toLowerCase(), null, !0, !0);
});
function Zb(e, t, r, n) {
  var i = Sr.hasOwnProperty(t) ? Sr[t] : null;
  (i !== null ? i.type !== 0 : n || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (kz(t, r, i, n) && (r = null), n || i === null ? Ez(t) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, "" + r)) : i.mustUseProperty ? e[i.propertyName] = r === null ? i.type === 3 ? !1 : "" : r : (t = i.attributeName, n = i.attributeNamespace, r === null ? e.removeAttribute(t) : (i = i.type, r = i === 3 || i === 4 && r === !0 ? "" : "" + r, n ? e.setAttributeNS(n, t, r) : e.setAttribute(t, r))));
}
var vo = xz.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Af = Symbol.for("react.element"), Ga = Symbol.for("react.portal"), Ka = Symbol.for("react.fragment"), ew = Symbol.for("react.strict_mode"), d0 = Symbol.for("react.profiler"), vT = Symbol.for("react.provider"), bT = Symbol.for("react.context"), tw = Symbol.for("react.forward_ref"), h0 = Symbol.for("react.suspense"), m0 = Symbol.for("react.suspense_list"), rw = Symbol.for("react.memo"), To = Symbol.for("react.lazy"), wT = Symbol.for("react.offscreen"), V_ = Symbol.iterator;
function $u(e) {
  return e === null || typeof e != "object" ? null : (e = V_ && e[V_] || e["@@iterator"], typeof e == "function" ? e : null);
}
var Ut = Object.assign, py;
function tc(e) {
  if (py === void 0) try {
    throw Error();
  } catch (r) {
    var t = r.stack.trim().match(/\n( *(at )?)/);
    py = t && t[1] || "";
  }
  return `
` + py + e;
}
var fy = !1;
function dy(e, t) {
  if (!e || fy) return "";
  fy = !0;
  var r = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (t) if (t = function() {
      throw Error();
    }, Object.defineProperty(t.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(t, []);
      } catch (p) {
        var n = p;
      }
      Reflect.construct(e, [], t);
    } else {
      try {
        t.call();
      } catch (p) {
        n = p;
      }
      e.call(t.prototype);
    }
    else {
      try {
        throw Error();
      } catch (p) {
        n = p;
      }
      e();
    }
  } catch (p) {
    if (p && n && typeof p.stack == "string") {
      for (var i = p.stack.split(`
`), s = n.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a]; ) a--;
      for (; 1 <= o && 0 <= a; o--, a--) if (i[o] !== s[a]) {
        if (o !== 1 || a !== 1)
          do
            if (o--, a--, 0 > a || i[o] !== s[a]) {
              var l = `
` + i[o].replace(" at new ", " at ");
              return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l;
            }
          while (1 <= o && 0 <= a);
        break;
      }
    }
  } finally {
    fy = !1, Error.prepareStackTrace = r;
  }
  return (e = e ? e.displayName || e.name : "") ? tc(e) : "";
}
function Az(e) {
  switch (e.tag) {
    case 5:
      return tc(e.type);
    case 16:
      return tc("Lazy");
    case 13:
      return tc("Suspense");
    case 19:
      return tc("SuspenseList");
    case 0:
    case 2:
    case 15:
      return e = dy(e.type, !1), e;
    case 11:
      return e = dy(e.type.render, !1), e;
    case 1:
      return e = dy(e.type, !0), e;
    default:
      return "";
  }
}
function g0(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case Ka:
      return "Fragment";
    case Ga:
      return "Portal";
    case d0:
      return "Profiler";
    case ew:
      return "StrictMode";
    case h0:
      return "Suspense";
    case m0:
      return "SuspenseList";
  }
  if (typeof e == "object") switch (e.$$typeof) {
    case bT:
      return (e.displayName || "Context") + ".Consumer";
    case vT:
      return (e._context.displayName || "Context") + ".Provider";
    case tw:
      var t = e.render;
      return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
    case rw:
      return t = e.displayName || null, t !== null ? t : g0(e.type) || "Memo";
    case To:
      t = e._payload, e = e._init;
      try {
        return g0(e(t));
      } catch {
      }
  }
  return null;
}
function Pz(e) {
  var t = e.type;
  switch (e.tag) {
    case 24:
      return "Cache";
    case 9:
      return (t.displayName || "Context") + ".Consumer";
    case 10:
      return (t._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return t;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return g0(t);
    case 8:
      return t === ew ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t;
  }
  return null;
}
function Xo(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return "";
  }
}
function ST(e) {
  var t = e.type;
  return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
}
function Cz(e) {
  var t = ST(e) ? "checked" : "value", r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), n = "" + e[t];
  if (!e.hasOwnProperty(t) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
    var i = r.get, s = r.set;
    return Object.defineProperty(e, t, { configurable: !0, get: function() {
      return i.call(this);
    }, set: function(o) {
      n = "" + o, s.call(this, o);
    } }), Object.defineProperty(e, t, { enumerable: r.enumerable }), { getValue: function() {
      return n;
    }, setValue: function(o) {
      n = "" + o;
    }, stopTracking: function() {
      e._valueTracker = null, delete e[t];
    } };
  }
}
function Pf(e) {
  e._valueTracker || (e._valueTracker = Cz(e));
}
function xT(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var r = t.getValue(), n = "";
  return e && (n = ST(e) ? e.checked ? "true" : "false" : e.value), e = n, e !== r ? (t.setValue(e), !0) : !1;
}
function Ih(e) {
  if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
  try {
    return e.activeElement || e.body;
  } catch {
    return e.body;
  }
}
function y0(e, t) {
  var r = t.checked;
  return Ut({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: r ?? e._wrapperState.initialChecked });
}
function W_(e, t) {
  var r = t.defaultValue == null ? "" : t.defaultValue, n = t.checked != null ? t.checked : t.defaultChecked;
  r = Xo(t.value != null ? t.value : r), e._wrapperState = { initialChecked: n, initialValue: r, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null };
}
function _T(e, t) {
  t = t.checked, t != null && Zb(e, "checked", t, !1);
}
function v0(e, t) {
  _T(e, t);
  var r = Xo(t.value), n = t.type;
  if (r != null) n === "number" ? (r === 0 && e.value === "" || e.value != r) && (e.value = "" + r) : e.value !== "" + r && (e.value = "" + r);
  else if (n === "submit" || n === "reset") {
    e.removeAttribute("value");
    return;
  }
  t.hasOwnProperty("value") ? b0(e, t.type, r) : t.hasOwnProperty("defaultValue") && b0(e, t.type, Xo(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked);
}
function H_(e, t, r) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var n = t.type;
    if (!(n !== "submit" && n !== "reset" || t.value !== void 0 && t.value !== null)) return;
    t = "" + e._wrapperState.initialValue, r || t === e.value || (e.value = t), e.defaultValue = t;
  }
  r = e.name, r !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, r !== "" && (e.name = r);
}
function b0(e, t, r) {
  (t !== "number" || Ih(e.ownerDocument) !== e) && (r == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + r && (e.defaultValue = "" + r));
}
var rc = Array.isArray;
function fl(e, t, r, n) {
  if (e = e.options, t) {
    t = {};
    for (var i = 0; i < r.length; i++) t["$" + r[i]] = !0;
    for (r = 0; r < e.length; r++) i = t.hasOwnProperty("$" + e[r].value), e[r].selected !== i && (e[r].selected = i), i && n && (e[r].defaultSelected = !0);
  } else {
    for (r = "" + Xo(r), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === r) {
        e[i].selected = !0, n && (e[i].defaultSelected = !0);
        return;
      }
      t !== null || e[i].disabled || (t = e[i]);
    }
    t !== null && (t.selected = !0);
  }
}
function w0(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(je(91));
  return Ut({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue });
}
function Q_(e, t) {
  var r = t.value;
  if (r == null) {
    if (r = t.children, t = t.defaultValue, r != null) {
      if (t != null) throw Error(je(92));
      if (rc(r)) {
        if (1 < r.length) throw Error(je(93));
        r = r[0];
      }
      t = r;
    }
    t == null && (t = ""), r = t;
  }
  e._wrapperState = { initialValue: Xo(r) };
}
function ET(e, t) {
  var r = Xo(t.value), n = Xo(t.defaultValue);
  r != null && (r = "" + r, r !== e.value && (e.value = r), t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)), n != null && (e.defaultValue = "" + n);
}
function Y_(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t);
}
function OT(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function S0(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml" ? OT(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e;
}
var Cf, kT = function(e) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, r, n, i) {
    MSApp.execUnsafeLocalFunction(function() {
      return e(t, r, n, i);
    });
  } : e;
}(function(e, t) {
  if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
  else {
    for (Cf = Cf || document.createElement("div"), Cf.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Cf.firstChild; e.firstChild; ) e.removeChild(e.firstChild);
    for (; t.firstChild; ) e.appendChild(t.firstChild);
  }
});
function kc(e, t) {
  if (t) {
    var r = e.firstChild;
    if (r && r === e.lastChild && r.nodeType === 3) {
      r.nodeValue = t;
      return;
    }
  }
  e.textContent = t;
}
var uc = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, Tz = ["Webkit", "ms", "Moz", "O"];
Object.keys(uc).forEach(function(e) {
  Tz.forEach(function(t) {
    t = t + e.charAt(0).toUpperCase() + e.substring(1), uc[t] = uc[e];
  });
});
function AT(e, t, r) {
  return t == null || typeof t == "boolean" || t === "" ? "" : r || typeof t != "number" || t === 0 || uc.hasOwnProperty(e) && uc[e] ? ("" + t).trim() : t + "px";
}
function PT(e, t) {
  e = e.style;
  for (var r in t) if (t.hasOwnProperty(r)) {
    var n = r.indexOf("--") === 0, i = AT(r, t[r], n);
    r === "float" && (r = "cssFloat"), n ? e.setProperty(r, i) : e[r] = i;
  }
}
var $z = Ut({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function x0(e, t) {
  if (t) {
    if ($z[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(je(137, e));
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(je(60));
      if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(je(61));
    }
    if (t.style != null && typeof t.style != "object") throw Error(je(62));
  }
}
function _0(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var E0 = null;
function nw(e) {
  return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
}
var O0 = null, dl = null, hl = null;
function G_(e) {
  if (e = sp(e)) {
    if (typeof O0 != "function") throw Error(je(280));
    var t = e.stateNode;
    t && (t = jm(t), O0(e.stateNode, e.type, t));
  }
}
function CT(e) {
  dl ? hl ? hl.push(e) : hl = [e] : dl = e;
}
function TT() {
  if (dl) {
    var e = dl, t = hl;
    if (hl = dl = null, G_(e), t) for (e = 0; e < t.length; e++) G_(t[e]);
  }
}
function $T(e, t) {
  return e(t);
}
function RT() {
}
var hy = !1;
function IT(e, t, r) {
  if (hy) return e(t, r);
  hy = !0;
  try {
    return $T(e, t, r);
  } finally {
    hy = !1, (dl !== null || hl !== null) && (RT(), TT());
  }
}
function Ac(e, t) {
  var r = e.stateNode;
  if (r === null) return null;
  var n = jm(r);
  if (n === null) return null;
  r = n[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (n = !n.disabled) || (e = e.type, n = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !n;
      break e;
    default:
      e = !1;
  }
  if (e) return null;
  if (r && typeof r != "function") throw Error(je(231, t, typeof r));
  return r;
}
var k0 = !1;
if (so) try {
  var Ru = {};
  Object.defineProperty(Ru, "passive", { get: function() {
    k0 = !0;
  } }), window.addEventListener("test", Ru, Ru), window.removeEventListener("test", Ru, Ru);
} catch {
  k0 = !1;
}
function Rz(e, t, r, n, i, s, o, a, l) {
  var p = Array.prototype.slice.call(arguments, 3);
  try {
    t.apply(r, p);
  } catch (f) {
    this.onError(f);
  }
}
var cc = !1, jh = null, Nh = !1, A0 = null, Iz = { onError: function(e) {
  cc = !0, jh = e;
} };
function jz(e, t, r, n, i, s, o, a, l) {
  cc = !1, jh = null, Rz.apply(Iz, arguments);
}
function Nz(e, t, r, n, i, s, o, a, l) {
  if (jz.apply(this, arguments), cc) {
    if (cc) {
      var p = jh;
      cc = !1, jh = null;
    } else throw Error(je(198));
    Nh || (Nh = !0, A0 = p);
  }
}
function ua(e) {
  var t = e, r = e;
  if (e.alternate) for (; t.return; ) t = t.return;
  else {
    e = t;
    do
      t = e, t.flags & 4098 && (r = t.return), e = t.return;
    while (e);
  }
  return t.tag === 3 ? r : null;
}
function jT(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
  }
  return null;
}
function K_(e) {
  if (ua(e) !== e) throw Error(je(188));
}
function Lz(e) {
  var t = e.alternate;
  if (!t) {
    if (t = ua(e), t === null) throw Error(je(188));
    return t !== e ? null : e;
  }
  for (var r = e, n = t; ; ) {
    var i = r.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (n = i.return, n !== null) {
        r = n;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === r) return K_(i), e;
        if (s === n) return K_(i), t;
        s = s.sibling;
      }
      throw Error(je(188));
    }
    if (r.return !== n.return) r = i, n = s;
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === r) {
          o = !0, r = i, n = s;
          break;
        }
        if (a === n) {
          o = !0, n = i, r = s;
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === r) {
            o = !0, r = s, n = i;
            break;
          }
          if (a === n) {
            o = !0, n = s, r = i;
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(je(189));
      }
    }
    if (r.alternate !== n) throw Error(je(190));
  }
  if (r.tag !== 3) throw Error(je(188));
  return r.stateNode.current === r ? e : t;
}
function NT(e) {
  return e = Lz(e), e !== null ? LT(e) : null;
}
function LT(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null; ) {
    var t = LT(e);
    if (t !== null) return t;
    e = e.sibling;
  }
  return null;
}
var MT = mn.unstable_scheduleCallback, X_ = mn.unstable_cancelCallback, Mz = mn.unstable_shouldYield, Dz = mn.unstable_requestPaint, Xt = mn.unstable_now, Fz = mn.unstable_getCurrentPriorityLevel, iw = mn.unstable_ImmediatePriority, DT = mn.unstable_UserBlockingPriority, Lh = mn.unstable_NormalPriority, zz = mn.unstable_LowPriority, FT = mn.unstable_IdlePriority, Tm = null, ki = null;
function qz(e) {
  if (ki && typeof ki.onCommitFiberRoot == "function") try {
    ki.onCommitFiberRoot(Tm, e, void 0, (e.current.flags & 128) === 128);
  } catch {
  }
}
var Kn = Math.clz32 ? Math.clz32 : Vz, Bz = Math.log, Uz = Math.LN2;
function Vz(e) {
  return e >>>= 0, e === 0 ? 32 : 31 - (Bz(e) / Uz | 0) | 0;
}
var Tf = 64, $f = 4194304;
function nc(e) {
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return e;
  }
}
function Mh(e, t) {
  var r = e.pendingLanes;
  if (r === 0) return 0;
  var n = 0, i = e.suspendedLanes, s = e.pingedLanes, o = r & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? n = nc(a) : (s &= o, s !== 0 && (n = nc(s)));
  } else o = r & ~i, o !== 0 ? n = nc(o) : s !== 0 && (n = nc(s));
  if (n === 0) return 0;
  if (t !== 0 && t !== n && !(t & i) && (i = n & -n, s = t & -t, i >= s || i === 16 && (s & 4194240) !== 0)) return t;
  if (n & 4 && (n |= r & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= n; 0 < t; ) r = 31 - Kn(t), i = 1 << r, n |= e[r], t &= ~i;
  return n;
}
function Wz(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function Hz(e, t) {
  for (var r = e.suspendedLanes, n = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s; ) {
    var o = 31 - Kn(s), a = 1 << o, l = i[o];
    l === -1 ? (!(a & r) || a & n) && (i[o] = Wz(a, t)) : l <= t && (e.expiredLanes |= a), s &= ~a;
  }
}
function P0(e) {
  return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0;
}
function zT() {
  var e = Tf;
  return Tf <<= 1, !(Tf & 4194240) && (Tf = 64), e;
}
function my(e) {
  for (var t = [], r = 0; 31 > r; r++) t.push(e);
  return t;
}
function ip(e, t, r) {
  e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Kn(t), e[t] = r;
}
function Qz(e, t) {
  var r = e.pendingLanes & ~t;
  e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
  var n = e.eventTimes;
  for (e = e.expirationTimes; 0 < r; ) {
    var i = 31 - Kn(r), s = 1 << i;
    t[i] = 0, n[i] = -1, e[i] = -1, r &= ~s;
  }
}
function ow(e, t) {
  var r = e.entangledLanes |= t;
  for (e = e.entanglements; r; ) {
    var n = 31 - Kn(r), i = 1 << n;
    i & t | e[n] & t && (e[n] |= t), r &= ~i;
  }
}
var wt = 0;
function qT(e) {
  return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1;
}
var BT, sw, UT, VT, WT, C0 = !1, Rf = [], zo = null, qo = null, Bo = null, Pc = /* @__PURE__ */ new Map(), Cc = /* @__PURE__ */ new Map(), Ro = [], Yz = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function J_(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      zo = null;
      break;
    case "dragenter":
    case "dragleave":
      qo = null;
      break;
    case "mouseover":
    case "mouseout":
      Bo = null;
      break;
    case "pointerover":
    case "pointerout":
      Pc.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Cc.delete(t.pointerId);
  }
}
function Iu(e, t, r, n, i, s) {
  return e === null || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: r, eventSystemFlags: n, nativeEvent: s, targetContainers: [i] }, t !== null && (t = sp(t), t !== null && sw(t)), e) : (e.eventSystemFlags |= n, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e);
}
function Gz(e, t, r, n, i) {
  switch (t) {
    case "focusin":
      return zo = Iu(zo, e, t, r, n, i), !0;
    case "dragenter":
      return qo = Iu(qo, e, t, r, n, i), !0;
    case "mouseover":
      return Bo = Iu(Bo, e, t, r, n, i), !0;
    case "pointerover":
      var s = i.pointerId;
      return Pc.set(s, Iu(Pc.get(s) || null, e, t, r, n, i)), !0;
    case "gotpointercapture":
      return s = i.pointerId, Cc.set(s, Iu(Cc.get(s) || null, e, t, r, n, i)), !0;
  }
  return !1;
}
function HT(e) {
  var t = zs(e.target);
  if (t !== null) {
    var r = ua(t);
    if (r !== null) {
      if (t = r.tag, t === 13) {
        if (t = jT(r), t !== null) {
          e.blockedOn = t, WT(e.priority, function() {
            UT(r);
          });
          return;
        }
      } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
        return;
      }
    }
  }
  e.blockedOn = null;
}
function lh(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
    var r = T0(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
    if (r === null) {
      r = e.nativeEvent;
      var n = new r.constructor(r.type, r);
      E0 = n, r.target.dispatchEvent(n), E0 = null;
    } else return t = sp(r), t !== null && sw(t), e.blockedOn = r, !1;
    t.shift();
  }
  return !0;
}
function Z_(e, t, r) {
  lh(e) && r.delete(t);
}
function Kz() {
  C0 = !1, zo !== null && lh(zo) && (zo = null), qo !== null && lh(qo) && (qo = null), Bo !== null && lh(Bo) && (Bo = null), Pc.forEach(Z_), Cc.forEach(Z_);
}
function ju(e, t) {
  e.blockedOn === t && (e.blockedOn = null, C0 || (C0 = !0, mn.unstable_scheduleCallback(mn.unstable_NormalPriority, Kz)));
}
function Tc(e) {
  function t(i) {
    return ju(i, e);
  }
  if (0 < Rf.length) {
    ju(Rf[0], e);
    for (var r = 1; r < Rf.length; r++) {
      var n = Rf[r];
      n.blockedOn === e && (n.blockedOn = null);
    }
  }
  for (zo !== null && ju(zo, e), qo !== null && ju(qo, e), Bo !== null && ju(Bo, e), Pc.forEach(t), Cc.forEach(t), r = 0; r < Ro.length; r++) n = Ro[r], n.blockedOn === e && (n.blockedOn = null);
  for (; 0 < Ro.length && (r = Ro[0], r.blockedOn === null); ) HT(r), r.blockedOn === null && Ro.shift();
}
var ml = vo.ReactCurrentBatchConfig, Dh = !0;
function Xz(e, t, r, n) {
  var i = wt, s = ml.transition;
  ml.transition = null;
  try {
    wt = 1, aw(e, t, r, n);
  } finally {
    wt = i, ml.transition = s;
  }
}
function Jz(e, t, r, n) {
  var i = wt, s = ml.transition;
  ml.transition = null;
  try {
    wt = 4, aw(e, t, r, n);
  } finally {
    wt = i, ml.transition = s;
  }
}
function aw(e, t, r, n) {
  if (Dh) {
    var i = T0(e, t, r, n);
    if (i === null) Oy(e, t, n, Fh, r), J_(e, n);
    else if (Gz(i, e, t, r, n)) n.stopPropagation();
    else if (J_(e, n), t & 4 && -1 < Yz.indexOf(e)) {
      for (; i !== null; ) {
        var s = sp(i);
        if (s !== null && BT(s), s = T0(e, t, r, n), s === null && Oy(e, t, n, Fh, r), s === i) break;
        i = s;
      }
      i !== null && n.stopPropagation();
    } else Oy(e, t, n, null, r);
  }
}
var Fh = null;
function T0(e, t, r, n) {
  if (Fh = null, e = nw(n), e = zs(e), e !== null) if (t = ua(e), t === null) e = null;
  else if (r = t.tag, r === 13) {
    if (e = jT(t), e !== null) return e;
    e = null;
  } else if (r === 3) {
    if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
    e = null;
  } else t !== e && (e = null);
  return Fh = e, null;
}
function QT(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (Fz()) {
        case iw:
          return 1;
        case DT:
          return 4;
        case Lh:
        case zz:
          return 16;
        case FT:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var jo = null, lw = null, uh = null;
function YT() {
  if (uh) return uh;
  var e, t = lw, r = t.length, n, i = "value" in jo ? jo.value : jo.textContent, s = i.length;
  for (e = 0; e < r && t[e] === i[e]; e++) ;
  var o = r - e;
  for (n = 1; n <= o && t[r - n] === i[s - n]; n++) ;
  return uh = i.slice(e, 1 < n ? 1 - n : void 0);
}
function ch(e) {
  var t = e.keyCode;
  return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
}
function If() {
  return !0;
}
function eE() {
  return !1;
}
function vn(e) {
  function t(r, n, i, s, o) {
    this._reactName = r, this._targetInst = i, this.type = n, this.nativeEvent = s, this.target = o, this.currentTarget = null;
    for (var a in e) e.hasOwnProperty(a) && (r = e[a], this[a] = r ? r(s) : s[a]);
    return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? If : eE, this.isPropagationStopped = eE, this;
  }
  return Ut(t.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var r = this.nativeEvent;
    r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = If);
  }, stopPropagation: function() {
    var r = this.nativeEvent;
    r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = If);
  }, persist: function() {
  }, isPersistent: If }), t;
}
var zl = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(e) {
  return e.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, uw = vn(zl), op = Ut({}, zl, { view: 0, detail: 0 }), Zz = vn(op), gy, yy, Nu, $m = Ut({}, op, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: cw, button: 0, buttons: 0, relatedTarget: function(e) {
  return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
}, movementX: function(e) {
  return "movementX" in e ? e.movementX : (e !== Nu && (Nu && e.type === "mousemove" ? (gy = e.screenX - Nu.screenX, yy = e.screenY - Nu.screenY) : yy = gy = 0, Nu = e), gy);
}, movementY: function(e) {
  return "movementY" in e ? e.movementY : yy;
} }), tE = vn($m), eq = Ut({}, $m, { dataTransfer: 0 }), tq = vn(eq), rq = Ut({}, op, { relatedTarget: 0 }), vy = vn(rq), nq = Ut({}, zl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), iq = vn(nq), oq = Ut({}, zl, { clipboardData: function(e) {
  return "clipboardData" in e ? e.clipboardData : window.clipboardData;
} }), sq = vn(oq), aq = Ut({}, zl, { data: 0 }), rE = vn(aq), lq = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, uq = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, cq = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function pq(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = cq[e]) ? !!t[e] : !1;
}
function cw() {
  return pq;
}
var fq = Ut({}, op, { key: function(e) {
  if (e.key) {
    var t = lq[e.key] || e.key;
    if (t !== "Unidentified") return t;
  }
  return e.type === "keypress" ? (e = ch(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? uq[e.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: cw, charCode: function(e) {
  return e.type === "keypress" ? ch(e) : 0;
}, keyCode: function(e) {
  return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
}, which: function(e) {
  return e.type === "keypress" ? ch(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
} }), dq = vn(fq), hq = Ut({}, $m, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), nE = vn(hq), mq = Ut({}, op, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: cw }), gq = vn(mq), yq = Ut({}, zl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), vq = vn(yq), bq = Ut({}, $m, {
  deltaX: function(e) {
    return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
  },
  deltaY: function(e) {
    return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), wq = vn(bq), Sq = [9, 13, 27, 32], pw = so && "CompositionEvent" in window, pc = null;
so && "documentMode" in document && (pc = document.documentMode);
var xq = so && "TextEvent" in window && !pc, GT = so && (!pw || pc && 8 < pc && 11 >= pc), iE = " ", oE = !1;
function KT(e, t) {
  switch (e) {
    case "keyup":
      return Sq.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function XT(e) {
  return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
}
var Xa = !1;
function _q(e, t) {
  switch (e) {
    case "compositionend":
      return XT(t);
    case "keypress":
      return t.which !== 32 ? null : (oE = !0, iE);
    case "textInput":
      return e = t.data, e === iE && oE ? null : e;
    default:
      return null;
  }
}
function Eq(e, t) {
  if (Xa) return e === "compositionend" || !pw && KT(e, t) ? (e = YT(), uh = lw = jo = null, Xa = !1, e) : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
        if (t.char && 1 < t.char.length) return t.char;
        if (t.which) return String.fromCharCode(t.which);
      }
      return null;
    case "compositionend":
      return GT && t.locale !== "ko" ? null : t.data;
    default:
      return null;
  }
}
var Oq = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function sE(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!Oq[e.type] : t === "textarea";
}
function JT(e, t, r, n) {
  CT(n), t = zh(t, "onChange"), 0 < t.length && (r = new uw("onChange", "change", null, r, n), e.push({ event: r, listeners: t }));
}
var fc = null, $c = null;
function kq(e) {
  u$(e, 0);
}
function Rm(e) {
  var t = el(e);
  if (xT(t)) return e;
}
function Aq(e, t) {
  if (e === "change") return t;
}
var ZT = !1;
if (so) {
  var by;
  if (so) {
    var wy = "oninput" in document;
    if (!wy) {
      var aE = document.createElement("div");
      aE.setAttribute("oninput", "return;"), wy = typeof aE.oninput == "function";
    }
    by = wy;
  } else by = !1;
  ZT = by && (!document.documentMode || 9 < document.documentMode);
}
function lE() {
  fc && (fc.detachEvent("onpropertychange", e$), $c = fc = null);
}
function e$(e) {
  if (e.propertyName === "value" && Rm($c)) {
    var t = [];
    JT(t, $c, e, nw(e)), IT(kq, t);
  }
}
function Pq(e, t, r) {
  e === "focusin" ? (lE(), fc = t, $c = r, fc.attachEvent("onpropertychange", e$)) : e === "focusout" && lE();
}
function Cq(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown") return Rm($c);
}
function Tq(e, t) {
  if (e === "click") return Rm(t);
}
function $q(e, t) {
  if (e === "input" || e === "change") return Rm(t);
}
function Rq(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var ni = typeof Object.is == "function" ? Object.is : Rq;
function Rc(e, t) {
  if (ni(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
  var r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length) return !1;
  for (n = 0; n < r.length; n++) {
    var i = r[n];
    if (!f0.call(t, i) || !ni(e[i], t[i])) return !1;
  }
  return !0;
}
function uE(e) {
  for (; e && e.firstChild; ) e = e.firstChild;
  return e;
}
function cE(e, t) {
  var r = uE(e);
  e = 0;
  for (var n; r; ) {
    if (r.nodeType === 3) {
      if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e };
      e = n;
    }
    e: {
      for (; r; ) {
        if (r.nextSibling) {
          r = r.nextSibling;
          break e;
        }
        r = r.parentNode;
      }
      r = void 0;
    }
    r = uE(r);
  }
}
function t$(e, t) {
  return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? t$(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1;
}
function r$() {
  for (var e = window, t = Ih(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var r = typeof t.contentWindow.location.href == "string";
    } catch {
      r = !1;
    }
    if (r) e = t.contentWindow;
    else break;
    t = Ih(e.document);
  }
  return t;
}
function fw(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
}
function Iq(e) {
  var t = r$(), r = e.focusedElem, n = e.selectionRange;
  if (t !== r && r && r.ownerDocument && t$(r.ownerDocument.documentElement, r)) {
    if (n !== null && fw(r)) {
      if (t = n.start, e = n.end, e === void 0 && (e = t), "selectionStart" in r) r.selectionStart = t, r.selectionEnd = Math.min(e, r.value.length);
      else if (e = (t = r.ownerDocument || document) && t.defaultView || window, e.getSelection) {
        e = e.getSelection();
        var i = r.textContent.length, s = Math.min(n.start, i);
        n = n.end === void 0 ? s : Math.min(n.end, i), !e.extend && s > n && (i = n, n = s, s = i), i = cE(r, s);
        var o = cE(
          r,
          n
        );
        i && o && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), s > n ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t)));
      }
    }
    for (t = [], e = r; e = e.parentNode; ) e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
    for (typeof r.focus == "function" && r.focus(), r = 0; r < t.length; r++) e = t[r], e.element.scrollLeft = e.left, e.element.scrollTop = e.top;
  }
}
var jq = so && "documentMode" in document && 11 >= document.documentMode, Ja = null, $0 = null, dc = null, R0 = !1;
function pE(e, t, r) {
  var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
  R0 || Ja == null || Ja !== Ih(n) || (n = Ja, "selectionStart" in n && fw(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = { anchorNode: n.anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset }), dc && Rc(dc, n) || (dc = n, n = zh($0, "onSelect"), 0 < n.length && (t = new uw("onSelect", "select", null, t, r), e.push({ event: t, listeners: n }), t.target = Ja)));
}
function jf(e, t) {
  var r = {};
  return r[e.toLowerCase()] = t.toLowerCase(), r["Webkit" + e] = "webkit" + t, r["Moz" + e] = "moz" + t, r;
}
var Za = { animationend: jf("Animation", "AnimationEnd"), animationiteration: jf("Animation", "AnimationIteration"), animationstart: jf("Animation", "AnimationStart"), transitionend: jf("Transition", "TransitionEnd") }, Sy = {}, n$ = {};
so && (n$ = document.createElement("div").style, "AnimationEvent" in window || (delete Za.animationend.animation, delete Za.animationiteration.animation, delete Za.animationstart.animation), "TransitionEvent" in window || delete Za.transitionend.transition);
function Im(e) {
  if (Sy[e]) return Sy[e];
  if (!Za[e]) return e;
  var t = Za[e], r;
  for (r in t) if (t.hasOwnProperty(r) && r in n$) return Sy[e] = t[r];
  return e;
}
var i$ = Im("animationend"), o$ = Im("animationiteration"), s$ = Im("animationstart"), a$ = Im("transitionend"), l$ = /* @__PURE__ */ new Map(), fE = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function os(e, t) {
  l$.set(e, t), la(t, [e]);
}
for (var xy = 0; xy < fE.length; xy++) {
  var _y = fE[xy], Nq = _y.toLowerCase(), Lq = _y[0].toUpperCase() + _y.slice(1);
  os(Nq, "on" + Lq);
}
os(i$, "onAnimationEnd");
os(o$, "onAnimationIteration");
os(s$, "onAnimationStart");
os("dblclick", "onDoubleClick");
os("focusin", "onFocus");
os("focusout", "onBlur");
os(a$, "onTransitionEnd");
bl("onMouseEnter", ["mouseout", "mouseover"]);
bl("onMouseLeave", ["mouseout", "mouseover"]);
bl("onPointerEnter", ["pointerout", "pointerover"]);
bl("onPointerLeave", ["pointerout", "pointerover"]);
la("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
la("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
la("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
la("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
la("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
la("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ic = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Mq = new Set("cancel close invalid load scroll toggle".split(" ").concat(ic));
function dE(e, t, r) {
  var n = e.type || "unknown-event";
  e.currentTarget = r, Nz(n, t, void 0, e), e.currentTarget = null;
}
function u$(e, t) {
  t = (t & 4) !== 0;
  for (var r = 0; r < e.length; r++) {
    var n = e[r], i = n.event;
    n = n.listeners;
    e: {
      var s = void 0;
      if (t) for (var o = n.length - 1; 0 <= o; o--) {
        var a = n[o], l = a.instance, p = a.currentTarget;
        if (a = a.listener, l !== s && i.isPropagationStopped()) break e;
        dE(i, a, p), s = l;
      }
      else for (o = 0; o < n.length; o++) {
        if (a = n[o], l = a.instance, p = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e;
        dE(i, a, p), s = l;
      }
    }
  }
  if (Nh) throw e = A0, Nh = !1, A0 = null, e;
}
function It(e, t) {
  var r = t[M0];
  r === void 0 && (r = t[M0] = /* @__PURE__ */ new Set());
  var n = e + "__bubble";
  r.has(n) || (c$(t, e, 2, !1), r.add(n));
}
function Ey(e, t, r) {
  var n = 0;
  t && (n |= 4), c$(r, e, n, t);
}
var Nf = "_reactListening" + Math.random().toString(36).slice(2);
function Ic(e) {
  if (!e[Nf]) {
    e[Nf] = !0, yT.forEach(function(r) {
      r !== "selectionchange" && (Mq.has(r) || Ey(r, !1, e), Ey(r, !0, e));
    });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[Nf] || (t[Nf] = !0, Ey("selectionchange", !1, t));
  }
}
function c$(e, t, r, n) {
  switch (QT(t)) {
    case 1:
      var i = Xz;
      break;
    case 4:
      i = Jz;
      break;
    default:
      i = aw;
  }
  r = i.bind(null, t, r, e), i = void 0, !k0 || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), n ? i !== void 0 ? e.addEventListener(t, r, { capture: !0, passive: i }) : e.addEventListener(t, r, !0) : i !== void 0 ? e.addEventListener(t, r, { passive: i }) : e.addEventListener(t, r, !1);
}
function Oy(e, t, r, n, i) {
  var s = n;
  if (!(t & 1) && !(t & 2) && n !== null) e: for (; ; ) {
    if (n === null) return;
    var o = n.tag;
    if (o === 3 || o === 4) {
      var a = n.stateNode.containerInfo;
      if (a === i || a.nodeType === 8 && a.parentNode === i) break;
      if (o === 4) for (o = n.return; o !== null; ) {
        var l = o.tag;
        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return;
        o = o.return;
      }
      for (; a !== null; ) {
        if (o = zs(a), o === null) return;
        if (l = o.tag, l === 5 || l === 6) {
          n = s = o;
          continue e;
        }
        a = a.parentNode;
      }
    }
    n = n.return;
  }
  IT(function() {
    var p = s, f = nw(r), d = [];
    e: {
      var m = l$.get(e);
      if (m !== void 0) {
        var v = uw, g = e;
        switch (e) {
          case "keypress":
            if (ch(r) === 0) break e;
          case "keydown":
          case "keyup":
            v = dq;
            break;
          case "focusin":
            g = "focus", v = vy;
            break;
          case "focusout":
            g = "blur", v = vy;
            break;
          case "beforeblur":
          case "afterblur":
            v = vy;
            break;
          case "click":
            if (r.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            v = tE;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            v = tq;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            v = gq;
            break;
          case i$:
          case o$:
          case s$:
            v = iq;
            break;
          case a$:
            v = vq;
            break;
          case "scroll":
            v = Zz;
            break;
          case "wheel":
            v = wq;
            break;
          case "copy":
          case "cut":
          case "paste":
            v = sq;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            v = nE;
        }
        var S = (t & 4) !== 0, _ = !S && e === "scroll", x = S ? m !== null ? m + "Capture" : null : m;
        S = [];
        for (var y = p, w; y !== null; ) {
          w = y;
          var k = w.stateNode;
          if (w.tag === 5 && k !== null && (w = k, x !== null && (k = Ac(y, x), k != null && S.push(jc(y, k, w)))), _) break;
          y = y.return;
        }
        0 < S.length && (m = new v(m, g, null, r, f), d.push({ event: m, listeners: S }));
      }
    }
    if (!(t & 7)) {
      e: {
        if (m = e === "mouseover" || e === "pointerover", v = e === "mouseout" || e === "pointerout", m && r !== E0 && (g = r.relatedTarget || r.fromElement) && (zs(g) || g[ao])) break e;
        if ((v || m) && (m = f.window === f ? f : (m = f.ownerDocument) ? m.defaultView || m.parentWindow : window, v ? (g = r.relatedTarget || r.toElement, v = p, g = g ? zs(g) : null, g !== null && (_ = ua(g), g !== _ || g.tag !== 5 && g.tag !== 6) && (g = null)) : (v = null, g = p), v !== g)) {
          if (S = tE, k = "onMouseLeave", x = "onMouseEnter", y = "mouse", (e === "pointerout" || e === "pointerover") && (S = nE, k = "onPointerLeave", x = "onPointerEnter", y = "pointer"), _ = v == null ? m : el(v), w = g == null ? m : el(g), m = new S(k, y + "leave", v, r, f), m.target = _, m.relatedTarget = w, k = null, zs(f) === p && (S = new S(x, y + "enter", g, r, f), S.target = w, S.relatedTarget = _, k = S), _ = k, v && g) t: {
            for (S = v, x = g, y = 0, w = S; w; w = La(w)) y++;
            for (w = 0, k = x; k; k = La(k)) w++;
            for (; 0 < y - w; ) S = La(S), y--;
            for (; 0 < w - y; ) x = La(x), w--;
            for (; y--; ) {
              if (S === x || x !== null && S === x.alternate) break t;
              S = La(S), x = La(x);
            }
            S = null;
          }
          else S = null;
          v !== null && hE(d, m, v, S, !1), g !== null && _ !== null && hE(d, _, g, S, !0);
        }
      }
      e: {
        if (m = p ? el(p) : window, v = m.nodeName && m.nodeName.toLowerCase(), v === "select" || v === "input" && m.type === "file") var A = Aq;
        else if (sE(m)) if (ZT) A = $q;
        else {
          A = Cq;
          var T = Pq;
        }
        else (v = m.nodeName) && v.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (A = Tq);
        if (A && (A = A(e, p))) {
          JT(d, A, r, f);
          break e;
        }
        T && T(e, m, p), e === "focusout" && (T = m._wrapperState) && T.controlled && m.type === "number" && b0(m, "number", m.value);
      }
      switch (T = p ? el(p) : window, e) {
        case "focusin":
          (sE(T) || T.contentEditable === "true") && (Ja = T, $0 = p, dc = null);
          break;
        case "focusout":
          dc = $0 = Ja = null;
          break;
        case "mousedown":
          R0 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          R0 = !1, pE(d, r, f);
          break;
        case "selectionchange":
          if (jq) break;
        case "keydown":
        case "keyup":
          pE(d, r, f);
      }
      var R;
      if (pw) e: {
        switch (e) {
          case "compositionstart":
            var I = "onCompositionStart";
            break e;
          case "compositionend":
            I = "onCompositionEnd";
            break e;
          case "compositionupdate":
            I = "onCompositionUpdate";
            break e;
        }
        I = void 0;
      }
      else Xa ? KT(e, r) && (I = "onCompositionEnd") : e === "keydown" && r.keyCode === 229 && (I = "onCompositionStart");
      I && (GT && r.locale !== "ko" && (Xa || I !== "onCompositionStart" ? I === "onCompositionEnd" && Xa && (R = YT()) : (jo = f, lw = "value" in jo ? jo.value : jo.textContent, Xa = !0)), T = zh(p, I), 0 < T.length && (I = new rE(I, e, null, r, f), d.push({ event: I, listeners: T }), R ? I.data = R : (R = XT(r), R !== null && (I.data = R)))), (R = xq ? _q(e, r) : Eq(e, r)) && (p = zh(p, "onBeforeInput"), 0 < p.length && (f = new rE("onBeforeInput", "beforeinput", null, r, f), d.push({ event: f, listeners: p }), f.data = R));
    }
    u$(d, t);
  });
}
function jc(e, t, r) {
  return { instance: e, listener: t, currentTarget: r };
}
function zh(e, t) {
  for (var r = t + "Capture", n = []; e !== null; ) {
    var i = e, s = i.stateNode;
    i.tag === 5 && s !== null && (i = s, s = Ac(e, r), s != null && n.unshift(jc(e, s, i)), s = Ac(e, t), s != null && n.push(jc(e, s, i))), e = e.return;
  }
  return n;
}
function La(e) {
  if (e === null) return null;
  do
    e = e.return;
  while (e && e.tag !== 5);
  return e || null;
}
function hE(e, t, r, n, i) {
  for (var s = t._reactName, o = []; r !== null && r !== n; ) {
    var a = r, l = a.alternate, p = a.stateNode;
    if (l !== null && l === n) break;
    a.tag === 5 && p !== null && (a = p, i ? (l = Ac(r, s), l != null && o.unshift(jc(r, l, a))) : i || (l = Ac(r, s), l != null && o.push(jc(r, l, a)))), r = r.return;
  }
  o.length !== 0 && e.push({ event: t, listeners: o });
}
var Dq = /\r\n?/g, Fq = /\u0000|\uFFFD/g;
function mE(e) {
  return (typeof e == "string" ? e : "" + e).replace(Dq, `
`).replace(Fq, "");
}
function Lf(e, t, r) {
  if (t = mE(t), mE(e) !== t && r) throw Error(je(425));
}
function qh() {
}
var I0 = null, j0 = null;
function N0(e, t) {
  return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
}
var L0 = typeof setTimeout == "function" ? setTimeout : void 0, zq = typeof clearTimeout == "function" ? clearTimeout : void 0, gE = typeof Promise == "function" ? Promise : void 0, qq = typeof queueMicrotask == "function" ? queueMicrotask : typeof gE < "u" ? function(e) {
  return gE.resolve(null).then(e).catch(Bq);
} : L0;
function Bq(e) {
  setTimeout(function() {
    throw e;
  });
}
function ky(e, t) {
  var r = t, n = 0;
  do {
    var i = r.nextSibling;
    if (e.removeChild(r), i && i.nodeType === 8) if (r = i.data, r === "/$") {
      if (n === 0) {
        e.removeChild(i), Tc(t);
        return;
      }
      n--;
    } else r !== "$" && r !== "$?" && r !== "$!" || n++;
    r = i;
  } while (r);
  Tc(t);
}
function Uo(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
      if (t === "/$") return null;
    }
  }
  return e;
}
function yE(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var r = e.data;
      if (r === "$" || r === "$!" || r === "$?") {
        if (t === 0) return e;
        t--;
      } else r === "/$" && t++;
    }
    e = e.previousSibling;
  }
  return null;
}
var ql = Math.random().toString(36).slice(2), Si = "__reactFiber$" + ql, Nc = "__reactProps$" + ql, ao = "__reactContainer$" + ql, M0 = "__reactEvents$" + ql, Uq = "__reactListeners$" + ql, Vq = "__reactHandles$" + ql;
function zs(e) {
  var t = e[Si];
  if (t) return t;
  for (var r = e.parentNode; r; ) {
    if (t = r[ao] || r[Si]) {
      if (r = t.alternate, t.child !== null || r !== null && r.child !== null) for (e = yE(e); e !== null; ) {
        if (r = e[Si]) return r;
        e = yE(e);
      }
      return t;
    }
    e = r, r = e.parentNode;
  }
  return null;
}
function sp(e) {
  return e = e[Si] || e[ao], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e;
}
function el(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(je(33));
}
function jm(e) {
  return e[Nc] || null;
}
var D0 = [], tl = -1;
function ss(e) {
  return { current: e };
}
function Nt(e) {
  0 > tl || (e.current = D0[tl], D0[tl] = null, tl--);
}
function Tt(e, t) {
  tl++, D0[tl] = e.current, e.current = t;
}
var Jo = {}, jr = ss(Jo), Zr = ss(!1), Ks = Jo;
function wl(e, t) {
  var r = e.type.contextTypes;
  if (!r) return Jo;
  var n = e.stateNode;
  if (n && n.__reactInternalMemoizedUnmaskedChildContext === t) return n.__reactInternalMemoizedMaskedChildContext;
  var i = {}, s;
  for (s in r) i[s] = t[s];
  return n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i;
}
function en(e) {
  return e = e.childContextTypes, e != null;
}
function Bh() {
  Nt(Zr), Nt(jr);
}
function vE(e, t, r) {
  if (jr.current !== Jo) throw Error(je(168));
  Tt(jr, t), Tt(Zr, r);
}
function p$(e, t, r) {
  var n = e.stateNode;
  if (t = t.childContextTypes, typeof n.getChildContext != "function") return r;
  n = n.getChildContext();
  for (var i in n) if (!(i in t)) throw Error(je(108, Pz(e) || "Unknown", i));
  return Ut({}, r, n);
}
function Uh(e) {
  return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Jo, Ks = jr.current, Tt(jr, e), Tt(Zr, Zr.current), !0;
}
function bE(e, t, r) {
  var n = e.stateNode;
  if (!n) throw Error(je(169));
  r ? (e = p$(e, t, Ks), n.__reactInternalMemoizedMergedChildContext = e, Nt(Zr), Nt(jr), Tt(jr, e)) : Nt(Zr), Tt(Zr, r);
}
var Xi = null, Nm = !1, Ay = !1;
function f$(e) {
  Xi === null ? Xi = [e] : Xi.push(e);
}
function Wq(e) {
  Nm = !0, f$(e);
}
function as() {
  if (!Ay && Xi !== null) {
    Ay = !0;
    var e = 0, t = wt;
    try {
      var r = Xi;
      for (wt = 1; e < r.length; e++) {
        var n = r[e];
        do
          n = n(!0);
        while (n !== null);
      }
      Xi = null, Nm = !1;
    } catch (i) {
      throw Xi !== null && (Xi = Xi.slice(e + 1)), MT(iw, as), i;
    } finally {
      wt = t, Ay = !1;
    }
  }
  return null;
}
var rl = [], nl = 0, Vh = null, Wh = 0, An = [], Pn = 0, Xs = null, Zi = 1, eo = "";
function Ls(e, t) {
  rl[nl++] = Wh, rl[nl++] = Vh, Vh = e, Wh = t;
}
function d$(e, t, r) {
  An[Pn++] = Zi, An[Pn++] = eo, An[Pn++] = Xs, Xs = e;
  var n = Zi;
  e = eo;
  var i = 32 - Kn(n) - 1;
  n &= ~(1 << i), r += 1;
  var s = 32 - Kn(t) + i;
  if (30 < s) {
    var o = i - i % 5;
    s = (n & (1 << o) - 1).toString(32), n >>= o, i -= o, Zi = 1 << 32 - Kn(t) + i | r << i | n, eo = s + e;
  } else Zi = 1 << s | r << i | n, eo = e;
}
function dw(e) {
  e.return !== null && (Ls(e, 1), d$(e, 1, 0));
}
function hw(e) {
  for (; e === Vh; ) Vh = rl[--nl], rl[nl] = null, Wh = rl[--nl], rl[nl] = null;
  for (; e === Xs; ) Xs = An[--Pn], An[Pn] = null, eo = An[--Pn], An[Pn] = null, Zi = An[--Pn], An[Pn] = null;
}
var dn = null, fn = null, Mt = !1, Yn = null;
function h$(e, t) {
  var r = $n(5, null, null, 0);
  r.elementType = "DELETED", r.stateNode = t, r.return = e, t = e.deletions, t === null ? (e.deletions = [r], e.flags |= 16) : t.push(r);
}
function wE(e, t) {
  switch (e.tag) {
    case 5:
      var r = e.type;
      return t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, dn = e, fn = Uo(t.firstChild), !0) : !1;
    case 6:
      return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, dn = e, fn = null, !0) : !1;
    case 13:
      return t = t.nodeType !== 8 ? null : t, t !== null ? (r = Xs !== null ? { id: Zi, overflow: eo } : null, e.memoizedState = { dehydrated: t, treeContext: r, retryLane: 1073741824 }, r = $n(18, null, null, 0), r.stateNode = t, r.return = e, e.child = r, dn = e, fn = null, !0) : !1;
    default:
      return !1;
  }
}
function F0(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0;
}
function z0(e) {
  if (Mt) {
    var t = fn;
    if (t) {
      var r = t;
      if (!wE(e, t)) {
        if (F0(e)) throw Error(je(418));
        t = Uo(r.nextSibling);
        var n = dn;
        t && wE(e, t) ? h$(n, r) : (e.flags = e.flags & -4097 | 2, Mt = !1, dn = e);
      }
    } else {
      if (F0(e)) throw Error(je(418));
      e.flags = e.flags & -4097 | 2, Mt = !1, dn = e;
    }
  }
}
function SE(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return;
  dn = e;
}
function Mf(e) {
  if (e !== dn) return !1;
  if (!Mt) return SE(e), Mt = !0, !1;
  var t;
  if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !N0(e.type, e.memoizedProps)), t && (t = fn)) {
    if (F0(e)) throw m$(), Error(je(418));
    for (; t; ) h$(e, t), t = Uo(t.nextSibling);
  }
  if (SE(e), e.tag === 13) {
    if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(je(317));
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var r = e.data;
          if (r === "/$") {
            if (t === 0) {
              fn = Uo(e.nextSibling);
              break e;
            }
            t--;
          } else r !== "$" && r !== "$!" && r !== "$?" || t++;
        }
        e = e.nextSibling;
      }
      fn = null;
    }
  } else fn = dn ? Uo(e.stateNode.nextSibling) : null;
  return !0;
}
function m$() {
  for (var e = fn; e; ) e = Uo(e.nextSibling);
}
function Sl() {
  fn = dn = null, Mt = !1;
}
function mw(e) {
  Yn === null ? Yn = [e] : Yn.push(e);
}
var Hq = vo.ReactCurrentBatchConfig;
function Lu(e, t, r) {
  if (e = r.ref, e !== null && typeof e != "function" && typeof e != "object") {
    if (r._owner) {
      if (r = r._owner, r) {
        if (r.tag !== 1) throw Error(je(309));
        var n = r.stateNode;
      }
      if (!n) throw Error(je(147, e));
      var i = n, s = "" + e;
      return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function(o) {
        var a = i.refs;
        o === null ? delete a[s] : a[s] = o;
      }, t._stringRef = s, t);
    }
    if (typeof e != "string") throw Error(je(284));
    if (!r._owner) throw Error(je(290, e));
  }
  return e;
}
function Df(e, t) {
  throw e = Object.prototype.toString.call(t), Error(je(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e));
}
function xE(e) {
  var t = e._init;
  return t(e._payload);
}
function g$(e) {
  function t(x, y) {
    if (e) {
      var w = x.deletions;
      w === null ? (x.deletions = [y], x.flags |= 16) : w.push(y);
    }
  }
  function r(x, y) {
    if (!e) return null;
    for (; y !== null; ) t(x, y), y = y.sibling;
    return null;
  }
  function n(x, y) {
    for (x = /* @__PURE__ */ new Map(); y !== null; ) y.key !== null ? x.set(y.key, y) : x.set(y.index, y), y = y.sibling;
    return x;
  }
  function i(x, y) {
    return x = Qo(x, y), x.index = 0, x.sibling = null, x;
  }
  function s(x, y, w) {
    return x.index = w, e ? (w = x.alternate, w !== null ? (w = w.index, w < y ? (x.flags |= 2, y) : w) : (x.flags |= 2, y)) : (x.flags |= 1048576, y);
  }
  function o(x) {
    return e && x.alternate === null && (x.flags |= 2), x;
  }
  function a(x, y, w, k) {
    return y === null || y.tag !== 6 ? (y = jy(w, x.mode, k), y.return = x, y) : (y = i(y, w), y.return = x, y);
  }
  function l(x, y, w, k) {
    var A = w.type;
    return A === Ka ? f(x, y, w.props.children, k, w.key) : y !== null && (y.elementType === A || typeof A == "object" && A !== null && A.$$typeof === To && xE(A) === y.type) ? (k = i(y, w.props), k.ref = Lu(x, y, w), k.return = x, k) : (k = yh(w.type, w.key, w.props, null, x.mode, k), k.ref = Lu(x, y, w), k.return = x, k);
  }
  function p(x, y, w, k) {
    return y === null || y.tag !== 4 || y.stateNode.containerInfo !== w.containerInfo || y.stateNode.implementation !== w.implementation ? (y = Ny(w, x.mode, k), y.return = x, y) : (y = i(y, w.children || []), y.return = x, y);
  }
  function f(x, y, w, k, A) {
    return y === null || y.tag !== 7 ? (y = Hs(w, x.mode, k, A), y.return = x, y) : (y = i(y, w), y.return = x, y);
  }
  function d(x, y, w) {
    if (typeof y == "string" && y !== "" || typeof y == "number") return y = jy("" + y, x.mode, w), y.return = x, y;
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case Af:
          return w = yh(y.type, y.key, y.props, null, x.mode, w), w.ref = Lu(x, null, y), w.return = x, w;
        case Ga:
          return y = Ny(y, x.mode, w), y.return = x, y;
        case To:
          var k = y._init;
          return d(x, k(y._payload), w);
      }
      if (rc(y) || $u(y)) return y = Hs(y, x.mode, w, null), y.return = x, y;
      Df(x, y);
    }
    return null;
  }
  function m(x, y, w, k) {
    var A = y !== null ? y.key : null;
    if (typeof w == "string" && w !== "" || typeof w == "number") return A !== null ? null : a(x, y, "" + w, k);
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Af:
          return w.key === A ? l(x, y, w, k) : null;
        case Ga:
          return w.key === A ? p(x, y, w, k) : null;
        case To:
          return A = w._init, m(
            x,
            y,
            A(w._payload),
            k
          );
      }
      if (rc(w) || $u(w)) return A !== null ? null : f(x, y, w, k, null);
      Df(x, w);
    }
    return null;
  }
  function v(x, y, w, k, A) {
    if (typeof k == "string" && k !== "" || typeof k == "number") return x = x.get(w) || null, a(y, x, "" + k, A);
    if (typeof k == "object" && k !== null) {
      switch (k.$$typeof) {
        case Af:
          return x = x.get(k.key === null ? w : k.key) || null, l(y, x, k, A);
        case Ga:
          return x = x.get(k.key === null ? w : k.key) || null, p(y, x, k, A);
        case To:
          var T = k._init;
          return v(x, y, w, T(k._payload), A);
      }
      if (rc(k) || $u(k)) return x = x.get(w) || null, f(y, x, k, A, null);
      Df(y, k);
    }
    return null;
  }
  function g(x, y, w, k) {
    for (var A = null, T = null, R = y, I = y = 0, B = null; R !== null && I < w.length; I++) {
      R.index > I ? (B = R, R = null) : B = R.sibling;
      var L = m(x, R, w[I], k);
      if (L === null) {
        R === null && (R = B);
        break;
      }
      e && R && L.alternate === null && t(x, R), y = s(L, y, I), T === null ? A = L : T.sibling = L, T = L, R = B;
    }
    if (I === w.length) return r(x, R), Mt && Ls(x, I), A;
    if (R === null) {
      for (; I < w.length; I++) R = d(x, w[I], k), R !== null && (y = s(R, y, I), T === null ? A = R : T.sibling = R, T = R);
      return Mt && Ls(x, I), A;
    }
    for (R = n(x, R); I < w.length; I++) B = v(R, x, I, w[I], k), B !== null && (e && B.alternate !== null && R.delete(B.key === null ? I : B.key), y = s(B, y, I), T === null ? A = B : T.sibling = B, T = B);
    return e && R.forEach(function(Y) {
      return t(x, Y);
    }), Mt && Ls(x, I), A;
  }
  function S(x, y, w, k) {
    var A = $u(w);
    if (typeof A != "function") throw Error(je(150));
    if (w = A.call(w), w == null) throw Error(je(151));
    for (var T = A = null, R = y, I = y = 0, B = null, L = w.next(); R !== null && !L.done; I++, L = w.next()) {
      R.index > I ? (B = R, R = null) : B = R.sibling;
      var Y = m(x, R, L.value, k);
      if (Y === null) {
        R === null && (R = B);
        break;
      }
      e && R && Y.alternate === null && t(x, R), y = s(Y, y, I), T === null ? A = Y : T.sibling = Y, T = Y, R = B;
    }
    if (L.done) return r(
      x,
      R
    ), Mt && Ls(x, I), A;
    if (R === null) {
      for (; !L.done; I++, L = w.next()) L = d(x, L.value, k), L !== null && (y = s(L, y, I), T === null ? A = L : T.sibling = L, T = L);
      return Mt && Ls(x, I), A;
    }
    for (R = n(x, R); !L.done; I++, L = w.next()) L = v(R, x, I, L.value, k), L !== null && (e && L.alternate !== null && R.delete(L.key === null ? I : L.key), y = s(L, y, I), T === null ? A = L : T.sibling = L, T = L);
    return e && R.forEach(function(Q) {
      return t(x, Q);
    }), Mt && Ls(x, I), A;
  }
  function _(x, y, w, k) {
    if (typeof w == "object" && w !== null && w.type === Ka && w.key === null && (w = w.props.children), typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Af:
          e: {
            for (var A = w.key, T = y; T !== null; ) {
              if (T.key === A) {
                if (A = w.type, A === Ka) {
                  if (T.tag === 7) {
                    r(x, T.sibling), y = i(T, w.props.children), y.return = x, x = y;
                    break e;
                  }
                } else if (T.elementType === A || typeof A == "object" && A !== null && A.$$typeof === To && xE(A) === T.type) {
                  r(x, T.sibling), y = i(T, w.props), y.ref = Lu(x, T, w), y.return = x, x = y;
                  break e;
                }
                r(x, T);
                break;
              } else t(x, T);
              T = T.sibling;
            }
            w.type === Ka ? (y = Hs(w.props.children, x.mode, k, w.key), y.return = x, x = y) : (k = yh(w.type, w.key, w.props, null, x.mode, k), k.ref = Lu(x, y, w), k.return = x, x = k);
          }
          return o(x);
        case Ga:
          e: {
            for (T = w.key; y !== null; ) {
              if (y.key === T) if (y.tag === 4 && y.stateNode.containerInfo === w.containerInfo && y.stateNode.implementation === w.implementation) {
                r(x, y.sibling), y = i(y, w.children || []), y.return = x, x = y;
                break e;
              } else {
                r(x, y);
                break;
              }
              else t(x, y);
              y = y.sibling;
            }
            y = Ny(w, x.mode, k), y.return = x, x = y;
          }
          return o(x);
        case To:
          return T = w._init, _(x, y, T(w._payload), k);
      }
      if (rc(w)) return g(x, y, w, k);
      if ($u(w)) return S(x, y, w, k);
      Df(x, w);
    }
    return typeof w == "string" && w !== "" || typeof w == "number" ? (w = "" + w, y !== null && y.tag === 6 ? (r(x, y.sibling), y = i(y, w), y.return = x, x = y) : (r(x, y), y = jy(w, x.mode, k), y.return = x, x = y), o(x)) : r(x, y);
  }
  return _;
}
var xl = g$(!0), y$ = g$(!1), Hh = ss(null), Qh = null, il = null, gw = null;
function yw() {
  gw = il = Qh = null;
}
function vw(e) {
  var t = Hh.current;
  Nt(Hh), e._currentValue = t;
}
function q0(e, t, r) {
  for (; e !== null; ) {
    var n = e.alternate;
    if ((e.childLanes & t) !== t ? (e.childLanes |= t, n !== null && (n.childLanes |= t)) : n !== null && (n.childLanes & t) !== t && (n.childLanes |= t), e === r) break;
    e = e.return;
  }
}
function gl(e, t) {
  Qh = e, gw = il = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Kr = !0), e.firstContext = null);
}
function jn(e) {
  var t = e._currentValue;
  if (gw !== e) if (e = { context: e, memoizedValue: t, next: null }, il === null) {
    if (Qh === null) throw Error(je(308));
    il = e, Qh.dependencies = { lanes: 0, firstContext: e };
  } else il = il.next = e;
  return t;
}
var qs = null;
function bw(e) {
  qs === null ? qs = [e] : qs.push(e);
}
function v$(e, t, r, n) {
  var i = t.interleaved;
  return i === null ? (r.next = r, bw(t)) : (r.next = i.next, i.next = r), t.interleaved = r, lo(e, n);
}
function lo(e, t) {
  e.lanes |= t;
  var r = e.alternate;
  for (r !== null && (r.lanes |= t), r = e, e = e.return; e !== null; ) e.childLanes |= t, r = e.alternate, r !== null && (r.childLanes |= t), r = e, e = e.return;
  return r.tag === 3 ? r.stateNode : null;
}
var $o = !1;
function ww(e) {
  e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function b$(e, t) {
  e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects });
}
function to(e, t) {
  return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null };
}
function Vo(e, t, r) {
  var n = e.updateQueue;
  if (n === null) return null;
  if (n = n.shared, dt & 2) {
    var i = n.pending;
    return i === null ? t.next = t : (t.next = i.next, i.next = t), n.pending = t, lo(e, r);
  }
  return i = n.interleaved, i === null ? (t.next = t, bw(n)) : (t.next = i.next, i.next = t), n.interleaved = t, lo(e, r);
}
function ph(e, t, r) {
  if (t = t.updateQueue, t !== null && (t = t.shared, (r & 4194240) !== 0)) {
    var n = t.lanes;
    n &= e.pendingLanes, r |= n, t.lanes = r, ow(e, r);
  }
}
function _E(e, t) {
  var r = e.updateQueue, n = e.alternate;
  if (n !== null && (n = n.updateQueue, r === n)) {
    var i = null, s = null;
    if (r = r.firstBaseUpdate, r !== null) {
      do {
        var o = { eventTime: r.eventTime, lane: r.lane, tag: r.tag, payload: r.payload, callback: r.callback, next: null };
        s === null ? i = s = o : s = s.next = o, r = r.next;
      } while (r !== null);
      s === null ? i = s = t : s = s.next = t;
    } else i = s = t;
    r = { baseState: n.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: n.shared, effects: n.effects }, e.updateQueue = r;
    return;
  }
  e = r.lastBaseUpdate, e === null ? r.firstBaseUpdate = t : e.next = t, r.lastBaseUpdate = t;
}
function Yh(e, t, r, n) {
  var i = e.updateQueue;
  $o = !1;
  var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a, p = l.next;
    l.next = null, o === null ? s = p : o.next = p, o = l;
    var f = e.alternate;
    f !== null && (f = f.updateQueue, a = f.lastBaseUpdate, a !== o && (a === null ? f.firstBaseUpdate = p : a.next = p, f.lastBaseUpdate = l));
  }
  if (s !== null) {
    var d = i.baseState;
    o = 0, f = p = l = null, a = s;
    do {
      var m = a.lane, v = a.eventTime;
      if ((n & m) === m) {
        f !== null && (f = f.next = {
          eventTime: v,
          lane: 0,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null
        });
        e: {
          var g = e, S = a;
          switch (m = t, v = r, S.tag) {
            case 1:
              if (g = S.payload, typeof g == "function") {
                d = g.call(v, d, m);
                break e;
              }
              d = g;
              break e;
            case 3:
              g.flags = g.flags & -65537 | 128;
            case 0:
              if (g = S.payload, m = typeof g == "function" ? g.call(v, d, m) : g, m == null) break e;
              d = Ut({}, d, m);
              break e;
            case 2:
              $o = !0;
          }
        }
        a.callback !== null && a.lane !== 0 && (e.flags |= 64, m = i.effects, m === null ? i.effects = [a] : m.push(a));
      } else v = { eventTime: v, lane: m, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, f === null ? (p = f = v, l = d) : f = f.next = v, o |= m;
      if (a = a.next, a === null) {
        if (a = i.shared.pending, a === null) break;
        m = a, a = m.next, m.next = null, i.lastBaseUpdate = m, i.shared.pending = null;
      }
    } while (!0);
    if (f === null && (l = d), i.baseState = l, i.firstBaseUpdate = p, i.lastBaseUpdate = f, t = i.shared.interleaved, t !== null) {
      i = t;
      do
        o |= i.lane, i = i.next;
      while (i !== t);
    } else s === null && (i.shared.lanes = 0);
    Zs |= o, e.lanes = o, e.memoizedState = d;
  }
}
function EE(e, t, r) {
  if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) {
    var n = e[t], i = n.callback;
    if (i !== null) {
      if (n.callback = null, n = r, typeof i != "function") throw Error(je(191, i));
      i.call(n);
    }
  }
}
var ap = {}, Ai = ss(ap), Lc = ss(ap), Mc = ss(ap);
function Bs(e) {
  if (e === ap) throw Error(je(174));
  return e;
}
function Sw(e, t) {
  switch (Tt(Mc, t), Tt(Lc, e), Tt(Ai, ap), e = t.nodeType, e) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : S0(null, "");
      break;
    default:
      e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = S0(t, e);
  }
  Nt(Ai), Tt(Ai, t);
}
function _l() {
  Nt(Ai), Nt(Lc), Nt(Mc);
}
function w$(e) {
  Bs(Mc.current);
  var t = Bs(Ai.current), r = S0(t, e.type);
  t !== r && (Tt(Lc, e), Tt(Ai, r));
}
function xw(e) {
  Lc.current === e && (Nt(Ai), Nt(Lc));
}
var qt = ss(0);
function Gh(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var r = t.memoizedState;
      if (r !== null && (r = r.dehydrated, r === null || r.data === "$?" || r.data === "$!")) return t;
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t;
    } else if (t.child !== null) {
      t.child.return = t, t = t.child;
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null;
      t = t.return;
    }
    t.sibling.return = t.return, t = t.sibling;
  }
  return null;
}
var Py = [];
function _w() {
  for (var e = 0; e < Py.length; e++) Py[e]._workInProgressVersionPrimary = null;
  Py.length = 0;
}
var fh = vo.ReactCurrentDispatcher, Cy = vo.ReactCurrentBatchConfig, Js = 0, Bt = null, lr = null, pr = null, Kh = !1, hc = !1, Dc = 0, Qq = 0;
function Or() {
  throw Error(je(321));
}
function Ew(e, t) {
  if (t === null) return !1;
  for (var r = 0; r < t.length && r < e.length; r++) if (!ni(e[r], t[r])) return !1;
  return !0;
}
function Ow(e, t, r, n, i, s) {
  if (Js = s, Bt = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, fh.current = e === null || e.memoizedState === null ? Xq : Jq, e = r(n, i), hc) {
    s = 0;
    do {
      if (hc = !1, Dc = 0, 25 <= s) throw Error(je(301));
      s += 1, pr = lr = null, t.updateQueue = null, fh.current = Zq, e = r(n, i);
    } while (hc);
  }
  if (fh.current = Xh, t = lr !== null && lr.next !== null, Js = 0, pr = lr = Bt = null, Kh = !1, t) throw Error(je(300));
  return e;
}
function kw() {
  var e = Dc !== 0;
  return Dc = 0, e;
}
function bi() {
  var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return pr === null ? Bt.memoizedState = pr = e : pr = pr.next = e, pr;
}
function Nn() {
  if (lr === null) {
    var e = Bt.alternate;
    e = e !== null ? e.memoizedState : null;
  } else e = lr.next;
  var t = pr === null ? Bt.memoizedState : pr.next;
  if (t !== null) pr = t, lr = e;
  else {
    if (e === null) throw Error(je(310));
    lr = e, e = { memoizedState: lr.memoizedState, baseState: lr.baseState, baseQueue: lr.baseQueue, queue: lr.queue, next: null }, pr === null ? Bt.memoizedState = pr = e : pr = pr.next = e;
  }
  return pr;
}
function Fc(e, t) {
  return typeof t == "function" ? t(e) : t;
}
function Ty(e) {
  var t = Nn(), r = t.queue;
  if (r === null) throw Error(je(311));
  r.lastRenderedReducer = e;
  var n = lr, i = n.baseQueue, s = r.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      i.next = s.next, s.next = o;
    }
    n.baseQueue = i = s, r.pending = null;
  }
  if (i !== null) {
    s = i.next, n = n.baseState;
    var a = o = null, l = null, p = s;
    do {
      var f = p.lane;
      if ((Js & f) === f) l !== null && (l = l.next = { lane: 0, action: p.action, hasEagerState: p.hasEagerState, eagerState: p.eagerState, next: null }), n = p.hasEagerState ? p.eagerState : e(n, p.action);
      else {
        var d = {
          lane: f,
          action: p.action,
          hasEagerState: p.hasEagerState,
          eagerState: p.eagerState,
          next: null
        };
        l === null ? (a = l = d, o = n) : l = l.next = d, Bt.lanes |= f, Zs |= f;
      }
      p = p.next;
    } while (p !== null && p !== s);
    l === null ? o = n : l.next = a, ni(n, t.memoizedState) || (Kr = !0), t.memoizedState = n, t.baseState = o, t.baseQueue = l, r.lastRenderedState = n;
  }
  if (e = r.interleaved, e !== null) {
    i = e;
    do
      s = i.lane, Bt.lanes |= s, Zs |= s, i = i.next;
    while (i !== e);
  } else i === null && (r.lanes = 0);
  return [t.memoizedState, r.dispatch];
}
function $y(e) {
  var t = Nn(), r = t.queue;
  if (r === null) throw Error(je(311));
  r.lastRenderedReducer = e;
  var n = r.dispatch, i = r.pending, s = t.memoizedState;
  if (i !== null) {
    r.pending = null;
    var o = i = i.next;
    do
      s = e(s, o.action), o = o.next;
    while (o !== i);
    ni(s, t.memoizedState) || (Kr = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), r.lastRenderedState = s;
  }
  return [s, n];
}
function S$() {
}
function x$(e, t) {
  var r = Bt, n = Nn(), i = t(), s = !ni(n.memoizedState, i);
  if (s && (n.memoizedState = i, Kr = !0), n = n.queue, Aw(O$.bind(null, r, n, e), [e]), n.getSnapshot !== t || s || pr !== null && pr.memoizedState.tag & 1) {
    if (r.flags |= 2048, zc(9, E$.bind(null, r, n, i, t), void 0, null), dr === null) throw Error(je(349));
    Js & 30 || _$(r, t, i);
  }
  return i;
}
function _$(e, t, r) {
  e.flags |= 16384, e = { getSnapshot: t, value: r }, t = Bt.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Bt.updateQueue = t, t.stores = [e]) : (r = t.stores, r === null ? t.stores = [e] : r.push(e));
}
function E$(e, t, r, n) {
  t.value = r, t.getSnapshot = n, k$(t) && A$(e);
}
function O$(e, t, r) {
  return r(function() {
    k$(t) && A$(e);
  });
}
function k$(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var r = t();
    return !ni(e, r);
  } catch {
    return !0;
  }
}
function A$(e) {
  var t = lo(e, 1);
  t !== null && Xn(t, e, 1, -1);
}
function OE(e) {
  var t = bi();
  return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Fc, lastRenderedState: e }, t.queue = e, e = e.dispatch = Kq.bind(null, Bt, e), [t.memoizedState, e];
}
function zc(e, t, r, n) {
  return e = { tag: e, create: t, destroy: r, deps: n, next: null }, t = Bt.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Bt.updateQueue = t, t.lastEffect = e.next = e) : (r = t.lastEffect, r === null ? t.lastEffect = e.next = e : (n = r.next, r.next = e, e.next = n, t.lastEffect = e)), e;
}
function P$() {
  return Nn().memoizedState;
}
function dh(e, t, r, n) {
  var i = bi();
  Bt.flags |= e, i.memoizedState = zc(1 | t, r, void 0, n === void 0 ? null : n);
}
function Lm(e, t, r, n) {
  var i = Nn();
  n = n === void 0 ? null : n;
  var s = void 0;
  if (lr !== null) {
    var o = lr.memoizedState;
    if (s = o.destroy, n !== null && Ew(n, o.deps)) {
      i.memoizedState = zc(t, r, s, n);
      return;
    }
  }
  Bt.flags |= e, i.memoizedState = zc(1 | t, r, s, n);
}
function kE(e, t) {
  return dh(8390656, 8, e, t);
}
function Aw(e, t) {
  return Lm(2048, 8, e, t);
}
function C$(e, t) {
  return Lm(4, 2, e, t);
}
function T$(e, t) {
  return Lm(4, 4, e, t);
}
function $$(e, t) {
  if (typeof t == "function") return e = e(), t(e), function() {
    t(null);
  };
  if (t != null) return e = e(), t.current = e, function() {
    t.current = null;
  };
}
function R$(e, t, r) {
  return r = r != null ? r.concat([e]) : null, Lm(4, 4, $$.bind(null, t, e), r);
}
function Pw() {
}
function I$(e, t) {
  var r = Nn();
  t = t === void 0 ? null : t;
  var n = r.memoizedState;
  return n !== null && t !== null && Ew(t, n[1]) ? n[0] : (r.memoizedState = [e, t], e);
}
function j$(e, t) {
  var r = Nn();
  t = t === void 0 ? null : t;
  var n = r.memoizedState;
  return n !== null && t !== null && Ew(t, n[1]) ? n[0] : (e = e(), r.memoizedState = [e, t], e);
}
function N$(e, t, r) {
  return Js & 21 ? (ni(r, t) || (r = zT(), Bt.lanes |= r, Zs |= r, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Kr = !0), e.memoizedState = r);
}
function Yq(e, t) {
  var r = wt;
  wt = r !== 0 && 4 > r ? r : 4, e(!0);
  var n = Cy.transition;
  Cy.transition = {};
  try {
    e(!1), t();
  } finally {
    wt = r, Cy.transition = n;
  }
}
function L$() {
  return Nn().memoizedState;
}
function Gq(e, t, r) {
  var n = Ho(e);
  if (r = { lane: n, action: r, hasEagerState: !1, eagerState: null, next: null }, M$(e)) D$(t, r);
  else if (r = v$(e, t, r, n), r !== null) {
    var i = Fr();
    Xn(r, e, n, i), F$(r, t, n);
  }
}
function Kq(e, t, r) {
  var n = Ho(e), i = { lane: n, action: r, hasEagerState: !1, eagerState: null, next: null };
  if (M$(e)) D$(t, i);
  else {
    var s = e.alternate;
    if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try {
      var o = t.lastRenderedState, a = s(o, r);
      if (i.hasEagerState = !0, i.eagerState = a, ni(a, o)) {
        var l = t.interleaved;
        l === null ? (i.next = i, bw(t)) : (i.next = l.next, l.next = i), t.interleaved = i;
        return;
      }
    } catch {
    } finally {
    }
    r = v$(e, t, i, n), r !== null && (i = Fr(), Xn(r, e, n, i), F$(r, t, n));
  }
}
function M$(e) {
  var t = e.alternate;
  return e === Bt || t !== null && t === Bt;
}
function D$(e, t) {
  hc = Kh = !0;
  var r = e.pending;
  r === null ? t.next = t : (t.next = r.next, r.next = t), e.pending = t;
}
function F$(e, t, r) {
  if (r & 4194240) {
    var n = t.lanes;
    n &= e.pendingLanes, r |= n, t.lanes = r, ow(e, r);
  }
}
var Xh = { readContext: jn, useCallback: Or, useContext: Or, useEffect: Or, useImperativeHandle: Or, useInsertionEffect: Or, useLayoutEffect: Or, useMemo: Or, useReducer: Or, useRef: Or, useState: Or, useDebugValue: Or, useDeferredValue: Or, useTransition: Or, useMutableSource: Or, useSyncExternalStore: Or, useId: Or, unstable_isNewReconciler: !1 }, Xq = { readContext: jn, useCallback: function(e, t) {
  return bi().memoizedState = [e, t === void 0 ? null : t], e;
}, useContext: jn, useEffect: kE, useImperativeHandle: function(e, t, r) {
  return r = r != null ? r.concat([e]) : null, dh(
    4194308,
    4,
    $$.bind(null, t, e),
    r
  );
}, useLayoutEffect: function(e, t) {
  return dh(4194308, 4, e, t);
}, useInsertionEffect: function(e, t) {
  return dh(4, 2, e, t);
}, useMemo: function(e, t) {
  var r = bi();
  return t = t === void 0 ? null : t, e = e(), r.memoizedState = [e, t], e;
}, useReducer: function(e, t, r) {
  var n = bi();
  return t = r !== void 0 ? r(t) : t, n.memoizedState = n.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, n.queue = e, e = e.dispatch = Gq.bind(null, Bt, e), [n.memoizedState, e];
}, useRef: function(e) {
  var t = bi();
  return e = { current: e }, t.memoizedState = e;
}, useState: OE, useDebugValue: Pw, useDeferredValue: function(e) {
  return bi().memoizedState = e;
}, useTransition: function() {
  var e = OE(!1), t = e[0];
  return e = Yq.bind(null, e[1]), bi().memoizedState = e, [t, e];
}, useMutableSource: function() {
}, useSyncExternalStore: function(e, t, r) {
  var n = Bt, i = bi();
  if (Mt) {
    if (r === void 0) throw Error(je(407));
    r = r();
  } else {
    if (r = t(), dr === null) throw Error(je(349));
    Js & 30 || _$(n, t, r);
  }
  i.memoizedState = r;
  var s = { value: r, getSnapshot: t };
  return i.queue = s, kE(O$.bind(
    null,
    n,
    s,
    e
  ), [e]), n.flags |= 2048, zc(9, E$.bind(null, n, s, r, t), void 0, null), r;
}, useId: function() {
  var e = bi(), t = dr.identifierPrefix;
  if (Mt) {
    var r = eo, n = Zi;
    r = (n & ~(1 << 32 - Kn(n) - 1)).toString(32) + r, t = ":" + t + "R" + r, r = Dc++, 0 < r && (t += "H" + r.toString(32)), t += ":";
  } else r = Qq++, t = ":" + t + "r" + r.toString(32) + ":";
  return e.memoizedState = t;
}, unstable_isNewReconciler: !1 }, Jq = {
  readContext: jn,
  useCallback: I$,
  useContext: jn,
  useEffect: Aw,
  useImperativeHandle: R$,
  useInsertionEffect: C$,
  useLayoutEffect: T$,
  useMemo: j$,
  useReducer: Ty,
  useRef: P$,
  useState: function() {
    return Ty(Fc);
  },
  useDebugValue: Pw,
  useDeferredValue: function(e) {
    var t = Nn();
    return N$(t, lr.memoizedState, e);
  },
  useTransition: function() {
    var e = Ty(Fc)[0], t = Nn().memoizedState;
    return [e, t];
  },
  useMutableSource: S$,
  useSyncExternalStore: x$,
  useId: L$,
  unstable_isNewReconciler: !1
}, Zq = { readContext: jn, useCallback: I$, useContext: jn, useEffect: Aw, useImperativeHandle: R$, useInsertionEffect: C$, useLayoutEffect: T$, useMemo: j$, useReducer: $y, useRef: P$, useState: function() {
  return $y(Fc);
}, useDebugValue: Pw, useDeferredValue: function(e) {
  var t = Nn();
  return lr === null ? t.memoizedState = e : N$(t, lr.memoizedState, e);
}, useTransition: function() {
  var e = $y(Fc)[0], t = Nn().memoizedState;
  return [e, t];
}, useMutableSource: S$, useSyncExternalStore: x$, useId: L$, unstable_isNewReconciler: !1 };
function Hn(e, t) {
  if (e && e.defaultProps) {
    t = Ut({}, t), e = e.defaultProps;
    for (var r in e) t[r] === void 0 && (t[r] = e[r]);
    return t;
  }
  return t;
}
function B0(e, t, r, n) {
  t = e.memoizedState, r = r(n, t), r = r == null ? t : Ut({}, t, r), e.memoizedState = r, e.lanes === 0 && (e.updateQueue.baseState = r);
}
var Mm = { isMounted: function(e) {
  return (e = e._reactInternals) ? ua(e) === e : !1;
}, enqueueSetState: function(e, t, r) {
  e = e._reactInternals;
  var n = Fr(), i = Ho(e), s = to(n, i);
  s.payload = t, r != null && (s.callback = r), t = Vo(e, s, i), t !== null && (Xn(t, e, i, n), ph(t, e, i));
}, enqueueReplaceState: function(e, t, r) {
  e = e._reactInternals;
  var n = Fr(), i = Ho(e), s = to(n, i);
  s.tag = 1, s.payload = t, r != null && (s.callback = r), t = Vo(e, s, i), t !== null && (Xn(t, e, i, n), ph(t, e, i));
}, enqueueForceUpdate: function(e, t) {
  e = e._reactInternals;
  var r = Fr(), n = Ho(e), i = to(r, n);
  i.tag = 2, t != null && (i.callback = t), t = Vo(e, i, n), t !== null && (Xn(t, e, n, r), ph(t, e, n));
} };
function AE(e, t, r, n, i, s, o) {
  return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(n, s, o) : t.prototype && t.prototype.isPureReactComponent ? !Rc(r, n) || !Rc(i, s) : !0;
}
function z$(e, t, r) {
  var n = !1, i = Jo, s = t.contextType;
  return typeof s == "object" && s !== null ? s = jn(s) : (i = en(t) ? Ks : jr.current, n = t.contextTypes, s = (n = n != null) ? wl(e, i) : Jo), t = new t(r, s), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Mm, e.stateNode = t, t._reactInternals = e, n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t;
}
function PE(e, t, r, n) {
  e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(r, n), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(r, n), t.state !== e && Mm.enqueueReplaceState(t, t.state, null);
}
function U0(e, t, r, n) {
  var i = e.stateNode;
  i.props = r, i.state = e.memoizedState, i.refs = {}, ww(e);
  var s = t.contextType;
  typeof s == "object" && s !== null ? i.context = jn(s) : (s = en(t) ? Ks : jr.current, i.context = wl(e, s)), i.state = e.memoizedState, s = t.getDerivedStateFromProps, typeof s == "function" && (B0(e, t, s, r), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Mm.enqueueReplaceState(i, i.state, null), Yh(e, r, i, n), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308);
}
function El(e, t) {
  try {
    var r = "", n = t;
    do
      r += Az(n), n = n.return;
    while (n);
    var i = r;
  } catch (s) {
    i = `
Error generating stack: ` + s.message + `
` + s.stack;
  }
  return { value: e, source: t, stack: i, digest: null };
}
function Ry(e, t, r) {
  return { value: e, source: null, stack: r ?? null, digest: t ?? null };
}
function V0(e, t) {
  try {
    console.error(t.value);
  } catch (r) {
    setTimeout(function() {
      throw r;
    });
  }
}
var eB = typeof WeakMap == "function" ? WeakMap : Map;
function q$(e, t, r) {
  r = to(-1, r), r.tag = 3, r.payload = { element: null };
  var n = t.value;
  return r.callback = function() {
    Zh || (Zh = !0, eb = n), V0(e, t);
  }, r;
}
function B$(e, t, r) {
  r = to(-1, r), r.tag = 3;
  var n = e.type.getDerivedStateFromError;
  if (typeof n == "function") {
    var i = t.value;
    r.payload = function() {
      return n(i);
    }, r.callback = function() {
      V0(e, t);
    };
  }
  var s = e.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (r.callback = function() {
    V0(e, t), typeof n != "function" && (Wo === null ? Wo = /* @__PURE__ */ new Set([this]) : Wo.add(this));
    var o = t.stack;
    this.componentDidCatch(t.value, { componentStack: o !== null ? o : "" });
  }), r;
}
function CE(e, t, r) {
  var n = e.pingCache;
  if (n === null) {
    n = e.pingCache = new eB();
    var i = /* @__PURE__ */ new Set();
    n.set(t, i);
  } else i = n.get(t), i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(t, i));
  i.has(r) || (i.add(r), e = hB.bind(null, e, t, r), t.then(e, e));
}
function TE(e) {
  do {
    var t;
    if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e;
    e = e.return;
  } while (e !== null);
  return null;
}
function $E(e, t, r, n, i) {
  return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, r.flags |= 131072, r.flags &= -52805, r.tag === 1 && (r.alternate === null ? r.tag = 17 : (t = to(-1, 1), t.tag = 2, Vo(r, t, 1))), r.lanes |= 1), e);
}
var tB = vo.ReactCurrentOwner, Kr = !1;
function Dr(e, t, r, n) {
  t.child = e === null ? y$(t, null, r, n) : xl(t, e.child, r, n);
}
function RE(e, t, r, n, i) {
  r = r.render;
  var s = t.ref;
  return gl(t, i), n = Ow(e, t, r, n, s, i), r = kw(), e !== null && !Kr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, uo(e, t, i)) : (Mt && r && dw(t), t.flags |= 1, Dr(e, t, n, i), t.child);
}
function IE(e, t, r, n, i) {
  if (e === null) {
    var s = r.type;
    return typeof s == "function" && !Lw(s) && s.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (t.tag = 15, t.type = s, U$(e, t, s, n, i)) : (e = yh(r.type, null, n, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e);
  }
  if (s = e.child, !(e.lanes & i)) {
    var o = s.memoizedProps;
    if (r = r.compare, r = r !== null ? r : Rc, r(o, n) && e.ref === t.ref) return uo(e, t, i);
  }
  return t.flags |= 1, e = Qo(s, n), e.ref = t.ref, e.return = t, t.child = e;
}
function U$(e, t, r, n, i) {
  if (e !== null) {
    var s = e.memoizedProps;
    if (Rc(s, n) && e.ref === t.ref) if (Kr = !1, t.pendingProps = n = s, (e.lanes & i) !== 0) e.flags & 131072 && (Kr = !0);
    else return t.lanes = e.lanes, uo(e, t, i);
  }
  return W0(e, t, r, n, i);
}
function V$(e, t, r) {
  var n = t.pendingProps, i = n.children, s = e !== null ? e.memoizedState : null;
  if (n.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Tt(sl, ln), ln |= r;
  else {
    if (!(r & 1073741824)) return e = s !== null ? s.baseLanes | r : r, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Tt(sl, ln), ln |= e, null;
    t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, n = s !== null ? s.baseLanes : r, Tt(sl, ln), ln |= n;
  }
  else s !== null ? (n = s.baseLanes | r, t.memoizedState = null) : n = r, Tt(sl, ln), ln |= n;
  return Dr(e, t, i, r), t.child;
}
function W$(e, t) {
  var r = t.ref;
  (e === null && r !== null || e !== null && e.ref !== r) && (t.flags |= 512, t.flags |= 2097152);
}
function W0(e, t, r, n, i) {
  var s = en(r) ? Ks : jr.current;
  return s = wl(t, s), gl(t, i), r = Ow(e, t, r, n, s, i), n = kw(), e !== null && !Kr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, uo(e, t, i)) : (Mt && n && dw(t), t.flags |= 1, Dr(e, t, r, i), t.child);
}
function jE(e, t, r, n, i) {
  if (en(r)) {
    var s = !0;
    Uh(t);
  } else s = !1;
  if (gl(t, i), t.stateNode === null) hh(e, t), z$(t, r, n), U0(t, r, n, i), n = !0;
  else if (e === null) {
    var o = t.stateNode, a = t.memoizedProps;
    o.props = a;
    var l = o.context, p = r.contextType;
    typeof p == "object" && p !== null ? p = jn(p) : (p = en(r) ? Ks : jr.current, p = wl(t, p));
    var f = r.getDerivedStateFromProps, d = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function";
    d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || l !== p) && PE(t, o, n, p), $o = !1;
    var m = t.memoizedState;
    o.state = m, Yh(t, n, o, i), l = t.memoizedState, a !== n || m !== l || Zr.current || $o ? (typeof f == "function" && (B0(t, r, f, n), l = t.memoizedState), (a = $o || AE(t, r, a, n, m, l, p)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = n, t.memoizedState = l), o.props = n, o.state = l, o.context = p, n = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), n = !1);
  } else {
    o = t.stateNode, b$(e, t), a = t.memoizedProps, p = t.type === t.elementType ? a : Hn(t.type, a), o.props = p, d = t.pendingProps, m = o.context, l = r.contextType, typeof l == "object" && l !== null ? l = jn(l) : (l = en(r) ? Ks : jr.current, l = wl(t, l));
    var v = r.getDerivedStateFromProps;
    (f = typeof v == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || m !== l) && PE(t, o, n, l), $o = !1, m = t.memoizedState, o.state = m, Yh(t, n, o, i);
    var g = t.memoizedState;
    a !== d || m !== g || Zr.current || $o ? (typeof v == "function" && (B0(t, r, v, n), g = t.memoizedState), (p = $o || AE(t, r, p, n, m, g, l) || !1) ? (f || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, g, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, g, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), t.memoizedProps = n, t.memoizedState = g), o.props = n, o.state = g, o.context = l, n = p) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), n = !1);
  }
  return H0(e, t, r, n, s, i);
}
function H0(e, t, r, n, i, s) {
  W$(e, t);
  var o = (t.flags & 128) !== 0;
  if (!n && !o) return i && bE(t, r, !1), uo(e, t, s);
  n = t.stateNode, tB.current = t;
  var a = o && typeof r.getDerivedStateFromError != "function" ? null : n.render();
  return t.flags |= 1, e !== null && o ? (t.child = xl(t, e.child, null, s), t.child = xl(t, null, a, s)) : Dr(e, t, a, s), t.memoizedState = n.state, i && bE(t, r, !0), t.child;
}
function H$(e) {
  var t = e.stateNode;
  t.pendingContext ? vE(e, t.pendingContext, t.pendingContext !== t.context) : t.context && vE(e, t.context, !1), Sw(e, t.containerInfo);
}
function NE(e, t, r, n, i) {
  return Sl(), mw(i), t.flags |= 256, Dr(e, t, r, n), t.child;
}
var Q0 = { dehydrated: null, treeContext: null, retryLane: 0 };
function Y0(e) {
  return { baseLanes: e, cachePool: null, transitions: null };
}
function Q$(e, t, r) {
  var n = t.pendingProps, i = qt.current, s = !1, o = (t.flags & 128) !== 0, a;
  if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), Tt(qt, i & 1), e === null)
    return z0(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = n.children, e = n.fallback, s ? (n = t.mode, s = t.child, o = { mode: "hidden", children: o }, !(n & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = zm(o, n, 0, null), e = Hs(e, n, r, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Y0(r), t.memoizedState = Q0, e) : Cw(t, o));
  if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return rB(e, t, o, n, a, i, r);
  if (s) {
    s = n.fallback, o = t.mode, i = e.child, a = i.sibling;
    var l = { mode: "hidden", children: n.children };
    return !(o & 1) && t.child !== i ? (n = t.child, n.childLanes = 0, n.pendingProps = l, t.deletions = null) : (n = Qo(i, l), n.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = Qo(a, s) : (s = Hs(s, o, r, null), s.flags |= 2), s.return = t, n.return = t, n.sibling = s, t.child = n, n = s, s = t.child, o = e.child.memoizedState, o = o === null ? Y0(r) : { baseLanes: o.baseLanes | r, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = e.childLanes & ~r, t.memoizedState = Q0, n;
  }
  return s = e.child, e = s.sibling, n = Qo(s, { mode: "visible", children: n.children }), !(t.mode & 1) && (n.lanes = r), n.return = t, n.sibling = null, e !== null && (r = t.deletions, r === null ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = n, t.memoizedState = null, n;
}
function Cw(e, t) {
  return t = zm({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t;
}
function Ff(e, t, r, n) {
  return n !== null && mw(n), xl(t, e.child, null, r), e = Cw(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e;
}
function rB(e, t, r, n, i, s, o) {
  if (r)
    return t.flags & 256 ? (t.flags &= -257, n = Ry(Error(je(422))), Ff(e, t, o, n)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (s = n.fallback, i = t.mode, n = zm({ mode: "visible", children: n.children }, i, 0, null), s = Hs(s, i, o, null), s.flags |= 2, n.return = t, s.return = t, n.sibling = s, t.child = n, t.mode & 1 && xl(t, e.child, null, o), t.child.memoizedState = Y0(o), t.memoizedState = Q0, s);
  if (!(t.mode & 1)) return Ff(e, t, o, null);
  if (i.data === "$!") {
    if (n = i.nextSibling && i.nextSibling.dataset, n) var a = n.dgst;
    return n = a, s = Error(je(419)), n = Ry(s, n, void 0), Ff(e, t, o, n);
  }
  if (a = (o & e.childLanes) !== 0, Kr || a) {
    if (n = dr, n !== null) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      i = i & (n.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, lo(e, i), Xn(n, e, i, -1));
    }
    return Nw(), n = Ry(Error(je(421))), Ff(e, t, o, n);
  }
  return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = mB.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, fn = Uo(i.nextSibling), dn = t, Mt = !0, Yn = null, e !== null && (An[Pn++] = Zi, An[Pn++] = eo, An[Pn++] = Xs, Zi = e.id, eo = e.overflow, Xs = t), t = Cw(t, n.children), t.flags |= 4096, t);
}
function LE(e, t, r) {
  e.lanes |= t;
  var n = e.alternate;
  n !== null && (n.lanes |= t), q0(e.return, t, r);
}
function Iy(e, t, r, n, i) {
  var s = e.memoizedState;
  s === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: n, tail: r, tailMode: i } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = n, s.tail = r, s.tailMode = i);
}
function Y$(e, t, r) {
  var n = t.pendingProps, i = n.revealOrder, s = n.tail;
  if (Dr(e, t, n.children, r), n = qt.current, n & 2) n = n & 1 | 2, t.flags |= 128;
  else {
    if (e !== null && e.flags & 128) e: for (e = t.child; e !== null; ) {
      if (e.tag === 13) e.memoizedState !== null && LE(e, r, t);
      else if (e.tag === 19) LE(e, r, t);
      else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue;
      }
      if (e === t) break e;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) break e;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
    n &= 1;
  }
  if (Tt(qt, n), !(t.mode & 1)) t.memoizedState = null;
  else switch (i) {
    case "forwards":
      for (r = t.child, i = null; r !== null; ) e = r.alternate, e !== null && Gh(e) === null && (i = r), r = r.sibling;
      r = i, r === null ? (i = t.child, t.child = null) : (i = r.sibling, r.sibling = null), Iy(t, !1, i, r, s);
      break;
    case "backwards":
      for (r = null, i = t.child, t.child = null; i !== null; ) {
        if (e = i.alternate, e !== null && Gh(e) === null) {
          t.child = i;
          break;
        }
        e = i.sibling, i.sibling = r, r = i, i = e;
      }
      Iy(t, !0, r, null, s);
      break;
    case "together":
      Iy(t, !1, null, null, void 0);
      break;
    default:
      t.memoizedState = null;
  }
  return t.child;
}
function hh(e, t) {
  !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2);
}
function uo(e, t, r) {
  if (e !== null && (t.dependencies = e.dependencies), Zs |= t.lanes, !(r & t.childLanes)) return null;
  if (e !== null && t.child !== e.child) throw Error(je(153));
  if (t.child !== null) {
    for (e = t.child, r = Qo(e, e.pendingProps), t.child = r, r.return = t; e.sibling !== null; ) e = e.sibling, r = r.sibling = Qo(e, e.pendingProps), r.return = t;
    r.sibling = null;
  }
  return t.child;
}
function nB(e, t, r) {
  switch (t.tag) {
    case 3:
      H$(t), Sl();
      break;
    case 5:
      w$(t);
      break;
    case 1:
      en(t.type) && Uh(t);
      break;
    case 4:
      Sw(t, t.stateNode.containerInfo);
      break;
    case 10:
      var n = t.type._context, i = t.memoizedProps.value;
      Tt(Hh, n._currentValue), n._currentValue = i;
      break;
    case 13:
      if (n = t.memoizedState, n !== null)
        return n.dehydrated !== null ? (Tt(qt, qt.current & 1), t.flags |= 128, null) : r & t.child.childLanes ? Q$(e, t, r) : (Tt(qt, qt.current & 1), e = uo(e, t, r), e !== null ? e.sibling : null);
      Tt(qt, qt.current & 1);
      break;
    case 19:
      if (n = (r & t.childLanes) !== 0, e.flags & 128) {
        if (n) return Y$(e, t, r);
        t.flags |= 128;
      }
      if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Tt(qt, qt.current), n) break;
      return null;
    case 22:
    case 23:
      return t.lanes = 0, V$(e, t, r);
  }
  return uo(e, t, r);
}
var G$, G0, K$, X$;
G$ = function(e, t) {
  for (var r = t.child; r !== null; ) {
    if (r.tag === 5 || r.tag === 6) e.appendChild(r.stateNode);
    else if (r.tag !== 4 && r.child !== null) {
      r.child.return = r, r = r.child;
      continue;
    }
    if (r === t) break;
    for (; r.sibling === null; ) {
      if (r.return === null || r.return === t) return;
      r = r.return;
    }
    r.sibling.return = r.return, r = r.sibling;
  }
};
G0 = function() {
};
K$ = function(e, t, r, n) {
  var i = e.memoizedProps;
  if (i !== n) {
    e = t.stateNode, Bs(Ai.current);
    var s = null;
    switch (r) {
      case "input":
        i = y0(e, i), n = y0(e, n), s = [];
        break;
      case "select":
        i = Ut({}, i, { value: void 0 }), n = Ut({}, n, { value: void 0 }), s = [];
        break;
      case "textarea":
        i = w0(e, i), n = w0(e, n), s = [];
        break;
      default:
        typeof i.onClick != "function" && typeof n.onClick == "function" && (e.onclick = qh);
    }
    x0(r, n);
    var o;
    r = null;
    for (p in i) if (!n.hasOwnProperty(p) && i.hasOwnProperty(p) && i[p] != null) if (p === "style") {
      var a = i[p];
      for (o in a) a.hasOwnProperty(o) && (r || (r = {}), r[o] = "");
    } else p !== "dangerouslySetInnerHTML" && p !== "children" && p !== "suppressContentEditableWarning" && p !== "suppressHydrationWarning" && p !== "autoFocus" && (Oc.hasOwnProperty(p) ? s || (s = []) : (s = s || []).push(p, null));
    for (p in n) {
      var l = n[p];
      if (a = i != null ? i[p] : void 0, n.hasOwnProperty(p) && l !== a && (l != null || a != null)) if (p === "style") if (a) {
        for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (r || (r = {}), r[o] = "");
        for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (r || (r = {}), r[o] = l[o]);
      } else r || (s || (s = []), s.push(
        p,
        r
      )), r = l;
      else p === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(p, l)) : p === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(p, "" + l) : p !== "suppressContentEditableWarning" && p !== "suppressHydrationWarning" && (Oc.hasOwnProperty(p) ? (l != null && p === "onScroll" && It("scroll", e), s || a === l || (s = [])) : (s = s || []).push(p, l));
    }
    r && (s = s || []).push("style", r);
    var p = s;
    (t.updateQueue = p) && (t.flags |= 4);
  }
};
X$ = function(e, t, r, n) {
  r !== n && (t.flags |= 4);
};
function Mu(e, t) {
  if (!Mt) switch (e.tailMode) {
    case "hidden":
      t = e.tail;
      for (var r = null; t !== null; ) t.alternate !== null && (r = t), t = t.sibling;
      r === null ? e.tail = null : r.sibling = null;
      break;
    case "collapsed":
      r = e.tail;
      for (var n = null; r !== null; ) r.alternate !== null && (n = r), r = r.sibling;
      n === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : n.sibling = null;
  }
}
function kr(e) {
  var t = e.alternate !== null && e.alternate.child === e.child, r = 0, n = 0;
  if (t) for (var i = e.child; i !== null; ) r |= i.lanes | i.childLanes, n |= i.subtreeFlags & 14680064, n |= i.flags & 14680064, i.return = e, i = i.sibling;
  else for (i = e.child; i !== null; ) r |= i.lanes | i.childLanes, n |= i.subtreeFlags, n |= i.flags, i.return = e, i = i.sibling;
  return e.subtreeFlags |= n, e.childLanes = r, t;
}
function iB(e, t, r) {
  var n = t.pendingProps;
  switch (hw(t), t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return kr(t), null;
    case 1:
      return en(t.type) && Bh(), kr(t), null;
    case 3:
      return n = t.stateNode, _l(), Nt(Zr), Nt(jr), _w(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (Mf(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Yn !== null && (nb(Yn), Yn = null))), G0(e, t), kr(t), null;
    case 5:
      xw(t);
      var i = Bs(Mc.current);
      if (r = t.type, e !== null && t.stateNode != null) K$(e, t, r, n, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
      else {
        if (!n) {
          if (t.stateNode === null) throw Error(je(166));
          return kr(t), null;
        }
        if (e = Bs(Ai.current), Mf(t)) {
          n = t.stateNode, r = t.type;
          var s = t.memoizedProps;
          switch (n[Si] = t, n[Nc] = s, e = (t.mode & 1) !== 0, r) {
            case "dialog":
              It("cancel", n), It("close", n);
              break;
            case "iframe":
            case "object":
            case "embed":
              It("load", n);
              break;
            case "video":
            case "audio":
              for (i = 0; i < ic.length; i++) It(ic[i], n);
              break;
            case "source":
              It("error", n);
              break;
            case "img":
            case "image":
            case "link":
              It(
                "error",
                n
              ), It("load", n);
              break;
            case "details":
              It("toggle", n);
              break;
            case "input":
              W_(n, s), It("invalid", n);
              break;
            case "select":
              n._wrapperState = { wasMultiple: !!s.multiple }, It("invalid", n);
              break;
            case "textarea":
              Q_(n, s), It("invalid", n);
          }
          x0(r, s), i = null;
          for (var o in s) if (s.hasOwnProperty(o)) {
            var a = s[o];
            o === "children" ? typeof a == "string" ? n.textContent !== a && (s.suppressHydrationWarning !== !0 && Lf(n.textContent, a, e), i = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Lf(
              n.textContent,
              a,
              e
            ), i = ["children", "" + a]) : Oc.hasOwnProperty(o) && a != null && o === "onScroll" && It("scroll", n);
          }
          switch (r) {
            case "input":
              Pf(n), H_(n, s, !0);
              break;
            case "textarea":
              Pf(n), Y_(n);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (n.onclick = qh);
          }
          n = i, t.updateQueue = n, n !== null && (t.flags |= 4);
        } else {
          o = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = OT(r)), e === "http://www.w3.org/1999/xhtml" ? r === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof n.is == "string" ? e = o.createElement(r, { is: n.is }) : (e = o.createElement(r), r === "select" && (o = e, n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : e = o.createElementNS(e, r), e[Si] = t, e[Nc] = n, G$(e, t, !1, !1), t.stateNode = e;
          e: {
            switch (o = _0(r, n), r) {
              case "dialog":
                It("cancel", e), It("close", e), i = n;
                break;
              case "iframe":
              case "object":
              case "embed":
                It("load", e), i = n;
                break;
              case "video":
              case "audio":
                for (i = 0; i < ic.length; i++) It(ic[i], e);
                i = n;
                break;
              case "source":
                It("error", e), i = n;
                break;
              case "img":
              case "image":
              case "link":
                It(
                  "error",
                  e
                ), It("load", e), i = n;
                break;
              case "details":
                It("toggle", e), i = n;
                break;
              case "input":
                W_(e, n), i = y0(e, n), It("invalid", e);
                break;
              case "option":
                i = n;
                break;
              case "select":
                e._wrapperState = { wasMultiple: !!n.multiple }, i = Ut({}, n, { value: void 0 }), It("invalid", e);
                break;
              case "textarea":
                Q_(e, n), i = w0(e, n), It("invalid", e);
                break;
              default:
                i = n;
            }
            x0(r, i), a = i;
            for (s in a) if (a.hasOwnProperty(s)) {
              var l = a[s];
              s === "style" ? PT(e, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && kT(e, l)) : s === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && kc(e, l) : typeof l == "number" && kc(e, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Oc.hasOwnProperty(s) ? l != null && s === "onScroll" && It("scroll", e) : l != null && Zb(e, s, l, o));
            }
            switch (r) {
              case "input":
                Pf(e), H_(e, n, !1);
                break;
              case "textarea":
                Pf(e), Y_(e);
                break;
              case "option":
                n.value != null && e.setAttribute("value", "" + Xo(n.value));
                break;
              case "select":
                e.multiple = !!n.multiple, s = n.value, s != null ? fl(e, !!n.multiple, s, !1) : n.defaultValue != null && fl(
                  e,
                  !!n.multiple,
                  n.defaultValue,
                  !0
                );
                break;
              default:
                typeof i.onClick == "function" && (e.onclick = qh);
            }
            switch (r) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                n = !!n.autoFocus;
                break e;
              case "img":
                n = !0;
                break e;
              default:
                n = !1;
            }
          }
          n && (t.flags |= 4);
        }
        t.ref !== null && (t.flags |= 512, t.flags |= 2097152);
      }
      return kr(t), null;
    case 6:
      if (e && t.stateNode != null) X$(e, t, e.memoizedProps, n);
      else {
        if (typeof n != "string" && t.stateNode === null) throw Error(je(166));
        if (r = Bs(Mc.current), Bs(Ai.current), Mf(t)) {
          if (n = t.stateNode, r = t.memoizedProps, n[Si] = t, (s = n.nodeValue !== r) && (e = dn, e !== null)) switch (e.tag) {
            case 3:
              Lf(n.nodeValue, r, (e.mode & 1) !== 0);
              break;
            case 5:
              e.memoizedProps.suppressHydrationWarning !== !0 && Lf(n.nodeValue, r, (e.mode & 1) !== 0);
          }
          s && (t.flags |= 4);
        } else n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n), n[Si] = t, t.stateNode = n;
      }
      return kr(t), null;
    case 13:
      if (Nt(qt), n = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
        if (Mt && fn !== null && t.mode & 1 && !(t.flags & 128)) m$(), Sl(), t.flags |= 98560, s = !1;
        else if (s = Mf(t), n !== null && n.dehydrated !== null) {
          if (e === null) {
            if (!s) throw Error(je(318));
            if (s = t.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(je(317));
            s[Si] = t;
          } else Sl(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
          kr(t), s = !1;
        } else Yn !== null && (nb(Yn), Yn = null), s = !0;
        if (!s) return t.flags & 65536 ? t : null;
      }
      return t.flags & 128 ? (t.lanes = r, t) : (n = n !== null, n !== (e !== null && e.memoizedState !== null) && n && (t.child.flags |= 8192, t.mode & 1 && (e === null || qt.current & 1 ? cr === 0 && (cr = 3) : Nw())), t.updateQueue !== null && (t.flags |= 4), kr(t), null);
    case 4:
      return _l(), G0(e, t), e === null && Ic(t.stateNode.containerInfo), kr(t), null;
    case 10:
      return vw(t.type._context), kr(t), null;
    case 17:
      return en(t.type) && Bh(), kr(t), null;
    case 19:
      if (Nt(qt), s = t.memoizedState, s === null) return kr(t), null;
      if (n = (t.flags & 128) !== 0, o = s.rendering, o === null) if (n) Mu(s, !1);
      else {
        if (cr !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null; ) {
          if (o = Gh(e), o !== null) {
            for (t.flags |= 128, Mu(s, !1), n = o.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), t.subtreeFlags = 0, n = r, r = t.child; r !== null; ) s = r, e = n, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, e = o.dependencies, s.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), r = r.sibling;
            return Tt(qt, qt.current & 1 | 2), t.child;
          }
          e = e.sibling;
        }
        s.tail !== null && Xt() > Ol && (t.flags |= 128, n = !0, Mu(s, !1), t.lanes = 4194304);
      }
      else {
        if (!n) if (e = Gh(o), e !== null) {
          if (t.flags |= 128, n = !0, r = e.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), Mu(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Mt) return kr(t), null;
        } else 2 * Xt() - s.renderingStartTime > Ol && r !== 1073741824 && (t.flags |= 128, n = !0, Mu(s, !1), t.lanes = 4194304);
        s.isBackwards ? (o.sibling = t.child, t.child = o) : (r = s.last, r !== null ? r.sibling = o : t.child = o, s.last = o);
      }
      return s.tail !== null ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = Xt(), t.sibling = null, r = qt.current, Tt(qt, n ? r & 1 | 2 : r & 1), t) : (kr(t), null);
    case 22:
    case 23:
      return jw(), n = t.memoizedState !== null, e !== null && e.memoizedState !== null !== n && (t.flags |= 8192), n && t.mode & 1 ? ln & 1073741824 && (kr(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : kr(t), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(je(156, t.tag));
}
function oB(e, t) {
  switch (hw(t), t.tag) {
    case 1:
      return en(t.type) && Bh(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 3:
      return _l(), Nt(Zr), Nt(jr), _w(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
    case 5:
      return xw(t), null;
    case 13:
      if (Nt(qt), e = t.memoizedState, e !== null && e.dehydrated !== null) {
        if (t.alternate === null) throw Error(je(340));
        Sl();
      }
      return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 19:
      return Nt(qt), null;
    case 4:
      return _l(), null;
    case 10:
      return vw(t.type._context), null;
    case 22:
    case 23:
      return jw(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var zf = !1, Tr = !1, sB = typeof WeakSet == "function" ? WeakSet : Set, Be = null;
function ol(e, t) {
  var r = e.ref;
  if (r !== null) if (typeof r == "function") try {
    r(null);
  } catch (n) {
    Ht(e, t, n);
  }
  else r.current = null;
}
function K0(e, t, r) {
  try {
    r();
  } catch (n) {
    Ht(e, t, n);
  }
}
var ME = !1;
function aB(e, t) {
  if (I0 = Dh, e = r$(), fw(e)) {
    if ("selectionStart" in e) var r = { start: e.selectionStart, end: e.selectionEnd };
    else e: {
      r = (r = e.ownerDocument) && r.defaultView || window;
      var n = r.getSelection && r.getSelection();
      if (n && n.rangeCount !== 0) {
        r = n.anchorNode;
        var i = n.anchorOffset, s = n.focusNode;
        n = n.focusOffset;
        try {
          r.nodeType, s.nodeType;
        } catch {
          r = null;
          break e;
        }
        var o = 0, a = -1, l = -1, p = 0, f = 0, d = e, m = null;
        t: for (; ; ) {
          for (var v; d !== r || i !== 0 && d.nodeType !== 3 || (a = o + i), d !== s || n !== 0 && d.nodeType !== 3 || (l = o + n), d.nodeType === 3 && (o += d.nodeValue.length), (v = d.firstChild) !== null; )
            m = d, d = v;
          for (; ; ) {
            if (d === e) break t;
            if (m === r && ++p === i && (a = o), m === s && ++f === n && (l = o), (v = d.nextSibling) !== null) break;
            d = m, m = d.parentNode;
          }
          d = v;
        }
        r = a === -1 || l === -1 ? null : { start: a, end: l };
      } else r = null;
    }
    r = r || { start: 0, end: 0 };
  } else r = null;
  for (j0 = { focusedElem: e, selectionRange: r }, Dh = !1, Be = t; Be !== null; ) if (t = Be, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, Be = e;
  else for (; Be !== null; ) {
    t = Be;
    try {
      var g = t.alternate;
      if (t.flags & 1024) switch (t.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (g !== null) {
            var S = g.memoizedProps, _ = g.memoizedState, x = t.stateNode, y = x.getSnapshotBeforeUpdate(t.elementType === t.type ? S : Hn(t.type, S), _);
            x.__reactInternalSnapshotBeforeUpdate = y;
          }
          break;
        case 3:
          var w = t.stateNode.containerInfo;
          w.nodeType === 1 ? w.textContent = "" : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(je(163));
      }
    } catch (k) {
      Ht(t, t.return, k);
    }
    if (e = t.sibling, e !== null) {
      e.return = t.return, Be = e;
      break;
    }
    Be = t.return;
  }
  return g = ME, ME = !1, g;
}
function mc(e, t, r) {
  var n = t.updateQueue;
  if (n = n !== null ? n.lastEffect : null, n !== null) {
    var i = n = n.next;
    do {
      if ((i.tag & e) === e) {
        var s = i.destroy;
        i.destroy = void 0, s !== void 0 && K0(t, r, s);
      }
      i = i.next;
    } while (i !== n);
  }
}
function Dm(e, t) {
  if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
    var r = t = t.next;
    do {
      if ((r.tag & e) === e) {
        var n = r.create;
        r.destroy = n();
      }
      r = r.next;
    } while (r !== t);
  }
}
function X0(e) {
  var t = e.ref;
  if (t !== null) {
    var r = e.stateNode;
    switch (e.tag) {
      case 5:
        e = r;
        break;
      default:
        e = r;
    }
    typeof t == "function" ? t(e) : t.current = e;
  }
}
function J$(e) {
  var t = e.alternate;
  t !== null && (e.alternate = null, J$(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Si], delete t[Nc], delete t[M0], delete t[Uq], delete t[Vq])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
}
function Z$(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4;
}
function DE(e) {
  e: for (; ; ) {
    for (; e.sibling === null; ) {
      if (e.return === null || Z$(e.return)) return null;
      e = e.return;
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
      e.child.return = e, e = e.child;
    }
    if (!(e.flags & 2)) return e.stateNode;
  }
}
function J0(e, t, r) {
  var n = e.tag;
  if (n === 5 || n === 6) e = e.stateNode, t ? r.nodeType === 8 ? r.parentNode.insertBefore(e, t) : r.insertBefore(e, t) : (r.nodeType === 8 ? (t = r.parentNode, t.insertBefore(e, r)) : (t = r, t.appendChild(e)), r = r._reactRootContainer, r != null || t.onclick !== null || (t.onclick = qh));
  else if (n !== 4 && (e = e.child, e !== null)) for (J0(e, t, r), e = e.sibling; e !== null; ) J0(e, t, r), e = e.sibling;
}
function Z0(e, t, r) {
  var n = e.tag;
  if (n === 5 || n === 6) e = e.stateNode, t ? r.insertBefore(e, t) : r.appendChild(e);
  else if (n !== 4 && (e = e.child, e !== null)) for (Z0(e, t, r), e = e.sibling; e !== null; ) Z0(e, t, r), e = e.sibling;
}
var vr = null, Qn = !1;
function Oo(e, t, r) {
  for (r = r.child; r !== null; ) eR(e, t, r), r = r.sibling;
}
function eR(e, t, r) {
  if (ki && typeof ki.onCommitFiberUnmount == "function") try {
    ki.onCommitFiberUnmount(Tm, r);
  } catch {
  }
  switch (r.tag) {
    case 5:
      Tr || ol(r, t);
    case 6:
      var n = vr, i = Qn;
      vr = null, Oo(e, t, r), vr = n, Qn = i, vr !== null && (Qn ? (e = vr, r = r.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r)) : vr.removeChild(r.stateNode));
      break;
    case 18:
      vr !== null && (Qn ? (e = vr, r = r.stateNode, e.nodeType === 8 ? ky(e.parentNode, r) : e.nodeType === 1 && ky(e, r), Tc(e)) : ky(vr, r.stateNode));
      break;
    case 4:
      n = vr, i = Qn, vr = r.stateNode.containerInfo, Qn = !0, Oo(e, t, r), vr = n, Qn = i;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!Tr && (n = r.updateQueue, n !== null && (n = n.lastEffect, n !== null))) {
        i = n = n.next;
        do {
          var s = i, o = s.destroy;
          s = s.tag, o !== void 0 && (s & 2 || s & 4) && K0(r, t, o), i = i.next;
        } while (i !== n);
      }
      Oo(e, t, r);
      break;
    case 1:
      if (!Tr && (ol(r, t), n = r.stateNode, typeof n.componentWillUnmount == "function")) try {
        n.props = r.memoizedProps, n.state = r.memoizedState, n.componentWillUnmount();
      } catch (a) {
        Ht(r, t, a);
      }
      Oo(e, t, r);
      break;
    case 21:
      Oo(e, t, r);
      break;
    case 22:
      r.mode & 1 ? (Tr = (n = Tr) || r.memoizedState !== null, Oo(e, t, r), Tr = n) : Oo(e, t, r);
      break;
    default:
      Oo(e, t, r);
  }
}
function FE(e) {
  var t = e.updateQueue;
  if (t !== null) {
    e.updateQueue = null;
    var r = e.stateNode;
    r === null && (r = e.stateNode = new sB()), t.forEach(function(n) {
      var i = gB.bind(null, e, n);
      r.has(n) || (r.add(n), n.then(i, i));
    });
  }
}
function Bn(e, t) {
  var r = t.deletions;
  if (r !== null) for (var n = 0; n < r.length; n++) {
    var i = r[n];
    try {
      var s = e, o = t, a = o;
      e: for (; a !== null; ) {
        switch (a.tag) {
          case 5:
            vr = a.stateNode, Qn = !1;
            break e;
          case 3:
            vr = a.stateNode.containerInfo, Qn = !0;
            break e;
          case 4:
            vr = a.stateNode.containerInfo, Qn = !0;
            break e;
        }
        a = a.return;
      }
      if (vr === null) throw Error(je(160));
      eR(s, o, i), vr = null, Qn = !1;
      var l = i.alternate;
      l !== null && (l.return = null), i.return = null;
    } catch (p) {
      Ht(i, t, p);
    }
  }
  if (t.subtreeFlags & 12854) for (t = t.child; t !== null; ) tR(t, e), t = t.sibling;
}
function tR(e, t) {
  var r = e.alternate, n = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (Bn(t, e), gi(e), n & 4) {
        try {
          mc(3, e, e.return), Dm(3, e);
        } catch (S) {
          Ht(e, e.return, S);
        }
        try {
          mc(5, e, e.return);
        } catch (S) {
          Ht(e, e.return, S);
        }
      }
      break;
    case 1:
      Bn(t, e), gi(e), n & 512 && r !== null && ol(r, r.return);
      break;
    case 5:
      if (Bn(t, e), gi(e), n & 512 && r !== null && ol(r, r.return), e.flags & 32) {
        var i = e.stateNode;
        try {
          kc(i, "");
        } catch (S) {
          Ht(e, e.return, S);
        }
      }
      if (n & 4 && (i = e.stateNode, i != null)) {
        var s = e.memoizedProps, o = r !== null ? r.memoizedProps : s, a = e.type, l = e.updateQueue;
        if (e.updateQueue = null, l !== null) try {
          a === "input" && s.type === "radio" && s.name != null && _T(i, s), _0(a, o);
          var p = _0(a, s);
          for (o = 0; o < l.length; o += 2) {
            var f = l[o], d = l[o + 1];
            f === "style" ? PT(i, d) : f === "dangerouslySetInnerHTML" ? kT(i, d) : f === "children" ? kc(i, d) : Zb(i, f, d, p);
          }
          switch (a) {
            case "input":
              v0(i, s);
              break;
            case "textarea":
              ET(i, s);
              break;
            case "select":
              var m = i._wrapperState.wasMultiple;
              i._wrapperState.wasMultiple = !!s.multiple;
              var v = s.value;
              v != null ? fl(i, !!s.multiple, v, !1) : m !== !!s.multiple && (s.defaultValue != null ? fl(
                i,
                !!s.multiple,
                s.defaultValue,
                !0
              ) : fl(i, !!s.multiple, s.multiple ? [] : "", !1));
          }
          i[Nc] = s;
        } catch (S) {
          Ht(e, e.return, S);
        }
      }
      break;
    case 6:
      if (Bn(t, e), gi(e), n & 4) {
        if (e.stateNode === null) throw Error(je(162));
        i = e.stateNode, s = e.memoizedProps;
        try {
          i.nodeValue = s;
        } catch (S) {
          Ht(e, e.return, S);
        }
      }
      break;
    case 3:
      if (Bn(t, e), gi(e), n & 4 && r !== null && r.memoizedState.isDehydrated) try {
        Tc(t.containerInfo);
      } catch (S) {
        Ht(e, e.return, S);
      }
      break;
    case 4:
      Bn(t, e), gi(e);
      break;
    case 13:
      Bn(t, e), gi(e), i = e.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (Rw = Xt())), n & 4 && FE(e);
      break;
    case 22:
      if (f = r !== null && r.memoizedState !== null, e.mode & 1 ? (Tr = (p = Tr) || f, Bn(t, e), Tr = p) : Bn(t, e), gi(e), n & 8192) {
        if (p = e.memoizedState !== null, (e.stateNode.isHidden = p) && !f && e.mode & 1) for (Be = e, f = e.child; f !== null; ) {
          for (d = Be = f; Be !== null; ) {
            switch (m = Be, v = m.child, m.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                mc(4, m, m.return);
                break;
              case 1:
                ol(m, m.return);
                var g = m.stateNode;
                if (typeof g.componentWillUnmount == "function") {
                  n = m, r = m.return;
                  try {
                    t = n, g.props = t.memoizedProps, g.state = t.memoizedState, g.componentWillUnmount();
                  } catch (S) {
                    Ht(n, r, S);
                  }
                }
                break;
              case 5:
                ol(m, m.return);
                break;
              case 22:
                if (m.memoizedState !== null) {
                  qE(d);
                  continue;
                }
            }
            v !== null ? (v.return = m, Be = v) : qE(d);
          }
          f = f.sibling;
        }
        e: for (f = null, d = e; ; ) {
          if (d.tag === 5) {
            if (f === null) {
              f = d;
              try {
                i = d.stateNode, p ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = AT("display", o));
              } catch (S) {
                Ht(e, e.return, S);
              }
            }
          } else if (d.tag === 6) {
            if (f === null) try {
              d.stateNode.nodeValue = p ? "" : d.memoizedProps;
            } catch (S) {
              Ht(e, e.return, S);
            }
          } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
          if (d === e) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === e) break e;
            f === d && (f = null), d = d.return;
          }
          f === d && (f = null), d.sibling.return = d.return, d = d.sibling;
        }
      }
      break;
    case 19:
      Bn(t, e), gi(e), n & 4 && FE(e);
      break;
    case 21:
      break;
    default:
      Bn(
        t,
        e
      ), gi(e);
  }
}
function gi(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      e: {
        for (var r = e.return; r !== null; ) {
          if (Z$(r)) {
            var n = r;
            break e;
          }
          r = r.return;
        }
        throw Error(je(160));
      }
      switch (n.tag) {
        case 5:
          var i = n.stateNode;
          n.flags & 32 && (kc(i, ""), n.flags &= -33);
          var s = DE(e);
          Z0(e, s, i);
          break;
        case 3:
        case 4:
          var o = n.stateNode.containerInfo, a = DE(e);
          J0(e, a, o);
          break;
        default:
          throw Error(je(161));
      }
    } catch (l) {
      Ht(e, e.return, l);
    }
    e.flags &= -3;
  }
  t & 4096 && (e.flags &= -4097);
}
function lB(e, t, r) {
  Be = e, rR(e);
}
function rR(e, t, r) {
  for (var n = (e.mode & 1) !== 0; Be !== null; ) {
    var i = Be, s = i.child;
    if (i.tag === 22 && n) {
      var o = i.memoizedState !== null || zf;
      if (!o) {
        var a = i.alternate, l = a !== null && a.memoizedState !== null || Tr;
        a = zf;
        var p = Tr;
        if (zf = o, (Tr = l) && !p) for (Be = i; Be !== null; ) o = Be, l = o.child, o.tag === 22 && o.memoizedState !== null ? BE(i) : l !== null ? (l.return = o, Be = l) : BE(i);
        for (; s !== null; ) Be = s, rR(s), s = s.sibling;
        Be = i, zf = a, Tr = p;
      }
      zE(e);
    } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, Be = s) : zE(e);
  }
}
function zE(e) {
  for (; Be !== null; ) {
    var t = Be;
    if (t.flags & 8772) {
      var r = t.alternate;
      try {
        if (t.flags & 8772) switch (t.tag) {
          case 0:
          case 11:
          case 15:
            Tr || Dm(5, t);
            break;
          case 1:
            var n = t.stateNode;
            if (t.flags & 4 && !Tr) if (r === null) n.componentDidMount();
            else {
              var i = t.elementType === t.type ? r.memoizedProps : Hn(t.type, r.memoizedProps);
              n.componentDidUpdate(i, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate);
            }
            var s = t.updateQueue;
            s !== null && EE(t, s, n);
            break;
          case 3:
            var o = t.updateQueue;
            if (o !== null) {
              if (r = null, t.child !== null) switch (t.child.tag) {
                case 5:
                  r = t.child.stateNode;
                  break;
                case 1:
                  r = t.child.stateNode;
              }
              EE(t, o, r);
            }
            break;
          case 5:
            var a = t.stateNode;
            if (r === null && t.flags & 4) {
              r = a;
              var l = t.memoizedProps;
              switch (t.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  l.autoFocus && r.focus();
                  break;
                case "img":
                  l.src && (r.src = l.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (t.memoizedState === null) {
              var p = t.alternate;
              if (p !== null) {
                var f = p.memoizedState;
                if (f !== null) {
                  var d = f.dehydrated;
                  d !== null && Tc(d);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(je(163));
        }
        Tr || t.flags & 512 && X0(t);
      } catch (m) {
        Ht(t, t.return, m);
      }
    }
    if (t === e) {
      Be = null;
      break;
    }
    if (r = t.sibling, r !== null) {
      r.return = t.return, Be = r;
      break;
    }
    Be = t.return;
  }
}
function qE(e) {
  for (; Be !== null; ) {
    var t = Be;
    if (t === e) {
      Be = null;
      break;
    }
    var r = t.sibling;
    if (r !== null) {
      r.return = t.return, Be = r;
      break;
    }
    Be = t.return;
  }
}
function BE(e) {
  for (; Be !== null; ) {
    var t = Be;
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var r = t.return;
          try {
            Dm(4, t);
          } catch (l) {
            Ht(t, r, l);
          }
          break;
        case 1:
          var n = t.stateNode;
          if (typeof n.componentDidMount == "function") {
            var i = t.return;
            try {
              n.componentDidMount();
            } catch (l) {
              Ht(t, i, l);
            }
          }
          var s = t.return;
          try {
            X0(t);
          } catch (l) {
            Ht(t, s, l);
          }
          break;
        case 5:
          var o = t.return;
          try {
            X0(t);
          } catch (l) {
            Ht(t, o, l);
          }
      }
    } catch (l) {
      Ht(t, t.return, l);
    }
    if (t === e) {
      Be = null;
      break;
    }
    var a = t.sibling;
    if (a !== null) {
      a.return = t.return, Be = a;
      break;
    }
    Be = t.return;
  }
}
var uB = Math.ceil, Jh = vo.ReactCurrentDispatcher, Tw = vo.ReactCurrentOwner, In = vo.ReactCurrentBatchConfig, dt = 0, dr = null, ir = null, wr = 0, ln = 0, sl = ss(0), cr = 0, qc = null, Zs = 0, Fm = 0, $w = 0, gc = null, Hr = null, Rw = 0, Ol = 1 / 0, Gi = null, Zh = !1, eb = null, Wo = null, qf = !1, No = null, em = 0, yc = 0, tb = null, mh = -1, gh = 0;
function Fr() {
  return dt & 6 ? Xt() : mh !== -1 ? mh : mh = Xt();
}
function Ho(e) {
  return e.mode & 1 ? dt & 2 && wr !== 0 ? wr & -wr : Hq.transition !== null ? (gh === 0 && (gh = zT()), gh) : (e = wt, e !== 0 || (e = window.event, e = e === void 0 ? 16 : QT(e.type)), e) : 1;
}
function Xn(e, t, r, n) {
  if (50 < yc) throw yc = 0, tb = null, Error(je(185));
  ip(e, r, n), (!(dt & 2) || e !== dr) && (e === dr && (!(dt & 2) && (Fm |= r), cr === 4 && Io(e, wr)), tn(e, n), r === 1 && dt === 0 && !(t.mode & 1) && (Ol = Xt() + 500, Nm && as()));
}
function tn(e, t) {
  var r = e.callbackNode;
  Hz(e, t);
  var n = Mh(e, e === dr ? wr : 0);
  if (n === 0) r !== null && X_(r), e.callbackNode = null, e.callbackPriority = 0;
  else if (t = n & -n, e.callbackPriority !== t) {
    if (r != null && X_(r), t === 1) e.tag === 0 ? Wq(UE.bind(null, e)) : f$(UE.bind(null, e)), qq(function() {
      !(dt & 6) && as();
    }), r = null;
    else {
      switch (qT(n)) {
        case 1:
          r = iw;
          break;
        case 4:
          r = DT;
          break;
        case 16:
          r = Lh;
          break;
        case 536870912:
          r = FT;
          break;
        default:
          r = Lh;
      }
      r = cR(r, nR.bind(null, e));
    }
    e.callbackPriority = t, e.callbackNode = r;
  }
}
function nR(e, t) {
  if (mh = -1, gh = 0, dt & 6) throw Error(je(327));
  var r = e.callbackNode;
  if (yl() && e.callbackNode !== r) return null;
  var n = Mh(e, e === dr ? wr : 0);
  if (n === 0) return null;
  if (n & 30 || n & e.expiredLanes || t) t = tm(e, n);
  else {
    t = n;
    var i = dt;
    dt |= 2;
    var s = oR();
    (dr !== e || wr !== t) && (Gi = null, Ol = Xt() + 500, Ws(e, t));
    do
      try {
        fB();
        break;
      } catch (a) {
        iR(e, a);
      }
    while (!0);
    yw(), Jh.current = s, dt = i, ir !== null ? t = 0 : (dr = null, wr = 0, t = cr);
  }
  if (t !== 0) {
    if (t === 2 && (i = P0(e), i !== 0 && (n = i, t = rb(e, i))), t === 1) throw r = qc, Ws(e, 0), Io(e, n), tn(e, Xt()), r;
    if (t === 6) Io(e, n);
    else {
      if (i = e.current.alternate, !(n & 30) && !cB(i) && (t = tm(e, n), t === 2 && (s = P0(e), s !== 0 && (n = s, t = rb(e, s))), t === 1)) throw r = qc, Ws(e, 0), Io(e, n), tn(e, Xt()), r;
      switch (e.finishedWork = i, e.finishedLanes = n, t) {
        case 0:
        case 1:
          throw Error(je(345));
        case 2:
          Ms(e, Hr, Gi);
          break;
        case 3:
          if (Io(e, n), (n & 130023424) === n && (t = Rw + 500 - Xt(), 10 < t)) {
            if (Mh(e, 0) !== 0) break;
            if (i = e.suspendedLanes, (i & n) !== n) {
              Fr(), e.pingedLanes |= e.suspendedLanes & i;
              break;
            }
            e.timeoutHandle = L0(Ms.bind(null, e, Hr, Gi), t);
            break;
          }
          Ms(e, Hr, Gi);
          break;
        case 4:
          if (Io(e, n), (n & 4194240) === n) break;
          for (t = e.eventTimes, i = -1; 0 < n; ) {
            var o = 31 - Kn(n);
            s = 1 << o, o = t[o], o > i && (i = o), n &= ~s;
          }
          if (n = i, n = Xt() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * uB(n / 1960)) - n, 10 < n) {
            e.timeoutHandle = L0(Ms.bind(null, e, Hr, Gi), n);
            break;
          }
          Ms(e, Hr, Gi);
          break;
        case 5:
          Ms(e, Hr, Gi);
          break;
        default:
          throw Error(je(329));
      }
    }
  }
  return tn(e, Xt()), e.callbackNode === r ? nR.bind(null, e) : null;
}
function rb(e, t) {
  var r = gc;
  return e.current.memoizedState.isDehydrated && (Ws(e, t).flags |= 256), e = tm(e, t), e !== 2 && (t = Hr, Hr = r, t !== null && nb(t)), e;
}
function nb(e) {
  Hr === null ? Hr = e : Hr.push.apply(Hr, e);
}
function cB(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var r = t.updateQueue;
      if (r !== null && (r = r.stores, r !== null)) for (var n = 0; n < r.length; n++) {
        var i = r[n], s = i.getSnapshot;
        i = i.value;
        try {
          if (!ni(s(), i)) return !1;
        } catch {
          return !1;
        }
      }
    }
    if (r = t.child, t.subtreeFlags & 16384 && r !== null) r.return = t, t = r;
    else {
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0;
        t = t.return;
      }
      t.sibling.return = t.return, t = t.sibling;
    }
  }
  return !0;
}
function Io(e, t) {
  for (t &= ~$w, t &= ~Fm, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t; ) {
    var r = 31 - Kn(t), n = 1 << r;
    e[r] = -1, t &= ~n;
  }
}
function UE(e) {
  if (dt & 6) throw Error(je(327));
  yl();
  var t = Mh(e, 0);
  if (!(t & 1)) return tn(e, Xt()), null;
  var r = tm(e, t);
  if (e.tag !== 0 && r === 2) {
    var n = P0(e);
    n !== 0 && (t = n, r = rb(e, n));
  }
  if (r === 1) throw r = qc, Ws(e, 0), Io(e, t), tn(e, Xt()), r;
  if (r === 6) throw Error(je(345));
  return e.finishedWork = e.current.alternate, e.finishedLanes = t, Ms(e, Hr, Gi), tn(e, Xt()), null;
}
function Iw(e, t) {
  var r = dt;
  dt |= 1;
  try {
    return e(t);
  } finally {
    dt = r, dt === 0 && (Ol = Xt() + 500, Nm && as());
  }
}
function ea(e) {
  No !== null && No.tag === 0 && !(dt & 6) && yl();
  var t = dt;
  dt |= 1;
  var r = In.transition, n = wt;
  try {
    if (In.transition = null, wt = 1, e) return e();
  } finally {
    wt = n, In.transition = r, dt = t, !(dt & 6) && as();
  }
}
function jw() {
  ln = sl.current, Nt(sl);
}
function Ws(e, t) {
  e.finishedWork = null, e.finishedLanes = 0;
  var r = e.timeoutHandle;
  if (r !== -1 && (e.timeoutHandle = -1, zq(r)), ir !== null) for (r = ir.return; r !== null; ) {
    var n = r;
    switch (hw(n), n.tag) {
      case 1:
        n = n.type.childContextTypes, n != null && Bh();
        break;
      case 3:
        _l(), Nt(Zr), Nt(jr), _w();
        break;
      case 5:
        xw(n);
        break;
      case 4:
        _l();
        break;
      case 13:
        Nt(qt);
        break;
      case 19:
        Nt(qt);
        break;
      case 10:
        vw(n.type._context);
        break;
      case 22:
      case 23:
        jw();
    }
    r = r.return;
  }
  if (dr = e, ir = e = Qo(e.current, null), wr = ln = t, cr = 0, qc = null, $w = Fm = Zs = 0, Hr = gc = null, qs !== null) {
    for (t = 0; t < qs.length; t++) if (r = qs[t], n = r.interleaved, n !== null) {
      r.interleaved = null;
      var i = n.next, s = r.pending;
      if (s !== null) {
        var o = s.next;
        s.next = i, n.next = o;
      }
      r.pending = n;
    }
    qs = null;
  }
  return e;
}
function iR(e, t) {
  do {
    var r = ir;
    try {
      if (yw(), fh.current = Xh, Kh) {
        for (var n = Bt.memoizedState; n !== null; ) {
          var i = n.queue;
          i !== null && (i.pending = null), n = n.next;
        }
        Kh = !1;
      }
      if (Js = 0, pr = lr = Bt = null, hc = !1, Dc = 0, Tw.current = null, r === null || r.return === null) {
        cr = 1, qc = t, ir = null;
        break;
      }
      e: {
        var s = e, o = r.return, a = r, l = t;
        if (t = wr, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
          var p = l, f = a, d = f.tag;
          if (!(f.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var m = f.alternate;
            m ? (f.updateQueue = m.updateQueue, f.memoizedState = m.memoizedState, f.lanes = m.lanes) : (f.updateQueue = null, f.memoizedState = null);
          }
          var v = TE(o);
          if (v !== null) {
            v.flags &= -257, $E(v, o, a, s, t), v.mode & 1 && CE(s, p, t), t = v, l = p;
            var g = t.updateQueue;
            if (g === null) {
              var S = /* @__PURE__ */ new Set();
              S.add(l), t.updateQueue = S;
            } else g.add(l);
            break e;
          } else {
            if (!(t & 1)) {
              CE(s, p, t), Nw();
              break e;
            }
            l = Error(je(426));
          }
        } else if (Mt && a.mode & 1) {
          var _ = TE(o);
          if (_ !== null) {
            !(_.flags & 65536) && (_.flags |= 256), $E(_, o, a, s, t), mw(El(l, a));
            break e;
          }
        }
        s = l = El(l, a), cr !== 4 && (cr = 2), gc === null ? gc = [s] : gc.push(s), s = o;
        do {
          switch (s.tag) {
            case 3:
              s.flags |= 65536, t &= -t, s.lanes |= t;
              var x = q$(s, l, t);
              _E(s, x);
              break e;
            case 1:
              a = l;
              var y = s.type, w = s.stateNode;
              if (!(s.flags & 128) && (typeof y.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (Wo === null || !Wo.has(w)))) {
                s.flags |= 65536, t &= -t, s.lanes |= t;
                var k = B$(s, a, t);
                _E(s, k);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      aR(r);
    } catch (A) {
      t = A, ir === r && r !== null && (ir = r = r.return);
      continue;
    }
    break;
  } while (!0);
}
function oR() {
  var e = Jh.current;
  return Jh.current = Xh, e === null ? Xh : e;
}
function Nw() {
  (cr === 0 || cr === 3 || cr === 2) && (cr = 4), dr === null || !(Zs & 268435455) && !(Fm & 268435455) || Io(dr, wr);
}
function tm(e, t) {
  var r = dt;
  dt |= 2;
  var n = oR();
  (dr !== e || wr !== t) && (Gi = null, Ws(e, t));
  do
    try {
      pB();
      break;
    } catch (i) {
      iR(e, i);
    }
  while (!0);
  if (yw(), dt = r, Jh.current = n, ir !== null) throw Error(je(261));
  return dr = null, wr = 0, cr;
}
function pB() {
  for (; ir !== null; ) sR(ir);
}
function fB() {
  for (; ir !== null && !Mz(); ) sR(ir);
}
function sR(e) {
  var t = uR(e.alternate, e, ln);
  e.memoizedProps = e.pendingProps, t === null ? aR(e) : ir = t, Tw.current = null;
}
function aR(e) {
  var t = e;
  do {
    var r = t.alternate;
    if (e = t.return, t.flags & 32768) {
      if (r = oB(r, t), r !== null) {
        r.flags &= 32767, ir = r;
        return;
      }
      if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
      else {
        cr = 6, ir = null;
        return;
      }
    } else if (r = iB(r, t, ln), r !== null) {
      ir = r;
      return;
    }
    if (t = t.sibling, t !== null) {
      ir = t;
      return;
    }
    ir = t = e;
  } while (t !== null);
  cr === 0 && (cr = 5);
}
function Ms(e, t, r) {
  var n = wt, i = In.transition;
  try {
    In.transition = null, wt = 1, dB(e, t, r, n);
  } finally {
    In.transition = i, wt = n;
  }
  return null;
}
function dB(e, t, r, n) {
  do
    yl();
  while (No !== null);
  if (dt & 6) throw Error(je(327));
  r = e.finishedWork;
  var i = e.finishedLanes;
  if (r === null) return null;
  if (e.finishedWork = null, e.finishedLanes = 0, r === e.current) throw Error(je(177));
  e.callbackNode = null, e.callbackPriority = 0;
  var s = r.lanes | r.childLanes;
  if (Qz(e, s), e === dr && (ir = dr = null, wr = 0), !(r.subtreeFlags & 2064) && !(r.flags & 2064) || qf || (qf = !0, cR(Lh, function() {
    return yl(), null;
  })), s = (r.flags & 15990) !== 0, r.subtreeFlags & 15990 || s) {
    s = In.transition, In.transition = null;
    var o = wt;
    wt = 1;
    var a = dt;
    dt |= 4, Tw.current = null, aB(e, r), tR(r, e), Iq(j0), Dh = !!I0, j0 = I0 = null, e.current = r, lB(r), Dz(), dt = a, wt = o, In.transition = s;
  } else e.current = r;
  if (qf && (qf = !1, No = e, em = i), s = e.pendingLanes, s === 0 && (Wo = null), qz(r.stateNode), tn(e, Xt()), t !== null) for (n = e.onRecoverableError, r = 0; r < t.length; r++) i = t[r], n(i.value, { componentStack: i.stack, digest: i.digest });
  if (Zh) throw Zh = !1, e = eb, eb = null, e;
  return em & 1 && e.tag !== 0 && yl(), s = e.pendingLanes, s & 1 ? e === tb ? yc++ : (yc = 0, tb = e) : yc = 0, as(), null;
}
function yl() {
  if (No !== null) {
    var e = qT(em), t = In.transition, r = wt;
    try {
      if (In.transition = null, wt = 16 > e ? 16 : e, No === null) var n = !1;
      else {
        if (e = No, No = null, em = 0, dt & 6) throw Error(je(331));
        var i = dt;
        for (dt |= 4, Be = e.current; Be !== null; ) {
          var s = Be, o = s.child;
          if (Be.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var p = a[l];
                for (Be = p; Be !== null; ) {
                  var f = Be;
                  switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      mc(8, f, s);
                  }
                  var d = f.child;
                  if (d !== null) d.return = f, Be = d;
                  else for (; Be !== null; ) {
                    f = Be;
                    var m = f.sibling, v = f.return;
                    if (J$(f), f === p) {
                      Be = null;
                      break;
                    }
                    if (m !== null) {
                      m.return = v, Be = m;
                      break;
                    }
                    Be = v;
                  }
                }
              }
              var g = s.alternate;
              if (g !== null) {
                var S = g.child;
                if (S !== null) {
                  g.child = null;
                  do {
                    var _ = S.sibling;
                    S.sibling = null, S = _;
                  } while (S !== null);
                }
              }
              Be = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) o.return = s, Be = o;
          else e: for (; Be !== null; ) {
            if (s = Be, s.flags & 2048) switch (s.tag) {
              case 0:
              case 11:
              case 15:
                mc(9, s, s.return);
            }
            var x = s.sibling;
            if (x !== null) {
              x.return = s.return, Be = x;
              break e;
            }
            Be = s.return;
          }
        }
        var y = e.current;
        for (Be = y; Be !== null; ) {
          o = Be;
          var w = o.child;
          if (o.subtreeFlags & 2064 && w !== null) w.return = o, Be = w;
          else e: for (o = y; Be !== null; ) {
            if (a = Be, a.flags & 2048) try {
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  Dm(9, a);
              }
            } catch (A) {
              Ht(a, a.return, A);
            }
            if (a === o) {
              Be = null;
              break e;
            }
            var k = a.sibling;
            if (k !== null) {
              k.return = a.return, Be = k;
              break e;
            }
            Be = a.return;
          }
        }
        if (dt = i, as(), ki && typeof ki.onPostCommitFiberRoot == "function") try {
          ki.onPostCommitFiberRoot(Tm, e);
        } catch {
        }
        n = !0;
      }
      return n;
    } finally {
      wt = r, In.transition = t;
    }
  }
  return !1;
}
function VE(e, t, r) {
  t = El(r, t), t = q$(e, t, 1), e = Vo(e, t, 1), t = Fr(), e !== null && (ip(e, 1, t), tn(e, t));
}
function Ht(e, t, r) {
  if (e.tag === 3) VE(e, e, r);
  else for (; t !== null; ) {
    if (t.tag === 3) {
      VE(t, e, r);
      break;
    } else if (t.tag === 1) {
      var n = t.stateNode;
      if (typeof t.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (Wo === null || !Wo.has(n))) {
        e = El(r, e), e = B$(t, e, 1), t = Vo(t, e, 1), e = Fr(), t !== null && (ip(t, 1, e), tn(t, e));
        break;
      }
    }
    t = t.return;
  }
}
function hB(e, t, r) {
  var n = e.pingCache;
  n !== null && n.delete(t), t = Fr(), e.pingedLanes |= e.suspendedLanes & r, dr === e && (wr & r) === r && (cr === 4 || cr === 3 && (wr & 130023424) === wr && 500 > Xt() - Rw ? Ws(e, 0) : $w |= r), tn(e, t);
}
function lR(e, t) {
  t === 0 && (e.mode & 1 ? (t = $f, $f <<= 1, !($f & 130023424) && ($f = 4194304)) : t = 1);
  var r = Fr();
  e = lo(e, t), e !== null && (ip(e, t, r), tn(e, r));
}
function mB(e) {
  var t = e.memoizedState, r = 0;
  t !== null && (r = t.retryLane), lR(e, r);
}
function gB(e, t) {
  var r = 0;
  switch (e.tag) {
    case 13:
      var n = e.stateNode, i = e.memoizedState;
      i !== null && (r = i.retryLane);
      break;
    case 19:
      n = e.stateNode;
      break;
    default:
      throw Error(je(314));
  }
  n !== null && n.delete(t), lR(e, r);
}
var uR;
uR = function(e, t, r) {
  if (e !== null) if (e.memoizedProps !== t.pendingProps || Zr.current) Kr = !0;
  else {
    if (!(e.lanes & r) && !(t.flags & 128)) return Kr = !1, nB(e, t, r);
    Kr = !!(e.flags & 131072);
  }
  else Kr = !1, Mt && t.flags & 1048576 && d$(t, Wh, t.index);
  switch (t.lanes = 0, t.tag) {
    case 2:
      var n = t.type;
      hh(e, t), e = t.pendingProps;
      var i = wl(t, jr.current);
      gl(t, r), i = Ow(null, t, n, e, i, r);
      var s = kw();
      return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, en(n) ? (s = !0, Uh(t)) : s = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, ww(t), i.updater = Mm, t.stateNode = i, i._reactInternals = t, U0(t, n, e, r), t = H0(null, t, n, !0, s, r)) : (t.tag = 0, Mt && s && dw(t), Dr(null, t, i, r), t = t.child), t;
    case 16:
      n = t.elementType;
      e: {
        switch (hh(e, t), e = t.pendingProps, i = n._init, n = i(n._payload), t.type = n, i = t.tag = vB(n), e = Hn(n, e), i) {
          case 0:
            t = W0(null, t, n, e, r);
            break e;
          case 1:
            t = jE(null, t, n, e, r);
            break e;
          case 11:
            t = RE(null, t, n, e, r);
            break e;
          case 14:
            t = IE(null, t, n, Hn(n.type, e), r);
            break e;
        }
        throw Error(je(
          306,
          n,
          ""
        ));
      }
      return t;
    case 0:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Hn(n, i), W0(e, t, n, i, r);
    case 1:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Hn(n, i), jE(e, t, n, i, r);
    case 3:
      e: {
        if (H$(t), e === null) throw Error(je(387));
        n = t.pendingProps, s = t.memoizedState, i = s.element, b$(e, t), Yh(t, n, null, r);
        var o = t.memoizedState;
        if (n = o.element, s.isDehydrated) if (s = { element: n, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) {
          i = El(Error(je(423)), t), t = NE(e, t, n, r, i);
          break e;
        } else if (n !== i) {
          i = El(Error(je(424)), t), t = NE(e, t, n, r, i);
          break e;
        } else for (fn = Uo(t.stateNode.containerInfo.firstChild), dn = t, Mt = !0, Yn = null, r = y$(t, null, n, r), t.child = r; r; ) r.flags = r.flags & -3 | 4096, r = r.sibling;
        else {
          if (Sl(), n === i) {
            t = uo(e, t, r);
            break e;
          }
          Dr(e, t, n, r);
        }
        t = t.child;
      }
      return t;
    case 5:
      return w$(t), e === null && z0(t), n = t.type, i = t.pendingProps, s = e !== null ? e.memoizedProps : null, o = i.children, N0(n, i) ? o = null : s !== null && N0(n, s) && (t.flags |= 32), W$(e, t), Dr(e, t, o, r), t.child;
    case 6:
      return e === null && z0(t), null;
    case 13:
      return Q$(e, t, r);
    case 4:
      return Sw(t, t.stateNode.containerInfo), n = t.pendingProps, e === null ? t.child = xl(t, null, n, r) : Dr(e, t, n, r), t.child;
    case 11:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Hn(n, i), RE(e, t, n, i, r);
    case 7:
      return Dr(e, t, t.pendingProps, r), t.child;
    case 8:
      return Dr(e, t, t.pendingProps.children, r), t.child;
    case 12:
      return Dr(e, t, t.pendingProps.children, r), t.child;
    case 10:
      e: {
        if (n = t.type._context, i = t.pendingProps, s = t.memoizedProps, o = i.value, Tt(Hh, n._currentValue), n._currentValue = o, s !== null) if (ni(s.value, o)) {
          if (s.children === i.children && !Zr.current) {
            t = uo(e, t, r);
            break e;
          }
        } else for (s = t.child, s !== null && (s.return = t); s !== null; ) {
          var a = s.dependencies;
          if (a !== null) {
            o = s.child;
            for (var l = a.firstContext; l !== null; ) {
              if (l.context === n) {
                if (s.tag === 1) {
                  l = to(-1, r & -r), l.tag = 2;
                  var p = s.updateQueue;
                  if (p !== null) {
                    p = p.shared;
                    var f = p.pending;
                    f === null ? l.next = l : (l.next = f.next, f.next = l), p.pending = l;
                  }
                }
                s.lanes |= r, l = s.alternate, l !== null && (l.lanes |= r), q0(
                  s.return,
                  r,
                  t
                ), a.lanes |= r;
                break;
              }
              l = l.next;
            }
          } else if (s.tag === 10) o = s.type === t.type ? null : s.child;
          else if (s.tag === 18) {
            if (o = s.return, o === null) throw Error(je(341));
            o.lanes |= r, a = o.alternate, a !== null && (a.lanes |= r), q0(o, r, t), o = s.sibling;
          } else o = s.child;
          if (o !== null) o.return = s;
          else for (o = s; o !== null; ) {
            if (o === t) {
              o = null;
              break;
            }
            if (s = o.sibling, s !== null) {
              s.return = o.return, o = s;
              break;
            }
            o = o.return;
          }
          s = o;
        }
        Dr(e, t, i.children, r), t = t.child;
      }
      return t;
    case 9:
      return i = t.type, n = t.pendingProps.children, gl(t, r), i = jn(i), n = n(i), t.flags |= 1, Dr(e, t, n, r), t.child;
    case 14:
      return n = t.type, i = Hn(n, t.pendingProps), i = Hn(n.type, i), IE(e, t, n, i, r);
    case 15:
      return U$(e, t, t.type, t.pendingProps, r);
    case 17:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Hn(n, i), hh(e, t), t.tag = 1, en(n) ? (e = !0, Uh(t)) : e = !1, gl(t, r), z$(t, n, i), U0(t, n, i, r), H0(null, t, n, !0, e, r);
    case 19:
      return Y$(e, t, r);
    case 22:
      return V$(e, t, r);
  }
  throw Error(je(156, t.tag));
};
function cR(e, t) {
  return MT(e, t);
}
function yB(e, t, r, n) {
  this.tag = e, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function $n(e, t, r, n) {
  return new yB(e, t, r, n);
}
function Lw(e) {
  return e = e.prototype, !(!e || !e.isReactComponent);
}
function vB(e) {
  if (typeof e == "function") return Lw(e) ? 1 : 0;
  if (e != null) {
    if (e = e.$$typeof, e === tw) return 11;
    if (e === rw) return 14;
  }
  return 2;
}
function Qo(e, t) {
  var r = e.alternate;
  return r === null ? (r = $n(e.tag, t, e.key, e.mode), r.elementType = e.elementType, r.type = e.type, r.stateNode = e.stateNode, r.alternate = e, e.alternate = r) : (r.pendingProps = t, r.type = e.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = e.flags & 14680064, r.childLanes = e.childLanes, r.lanes = e.lanes, r.child = e.child, r.memoizedProps = e.memoizedProps, r.memoizedState = e.memoizedState, r.updateQueue = e.updateQueue, t = e.dependencies, r.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, r.sibling = e.sibling, r.index = e.index, r.ref = e.ref, r;
}
function yh(e, t, r, n, i, s) {
  var o = 2;
  if (n = e, typeof e == "function") Lw(e) && (o = 1);
  else if (typeof e == "string") o = 5;
  else e: switch (e) {
    case Ka:
      return Hs(r.children, i, s, t);
    case ew:
      o = 8, i |= 8;
      break;
    case d0:
      return e = $n(12, r, t, i | 2), e.elementType = d0, e.lanes = s, e;
    case h0:
      return e = $n(13, r, t, i), e.elementType = h0, e.lanes = s, e;
    case m0:
      return e = $n(19, r, t, i), e.elementType = m0, e.lanes = s, e;
    case wT:
      return zm(r, i, s, t);
    default:
      if (typeof e == "object" && e !== null) switch (e.$$typeof) {
        case vT:
          o = 10;
          break e;
        case bT:
          o = 9;
          break e;
        case tw:
          o = 11;
          break e;
        case rw:
          o = 14;
          break e;
        case To:
          o = 16, n = null;
          break e;
      }
      throw Error(je(130, e == null ? e : typeof e, ""));
  }
  return t = $n(o, r, t, i), t.elementType = e, t.type = n, t.lanes = s, t;
}
function Hs(e, t, r, n) {
  return e = $n(7, e, n, t), e.lanes = r, e;
}
function zm(e, t, r, n) {
  return e = $n(22, e, n, t), e.elementType = wT, e.lanes = r, e.stateNode = { isHidden: !1 }, e;
}
function jy(e, t, r) {
  return e = $n(6, e, null, t), e.lanes = r, e;
}
function Ny(e, t, r) {
  return t = $n(4, e.children !== null ? e.children : [], e.key, t), t.lanes = r, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t;
}
function bB(e, t, r, n, i) {
  this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = my(0), this.expirationTimes = my(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = my(0), this.identifierPrefix = n, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null;
}
function Mw(e, t, r, n, i, s, o, a, l) {
  return e = new bB(e, t, r, a, l), t === 1 ? (t = 1, s === !0 && (t |= 8)) : t = 0, s = $n(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: n, isDehydrated: r, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ww(s), e;
}
function wB(e, t, r) {
  var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: Ga, key: n == null ? null : "" + n, children: e, containerInfo: t, implementation: r };
}
function pR(e) {
  if (!e) return Jo;
  e = e._reactInternals;
  e: {
    if (ua(e) !== e || e.tag !== 1) throw Error(je(170));
    var t = e;
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context;
          break e;
        case 1:
          if (en(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      t = t.return;
    } while (t !== null);
    throw Error(je(171));
  }
  if (e.tag === 1) {
    var r = e.type;
    if (en(r)) return p$(e, r, t);
  }
  return t;
}
function fR(e, t, r, n, i, s, o, a, l) {
  return e = Mw(r, n, !0, e, i, s, o, a, l), e.context = pR(null), r = e.current, n = Fr(), i = Ho(r), s = to(n, i), s.callback = t ?? null, Vo(r, s, i), e.current.lanes = i, ip(e, i, n), tn(e, n), e;
}
function qm(e, t, r, n) {
  var i = t.current, s = Fr(), o = Ho(i);
  return r = pR(r), t.context === null ? t.context = r : t.pendingContext = r, t = to(s, o), t.payload = { element: e }, n = n === void 0 ? null : n, n !== null && (t.callback = n), e = Vo(i, t, o), e !== null && (Xn(e, i, o, s), ph(e, i, o)), o;
}
function rm(e) {
  if (e = e.current, !e.child) return null;
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode;
    default:
      return e.child.stateNode;
  }
}
function WE(e, t) {
  if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
    var r = e.retryLane;
    e.retryLane = r !== 0 && r < t ? r : t;
  }
}
function Dw(e, t) {
  WE(e, t), (e = e.alternate) && WE(e, t);
}
function SB() {
  return null;
}
var dR = typeof reportError == "function" ? reportError : function(e) {
  console.error(e);
};
function Fw(e) {
  this._internalRoot = e;
}
Bm.prototype.render = Fw.prototype.render = function(e) {
  var t = this._internalRoot;
  if (t === null) throw Error(je(409));
  qm(e, t, null, null);
};
Bm.prototype.unmount = Fw.prototype.unmount = function() {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    ea(function() {
      qm(null, e, null, null);
    }), t[ao] = null;
  }
};
function Bm(e) {
  this._internalRoot = e;
}
Bm.prototype.unstable_scheduleHydration = function(e) {
  if (e) {
    var t = VT();
    e = { blockedOn: null, target: e, priority: t };
    for (var r = 0; r < Ro.length && t !== 0 && t < Ro[r].priority; r++) ;
    Ro.splice(r, 0, e), r === 0 && HT(e);
  }
};
function zw(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
}
function Um(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "));
}
function HE() {
}
function xB(e, t, r, n, i) {
  if (i) {
    if (typeof n == "function") {
      var s = n;
      n = function() {
        var p = rm(o);
        s.call(p);
      };
    }
    var o = fR(t, n, e, 0, null, !1, !1, "", HE);
    return e._reactRootContainer = o, e[ao] = o.current, Ic(e.nodeType === 8 ? e.parentNode : e), ea(), o;
  }
  for (; i = e.lastChild; ) e.removeChild(i);
  if (typeof n == "function") {
    var a = n;
    n = function() {
      var p = rm(l);
      a.call(p);
    };
  }
  var l = Mw(e, 0, !1, null, null, !1, !1, "", HE);
  return e._reactRootContainer = l, e[ao] = l.current, Ic(e.nodeType === 8 ? e.parentNode : e), ea(function() {
    qm(t, l, r, n);
  }), l;
}
function Vm(e, t, r, n, i) {
  var s = r._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function() {
        var l = rm(o);
        a.call(l);
      };
    }
    qm(t, o, e, i);
  } else o = xB(r, t, e, i, n);
  return rm(o);
}
BT = function(e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
        var r = nc(t.pendingLanes);
        r !== 0 && (ow(t, r | 1), tn(t, Xt()), !(dt & 6) && (Ol = Xt() + 500, as()));
      }
      break;
    case 13:
      ea(function() {
        var n = lo(e, 1);
        if (n !== null) {
          var i = Fr();
          Xn(n, e, 1, i);
        }
      }), Dw(e, 1);
  }
};
sw = function(e) {
  if (e.tag === 13) {
    var t = lo(e, 134217728);
    if (t !== null) {
      var r = Fr();
      Xn(t, e, 134217728, r);
    }
    Dw(e, 134217728);
  }
};
UT = function(e) {
  if (e.tag === 13) {
    var t = Ho(e), r = lo(e, t);
    if (r !== null) {
      var n = Fr();
      Xn(r, e, t, n);
    }
    Dw(e, t);
  }
};
VT = function() {
  return wt;
};
WT = function(e, t) {
  var r = wt;
  try {
    return wt = e, t();
  } finally {
    wt = r;
  }
};
O0 = function(e, t, r) {
  switch (t) {
    case "input":
      if (v0(e, r), t = r.name, r.type === "radio" && t != null) {
        for (r = e; r.parentNode; ) r = r.parentNode;
        for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < r.length; t++) {
          var n = r[t];
          if (n !== e && n.form === e.form) {
            var i = jm(n);
            if (!i) throw Error(je(90));
            xT(n), v0(n, i);
          }
        }
      }
      break;
    case "textarea":
      ET(e, r);
      break;
    case "select":
      t = r.value, t != null && fl(e, !!r.multiple, t, !1);
  }
};
$T = Iw;
RT = ea;
var _B = { usingClientEntryPoint: !1, Events: [sp, el, jm, CT, TT, Iw] }, Du = { findFiberByHostInstance: zs, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, EB = { bundleType: Du.bundleType, version: Du.version, rendererPackageName: Du.rendererPackageName, rendererConfig: Du.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: vo.ReactCurrentDispatcher, findHostInstanceByFiber: function(e) {
  return e = NT(e), e === null ? null : e.stateNode;
}, findFiberByHostInstance: Du.findFiberByHostInstance || SB, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Bf = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Bf.isDisabled && Bf.supportsFiber) try {
    Tm = Bf.inject(EB), ki = Bf;
  } catch {
  }
}
yn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _B;
yn.createPortal = function(e, t) {
  var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!zw(t)) throw Error(je(200));
  return wB(e, t, null, r);
};
yn.createRoot = function(e, t) {
  if (!zw(e)) throw Error(je(299));
  var r = !1, n = "", i = dR;
  return t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (n = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = Mw(e, 1, !1, null, null, r, !1, n, i), e[ao] = t.current, Ic(e.nodeType === 8 ? e.parentNode : e), new Fw(t);
};
yn.findDOMNode = function(e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0)
    throw typeof e.render == "function" ? Error(je(188)) : (e = Object.keys(e).join(","), Error(je(268, e)));
  return e = NT(t), e = e === null ? null : e.stateNode, e;
};
yn.flushSync = function(e) {
  return ea(e);
};
yn.hydrate = function(e, t, r) {
  if (!Um(t)) throw Error(je(200));
  return Vm(null, e, t, !0, r);
};
yn.hydrateRoot = function(e, t, r) {
  if (!zw(e)) throw Error(je(405));
  var n = r != null && r.hydratedSources || null, i = !1, s = "", o = dR;
  if (r != null && (r.unstable_strictMode === !0 && (i = !0), r.identifierPrefix !== void 0 && (s = r.identifierPrefix), r.onRecoverableError !== void 0 && (o = r.onRecoverableError)), t = fR(t, null, e, 1, r ?? null, i, !1, s, o), e[ao] = t.current, Ic(e), n) for (e = 0; e < n.length; e++) r = n[e], i = r._getVersion, i = i(r._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [r, i] : t.mutableSourceEagerHydrationData.push(
    r,
    i
  );
  return new Bm(t);
};
yn.render = function(e, t, r) {
  if (!Um(t)) throw Error(je(200));
  return Vm(null, e, t, !1, r);
};
yn.unmountComponentAtNode = function(e) {
  if (!Um(e)) throw Error(je(40));
  return e._reactRootContainer ? (ea(function() {
    Vm(null, null, e, !1, function() {
      e._reactRootContainer = null, e[ao] = null;
    });
  }), !0) : !1;
};
yn.unstable_batchedUpdates = Iw;
yn.unstable_renderSubtreeIntoContainer = function(e, t, r, n) {
  if (!Um(r)) throw Error(je(200));
  if (e == null || e._reactInternals === void 0) throw Error(je(38));
  return Vm(e, t, r, !1, n);
};
yn.version = "18.3.1-next-f1338f8080-20240426";
function hR() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(hR);
    } catch (e) {
      console.error(e);
    }
}
hR(), hT.exports = yn;
var mR = hT.exports, gR = { exports: {} }, Ly = { exports: {} };
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */
var QE;
function OB() {
  return QE || (QE = 1, function(e, t) {
    (function() {
      var r = function(n) {
        var i = new r.Builder();
        return i.pipeline.add(
          r.trimmer,
          r.stopWordFilter,
          r.stemmer
        ), i.searchPipeline.add(
          r.stemmer
        ), n.call(i, i), i.build();
      };
      r.version = "2.3.9";
      /*!
       * lunr.utils
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.utils = {}, r.utils.warn = /* @__PURE__ */ function(n) {
        return function(i) {
          n.console && console.warn && console.warn(i);
        };
      }(this), r.utils.asString = function(n) {
        return n == null ? "" : n.toString();
      }, r.utils.clone = function(n) {
        if (n == null)
          return n;
        for (var i = /* @__PURE__ */ Object.create(null), s = Object.keys(n), o = 0; o < s.length; o++) {
          var a = s[o], l = n[a];
          if (Array.isArray(l)) {
            i[a] = l.slice();
            continue;
          }
          if (typeof l == "string" || typeof l == "number" || typeof l == "boolean") {
            i[a] = l;
            continue;
          }
          throw new TypeError("clone is not deep and does not support nested objects");
        }
        return i;
      }, r.FieldRef = function(n, i, s) {
        this.docRef = n, this.fieldName = i, this._stringValue = s;
      }, r.FieldRef.joiner = "/", r.FieldRef.fromString = function(n) {
        var i = n.indexOf(r.FieldRef.joiner);
        if (i === -1)
          throw "malformed field ref string";
        var s = n.slice(0, i), o = n.slice(i + 1);
        return new r.FieldRef(o, s, n);
      }, r.FieldRef.prototype.toString = function() {
        return this._stringValue == null && (this._stringValue = this.fieldName + r.FieldRef.joiner + this.docRef), this._stringValue;
      };
      /*!
       * lunr.Set
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Set = function(n) {
        if (this.elements = /* @__PURE__ */ Object.create(null), n) {
          this.length = n.length;
          for (var i = 0; i < this.length; i++)
            this.elements[n[i]] = !0;
        } else
          this.length = 0;
      }, r.Set.complete = {
        intersect: function(n) {
          return n;
        },
        union: function() {
          return this;
        },
        contains: function() {
          return !0;
        }
      }, r.Set.empty = {
        intersect: function() {
          return this;
        },
        union: function(n) {
          return n;
        },
        contains: function() {
          return !1;
        }
      }, r.Set.prototype.contains = function(n) {
        return !!this.elements[n];
      }, r.Set.prototype.intersect = function(n) {
        var i, s, o, a = [];
        if (n === r.Set.complete)
          return this;
        if (n === r.Set.empty)
          return n;
        this.length < n.length ? (i = this, s = n) : (i = n, s = this), o = Object.keys(i.elements);
        for (var l = 0; l < o.length; l++) {
          var p = o[l];
          p in s.elements && a.push(p);
        }
        return new r.Set(a);
      }, r.Set.prototype.union = function(n) {
        return n === r.Set.complete ? r.Set.complete : n === r.Set.empty ? this : new r.Set(Object.keys(this.elements).concat(Object.keys(n.elements)));
      }, r.idf = function(n, i) {
        var s = 0;
        for (var o in n)
          o != "_index" && (s += Object.keys(n[o]).length);
        var a = (i - s + 0.5) / (s + 0.5);
        return Math.log(1 + Math.abs(a));
      }, r.Token = function(n, i) {
        this.str = n || "", this.metadata = i || {};
      }, r.Token.prototype.toString = function() {
        return this.str;
      }, r.Token.prototype.update = function(n) {
        return this.str = n(this.str, this.metadata), this;
      }, r.Token.prototype.clone = function(n) {
        return n = n || function(i) {
          return i;
        }, new r.Token(n(this.str, this.metadata), this.metadata);
      };
      /*!
       * lunr.tokenizer
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.tokenizer = function(n, i) {
        if (n == null || n == null)
          return [];
        if (Array.isArray(n))
          return n.map(function(v) {
            return new r.Token(
              r.utils.asString(v).toLowerCase(),
              r.utils.clone(i)
            );
          });
        for (var s = n.toString().toLowerCase(), o = s.length, a = [], l = 0, p = 0; l <= o; l++) {
          var f = s.charAt(l), d = l - p;
          if (f.match(r.tokenizer.separator) || l == o) {
            if (d > 0) {
              var m = r.utils.clone(i) || {};
              m.position = [p, d], m.index = a.length, a.push(
                new r.Token(
                  s.slice(p, l),
                  m
                )
              );
            }
            p = l + 1;
          }
        }
        return a;
      }, r.tokenizer.separator = /[\s\-]+/;
      /*!
       * lunr.Pipeline
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Pipeline = function() {
        this._stack = [];
      }, r.Pipeline.registeredFunctions = /* @__PURE__ */ Object.create(null), r.Pipeline.registerFunction = function(n, i) {
        i in this.registeredFunctions && r.utils.warn("Overwriting existing registered function: " + i), n.label = i, r.Pipeline.registeredFunctions[n.label] = n;
      }, r.Pipeline.warnIfFunctionNotRegistered = function(n) {
        var i = n.label && n.label in this.registeredFunctions;
        i || r.utils.warn(`Function is not registered with pipeline. This may cause problems when serialising the index.
`, n);
      }, r.Pipeline.load = function(n) {
        var i = new r.Pipeline();
        return n.forEach(function(s) {
          var o = r.Pipeline.registeredFunctions[s];
          if (o)
            i.add(o);
          else
            throw new Error("Cannot load unregistered function: " + s);
        }), i;
      }, r.Pipeline.prototype.add = function() {
        var n = Array.prototype.slice.call(arguments);
        n.forEach(function(i) {
          r.Pipeline.warnIfFunctionNotRegistered(i), this._stack.push(i);
        }, this);
      }, r.Pipeline.prototype.after = function(n, i) {
        r.Pipeline.warnIfFunctionNotRegistered(i);
        var s = this._stack.indexOf(n);
        if (s == -1)
          throw new Error("Cannot find existingFn");
        s = s + 1, this._stack.splice(s, 0, i);
      }, r.Pipeline.prototype.before = function(n, i) {
        r.Pipeline.warnIfFunctionNotRegistered(i);
        var s = this._stack.indexOf(n);
        if (s == -1)
          throw new Error("Cannot find existingFn");
        this._stack.splice(s, 0, i);
      }, r.Pipeline.prototype.remove = function(n) {
        var i = this._stack.indexOf(n);
        i != -1 && this._stack.splice(i, 1);
      }, r.Pipeline.prototype.run = function(n) {
        for (var i = this._stack.length, s = 0; s < i; s++) {
          for (var o = this._stack[s], a = [], l = 0; l < n.length; l++) {
            var p = o(n[l], l, n);
            if (!(p == null || p === ""))
              if (Array.isArray(p))
                for (var f = 0; f < p.length; f++)
                  a.push(p[f]);
              else
                a.push(p);
          }
          n = a;
        }
        return n;
      }, r.Pipeline.prototype.runString = function(n, i) {
        var s = new r.Token(n, i);
        return this.run([s]).map(function(o) {
          return o.toString();
        });
      }, r.Pipeline.prototype.reset = function() {
        this._stack = [];
      }, r.Pipeline.prototype.toJSON = function() {
        return this._stack.map(function(n) {
          return r.Pipeline.warnIfFunctionNotRegistered(n), n.label;
        });
      };
      /*!
       * lunr.Vector
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Vector = function(n) {
        this._magnitude = 0, this.elements = n || [];
      }, r.Vector.prototype.positionForIndex = function(n) {
        if (this.elements.length == 0)
          return 0;
        for (var i = 0, s = this.elements.length / 2, o = s - i, a = Math.floor(o / 2), l = this.elements[a * 2]; o > 1 && (l < n && (i = a), l > n && (s = a), l != n); )
          o = s - i, a = i + Math.floor(o / 2), l = this.elements[a * 2];
        if (l == n || l > n)
          return a * 2;
        if (l < n)
          return (a + 1) * 2;
      }, r.Vector.prototype.insert = function(n, i) {
        this.upsert(n, i, function() {
          throw "duplicate index";
        });
      }, r.Vector.prototype.upsert = function(n, i, s) {
        this._magnitude = 0;
        var o = this.positionForIndex(n);
        this.elements[o] == n ? this.elements[o + 1] = s(this.elements[o + 1], i) : this.elements.splice(o, 0, n, i);
      }, r.Vector.prototype.magnitude = function() {
        if (this._magnitude) return this._magnitude;
        for (var n = 0, i = this.elements.length, s = 1; s < i; s += 2) {
          var o = this.elements[s];
          n += o * o;
        }
        return this._magnitude = Math.sqrt(n);
      }, r.Vector.prototype.dot = function(n) {
        for (var i = 0, s = this.elements, o = n.elements, a = s.length, l = o.length, p = 0, f = 0, d = 0, m = 0; d < a && m < l; )
          p = s[d], f = o[m], p < f ? d += 2 : p > f ? m += 2 : p == f && (i += s[d + 1] * o[m + 1], d += 2, m += 2);
        return i;
      }, r.Vector.prototype.similarity = function(n) {
        return this.dot(n) / this.magnitude() || 0;
      }, r.Vector.prototype.toArray = function() {
        for (var n = new Array(this.elements.length / 2), i = 1, s = 0; i < this.elements.length; i += 2, s++)
          n[s] = this.elements[i];
        return n;
      }, r.Vector.prototype.toJSON = function() {
        return this.elements;
      };
      /*!
       * lunr.stemmer
       * Copyright (C) 2020 Oliver Nightingale
       * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
       */
      r.stemmer = function() {
        var n = {
          ational: "ate",
          tional: "tion",
          enci: "ence",
          anci: "ance",
          izer: "ize",
          bli: "ble",
          alli: "al",
          entli: "ent",
          eli: "e",
          ousli: "ous",
          ization: "ize",
          ation: "ate",
          ator: "ate",
          alism: "al",
          iveness: "ive",
          fulness: "ful",
          ousness: "ous",
          aliti: "al",
          iviti: "ive",
          biliti: "ble",
          logi: "log"
        }, i = {
          icate: "ic",
          ative: "",
          alize: "al",
          iciti: "ic",
          ical: "ic",
          ful: "",
          ness: ""
        }, s = "[^aeiou]", o = "[aeiouy]", a = s + "[^aeiouy]*", l = o + "[aeiou]*", p = "^(" + a + ")?" + l + a, f = "^(" + a + ")?" + l + a + "(" + l + ")?$", d = "^(" + a + ")?" + l + a + l + a, m = "^(" + a + ")?" + o, v = new RegExp(p), g = new RegExp(d), S = new RegExp(f), _ = new RegExp(m), x = /^(.+?)(ss|i)es$/, y = /^(.+?)([^s])s$/, w = /^(.+?)eed$/, k = /^(.+?)(ed|ing)$/, A = /.$/, T = /(at|bl|iz)$/, R = new RegExp("([^aeiouylsz])\\1$"), I = new RegExp("^" + a + o + "[^aeiouwxy]$"), B = /^(.+?[^aeiou])y$/, L = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/, Y = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/, Q = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/, re = /^(.+?)(s|t)(ion)$/, oe = /^(.+?)e$/, ce = /ll$/, pe = new RegExp("^" + a + o + "[^aeiouwxy]$"), fe = function(Z) {
          var K, z, te, q, j, H, F;
          if (Z.length < 3)
            return Z;
          if (te = Z.substr(0, 1), te == "y" && (Z = te.toUpperCase() + Z.substr(1)), q = x, j = y, q.test(Z) ? Z = Z.replace(q, "$1$2") : j.test(Z) && (Z = Z.replace(j, "$1$2")), q = w, j = k, q.test(Z)) {
            var ue = q.exec(Z);
            q = v, q.test(ue[1]) && (q = A, Z = Z.replace(q, ""));
          } else if (j.test(Z)) {
            var ue = j.exec(Z);
            K = ue[1], j = _, j.test(K) && (Z = K, j = T, H = R, F = I, j.test(Z) ? Z = Z + "e" : H.test(Z) ? (q = A, Z = Z.replace(q, "")) : F.test(Z) && (Z = Z + "e"));
          }
          if (q = B, q.test(Z)) {
            var ue = q.exec(Z);
            K = ue[1], Z = K + "i";
          }
          if (q = L, q.test(Z)) {
            var ue = q.exec(Z);
            K = ue[1], z = ue[2], q = v, q.test(K) && (Z = K + n[z]);
          }
          if (q = Y, q.test(Z)) {
            var ue = q.exec(Z);
            K = ue[1], z = ue[2], q = v, q.test(K) && (Z = K + i[z]);
          }
          if (q = Q, j = re, q.test(Z)) {
            var ue = q.exec(Z);
            K = ue[1], q = g, q.test(K) && (Z = K);
          } else if (j.test(Z)) {
            var ue = j.exec(Z);
            K = ue[1] + ue[2], j = g, j.test(K) && (Z = K);
          }
          if (q = oe, q.test(Z)) {
            var ue = q.exec(Z);
            K = ue[1], q = g, j = S, H = pe, (q.test(K) || j.test(K) && !H.test(K)) && (Z = K);
          }
          return q = ce, j = g, q.test(Z) && j.test(Z) && (q = A, Z = Z.replace(q, "")), te == "y" && (Z = te.toLowerCase() + Z.substr(1)), Z;
        };
        return function(G) {
          return G.update(fe);
        };
      }(), r.Pipeline.registerFunction(r.stemmer, "stemmer");
      /*!
       * lunr.stopWordFilter
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.generateStopWordFilter = function(n) {
        var i = n.reduce(function(s, o) {
          return s[o] = o, s;
        }, {});
        return function(s) {
          if (s && i[s.toString()] !== s.toString()) return s;
        };
      }, r.stopWordFilter = r.generateStopWordFilter([
        "a",
        "able",
        "about",
        "across",
        "after",
        "all",
        "almost",
        "also",
        "am",
        "among",
        "an",
        "and",
        "any",
        "are",
        "as",
        "at",
        "be",
        "because",
        "been",
        "but",
        "by",
        "can",
        "cannot",
        "could",
        "dear",
        "did",
        "do",
        "does",
        "either",
        "else",
        "ever",
        "every",
        "for",
        "from",
        "get",
        "got",
        "had",
        "has",
        "have",
        "he",
        "her",
        "hers",
        "him",
        "his",
        "how",
        "however",
        "i",
        "if",
        "in",
        "into",
        "is",
        "it",
        "its",
        "just",
        "least",
        "let",
        "like",
        "likely",
        "may",
        "me",
        "might",
        "most",
        "must",
        "my",
        "neither",
        "no",
        "nor",
        "not",
        "of",
        "off",
        "often",
        "on",
        "only",
        "or",
        "other",
        "our",
        "own",
        "rather",
        "said",
        "say",
        "says",
        "she",
        "should",
        "since",
        "so",
        "some",
        "than",
        "that",
        "the",
        "their",
        "them",
        "then",
        "there",
        "these",
        "they",
        "this",
        "tis",
        "to",
        "too",
        "twas",
        "us",
        "wants",
        "was",
        "we",
        "were",
        "what",
        "when",
        "where",
        "which",
        "while",
        "who",
        "whom",
        "why",
        "will",
        "with",
        "would",
        "yet",
        "you",
        "your"
      ]), r.Pipeline.registerFunction(r.stopWordFilter, "stopWordFilter");
      /*!
       * lunr.trimmer
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.trimmer = function(n) {
        return n.update(function(i) {
          return i.replace(/^\W+/, "").replace(/\W+$/, "");
        });
      }, r.Pipeline.registerFunction(r.trimmer, "trimmer");
      /*!
       * lunr.TokenSet
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.TokenSet = function() {
        this.final = !1, this.edges = {}, this.id = r.TokenSet._nextId, r.TokenSet._nextId += 1;
      }, r.TokenSet._nextId = 1, r.TokenSet.fromArray = function(n) {
        for (var i = new r.TokenSet.Builder(), s = 0, o = n.length; s < o; s++)
          i.insert(n[s]);
        return i.finish(), i.root;
      }, r.TokenSet.fromClause = function(n) {
        return "editDistance" in n ? r.TokenSet.fromFuzzyString(n.term, n.editDistance) : r.TokenSet.fromString(n.term);
      }, r.TokenSet.fromFuzzyString = function(n, i) {
        for (var s = new r.TokenSet(), o = [{
          node: s,
          editsRemaining: i,
          str: n
        }]; o.length; ) {
          var a = o.pop();
          if (a.str.length > 0) {
            var l = a.str.charAt(0), p;
            l in a.node.edges ? p = a.node.edges[l] : (p = new r.TokenSet(), a.node.edges[l] = p), a.str.length == 1 && (p.final = !0), o.push({
              node: p,
              editsRemaining: a.editsRemaining,
              str: a.str.slice(1)
            });
          }
          if (a.editsRemaining != 0) {
            if ("*" in a.node.edges)
              var f = a.node.edges["*"];
            else {
              var f = new r.TokenSet();
              a.node.edges["*"] = f;
            }
            if (a.str.length == 0 && (f.final = !0), o.push({
              node: f,
              editsRemaining: a.editsRemaining - 1,
              str: a.str
            }), a.str.length > 1 && o.push({
              node: a.node,
              editsRemaining: a.editsRemaining - 1,
              str: a.str.slice(1)
            }), a.str.length == 1 && (a.node.final = !0), a.str.length >= 1) {
              if ("*" in a.node.edges)
                var d = a.node.edges["*"];
              else {
                var d = new r.TokenSet();
                a.node.edges["*"] = d;
              }
              a.str.length == 1 && (d.final = !0), o.push({
                node: d,
                editsRemaining: a.editsRemaining - 1,
                str: a.str.slice(1)
              });
            }
            if (a.str.length > 1) {
              var m = a.str.charAt(0), v = a.str.charAt(1), g;
              v in a.node.edges ? g = a.node.edges[v] : (g = new r.TokenSet(), a.node.edges[v] = g), a.str.length == 1 && (g.final = !0), o.push({
                node: g,
                editsRemaining: a.editsRemaining - 1,
                str: m + a.str.slice(2)
              });
            }
          }
        }
        return s;
      }, r.TokenSet.fromString = function(n) {
        for (var i = new r.TokenSet(), s = i, o = 0, a = n.length; o < a; o++) {
          var l = n[o], p = o == a - 1;
          if (l == "*")
            i.edges[l] = i, i.final = p;
          else {
            var f = new r.TokenSet();
            f.final = p, i.edges[l] = f, i = f;
          }
        }
        return s;
      }, r.TokenSet.prototype.toArray = function() {
        for (var n = [], i = [{
          prefix: "",
          node: this
        }]; i.length; ) {
          var s = i.pop(), o = Object.keys(s.node.edges), a = o.length;
          s.node.final && (s.prefix.charAt(0), n.push(s.prefix));
          for (var l = 0; l < a; l++) {
            var p = o[l];
            i.push({
              prefix: s.prefix.concat(p),
              node: s.node.edges[p]
            });
          }
        }
        return n;
      }, r.TokenSet.prototype.toString = function() {
        if (this._str)
          return this._str;
        for (var n = this.final ? "1" : "0", i = Object.keys(this.edges).sort(), s = i.length, o = 0; o < s; o++) {
          var a = i[o], l = this.edges[a];
          n = n + a + l.id;
        }
        return n;
      }, r.TokenSet.prototype.intersect = function(n) {
        for (var i = new r.TokenSet(), s = void 0, o = [{
          qNode: n,
          output: i,
          node: this
        }]; o.length; ) {
          s = o.pop();
          for (var a = Object.keys(s.qNode.edges), l = a.length, p = Object.keys(s.node.edges), f = p.length, d = 0; d < l; d++)
            for (var m = a[d], v = 0; v < f; v++) {
              var g = p[v];
              if (g == m || m == "*") {
                var S = s.node.edges[g], _ = s.qNode.edges[m], x = S.final && _.final, y = void 0;
                g in s.output.edges ? (y = s.output.edges[g], y.final = y.final || x) : (y = new r.TokenSet(), y.final = x, s.output.edges[g] = y), o.push({
                  qNode: _,
                  output: y,
                  node: S
                });
              }
            }
        }
        return i;
      }, r.TokenSet.Builder = function() {
        this.previousWord = "", this.root = new r.TokenSet(), this.uncheckedNodes = [], this.minimizedNodes = {};
      }, r.TokenSet.Builder.prototype.insert = function(n) {
        var i, s = 0;
        if (n < this.previousWord)
          throw new Error("Out of order word insertion");
        for (var o = 0; o < n.length && o < this.previousWord.length && n[o] == this.previousWord[o]; o++)
          s++;
        this.minimize(s), this.uncheckedNodes.length == 0 ? i = this.root : i = this.uncheckedNodes[this.uncheckedNodes.length - 1].child;
        for (var o = s; o < n.length; o++) {
          var a = new r.TokenSet(), l = n[o];
          i.edges[l] = a, this.uncheckedNodes.push({
            parent: i,
            char: l,
            child: a
          }), i = a;
        }
        i.final = !0, this.previousWord = n;
      }, r.TokenSet.Builder.prototype.finish = function() {
        this.minimize(0);
      }, r.TokenSet.Builder.prototype.minimize = function(n) {
        for (var i = this.uncheckedNodes.length - 1; i >= n; i--) {
          var s = this.uncheckedNodes[i], o = s.child.toString();
          o in this.minimizedNodes ? s.parent.edges[s.char] = this.minimizedNodes[o] : (s.child._str = o, this.minimizedNodes[o] = s.child), this.uncheckedNodes.pop();
        }
      };
      /*!
       * lunr.Index
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Index = function(n) {
        this.invertedIndex = n.invertedIndex, this.fieldVectors = n.fieldVectors, this.tokenSet = n.tokenSet, this.fields = n.fields, this.pipeline = n.pipeline;
      }, r.Index.prototype.search = function(n) {
        return this.query(function(i) {
          var s = new r.QueryParser(n, i);
          s.parse();
        });
      }, r.Index.prototype.query = function(n) {
        for (var i = new r.Query(this.fields), s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null), p = /* @__PURE__ */ Object.create(null), f = 0; f < this.fields.length; f++)
          o[this.fields[f]] = new r.Vector();
        n.call(i, i);
        for (var f = 0; f < i.clauses.length; f++) {
          var d = i.clauses[f], m = null, v = r.Set.empty;
          d.usePipeline ? m = this.pipeline.runString(d.term, {
            fields: d.fields
          }) : m = [d.term];
          for (var g = 0; g < m.length; g++) {
            var S = m[g];
            d.term = S;
            var _ = r.TokenSet.fromClause(d), x = this.tokenSet.intersect(_).toArray();
            if (x.length === 0 && d.presence === r.Query.presence.REQUIRED) {
              for (var y = 0; y < d.fields.length; y++) {
                var w = d.fields[y];
                l[w] = r.Set.empty;
              }
              break;
            }
            for (var k = 0; k < x.length; k++)
              for (var A = x[k], T = this.invertedIndex[A], R = T._index, y = 0; y < d.fields.length; y++) {
                var w = d.fields[y], I = T[w], B = Object.keys(I), L = A + "/" + w, Y = new r.Set(B);
                if (d.presence == r.Query.presence.REQUIRED && (v = v.union(Y), l[w] === void 0 && (l[w] = r.Set.complete)), d.presence == r.Query.presence.PROHIBITED) {
                  p[w] === void 0 && (p[w] = r.Set.empty), p[w] = p[w].union(Y);
                  continue;
                }
                if (o[w].upsert(R, d.boost, function(N, J) {
                  return N + J;
                }), !a[L]) {
                  for (var Q = 0; Q < B.length; Q++) {
                    var re = B[Q], oe = new r.FieldRef(re, w), ce = I[re], pe;
                    (pe = s[oe]) === void 0 ? s[oe] = new r.MatchData(A, w, ce) : pe.add(A, w, ce);
                  }
                  a[L] = !0;
                }
              }
          }
          if (d.presence === r.Query.presence.REQUIRED)
            for (var y = 0; y < d.fields.length; y++) {
              var w = d.fields[y];
              l[w] = l[w].intersect(v);
            }
        }
        for (var fe = r.Set.complete, G = r.Set.empty, f = 0; f < this.fields.length; f++) {
          var w = this.fields[f];
          l[w] && (fe = fe.intersect(l[w])), p[w] && (G = G.union(p[w]));
        }
        var Z = Object.keys(s), K = [], z = /* @__PURE__ */ Object.create(null);
        if (i.isNegated()) {
          Z = Object.keys(this.fieldVectors);
          for (var f = 0; f < Z.length; f++) {
            var oe = Z[f], te = r.FieldRef.fromString(oe);
            s[oe] = new r.MatchData();
          }
        }
        for (var f = 0; f < Z.length; f++) {
          var te = r.FieldRef.fromString(Z[f]), q = te.docRef;
          if (fe.contains(q) && !G.contains(q)) {
            var j = this.fieldVectors[te], H = o[te.fieldName].similarity(j), F;
            if ((F = z[q]) !== void 0)
              F.score += H, F.matchData.combine(s[te]);
            else {
              var ue = {
                ref: q,
                score: H,
                matchData: s[te]
              };
              z[q] = ue, K.push(ue);
            }
          }
        }
        return K.sort(function(ge, Ae) {
          return Ae.score - ge.score;
        });
      }, r.Index.prototype.toJSON = function() {
        var n = Object.keys(this.invertedIndex).sort().map(function(s) {
          return [s, this.invertedIndex[s]];
        }, this), i = Object.keys(this.fieldVectors).map(function(s) {
          return [s, this.fieldVectors[s].toJSON()];
        }, this);
        return {
          version: r.version,
          fields: this.fields,
          fieldVectors: i,
          invertedIndex: n,
          pipeline: this.pipeline.toJSON()
        };
      }, r.Index.load = function(n) {
        var i = {}, s = {}, o = n.fieldVectors, a = /* @__PURE__ */ Object.create(null), l = n.invertedIndex, p = new r.TokenSet.Builder(), f = r.Pipeline.load(n.pipeline);
        n.version != r.version && r.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + r.version + "' does not match serialized index '" + n.version + "'");
        for (var d = 0; d < o.length; d++) {
          var m = o[d], v = m[0], g = m[1];
          s[v] = new r.Vector(g);
        }
        for (var d = 0; d < l.length; d++) {
          var m = l[d], S = m[0], _ = m[1];
          p.insert(S), a[S] = _;
        }
        return p.finish(), i.fields = n.fields, i.fieldVectors = s, i.invertedIndex = a, i.tokenSet = p.root, i.pipeline = f, new r.Index(i);
      };
      /*!
       * lunr.Builder
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Builder = function() {
        this._ref = "id", this._fields = /* @__PURE__ */ Object.create(null), this._documents = /* @__PURE__ */ Object.create(null), this.invertedIndex = /* @__PURE__ */ Object.create(null), this.fieldTermFrequencies = {}, this.fieldLengths = {}, this.tokenizer = r.tokenizer, this.pipeline = new r.Pipeline(), this.searchPipeline = new r.Pipeline(), this.documentCount = 0, this._b = 0.75, this._k1 = 1.2, this.termIndex = 0, this.metadataWhitelist = [];
      }, r.Builder.prototype.ref = function(n) {
        this._ref = n;
      }, r.Builder.prototype.field = function(n, i) {
        if (/\//.test(n))
          throw new RangeError("Field '" + n + "' contains illegal character '/'");
        this._fields[n] = i || {};
      }, r.Builder.prototype.b = function(n) {
        n < 0 ? this._b = 0 : n > 1 ? this._b = 1 : this._b = n;
      }, r.Builder.prototype.k1 = function(n) {
        this._k1 = n;
      }, r.Builder.prototype.add = function(n, i) {
        var s = n[this._ref], o = Object.keys(this._fields);
        this._documents[s] = i || {}, this.documentCount += 1;
        for (var a = 0; a < o.length; a++) {
          var l = o[a], p = this._fields[l].extractor, f = p ? p(n) : n[l], d = this.tokenizer(f, {
            fields: [l]
          }), m = this.pipeline.run(d), v = new r.FieldRef(s, l), g = /* @__PURE__ */ Object.create(null);
          this.fieldTermFrequencies[v] = g, this.fieldLengths[v] = 0, this.fieldLengths[v] += m.length;
          for (var S = 0; S < m.length; S++) {
            var _ = m[S];
            if (g[_] == null && (g[_] = 0), g[_] += 1, this.invertedIndex[_] == null) {
              var x = /* @__PURE__ */ Object.create(null);
              x._index = this.termIndex, this.termIndex += 1;
              for (var y = 0; y < o.length; y++)
                x[o[y]] = /* @__PURE__ */ Object.create(null);
              this.invertedIndex[_] = x;
            }
            this.invertedIndex[_][l][s] == null && (this.invertedIndex[_][l][s] = /* @__PURE__ */ Object.create(null));
            for (var w = 0; w < this.metadataWhitelist.length; w++) {
              var k = this.metadataWhitelist[w], A = _.metadata[k];
              this.invertedIndex[_][l][s][k] == null && (this.invertedIndex[_][l][s][k] = []), this.invertedIndex[_][l][s][k].push(A);
            }
          }
        }
      }, r.Builder.prototype.calculateAverageFieldLengths = function() {
        for (var n = Object.keys(this.fieldLengths), i = n.length, s = {}, o = {}, a = 0; a < i; a++) {
          var l = r.FieldRef.fromString(n[a]), p = l.fieldName;
          o[p] || (o[p] = 0), o[p] += 1, s[p] || (s[p] = 0), s[p] += this.fieldLengths[l];
        }
        for (var f = Object.keys(this._fields), a = 0; a < f.length; a++) {
          var d = f[a];
          s[d] = s[d] / o[d];
        }
        this.averageFieldLength = s;
      }, r.Builder.prototype.createFieldVectors = function() {
        for (var n = {}, i = Object.keys(this.fieldTermFrequencies), s = i.length, o = /* @__PURE__ */ Object.create(null), a = 0; a < s; a++) {
          for (var l = r.FieldRef.fromString(i[a]), p = l.fieldName, f = this.fieldLengths[l], d = new r.Vector(), m = this.fieldTermFrequencies[l], v = Object.keys(m), g = v.length, S = this._fields[p].boost || 1, _ = this._documents[l.docRef].boost || 1, x = 0; x < g; x++) {
            var y = v[x], w = m[y], k = this.invertedIndex[y]._index, A, T, R;
            o[y] === void 0 ? (A = r.idf(this.invertedIndex[y], this.documentCount), o[y] = A) : A = o[y], T = A * ((this._k1 + 1) * w) / (this._k1 * (1 - this._b + this._b * (f / this.averageFieldLength[p])) + w), T *= S, T *= _, R = Math.round(T * 1e3) / 1e3, d.insert(k, R);
          }
          n[l] = d;
        }
        this.fieldVectors = n;
      }, r.Builder.prototype.createTokenSet = function() {
        this.tokenSet = r.TokenSet.fromArray(
          Object.keys(this.invertedIndex).sort()
        );
      }, r.Builder.prototype.build = function() {
        return this.calculateAverageFieldLengths(), this.createFieldVectors(), this.createTokenSet(), new r.Index({
          invertedIndex: this.invertedIndex,
          fieldVectors: this.fieldVectors,
          tokenSet: this.tokenSet,
          fields: Object.keys(this._fields),
          pipeline: this.searchPipeline
        });
      }, r.Builder.prototype.use = function(n) {
        var i = Array.prototype.slice.call(arguments, 1);
        i.unshift(this), n.apply(this, i);
      }, r.MatchData = function(n, i, s) {
        for (var o = /* @__PURE__ */ Object.create(null), a = Object.keys(s || {}), l = 0; l < a.length; l++) {
          var p = a[l];
          o[p] = s[p].slice();
        }
        this.metadata = /* @__PURE__ */ Object.create(null), n !== void 0 && (this.metadata[n] = /* @__PURE__ */ Object.create(null), this.metadata[n][i] = o);
      }, r.MatchData.prototype.combine = function(n) {
        for (var i = Object.keys(n.metadata), s = 0; s < i.length; s++) {
          var o = i[s], a = Object.keys(n.metadata[o]);
          this.metadata[o] == null && (this.metadata[o] = /* @__PURE__ */ Object.create(null));
          for (var l = 0; l < a.length; l++) {
            var p = a[l], f = Object.keys(n.metadata[o][p]);
            this.metadata[o][p] == null && (this.metadata[o][p] = /* @__PURE__ */ Object.create(null));
            for (var d = 0; d < f.length; d++) {
              var m = f[d];
              this.metadata[o][p][m] == null ? this.metadata[o][p][m] = n.metadata[o][p][m] : this.metadata[o][p][m] = this.metadata[o][p][m].concat(n.metadata[o][p][m]);
            }
          }
        }
      }, r.MatchData.prototype.add = function(n, i, s) {
        if (!(n in this.metadata)) {
          this.metadata[n] = /* @__PURE__ */ Object.create(null), this.metadata[n][i] = s;
          return;
        }
        if (!(i in this.metadata[n])) {
          this.metadata[n][i] = s;
          return;
        }
        for (var o = Object.keys(s), a = 0; a < o.length; a++) {
          var l = o[a];
          l in this.metadata[n][i] ? this.metadata[n][i][l] = this.metadata[n][i][l].concat(s[l]) : this.metadata[n][i][l] = s[l];
        }
      }, r.Query = function(n) {
        this.clauses = [], this.allFields = n;
      }, r.Query.wildcard = new String("*"), r.Query.wildcard.NONE = 0, r.Query.wildcard.LEADING = 1, r.Query.wildcard.TRAILING = 2, r.Query.presence = {
        /**
         * Term's presence in a document is optional, this is the default value.
         */
        OPTIONAL: 1,
        /**
         * Term's presence in a document is required, documents that do not contain
         * this term will not be returned.
         */
        REQUIRED: 2,
        /**
         * Term's presence in a document is prohibited, documents that do contain
         * this term will not be returned.
         */
        PROHIBITED: 3
      }, r.Query.prototype.clause = function(n) {
        return "fields" in n || (n.fields = this.allFields), "boost" in n || (n.boost = 1), "usePipeline" in n || (n.usePipeline = !0), "wildcard" in n || (n.wildcard = r.Query.wildcard.NONE), n.wildcard & r.Query.wildcard.LEADING && n.term.charAt(0) != r.Query.wildcard && (n.term = "*" + n.term), n.wildcard & r.Query.wildcard.TRAILING && n.term.slice(-1) != r.Query.wildcard && (n.term = "" + n.term + "*"), "presence" in n || (n.presence = r.Query.presence.OPTIONAL), this.clauses.push(n), this;
      }, r.Query.prototype.isNegated = function() {
        for (var n = 0; n < this.clauses.length; n++)
          if (this.clauses[n].presence != r.Query.presence.PROHIBITED)
            return !1;
        return !0;
      }, r.Query.prototype.term = function(n, i) {
        if (Array.isArray(n))
          return n.forEach(function(o) {
            this.term(o, r.utils.clone(i));
          }, this), this;
        var s = i || {};
        return s.term = n.toString(), this.clause(s), this;
      }, r.QueryParseError = function(n, i, s) {
        this.name = "QueryParseError", this.message = n, this.start = i, this.end = s;
      }, r.QueryParseError.prototype = new Error(), r.QueryLexer = function(n) {
        this.lexemes = [], this.str = n, this.length = n.length, this.pos = 0, this.start = 0, this.escapeCharPositions = [];
      }, r.QueryLexer.prototype.run = function() {
        for (var n = r.QueryLexer.lexText; n; )
          n = n(this);
      }, r.QueryLexer.prototype.sliceString = function() {
        for (var n = [], i = this.start, s = this.pos, o = 0; o < this.escapeCharPositions.length; o++)
          s = this.escapeCharPositions[o], n.push(this.str.slice(i, s)), i = s + 1;
        return n.push(this.str.slice(i, this.pos)), this.escapeCharPositions.length = 0, n.join("");
      }, r.QueryLexer.prototype.emit = function(n) {
        this.lexemes.push({
          type: n,
          str: this.sliceString(),
          start: this.start,
          end: this.pos
        }), this.start = this.pos;
      }, r.QueryLexer.prototype.escapeCharacter = function() {
        this.escapeCharPositions.push(this.pos - 1), this.pos += 1;
      }, r.QueryLexer.prototype.next = function() {
        if (this.pos >= this.length)
          return r.QueryLexer.EOS;
        var n = this.str.charAt(this.pos);
        return this.pos += 1, n;
      }, r.QueryLexer.prototype.width = function() {
        return this.pos - this.start;
      }, r.QueryLexer.prototype.ignore = function() {
        this.start == this.pos && (this.pos += 1), this.start = this.pos;
      }, r.QueryLexer.prototype.backup = function() {
        this.pos -= 1;
      }, r.QueryLexer.prototype.acceptDigitRun = function() {
        var n, i;
        do
          n = this.next(), i = n.charCodeAt(0);
        while (i > 47 && i < 58);
        n != r.QueryLexer.EOS && this.backup();
      }, r.QueryLexer.prototype.more = function() {
        return this.pos < this.length;
      }, r.QueryLexer.EOS = "EOS", r.QueryLexer.FIELD = "FIELD", r.QueryLexer.TERM = "TERM", r.QueryLexer.EDIT_DISTANCE = "EDIT_DISTANCE", r.QueryLexer.BOOST = "BOOST", r.QueryLexer.PRESENCE = "PRESENCE", r.QueryLexer.lexField = function(n) {
        return n.backup(), n.emit(r.QueryLexer.FIELD), n.ignore(), r.QueryLexer.lexText;
      }, r.QueryLexer.lexTerm = function(n) {
        if (n.width() > 1 && (n.backup(), n.emit(r.QueryLexer.TERM)), n.ignore(), n.more())
          return r.QueryLexer.lexText;
      }, r.QueryLexer.lexEditDistance = function(n) {
        return n.ignore(), n.acceptDigitRun(), n.emit(r.QueryLexer.EDIT_DISTANCE), r.QueryLexer.lexText;
      }, r.QueryLexer.lexBoost = function(n) {
        return n.ignore(), n.acceptDigitRun(), n.emit(r.QueryLexer.BOOST), r.QueryLexer.lexText;
      }, r.QueryLexer.lexEOS = function(n) {
        n.width() > 0 && n.emit(r.QueryLexer.TERM);
      }, r.QueryLexer.termSeparator = r.tokenizer.separator, r.QueryLexer.lexText = function(n) {
        for (; ; ) {
          var i = n.next();
          if (i == r.QueryLexer.EOS)
            return r.QueryLexer.lexEOS;
          if (i.charCodeAt(0) == 92) {
            n.escapeCharacter();
            continue;
          }
          if (i == ":")
            return r.QueryLexer.lexField;
          if (i == "~")
            return n.backup(), n.width() > 0 && n.emit(r.QueryLexer.TERM), r.QueryLexer.lexEditDistance;
          if (i == "^")
            return n.backup(), n.width() > 0 && n.emit(r.QueryLexer.TERM), r.QueryLexer.lexBoost;
          if (i == "+" && n.width() === 1 || i == "-" && n.width() === 1)
            return n.emit(r.QueryLexer.PRESENCE), r.QueryLexer.lexText;
          if (i.match(r.QueryLexer.termSeparator))
            return r.QueryLexer.lexTerm;
        }
      }, r.QueryParser = function(n, i) {
        this.lexer = new r.QueryLexer(n), this.query = i, this.currentClause = {}, this.lexemeIdx = 0;
      }, r.QueryParser.prototype.parse = function() {
        this.lexer.run(), this.lexemes = this.lexer.lexemes;
        for (var n = r.QueryParser.parseClause; n; )
          n = n(this);
        return this.query;
      }, r.QueryParser.prototype.peekLexeme = function() {
        return this.lexemes[this.lexemeIdx];
      }, r.QueryParser.prototype.consumeLexeme = function() {
        var n = this.peekLexeme();
        return this.lexemeIdx += 1, n;
      }, r.QueryParser.prototype.nextClause = function() {
        var n = this.currentClause;
        this.query.clause(n), this.currentClause = {};
      }, r.QueryParser.parseClause = function(n) {
        var i = n.peekLexeme();
        if (i != null)
          switch (i.type) {
            case r.QueryLexer.PRESENCE:
              return r.QueryParser.parsePresence;
            case r.QueryLexer.FIELD:
              return r.QueryParser.parseField;
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var s = "expected either a field or a term, found " + i.type;
              throw i.str.length >= 1 && (s += " with value '" + i.str + "'"), new r.QueryParseError(s, i.start, i.end);
          }
      }, r.QueryParser.parsePresence = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          switch (i.str) {
            case "-":
              n.currentClause.presence = r.Query.presence.PROHIBITED;
              break;
            case "+":
              n.currentClause.presence = r.Query.presence.REQUIRED;
              break;
            default:
              var s = "unrecognised presence operator'" + i.str + "'";
              throw new r.QueryParseError(s, i.start, i.end);
          }
          var o = n.peekLexeme();
          if (o == null) {
            var s = "expecting term or field, found nothing";
            throw new r.QueryParseError(s, i.start, i.end);
          }
          switch (o.type) {
            case r.QueryLexer.FIELD:
              return r.QueryParser.parseField;
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var s = "expecting term or field, found '" + o.type + "'";
              throw new r.QueryParseError(s, o.start, o.end);
          }
        }
      }, r.QueryParser.parseField = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          if (n.query.allFields.indexOf(i.str) == -1) {
            var s = n.query.allFields.map(function(l) {
              return "'" + l + "'";
            }).join(", "), o = "unrecognised field '" + i.str + "', possible fields: " + s;
            throw new r.QueryParseError(o, i.start, i.end);
          }
          n.currentClause.fields = [i.str];
          var a = n.peekLexeme();
          if (a == null) {
            var o = "expecting term, found nothing";
            throw new r.QueryParseError(o, i.start, i.end);
          }
          switch (a.type) {
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var o = "expecting term, found '" + a.type + "'";
              throw new r.QueryParseError(o, a.start, a.end);
          }
        }
      }, r.QueryParser.parseTerm = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          n.currentClause.term = i.str.toLowerCase(), i.str.indexOf("*") != -1 && (n.currentClause.usePipeline = !1);
          var s = n.peekLexeme();
          if (s == null) {
            n.nextClause();
            return;
          }
          switch (s.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var o = "Unexpected lexeme type '" + s.type + "'";
              throw new r.QueryParseError(o, s.start, s.end);
          }
        }
      }, r.QueryParser.parseEditDistance = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          var s = parseInt(i.str, 10);
          if (isNaN(s)) {
            var o = "edit distance must be numeric";
            throw new r.QueryParseError(o, i.start, i.end);
          }
          n.currentClause.editDistance = s;
          var a = n.peekLexeme();
          if (a == null) {
            n.nextClause();
            return;
          }
          switch (a.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var o = "Unexpected lexeme type '" + a.type + "'";
              throw new r.QueryParseError(o, a.start, a.end);
          }
        }
      }, r.QueryParser.parseBoost = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          var s = parseInt(i.str, 10);
          if (isNaN(s)) {
            var o = "boost must be numeric";
            throw new r.QueryParseError(o, i.start, i.end);
          }
          n.currentClause.boost = s;
          var a = n.peekLexeme();
          if (a == null) {
            n.nextClause();
            return;
          }
          switch (a.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var o = "Unexpected lexeme type '" + a.type + "'";
              throw new r.QueryParseError(o, a.start, a.end);
          }
        }
      }, function(n, i) {
        e.exports = i();
      }(this, function() {
        return r;
      });
    })();
  }(Ly)), Ly.exports;
}
var My, YE;
function kB() {
  if (YE) return My;
  YE = 1;
  function e() {
    return typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : typeof setImmediate == "function" ? setImmediate : function(r) {
      setTimeout(r, 0);
    };
  }
  return My = e(), My;
}
var Dy, GE;
function AB() {
  if (GE) return Dy;
  GE = 1;
  var e = kB();
  return Dy = function(r, n) {
    if (r) {
      n.then(function(i) {
        e(function() {
          r(null, i);
        });
      }, function(i) {
        e(function() {
          r(i);
        });
      });
      return;
    } else
      return n;
  }, Dy;
}
var Fy, KE;
function PB() {
  if (KE) return Fy;
  KE = 1, Fy = s, s.default = s, s.stable = p, s.stableStringify = p;
  var e = "[...]", t = "[Circular]", r = [], n = [];
  function i() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function s(m, v, g, S) {
    typeof S > "u" && (S = i()), a(m, "", 0, [], void 0, 0, S);
    var _;
    try {
      n.length === 0 ? _ = JSON.stringify(m, v, g) : _ = JSON.stringify(m, d(v), g);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; r.length !== 0; ) {
        var x = r.pop();
        x.length === 4 ? Object.defineProperty(x[0], x[1], x[3]) : x[0][x[1]] = x[2];
      }
    }
    return _;
  }
  function o(m, v, g, S) {
    var _ = Object.getOwnPropertyDescriptor(S, g);
    _.get !== void 0 ? _.configurable ? (Object.defineProperty(S, g, { value: m }), r.push([S, g, v, _])) : n.push([v, g, m]) : (S[g] = m, r.push([S, g, v]));
  }
  function a(m, v, g, S, _, x, y) {
    x += 1;
    var w;
    if (typeof m == "object" && m !== null) {
      for (w = 0; w < S.length; w++)
        if (S[w] === m) {
          o(t, m, v, _);
          return;
        }
      if (typeof y.depthLimit < "u" && x > y.depthLimit) {
        o(e, m, v, _);
        return;
      }
      if (typeof y.edgesLimit < "u" && g + 1 > y.edgesLimit) {
        o(e, m, v, _);
        return;
      }
      if (S.push(m), Array.isArray(m))
        for (w = 0; w < m.length; w++)
          a(m[w], w, w, S, m, x, y);
      else {
        var k = Object.keys(m);
        for (w = 0; w < k.length; w++) {
          var A = k[w];
          a(m[A], A, w, S, m, x, y);
        }
      }
      S.pop();
    }
  }
  function l(m, v) {
    return m < v ? -1 : m > v ? 1 : 0;
  }
  function p(m, v, g, S) {
    typeof S > "u" && (S = i());
    var _ = f(m, "", 0, [], void 0, 0, S) || m, x;
    try {
      n.length === 0 ? x = JSON.stringify(_, v, g) : x = JSON.stringify(_, d(v), g);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; r.length !== 0; ) {
        var y = r.pop();
        y.length === 4 ? Object.defineProperty(y[0], y[1], y[3]) : y[0][y[1]] = y[2];
      }
    }
    return x;
  }
  function f(m, v, g, S, _, x, y) {
    x += 1;
    var w;
    if (typeof m == "object" && m !== null) {
      for (w = 0; w < S.length; w++)
        if (S[w] === m) {
          o(t, m, v, _);
          return;
        }
      try {
        if (typeof m.toJSON == "function")
          return;
      } catch {
        return;
      }
      if (typeof y.depthLimit < "u" && x > y.depthLimit) {
        o(e, m, v, _);
        return;
      }
      if (typeof y.edgesLimit < "u" && g + 1 > y.edgesLimit) {
        o(e, m, v, _);
        return;
      }
      if (S.push(m), Array.isArray(m))
        for (w = 0; w < m.length; w++)
          f(m[w], w, w, S, m, x, y);
      else {
        var k = {}, A = Object.keys(m).sort(l);
        for (w = 0; w < A.length; w++) {
          var T = A[w];
          f(m[T], T, w, S, m, x, y), k[T] = m[T];
        }
        if (typeof _ < "u")
          r.push([_, v, m]), _[v] = k;
        else
          return k;
      }
      S.pop();
    }
  }
  function d(m) {
    return m = typeof m < "u" ? m : function(v, g) {
      return g;
    }, function(v, g) {
      if (n.length > 0)
        for (var S = 0; S < n.length; S++) {
          var _ = n[S];
          if (_[1] === v && _[0] === g) {
            g = _[2], n.splice(S, 1);
            break;
          }
        }
      return m.call(this, v, g);
    };
  }
  return Fy;
}
/*!
 * Stickyfill -- `position: sticky` polyfill
 * v. 1.1.1 | https://github.com/wilddeer/stickyfill
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 */
var zy, XE;
function CB() {
  return XE || (XE = 1, zy = function(e, t) {
    e || (e = document), t || (t = window);
    var r = [], n, i = !1, s = e.documentElement, o = function() {
    }, a, l = "hidden", p = "visibilitychange";
    e.webkitHidden !== void 0 && (l = "webkitHidden", p = "webkitvisibilitychange"), t.getComputedStyle || v();
    for (var f = ["", "-webkit-", "-moz-", "-ms-"], d = document.createElement("div"), m = f.length - 1; m >= 0; m--) {
      try {
        d.style.position = f[m] + "sticky";
      } catch {
      }
      d.style.position != "" && v();
    }
    _();
    function v() {
      Z = j = K = z = te = q = o;
    }
    function g(F, ue) {
      for (key in ue)
        ue.hasOwnProperty(key) && (F[key] = ue[key]);
    }
    function S(F) {
      return parseFloat(F) || 0;
    }
    function _() {
      n = {
        top: t.pageYOffset,
        left: t.pageXOffset
      };
    }
    function x() {
      if (t.pageXOffset != n.left) {
        _(), K();
        return;
      }
      t.pageYOffset != n.top && (_(), w());
    }
    function y(F) {
      setTimeout(function() {
        t.pageYOffset != n.top && (n.top = t.pageYOffset, w());
      }, 0);
    }
    function w() {
      for (var F = r.length - 1; F >= 0; F--)
        k(r[F]);
    }
    function k(F) {
      if (F.inited) {
        var ue = n.top <= F.limit.start ? 0 : n.top >= F.limit.end ? 2 : 1;
        F.mode != ue && L(F, ue);
      }
    }
    function A() {
      for (var F = r.length - 1; F >= 0; F--)
        if (r[F].inited) {
          var ue = Math.abs(oe(r[F].clone) - r[F].docOffsetTop), ge = Math.abs(r[F].parent.node.offsetHeight - r[F].parent.height);
          if (ue >= 2 || ge >= 2) return !1;
        }
      return !0;
    }
    function T(F) {
      isNaN(parseFloat(F.computed.top)) || F.isCell || (F.inited = !0, F.clone || Y(F), F.parent.computed.position != "absolute" && F.parent.computed.position != "relative" && (F.parent.node.style.position = "relative"), k(F), F.parent.height = F.parent.node.offsetHeight, F.docOffsetTop = oe(F.clone));
    }
    function R(F) {
      var ue = !0;
      F.clone && Q(F), g(F.node.style, F.css);
      for (var ge = r.length - 1; ge >= 0; ge--)
        if (r[ge].node !== F.node && r[ge].parent.node === F.parent.node) {
          ue = !1;
          break;
        }
      ue && (F.parent.node.style.position = F.parent.css.position), F.mode = -1;
    }
    function I() {
      for (var F = r.length - 1; F >= 0; F--)
        T(r[F]);
    }
    function B() {
      for (var F = r.length - 1; F >= 0; F--)
        R(r[F]);
    }
    function L(F, ue) {
      var ge = F.node.style;
      switch (ue) {
        case 0:
          ge.position = "absolute", ge.left = F.offset.left + "px", ge.right = F.offset.right + "px", ge.top = F.offset.top + "px", ge.bottom = "auto", ge.width = "auto", ge.marginLeft = 0, ge.marginRight = 0, ge.marginTop = 0;
          break;
        case 1:
          ge.position = "fixed", ge.left = F.box.left + "px", ge.right = F.box.right + "px", ge.top = F.css.top, ge.bottom = "auto", ge.width = "auto", ge.marginLeft = 0, ge.marginRight = 0, ge.marginTop = 0;
          break;
        case 2:
          ge.position = "absolute", ge.left = F.offset.left + "px", ge.right = F.offset.right + "px", ge.top = "auto", ge.bottom = 0, ge.width = "auto", ge.marginLeft = 0, ge.marginRight = 0;
          break;
      }
      F.mode = ue;
    }
    function Y(F) {
      F.clone = document.createElement("div");
      var ue = F.node.nextSibling || F.node, ge = F.clone.style;
      ge.height = F.height + "px", ge.width = F.width + "px", ge.marginTop = F.computed.marginTop, ge.marginBottom = F.computed.marginBottom, ge.marginLeft = F.computed.marginLeft, ge.marginRight = F.computed.marginRight, ge.padding = ge.border = ge.borderSpacing = 0, ge.fontSize = "1em", ge.position = "static", ge.cssFloat = F.computed.cssFloat, F.node.parentNode.insertBefore(F.clone, ue);
    }
    function Q(F) {
      F.clone.parentNode.removeChild(F.clone), F.clone = void 0;
    }
    function re(F) {
      var ue = getComputedStyle(F), ge = F.parentNode, Ae = getComputedStyle(ge), C = F.style.position;
      F.style.position = "relative";
      var N = {
        top: ue.top,
        marginTop: ue.marginTop,
        marginBottom: ue.marginBottom,
        marginLeft: ue.marginLeft,
        marginRight: ue.marginRight,
        cssFloat: ue.cssFloat
      }, J = {
        top: S(ue.top),
        marginBottom: S(ue.marginBottom),
        paddingLeft: S(ue.paddingLeft),
        paddingRight: S(ue.paddingRight),
        borderLeftWidth: S(ue.borderLeftWidth),
        borderRightWidth: S(ue.borderRightWidth)
      };
      F.style.position = C;
      var X = {
        position: F.style.position,
        top: F.style.top,
        bottom: F.style.bottom,
        left: F.style.left,
        right: F.style.right,
        width: F.style.width,
        marginTop: F.style.marginTop,
        marginLeft: F.style.marginLeft,
        marginRight: F.style.marginRight
      }, ae = ce(F), U = ce(ge), W = {
        node: ge,
        css: {
          position: ge.style.position
        },
        computed: {
          position: Ae.position
        },
        numeric: {
          borderLeftWidth: S(Ae.borderLeftWidth),
          borderRightWidth: S(Ae.borderRightWidth),
          borderTopWidth: S(Ae.borderTopWidth),
          borderBottomWidth: S(Ae.borderBottomWidth)
        }
      }, ve = {
        node: F,
        box: {
          left: ae.win.left,
          right: s.clientWidth - ae.win.right
        },
        offset: {
          top: ae.win.top - U.win.top - W.numeric.borderTopWidth,
          left: ae.win.left - U.win.left - W.numeric.borderLeftWidth,
          right: -ae.win.right + U.win.right - W.numeric.borderRightWidth
        },
        css: X,
        isCell: ue.display == "table-cell",
        computed: N,
        numeric: J,
        width: ae.win.right - ae.win.left,
        height: ae.win.bottom - ae.win.top,
        mode: -1,
        inited: !1,
        parent: W,
        limit: {
          start: ae.doc.top - J.top,
          end: U.doc.top + ge.offsetHeight - W.numeric.borderBottomWidth - F.offsetHeight - J.top - J.marginBottom
        }
      };
      return ve;
    }
    function oe(F) {
      for (var ue = 0; F; )
        ue += F.offsetTop, F = F.offsetParent;
      return ue;
    }
    function ce(F) {
      var ue = F.getBoundingClientRect();
      return {
        doc: {
          top: ue.top + t.pageYOffset,
          left: ue.left + t.pageXOffset
        },
        win: ue
      };
    }
    function pe() {
      a = setInterval(function() {
        !A() && K();
      }, 500);
    }
    function fe() {
      clearInterval(a);
    }
    function G() {
      i && (document[l] ? fe() : pe());
    }
    function Z() {
      i || (_(), I(), t.addEventListener("scroll", x), t.addEventListener("wheel", y), t.addEventListener("resize", K), t.addEventListener("orientationchange", K), e.addEventListener(p, G), pe(), i = !0);
    }
    function K() {
      if (i) {
        B();
        for (var F = r.length - 1; F >= 0; F--)
          r[F] = re(r[F].node);
        I();
      }
    }
    function z() {
      t.removeEventListener("scroll", x), t.removeEventListener("wheel", y), t.removeEventListener("resize", K), t.removeEventListener("orientationchange", K), e.removeEventListener(p, G), fe(), i = !1;
    }
    function te() {
      z(), B();
    }
    function q() {
      for (te(); r.length; )
        r.pop();
    }
    function j(F) {
      for (var ue = r.length - 1; ue >= 0; ue--)
        if (r[ue].node === F) return;
      var ge = re(F);
      r.push(ge), i ? T(ge) : Z();
    }
    function H(F) {
      for (var ue = r.length - 1; ue >= 0; ue--)
        r[ue].node === F && (R(r[ue]), r.splice(ue, 1));
    }
    return {
      stickies: r,
      add: j,
      remove: H,
      init: Z,
      rebuild: K,
      pause: z,
      stop: te,
      kill: q
    };
  }), zy;
}
function hn(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? hn = function(t) {
    return typeof t;
  } : hn = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hn(e);
}
function ft(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JE(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function _t(e, t, r) {
  return t && JE(e.prototype, t), r && JE(e, r), e;
}
function $r(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function Pt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), t && Bc(e, t);
}
function xr(e) {
  return xr = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, xr(e);
}
function Bc(e, t) {
  return Bc = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, Bc(e, t);
}
function yR() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function vh(e, t, r) {
  return yR() ? vh = Reflect.construct : vh = function(i, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(i, a), p = new l();
    return o && Bc(p, o.prototype), p;
  }, vh.apply(null, arguments);
}
function TB(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function ib(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return ib = function(n) {
    if (n === null || !TB(n)) return n;
    if (typeof n != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(n)) return t.get(n);
      t.set(n, i);
    }
    function i() {
      return vh(n, arguments, xr(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Bc(i, n);
  }, ib(e);
}
function kn(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function vR(e, t) {
  return t && (typeof t == "object" || typeof t == "function") ? t : kn(e);
}
function Ct(e) {
  var t = yR();
  return function() {
    var n = xr(e), i;
    if (t) {
      var s = xr(this).constructor;
      i = Reflect.construct(n, arguments, s);
    } else
      i = n.apply(this, arguments);
    return vR(this, i);
  };
}
function $B(e, t) {
  for (; !Object.prototype.hasOwnProperty.call(e, t) && (e = xr(e), e !== null); )
    ;
  return e;
}
function rn(e, t, r) {
  return typeof Reflect < "u" && Reflect.get ? rn = Reflect.get : rn = function(i, s, o) {
    var a = $B(i, s);
    if (a) {
      var l = Object.getOwnPropertyDescriptor(a, s);
      return l.get ? l.get.call(o) : l.value;
    }
  }, rn(e, t, r || e);
}
function lp(e, t) {
  return bR(e) || IB(e, t) || qw(e, t) || wR();
}
function Fu(e) {
  return bR(e) || RB(e) || qw(e) || wR();
}
function bR(e) {
  if (Array.isArray(e)) return e;
}
function RB(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e);
}
function IB(e, t) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
    var r = [], n = !0, i = !1, s = void 0;
    try {
      for (var o = e[Symbol.iterator](), a; !(n = (a = o.next()).done) && (r.push(a.value), !(t && r.length === t)); n = !0)
        ;
    } catch (l) {
      i = !0, s = l;
    } finally {
      try {
        !n && o.return != null && o.return();
      } finally {
        if (i) throw s;
      }
    }
    return r;
  }
}
function qw(e, t) {
  if (e) {
    if (typeof e == "string") return ZE(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return ZE(e, t);
  }
}
function ZE(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function wR() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function At(e, t) {
  var r;
  if (typeof Symbol > "u" || e[Symbol.iterator] == null) {
    if (Array.isArray(e) || (r = qw(e)) || t) {
      r && (e = r);
      var n = 0, i = function() {
      };
      return {
        s: i,
        n: function() {
          return n >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[n++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: i
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0, o = !1, a;
  return {
    s: function() {
      r = e[Symbol.iterator]();
    },
    n: function() {
      var l = r.next();
      return s = l.done, l;
    },
    e: function(l) {
      o = !0, a = l;
    },
    f: function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (o) throw a;
      }
    }
  };
}
var tr = {
  ANCHOR: "&",
  COMMENT: "#",
  TAG: "!",
  DIRECTIVES_END: "-",
  DOCUMENT_END: "."
}, _e = {
  ALIAS: "ALIAS",
  BLANK_LINE: "BLANK_LINE",
  BLOCK_FOLDED: "BLOCK_FOLDED",
  BLOCK_LITERAL: "BLOCK_LITERAL",
  COMMENT: "COMMENT",
  DIRECTIVE: "DIRECTIVE",
  DOCUMENT: "DOCUMENT",
  FLOW_MAP: "FLOW_MAP",
  FLOW_SEQ: "FLOW_SEQ",
  MAP: "MAP",
  MAP_KEY: "MAP_KEY",
  MAP_VALUE: "MAP_VALUE",
  PLAIN: "PLAIN",
  QUOTE_DOUBLE: "QUOTE_DOUBLE",
  QUOTE_SINGLE: "QUOTE_SINGLE",
  SEQ: "SEQ",
  SEQ_ITEM: "SEQ_ITEM"
}, bh = "tag:yaml.org,2002:", Lo = {
  MAP: "tag:yaml.org,2002:map",
  SEQ: "tag:yaml.org,2002:seq",
  STR: "tag:yaml.org,2002:str"
};
function eO(e) {
  for (var t = [0], r = e.indexOf(`
`); r !== -1; )
    r += 1, t.push(r), r = e.indexOf(`
`, r);
  return t;
}
function SR(e) {
  var t, r;
  return typeof e == "string" ? (t = eO(e), r = e) : (Array.isArray(e) && (e = e[0]), e && e.context && (e.lineStarts || (e.lineStarts = eO(e.context.src)), t = e.lineStarts, r = e.context.src)), {
    lineStarts: t,
    src: r
  };
}
function ob(e, t) {
  if (typeof e != "number" || e < 0) return null;
  var r = SR(t), n = r.lineStarts, i = r.src;
  if (!n || !i || e > i.length) return null;
  for (var s = 0; s < n.length; ++s) {
    var o = n[s];
    if (e < o)
      return {
        line: s,
        col: e - n[s - 1] + 1
      };
    if (e === o) return {
      line: s + 1,
      col: 1
    };
  }
  var a = n.length;
  return {
    line: a,
    col: e - n[a - 1] + 1
  };
}
function jB(e, t) {
  var r = SR(t), n = r.lineStarts, i = r.src;
  if (!n || !(e >= 1) || e > n.length) return null;
  for (var s = n[e - 1], o = n[e]; o && o > s && i[o - 1] === `
`; )
    --o;
  return i.slice(s, o);
}
function NB(e, t) {
  var r = e.start, n = e.end, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80, s = jB(r.line, t);
  if (!s) return null;
  var o = r.col;
  if (s.length > i)
    if (o <= i - 10)
      s = s.substr(0, i - 1) + "…";
    else {
      var a = Math.round(i / 2);
      s.length > o + a && (s = s.substr(0, o + a - 1) + "…"), o -= s.length - i, s = "…" + s.substr(1 - i);
    }
  var l = 1, p = "";
  n && (n.line === r.line && o + (n.col - r.col) <= i + 1 ? l = n.col - r.col : (l = Math.min(s.length + 1, i) - o, p = "…"));
  var f = o > 1 ? " ".repeat(o - 1) : "", d = "^".repeat(l);
  return "".concat(s, `
`).concat(f).concat(d).concat(p);
}
var Dt = /* @__PURE__ */ function() {
  function e(t, r) {
    ft(this, e), this.start = t, this.end = r || t;
  }
  return _t(e, [{
    key: "isEmpty",
    value: function() {
      return typeof this.start != "number" || !this.end || this.end <= this.start;
    }
    /**
     * Set `origStart` and `origEnd` to point to the original source range for
     * this node, which may differ due to dropped CR characters.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */
  }, {
    key: "setOrigRange",
    value: function(r, n) {
      var i = this.start, s = this.end;
      if (r.length === 0 || s <= r[0])
        return this.origStart = i, this.origEnd = s, n;
      for (var o = n; o < r.length && !(r[o] > i); )
        ++o;
      this.origStart = i + o;
      for (var a = o; o < r.length && !(r[o] >= s); )
        ++o;
      return this.origEnd = s + o, a;
    }
  }], [{
    key: "copy",
    value: function(r) {
      return new e(r.start, r.end);
    }
  }]), e;
}(), De = /* @__PURE__ */ function() {
  function e(t, r, n) {
    ft(this, e), Object.defineProperty(this, "context", {
      value: n || null,
      writable: !0
    }), this.error = null, this.range = null, this.valueRange = null, this.props = r || [], this.type = t, this.value = null;
  }
  return _t(e, [{
    key: "getPropValue",
    value: function(r, n, i) {
      if (!this.context) return null;
      var s = this.context.src, o = this.props[r];
      return o && s[o.start] === n ? s.slice(o.start + (i ? 1 : 0), o.end) : null;
    }
  }, {
    key: "anchor",
    get: function() {
      for (var r = 0; r < this.props.length; ++r) {
        var n = this.getPropValue(r, tr.ANCHOR, !0);
        if (n != null) return n;
      }
      return null;
    }
  }, {
    key: "comment",
    get: function() {
      for (var r = [], n = 0; n < this.props.length; ++n) {
        var i = this.getPropValue(n, tr.COMMENT, !0);
        i != null && r.push(i);
      }
      return r.length > 0 ? r.join(`
`) : null;
    }
  }, {
    key: "commentHasRequiredWhitespace",
    value: function(r) {
      var n = this.context.src;
      if (this.header && r === this.header.end || !this.valueRange) return !1;
      var i = this.valueRange.end;
      return r !== i || e.atBlank(n, i - 1);
    }
  }, {
    key: "hasComment",
    get: function() {
      if (this.context) {
        for (var r = this.context.src, n = 0; n < this.props.length; ++n)
          if (r[this.props[n].start] === tr.COMMENT) return !0;
      }
      return !1;
    }
  }, {
    key: "hasProps",
    get: function() {
      if (this.context) {
        for (var r = this.context.src, n = 0; n < this.props.length; ++n)
          if (r[this.props[n].start] !== tr.COMMENT) return !0;
      }
      return !1;
    }
  }, {
    key: "includesTrailingLines",
    get: function() {
      return !1;
    }
  }, {
    key: "jsonLike",
    get: function() {
      var r = [_e.FLOW_MAP, _e.FLOW_SEQ, _e.QUOTE_DOUBLE, _e.QUOTE_SINGLE];
      return r.indexOf(this.type) !== -1;
    }
  }, {
    key: "rangeAsLinePos",
    get: function() {
      if (!(!this.range || !this.context)) {
        var r = ob(this.range.start, this.context.root);
        if (r) {
          var n = ob(this.range.end, this.context.root);
          return {
            start: r,
            end: n
          };
        }
      }
    }
  }, {
    key: "rawValue",
    get: function() {
      if (!this.valueRange || !this.context) return null;
      var r = this.valueRange, n = r.start, i = r.end;
      return this.context.src.slice(n, i);
    }
  }, {
    key: "tag",
    get: function() {
      for (var r = 0; r < this.props.length; ++r) {
        var n = this.getPropValue(r, tr.TAG, !1);
        if (n != null) {
          if (n[1] === "<")
            return {
              verbatim: n.slice(2, -1)
            };
          var i = n.match(/^(.*!)([^!]*)$/), s = lp(i, 3);
          s[0];
          var o = s[1], a = s[2];
          return {
            handle: o,
            suffix: a
          };
        }
      }
      return null;
    }
  }, {
    key: "valueRangeContainsNewline",
    get: function() {
      if (!this.valueRange || !this.context) return !1;
      for (var r = this.valueRange, n = r.start, i = r.end, s = this.context.src, o = n; o < i; ++o)
        if (s[o] === `
`) return !0;
      return !1;
    }
  }, {
    key: "parseComment",
    value: function(r) {
      var n = this.context.src;
      if (n[r] === tr.COMMENT) {
        var i = e.endOfLine(n, r + 1), s = new Dt(r, i);
        return this.props.push(s), i;
      }
      return r;
    }
    /**
     * Populates the `origStart` and `origEnd` values of all ranges for this
     * node. Extended by child classes to handle descendant nodes.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */
  }, {
    key: "setOrigRanges",
    value: function(r, n) {
      return this.range && (n = this.range.setOrigRange(r, n)), this.valueRange && this.valueRange.setOrigRange(r, n), this.props.forEach(function(i) {
        return i.setOrigRange(r, n);
      }), n;
    }
  }, {
    key: "toString",
    value: function() {
      var r = this.context.src, n = this.range, i = this.value;
      if (i != null) return i;
      var s = r.slice(n.start, n.end);
      return e.addStringTerminator(r, n.end, s);
    }
  }], [{
    key: "addStringTerminator",
    value: function(r, n, i) {
      if (i[i.length - 1] === `
`) return i;
      var s = e.endOfWhiteSpace(r, n);
      return s >= r.length || r[s] === `
` ? i + `
` : i;
    }
    // ^(---|...)
  }, {
    key: "atDocumentBoundary",
    value: function(r, n, i) {
      var s = r[n];
      if (!s) return !0;
      var o = r[n - 1];
      if (o && o !== `
`) return !1;
      if (i) {
        if (s !== i) return !1;
      } else if (s !== tr.DIRECTIVES_END && s !== tr.DOCUMENT_END) return !1;
      var a = r[n + 1], l = r[n + 2];
      if (a !== s || l !== s) return !1;
      var p = r[n + 3];
      return !p || p === `
` || p === "	" || p === " ";
    }
  }, {
    key: "endOfIdentifier",
    value: function(r, n) {
      for (var i = r[n], s = i === "<", o = s ? [`
`, "	", " ", ">"] : [`
`, "	", " ", "[", "]", "{", "}", ","]; i && o.indexOf(i) === -1; )
        i = r[n += 1];
      return s && i === ">" && (n += 1), n;
    }
  }, {
    key: "endOfIndent",
    value: function(r, n) {
      for (var i = r[n]; i === " "; )
        i = r[n += 1];
      return n;
    }
  }, {
    key: "endOfLine",
    value: function(r, n) {
      for (var i = r[n]; i && i !== `
`; )
        i = r[n += 1];
      return n;
    }
  }, {
    key: "endOfWhiteSpace",
    value: function(r, n) {
      for (var i = r[n]; i === "	" || i === " "; )
        i = r[n += 1];
      return n;
    }
  }, {
    key: "startOfLine",
    value: function(r, n) {
      var i = r[n - 1];
      if (i === `
`) return n;
      for (; i && i !== `
`; )
        i = r[n -= 1];
      return n + 1;
    }
    /**
     * End of indentation, or null if the line's indent level is not more
     * than `indent`
     *
     * @param {string} src
     * @param {number} indent
     * @param {number} lineStart
     * @returns {?number}
     */
  }, {
    key: "endOfBlockIndent",
    value: function(r, n, i) {
      var s = e.endOfIndent(r, i);
      if (s > i + n)
        return s;
      var o = e.endOfWhiteSpace(r, s), a = r[o];
      return !a || a === `
` ? o : null;
    }
  }, {
    key: "atBlank",
    value: function(r, n, i) {
      var s = r[n];
      return s === `
` || s === "	" || s === " " || i && !s;
    }
  }, {
    key: "nextNodeIsIndented",
    value: function(r, n, i) {
      return !r || n < 0 ? !1 : n > 0 ? !0 : i && r === "-";
    }
    // should be at line or string end, or at next non-whitespace char
  }, {
    key: "normalizeOffset",
    value: function(r, n) {
      var i = r[n];
      return i ? i !== `
` && r[n - 1] === `
` ? n - 1 : e.endOfWhiteSpace(r, n) : n;
    }
    // fold single newline into space, multiple newlines to N - 1 newlines
    // presumes src[offset] === '\n'
  }, {
    key: "foldNewline",
    value: function(r, n, i) {
      for (var s = 0, o = !1, a = "", l = r[n + 1]; l === " " || l === "	" || l === `
`; ) {
        switch (l) {
          case `
`:
            s = 0, n += 1, a += `
`;
            break;
          case "	":
            s <= i && (o = !0), n = e.endOfWhiteSpace(r, n + 2) - 1;
            break;
          case " ":
            s += 1, n += 1;
            break;
        }
        l = r[n + 1];
      }
      return a || (a = " "), l && s <= i && (o = !0), {
        fold: a,
        offset: n,
        error: o
      };
    }
  }]), e;
}(), kl = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i, s) {
    var o;
    if (ft(this, r), !s || !(i instanceof De)) throw new Error("Invalid arguments for new ".concat(n));
    return o = t.call(this), o.name = n, o.message = s, o.source = i, o;
  }
  return _t(r, [{
    key: "makePretty",
    value: function() {
      if (this.source) {
        this.nodeType = this.source.type;
        var i = this.source.context && this.source.context.root;
        if (typeof this.offset == "number") {
          this.range = new Dt(this.offset, this.offset + 1);
          var s = i && ob(this.offset, i);
          if (s) {
            var o = {
              line: s.line,
              col: s.col + 1
            };
            this.linePos = {
              start: s,
              end: o
            };
          }
          delete this.offset;
        } else
          this.range = this.source.range, this.linePos = this.source.rangeAsLinePos;
        if (this.linePos) {
          var a = this.linePos.start, l = a.line, p = a.col;
          this.message += " at line ".concat(l, ", column ").concat(p);
          var f = i && NB(this.linePos, i);
          f && (this.message += `:

`.concat(f, `
`));
        }
        delete this.source;
      }
    }
  }]), r;
}(/* @__PURE__ */ ib(Error)), Uc = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i) {
    return ft(this, r), t.call(this, "YAMLReferenceError", n, i);
  }
  return r;
}(kl), nt = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i) {
    return ft(this, r), t.call(this, "YAMLSemanticError", n, i);
  }
  return r;
}(kl), Ir = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i) {
    return ft(this, r), t.call(this, "YAMLSyntaxError", n, i);
  }
  return r;
}(kl), Bl = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i) {
    return ft(this, r), t.call(this, "YAMLWarning", n, i);
  }
  return r;
}(kl), xR = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "strValue",
    get: function() {
      if (!this.valueRange || !this.context) return null;
      for (var i = this.valueRange, s = i.start, o = i.end, a = this.context.src, l = a[o - 1]; s < o && (l === `
` || l === "	" || l === " "); )
        l = a[--o - 1];
      for (var p = "", f = s; f < o; ++f) {
        var d = a[f];
        if (d === `
`) {
          var m = De.foldNewline(a, f, -1), v = m.fold, g = m.offset;
          p += v, f = g;
        } else if (d === " " || d === "	") {
          for (var S = f, _ = a[f + 1]; f < o && (_ === " " || _ === "	"); )
            f += 1, _ = a[f + 1];
          _ !== `
` && (p += f > S ? a.slice(S, f + 1) : d);
        } else
          p += d;
      }
      var x = a[s];
      switch (x) {
        case "	": {
          var y = "Plain value cannot start with a tab character", w = [new nt(this, y)];
          return {
            errors: w,
            str: p
          };
        }
        case "@":
        case "`": {
          var k = "Plain value cannot start with reserved character ".concat(x), A = [new nt(this, k)];
          return {
            errors: A,
            str: p
          };
        }
        default:
          return p;
      }
    }
  }, {
    key: "parseBlockValue",
    value: function(i) {
      for (var s = this.context, o = s.indent, a = s.inFlow, l = s.src, p = i, f = i, d = l[p]; d === `
` && !De.atDocumentBoundary(l, p + 1); d = l[p]) {
        var m = De.endOfBlockIndent(l, o, p + 1);
        if (m === null || l[m] === "#") break;
        l[m] === `
` ? p = m : (f = r.endOfLine(l, m, a), p = f);
      }
      return this.valueRange.isEmpty() && (this.valueRange.start = i), this.valueRange.end = f, f;
    }
    /**
     * Parses a plain value from the source
     *
     * Accepted forms are:
     * ```
     * #comment
     *
     * first line
     *
     * first line #comment
     *
     * first line
     * block
     * lines
     *
     * #comment
     * block
     * lines
     * ```
     * where block lines are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar, may be `\n`
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.inFlow, a = i.src, l = s, p = a[l];
      return p && p !== "#" && p !== `
` && (l = r.endOfLine(a, s, o)), this.valueRange = new Dt(s, l), l = De.endOfWhiteSpace(a, l), l = this.parseComment(l), (!this.hasComment || this.valueRange.isEmpty()) && (l = this.parseBlockValue(l)), l;
    }
  }], [{
    key: "endOfLine",
    value: function(i, s, o) {
      for (var a = i[s], l = s; a && a !== `
` && !(o && (a === "[" || a === "]" || a === "{" || a === "}" || a === ",")); ) {
        var p = i[l + 1];
        if (a === ":" && (!p || p === `
` || p === "	" || p === " " || o && p === ",") || (a === " " || a === "	") && p === "#") break;
        l += 1, a = p;
      }
      return l;
    }
  }]), r;
}(De), Vc = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.call(this, _e.BLANK_LINE);
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return !0;
    }
    /**
     * Parses a blank line from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first \n character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      return this.context = i, this.range = new Dt(s, s + 1), s + 1;
    }
  }]), r;
}(De), Bw = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i) {
    var s;
    return ft(this, r), s = t.call(this, n, i), s.node = null, s;
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return !!this.node && this.node.includesTrailingLines;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.parseNode, a = i.src, l = i.atLineStart, p = i.lineStart;
      !l && this.type === _e.SEQ_ITEM && (this.error = new nt(this, "Sequence items must not have preceding content on the same line"));
      for (var f = l ? s - p : i.indent, d = De.endOfWhiteSpace(a, s + 1), m = a[d], v = m === "#", g = [], S = null; m === `
` || m === "#"; ) {
        if (m === "#") {
          var _ = De.endOfLine(a, d + 1);
          g.push(new Dt(d, _)), d = _;
        } else {
          l = !0, p = d + 1;
          var x = De.endOfWhiteSpace(a, p);
          a[x] === `
` && g.length === 0 && (S = new Vc(), p = S.parse({
            src: a
          }, p)), d = De.endOfIndent(a, p);
        }
        m = a[d];
      }
      if (De.nextNodeIsIndented(m, d - (p + f), this.type !== _e.SEQ_ITEM) ? this.node = o({
        atLineStart: l,
        inCollection: !1,
        indent: f,
        lineStart: p,
        parent: this
      }, d) : m && p > s + 1 && (d = p - 1), this.node) {
        if (S) {
          var y = i.parent.items || i.parent.contents;
          y && y.push(S);
        }
        g.length && Array.prototype.push.apply(this.props, g), d = this.node.range.end;
      } else if (v) {
        var w = g[0];
        this.props.push(w), d = w.end;
      } else
        d = De.endOfLine(a, s + 1);
      var k = this.node ? this.node.valueRange.end : d;
      return this.valueRange = new Dt(s, k), d;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = rn(xr(r.prototype), "setOrigRanges", this).call(this, i, s), this.node ? this.node.setOrigRanges(i, s) : s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.context.src, s = this.node, o = this.range, a = this.value;
      if (a != null) return a;
      var l = s ? i.slice(o.start, s.range.start) + String(s) : i.slice(o.start, o.end);
      return De.addStringTerminator(i, o.end, l);
    }
  }]), r;
}(De), vc = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.call(this, _e.COMMENT);
  }
  return _t(r, [{
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = this.parseComment(s);
      return this.range = new Dt(s, o), o;
    }
  }]), r;
}(De);
function sb(e) {
  for (var t = e; t instanceof Bw; )
    t = t.node;
  if (!(t instanceof _R)) return null;
  for (var r = t.items.length, n = -1, i = r - 1; i >= 0; --i) {
    var s = t.items[i];
    if (s.type === _e.COMMENT) {
      var o = s.context, a = o.indent, l = o.lineStart;
      if (a > 0 && s.range.start >= l + a) break;
      n = i;
    } else if (s.type === _e.BLANK_LINE) n = i;
    else break;
  }
  if (n === -1) return null;
  for (var p = t.items.splice(n, r - n), f = p[0].range.start; t.range.end = f, t.valueRange && t.valueRange.end > f && (t.valueRange.end = f), t !== e; )
    t = t.context.parent;
  return p;
}
var _R = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n) {
    var i;
    ft(this, r), i = t.call(this, n.type === _e.SEQ_ITEM ? _e.SEQ : _e.MAP);
    for (var s = n.props.length - 1; s >= 0; --s)
      if (n.props[s].start < n.context.lineStart) {
        i.props = n.props.slice(0, s + 1), n.props = n.props.slice(s + 1);
        var o = n.props[0] || n.valueRange;
        n.range.start = o.start;
        break;
      }
    i.items = [n];
    var a = sb(n);
    return a && Array.prototype.push.apply(i.items, a), i;
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return this.items.length > 0;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.parseNode, a = i.src, l = De.startOfLine(a, s), p = this.items[0];
      p.context.parent = this, this.valueRange = Dt.copy(p.valueRange);
      var f = p.range.start - p.context.lineStart, d = s;
      d = De.normalizeOffset(a, d);
      for (var m = a[d], v = De.endOfWhiteSpace(a, l) === d, g = !1; m; ) {
        for (; m === `
` || m === "#"; ) {
          if (v && m === `
` && !g) {
            var S = new Vc();
            if (d = S.parse({
              src: a
            }, d), this.valueRange.end = d, d >= a.length) {
              m = null;
              break;
            }
            this.items.push(S), d -= 1;
          } else if (m === "#") {
            if (d < l + f && !r.nextContentHasIndent(a, d, f))
              return d;
            var _ = new vc();
            if (d = _.parse({
              indent: f,
              lineStart: l,
              src: a
            }, d), this.items.push(_), this.valueRange.end = d, d >= a.length) {
              m = null;
              break;
            }
          }
          if (l = d + 1, d = De.endOfIndent(a, l), De.atBlank(a, d)) {
            var x = De.endOfWhiteSpace(a, d), y = a[x];
            (!y || y === `
` || y === "#") && (d = x);
          }
          m = a[d], v = !0;
        }
        if (!m)
          break;
        if (d !== l + f && (v || m !== ":")) {
          if (d < l + f) {
            l > s && (d = l);
            break;
          } else if (!this.error) {
            var w = "All collection items must start at the same column";
            this.error = new Ir(this, w);
          }
        }
        if (p.type === _e.SEQ_ITEM) {
          if (m !== "-") {
            l > s && (d = l);
            break;
          }
        } else if (m === "-" && !this.error) {
          var k = a[d + 1];
          if (!k || k === `
` || k === "	" || k === " ") {
            var A = "A collection cannot be both a mapping and a sequence";
            this.error = new Ir(this, A);
          }
        }
        var T = o({
          atLineStart: v,
          inCollection: !0,
          indent: f,
          lineStart: l,
          parent: this
        }, d);
        if (!T) return d;
        if (this.items.push(T), this.valueRange.end = T.valueRange.end, d = De.normalizeOffset(a, T.range.end), m = a[d], v = !1, g = T.includesTrailingLines, m) {
          for (var R = d - 1, I = a[R]; I === " " || I === "	"; )
            I = a[--R];
          I === `
` && (l = R + 1, v = !0);
        }
        var B = sb(T);
        B && Array.prototype.push.apply(this.items, B);
      }
      return d;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = rn(xr(r.prototype), "setOrigRanges", this).call(this, i, s), this.items.forEach(function(o) {
        s = o.setOrigRanges(i, s);
      }), s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.context.src, s = this.items, o = this.range, a = this.value;
      if (a != null) return a;
      for (var l = i.slice(o.start, s[0].range.start) + String(s[0]), p = 1; p < s.length; ++p) {
        var f = s[p], d = f.context, m = d.atLineStart, v = d.indent;
        if (m) for (var g = 0; g < v; ++g)
          l += " ";
        l += String(f);
      }
      return De.addStringTerminator(i, o.end, l);
    }
  }], [{
    key: "nextContentHasIndent",
    value: function(i, s, o) {
      var a = De.endOfLine(i, s) + 1;
      s = De.endOfWhiteSpace(i, a);
      var l = i[s];
      return l ? s >= a + o ? !0 : l !== "#" && l !== `
` ? !1 : r.nextContentHasIndent(i, s, o) : !1;
    }
  }]), r;
}(De), LB = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    var n;
    return ft(this, r), n = t.call(this, _e.DIRECTIVE), n.name = null, n;
  }
  return _t(r, [{
    key: "parameters",
    get: function() {
      var i = this.rawValue;
      return i ? i.trim().split(/[ \t]+/) : [];
    }
  }, {
    key: "parseName",
    value: function(i) {
      for (var s = this.context.src, o = i, a = s[o]; a && a !== `
` && a !== "	" && a !== " "; )
        a = s[o += 1];
      return this.name = s.slice(i, o), o;
    }
  }, {
    key: "parseParameters",
    value: function(i) {
      for (var s = this.context.src, o = i, a = s[o]; a && a !== `
` && a !== "#"; )
        a = s[o += 1];
      return this.valueRange = new Dt(i, o), o;
    }
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = this.parseName(s + 1);
      return o = this.parseParameters(o), o = this.parseComment(o), this.range = new Dt(s, o), o;
    }
  }]), r;
}(De), MB = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    var n;
    return ft(this, r), n = t.call(this, _e.DOCUMENT), n.directives = null, n.contents = null, n.directivesEndMarker = null, n.documentEndMarker = null, n;
  }
  return _t(r, [{
    key: "parseDirectives",
    value: function(i) {
      var s = this.context.src;
      this.directives = [];
      for (var o = !0, a = !1, l = i; !De.atDocumentBoundary(s, l, tr.DIRECTIVES_END); )
        switch (l = r.startCommentOrEndBlankLine(s, l), s[l]) {
          case `
`:
            if (o) {
              var p = new Vc();
              l = p.parse({
                src: s
              }, l), l < s.length && this.directives.push(p);
            } else
              l += 1, o = !0;
            break;
          case "#":
            {
              var f = new vc();
              l = f.parse({
                src: s
              }, l), this.directives.push(f), o = !1;
            }
            break;
          case "%":
            {
              var d = new LB();
              l = d.parse({
                parent: this,
                src: s
              }, l), this.directives.push(d), a = !0, o = !1;
            }
            break;
          default:
            return a ? this.error = new nt(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), l;
        }
      return s[l] ? (this.directivesEndMarker = new Dt(l, l + 3), l + 3) : (a ? this.error = new nt(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), l);
    }
  }, {
    key: "parseContents",
    value: function(i) {
      var s = this.context, o = s.parseNode, a = s.src;
      this.contents || (this.contents = []);
      for (var l = i; a[l - 1] === "-"; )
        l -= 1;
      var p = De.endOfWhiteSpace(a, i), f = l === i;
      for (this.valueRange = new Dt(p); !De.atDocumentBoundary(a, p, tr.DOCUMENT_END); ) {
        switch (a[p]) {
          case `
`:
            if (f) {
              var d = new Vc();
              p = d.parse({
                src: a
              }, p), p < a.length && this.contents.push(d);
            } else
              p += 1, f = !0;
            l = p;
            break;
          case "#":
            {
              var m = new vc();
              p = m.parse({
                src: a
              }, p), this.contents.push(m), f = !1;
            }
            break;
          default: {
            var v = De.endOfIndent(a, p), g = {
              atLineStart: f,
              indent: -1,
              inFlow: !1,
              inCollection: !1,
              lineStart: l,
              parent: this
            }, S = o(g, v);
            if (!S) return this.valueRange.end = v;
            this.contents.push(S), p = S.range.end, f = !1;
            var _ = sb(S);
            _ && Array.prototype.push.apply(this.contents, _);
          }
        }
        p = r.startCommentOrEndBlankLine(a, p);
      }
      if (this.valueRange.end = p, a[p] && (this.documentEndMarker = new Dt(p, p + 3), p += 3, a[p])) {
        if (p = De.endOfWhiteSpace(a, p), a[p] === "#") {
          var x = new vc();
          p = x.parse({
            src: a
          }, p), this.contents.push(x);
        }
        switch (a[p]) {
          case `
`:
            p += 1;
            break;
          case void 0:
            break;
          default:
            this.error = new Ir(this, "Document end marker line cannot have a non-comment suffix");
        }
      }
      return p;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      i.root = this, this.context = i;
      var o = i.src, a = o.charCodeAt(s) === 65279 ? s + 1 : s;
      return a = this.parseDirectives(a), a = this.parseContents(a), a;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = rn(xr(r.prototype), "setOrigRanges", this).call(this, i, s), this.directives.forEach(function(o) {
        s = o.setOrigRanges(i, s);
      }), this.directivesEndMarker && (s = this.directivesEndMarker.setOrigRange(i, s)), this.contents.forEach(function(o) {
        s = o.setOrigRanges(i, s);
      }), this.documentEndMarker && (s = this.documentEndMarker.setOrigRange(i, s)), s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.contents, s = this.directives, o = this.value;
      if (o != null) return o;
      var a = s.join("");
      return i.length > 0 && ((s.length > 0 || i[0].type === _e.COMMENT) && (a += `---
`), a += i.join("")), a[a.length - 1] !== `
` && (a += `
`), a;
    }
  }], [{
    key: "startCommentOrEndBlankLine",
    value: function(i, s) {
      var o = De.endOfWhiteSpace(i, s), a = i[o];
      return a === "#" || a === `
` ? o : s;
    }
  }]), r;
}(De), DB = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "parse",
    value: (
      /**
       * Parses an *alias from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      function(i, s) {
        this.context = i;
        var o = i.src, a = De.endOfIdentifier(o, s + 1);
        return this.valueRange = new Dt(s + 1, a), a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a;
      }
    )
  }]), r;
}(De), ko = {
  CLIP: "CLIP",
  KEEP: "KEEP",
  STRIP: "STRIP"
}, FB = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i) {
    var s;
    return ft(this, r), s = t.call(this, n, i), s.blockIndent = null, s.chomping = ko.CLIP, s.header = null, s;
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return this.chomping === ko.KEEP;
    }
  }, {
    key: "strValue",
    get: function() {
      if (!this.valueRange || !this.context) return null;
      var i = this.valueRange, s = i.start, o = i.end, a = this.context, l = a.indent, p = a.src;
      if (this.valueRange.isEmpty()) return "";
      for (var f = null, d = p[o - 1]; d === `
` || d === "	" || d === " "; ) {
        if (o -= 1, o <= s) {
          if (this.chomping === ko.KEEP) break;
          return "";
        }
        d === `
` && (f = o), d = p[o - 1];
      }
      var m = o + 1;
      f && (this.chomping === ko.KEEP ? (m = f, o = this.valueRange.end) : o = f);
      for (var v = l + this.blockIndent, g = this.type === _e.BLOCK_FOLDED, S = !0, _ = "", x = "", y = !1, w = s; w < o; ++w) {
        for (var k = 0; k < v && p[w] === " "; ++k)
          w += 1;
        var A = p[w];
        if (A === `
`)
          x === `
` ? _ += `
` : x = `
`;
        else {
          var T = De.endOfLine(p, w), R = p.slice(w, T);
          w = T, g && (A === " " || A === "	") && w < m ? (x === " " ? x = `
` : !y && !S && x === `
` && (x = `

`), _ += x + R, x = T < o && p[T] || "", y = !0) : (_ += x + R, x = g && w < m ? " " : `
`, y = !1), S && R !== "" && (S = !1);
        }
      }
      return this.chomping === ko.STRIP ? _ : _ + `
`;
    }
  }, {
    key: "parseBlockHeader",
    value: function(i) {
      for (var s = this.context.src, o = i + 1, a = ""; ; ) {
        var l = s[o];
        switch (l) {
          case "-":
            this.chomping = ko.STRIP;
            break;
          case "+":
            this.chomping = ko.KEEP;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            a += l;
            break;
          default:
            return this.blockIndent = Number(a) || null, this.header = new Dt(i, o), o;
        }
        o += 1;
      }
    }
  }, {
    key: "parseBlockValue",
    value: function(i) {
      for (var s = this.context, o = s.indent, a = s.src, l = !!this.blockIndent, p = i, f = i, d = 1, m = a[p]; m === `
` && (p += 1, !De.atDocumentBoundary(a, p)); m = a[p]) {
        var v = De.endOfBlockIndent(a, o, p);
        if (v === null) break;
        var g = a[v], S = v - (p + o);
        if (this.blockIndent) {
          if (g && g !== `
` && S < this.blockIndent) {
            if (a[v] === "#") break;
            if (!this.error) {
              var x = l ? "explicit indentation indicator" : "first line", y = "Block scalars must not be less indented than their ".concat(x);
              this.error = new nt(this, y);
            }
          }
        } else if (a[v] !== `
`) {
          if (S < d) {
            var _ = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            this.error = new nt(this, _);
          }
          this.blockIndent = S;
        } else S > d && (d = S);
        a[v] === `
` ? p = v : p = f = De.endOfLine(a, v);
      }
      return this.chomping !== ko.KEEP && (p = a[f] ? f + 1 : f), this.valueRange = new Dt(i + 1, p), p;
    }
    /**
     * Parses a block value from the source
     *
     * Accepted forms are:
     * ```
     * BS
     * block
     * lines
     *
     * BS #comment
     * block
     * lines
     * ```
     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
     * are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this block
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.src, a = this.parseBlockHeader(s);
      return a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a = this.parseBlockValue(a), a;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = rn(xr(r.prototype), "setOrigRanges", this).call(this, i, s), this.header ? this.header.setOrigRange(i, s) : s;
    }
  }]), r;
}(De), zB = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n, i) {
    var s;
    return ft(this, r), s = t.call(this, n, i), s.items = null, s;
  }
  return _t(r, [{
    key: "prevNodeIsJsonLike",
    value: function() {
      var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length, s = this.items[i - 1];
      return !!s && (s.jsonLike || s.type === _e.COMMENT && this.prevNodeIsJsonLike(i - 1));
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.parseNode, a = i.src, l = i.indent, p = i.lineStart, f = a[s];
      this.items = [{
        char: f,
        offset: s
      }];
      var d = De.endOfWhiteSpace(a, s + 1);
      for (f = a[d]; f && f !== "]" && f !== "}"; ) {
        switch (f) {
          case `
`:
            {
              p = d + 1;
              var m = De.endOfWhiteSpace(a, p);
              if (a[m] === `
`) {
                var v = new Vc();
                p = v.parse({
                  src: a
                }, p), this.items.push(v);
              }
              if (d = De.endOfIndent(a, p), d <= p + l && (f = a[d], d < p + l || f !== "]" && f !== "}")) {
                var g = "Insufficient indentation in flow collection";
                this.error = new nt(this, g);
              }
            }
            break;
          case ",":
            this.items.push({
              char: f,
              offset: d
            }), d += 1;
            break;
          case "#":
            {
              var S = new vc();
              d = S.parse({
                src: a
              }, d), this.items.push(S);
            }
            break;
          case "?":
          case ":": {
            var _ = a[d + 1];
            if (_ === `
` || _ === "	" || _ === " " || _ === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
            f === ":" && this.prevNodeIsJsonLike()) {
              this.items.push({
                char: f,
                offset: d
              }), d += 1;
              break;
            }
          }
          default: {
            var x = o({
              atLineStart: !1,
              inCollection: !1,
              inFlow: !0,
              indent: -1,
              lineStart: p,
              parent: this
            }, d);
            if (!x)
              return this.valueRange = new Dt(s, d), d;
            this.items.push(x), d = De.normalizeOffset(a, x.range.end);
          }
        }
        d = De.endOfWhiteSpace(a, d), f = a[d];
      }
      return this.valueRange = new Dt(s, d + 1), f && (this.items.push({
        char: f,
        offset: d
      }), d = De.endOfWhiteSpace(a, d + 1), d = this.parseComment(d)), d;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = rn(xr(r.prototype), "setOrigRanges", this).call(this, i, s), this.items.forEach(function(o) {
        if (o instanceof De)
          s = o.setOrigRanges(i, s);
        else if (i.length === 0)
          o.origOffset = o.offset;
        else {
          for (var a = s; a < i.length && !(i[a] > o.offset); )
            ++a;
          o.origOffset = o.offset + a, s = a;
        }
      }), s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.context.src, s = this.items, o = this.range, a = this.value;
      if (a != null) return a;
      var l = s.filter(function(d) {
        return d instanceof De;
      }), p = "", f = o.start;
      return l.forEach(function(d) {
        var m = i.slice(f, d.range.start);
        f = d.range.end, p += m + String(d), p[p.length - 1] === `
` && i[f - 1] !== `
` && i[f] === `
` && (f += 1);
      }), p += i.slice(f, o.end), De.addStringTerminator(i, o.end, p);
    }
  }]), r;
}(De), qB = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "strValue",
    get: (
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      function() {
        if (!this.valueRange || !this.context) return null;
        var i = [], s = this.valueRange, o = s.start, a = s.end, l = this.context, p = l.indent, f = l.src;
        f[a - 1] !== '"' && i.push(new Ir(this, 'Missing closing "quote'));
        for (var d = "", m = o + 1; m < a - 1; ++m) {
          var v = f[m];
          if (v === `
`) {
            De.atDocumentBoundary(f, m + 1) && i.push(new nt(this, "Document boundary indicators are not allowed within string values"));
            var g = De.foldNewline(f, m, p), S = g.fold, _ = g.offset, x = g.error;
            d += S, m = _, x && i.push(new nt(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (v === "\\")
            switch (m += 1, f[m]) {
              case "0":
                d += "\0";
                break;
              case "a":
                d += "\x07";
                break;
              case "b":
                d += "\b";
                break;
              case "e":
                d += "\x1B";
                break;
              case "f":
                d += "\f";
                break;
              case "n":
                d += `
`;
                break;
              case "r":
                d += "\r";
                break;
              case "t":
                d += "	";
                break;
              case "v":
                d += "\v";
                break;
              case "N":
                d += "";
                break;
              case "_":
                d += " ";
                break;
              case "L":
                d += "\u2028";
                break;
              case "P":
                d += "\u2029";
                break;
              case " ":
                d += " ";
                break;
              case '"':
                d += '"';
                break;
              case "/":
                d += "/";
                break;
              case "\\":
                d += "\\";
                break;
              case "	":
                d += "	";
                break;
              case "x":
                d += this.parseCharCode(m + 1, 2, i), m += 2;
                break;
              case "u":
                d += this.parseCharCode(m + 1, 4, i), m += 4;
                break;
              case "U":
                d += this.parseCharCode(m + 1, 8, i), m += 8;
                break;
              case `
`:
                for (; f[m + 1] === " " || f[m + 1] === "	"; )
                  m += 1;
                break;
              default:
                i.push(new Ir(this, "Invalid escape sequence ".concat(f.substr(m - 1, 2)))), d += "\\" + f[m];
            }
          else if (v === " " || v === "	") {
            for (var y = m, w = f[m + 1]; w === " " || w === "	"; )
              m += 1, w = f[m + 1];
            w !== `
` && (d += m > y ? f.slice(y, m + 1) : v);
          } else
            d += v;
        }
        return i.length > 0 ? {
          errors: i,
          str: d
        } : d;
      }
    )
  }, {
    key: "parseCharCode",
    value: function(i, s, o) {
      var a = this.context.src, l = a.substr(i, s), p = l.length === s && /^[0-9a-fA-F]+$/.test(l), f = p ? parseInt(l, 16) : NaN;
      return isNaN(f) ? (o.push(new Ir(this, "Invalid escape sequence ".concat(a.substr(i - 2, s + 2)))), a.substr(i - 2, s + 2)) : String.fromCodePoint(f);
    }
    /**
     * Parses a "double quoted" value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.src, a = r.endOfQuote(o, s + 1);
      return this.valueRange = new Dt(s, a), a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a;
    }
  }], [{
    key: "endOfQuote",
    value: function(i, s) {
      for (var o = i[s]; o && o !== '"'; )
        s += o === "\\" ? 2 : 1, o = i[s];
      return s + 1;
    }
  }]), r;
}(De), BB = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "strValue",
    get: (
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      function() {
        if (!this.valueRange || !this.context) return null;
        var i = [], s = this.valueRange, o = s.start, a = s.end, l = this.context, p = l.indent, f = l.src;
        f[a - 1] !== "'" && i.push(new Ir(this, "Missing closing 'quote"));
        for (var d = "", m = o + 1; m < a - 1; ++m) {
          var v = f[m];
          if (v === `
`) {
            De.atDocumentBoundary(f, m + 1) && i.push(new nt(this, "Document boundary indicators are not allowed within string values"));
            var g = De.foldNewline(f, m, p), S = g.fold, _ = g.offset, x = g.error;
            d += S, m = _, x && i.push(new nt(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (v === "'")
            d += v, m += 1, f[m] !== "'" && i.push(new Ir(this, "Unescaped single quote? This should not happen."));
          else if (v === " " || v === "	") {
            for (var y = m, w = f[m + 1]; w === " " || w === "	"; )
              m += 1, w = f[m + 1];
            w !== `
` && (d += m > y ? f.slice(y, m + 1) : v);
          } else
            d += v;
        }
        return i.length > 0 ? {
          errors: i,
          str: d
        } : d;
      }
    )
    /**
     * Parses a 'single quoted' value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.src, a = r.endOfQuote(o, s + 1);
      return this.valueRange = new Dt(s, a), a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a;
    }
  }], [{
    key: "endOfQuote",
    value: function(i, s) {
      for (var o = i[s]; o; )
        if (o === "'") {
          if (i[s + 1] !== "'") break;
          o = i[s += 2];
        } else
          o = i[s += 1];
      return s + 1;
    }
  }]), r;
}(De);
function UB(e, t) {
  switch (e) {
    case _e.ALIAS:
      return new DB(e, t);
    case _e.BLOCK_FOLDED:
    case _e.BLOCK_LITERAL:
      return new FB(e, t);
    case _e.FLOW_MAP:
    case _e.FLOW_SEQ:
      return new zB(e, t);
    case _e.MAP_KEY:
    case _e.MAP_VALUE:
    case _e.SEQ_ITEM:
      return new Bw(e, t);
    case _e.COMMENT:
    case _e.PLAIN:
      return new xR(e, t);
    case _e.QUOTE_DOUBLE:
      return new qB(e, t);
    case _e.QUOTE_SINGLE:
      return new BB(e, t);
    default:
      return null;
  }
}
var VB = /* @__PURE__ */ function() {
  function e() {
    var t = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.atLineStart, s = n.inCollection, o = n.inFlow, a = n.indent, l = n.lineStart, p = n.parent;
    ft(this, e), $r(this, "parseNode", function(f, d) {
      if (De.atDocumentBoundary(t.src, d)) return null;
      var m = new e(t, f), v = m.parseProps(d), g = v.props, S = v.type, _ = v.valueStart, x = UB(S, g), y = x.parse(m, _);
      if (x.range = new Dt(d, y), y <= d && (x.error = new Error("Node#parse consumed no characters"), x.error.parseEnd = y, x.error.source = x, x.range.end = d + 1), m.nodeStartsCollection(x)) {
        !x.error && !m.atLineStart && m.parent.type === _e.DOCUMENT && (x.error = new Ir(x, "Block collection must not have preceding content here (e.g. directives-end indicator)"));
        var w = new _R(x);
        return y = w.parse(new e(m), y), w.range = new Dt(d, y), w;
      }
      return x;
    }), this.atLineStart = i ?? (r.atLineStart || !1), this.inCollection = s ?? (r.inCollection || !1), this.inFlow = o ?? (r.inFlow || !1), this.indent = a ?? r.indent, this.lineStart = l ?? r.lineStart, this.parent = p ?? (r.parent || {}), this.root = r.root, this.src = r.src;
  }
  return _t(e, [{
    key: "nodeStartsCollection",
    value: function(r) {
      var n = this.inCollection, i = this.inFlow, s = this.src;
      if (n || i) return !1;
      if (r instanceof Bw) return !0;
      var o = r.range.end;
      return s[o] === `
` || s[o - 1] === `
` ? !1 : (o = De.endOfWhiteSpace(s, o), s[o] === ":");
    }
    // Anchor and tag are before type, which determines the node implementation
    // class; hence this intermediate step.
  }, {
    key: "parseProps",
    value: function(r) {
      var n = this.inFlow, i = this.parent, s = this.src, o = [], a = !1;
      r = this.atLineStart ? De.endOfIndent(s, r) : De.endOfWhiteSpace(s, r);
      for (var l = s[r]; l === tr.ANCHOR || l === tr.COMMENT || l === tr.TAG || l === `
`; ) {
        if (l === `
`) {
          var p = r, f = void 0;
          do
            f = p + 1, p = De.endOfIndent(s, f);
          while (s[p] === `
`);
          var d = p - (f + this.indent), m = i.type === _e.SEQ_ITEM && i.context.atLineStart;
          if (s[p] !== "#" && !De.nextNodeIsIndented(s[p], d, !m)) break;
          this.atLineStart = !0, this.lineStart = f, a = !1, r = p;
        } else if (l === tr.COMMENT) {
          var v = De.endOfLine(s, r + 1);
          o.push(new Dt(r, v)), r = v;
        } else {
          var g = De.endOfIdentifier(s, r + 1);
          l === tr.TAG && s[g] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(s.slice(r + 1, g + 13)) && (g = De.endOfIdentifier(s, g + 5)), o.push(new Dt(r, g)), a = !0, r = De.endOfWhiteSpace(s, g);
        }
        l = s[r];
      }
      a && l === ":" && De.atBlank(s, r + 1, !0) && (r -= 1);
      var S = e.parseType(s, r, n);
      return {
        props: o,
        type: S,
        valueStart: r
      };
    }
    /**
     * Parses a node from the source
     * @param {ParseContext} overlay
     * @param {number} start - Index of first non-whitespace character for the node
     * @returns {?Node} - null if at a document boundary
     */
  }], [{
    key: "parseType",
    value: function(r, n, i) {
      switch (r[n]) {
        case "*":
          return _e.ALIAS;
        case ">":
          return _e.BLOCK_FOLDED;
        case "|":
          return _e.BLOCK_LITERAL;
        case "{":
          return _e.FLOW_MAP;
        case "[":
          return _e.FLOW_SEQ;
        case "?":
          return !i && De.atBlank(r, n + 1, !0) ? _e.MAP_KEY : _e.PLAIN;
        case ":":
          return !i && De.atBlank(r, n + 1, !0) ? _e.MAP_VALUE : _e.PLAIN;
        case "-":
          return !i && De.atBlank(r, n + 1, !0) ? _e.SEQ_ITEM : _e.PLAIN;
        case '"':
          return _e.QUOTE_DOUBLE;
        case "'":
          return _e.QUOTE_SINGLE;
        default:
          return _e.PLAIN;
      }
    }
  }]), e;
}();
function Uw(e) {
  var t = [];
  e.indexOf("\r") !== -1 && (e = e.replace(/\r\n?/g, function(o, a) {
    return o.length > 1 && t.push(a), `
`;
  }));
  var r = [], n = 0;
  do {
    var i = new MB(), s = new VB({
      src: e
    });
    n = i.parse(s, n), r.push(i);
  } while (n < e.length);
  return r.setOrigRanges = function() {
    if (t.length === 0) return !1;
    for (var o = 1; o < t.length; ++o)
      t[o] -= o;
    for (var a = 0, l = 0; l < r.length; ++l)
      a = r[l].setOrigRanges(t, a);
    return t.splice(0, t.length), !0;
  }, r.toString = function() {
    return r.join(`...
`);
  }, r;
}
function WB(e, t, r) {
  if (!r) return e;
  var n = r.replace(/[\s\S]^/gm, "$&".concat(t, "#"));
  return "#".concat(n, `
`).concat(t).concat(e);
}
function al(e, t, r) {
  return r ? r.indexOf(`
`) === -1 ? "".concat(e, " #").concat(r) : "".concat(e, `
`) + r.replace(/^/gm, "".concat(t || "", "#")) : e;
}
var Qr = function e() {
  ft(this, e);
};
function Jn(e, t, r) {
  if (Array.isArray(e)) return e.map(function(s, o) {
    return Jn(s, String(o), r);
  });
  if (e && typeof e.toJSON == "function") {
    var n = r && r.anchors && r.anchors.get(e);
    n && (r.onCreate = function(s) {
      n.res = s, delete r.onCreate;
    });
    var i = e.toJSON(t, r);
    return n && r.onCreate && r.onCreate(i), i;
  }
  return (!r || !r.keep) && typeof e == "bigint" ? Number(e) : e;
}
var St = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n) {
    var i;
    return ft(this, r), i = t.call(this), i.value = n, i;
  }
  return _t(r, [{
    key: "toJSON",
    value: function(i, s) {
      return s && s.keep ? this.value : Jn(this.value, i, s);
    }
  }, {
    key: "toString",
    value: function() {
      return String(this.value);
    }
  }]), r;
}(Qr);
function tO(e, t, r) {
  for (var n = r, i = t.length - 1; i >= 0; --i) {
    var s = t[i];
    if (Number.isInteger(s) && s >= 0) {
      var o = [];
      o[s] = n, n = o;
    } else {
      var a = {};
      Object.defineProperty(a, s, {
        value: n,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }), n = a;
    }
  }
  return e.createNode(n, !1);
}
var oc = function(t) {
  return t == null || hn(t) === "object" && t[Symbol.iterator]().next().done;
}, br = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n) {
    var i;
    return ft(this, r), i = t.call(this), $r(kn(i), "items", []), i.schema = n, i;
  }
  return _t(r, [{
    key: "addIn",
    value: function(i, s) {
      if (oc(i)) this.add(s);
      else {
        var o = Fu(i), a = o[0], l = o.slice(1), p = this.get(a, !0);
        if (p instanceof r) p.addIn(l, s);
        else if (p === void 0 && this.schema) this.set(a, tO(this.schema, l, s));
        else throw new Error("Expected YAML collection at ".concat(a, ". Remaining path: ").concat(l));
      }
    }
  }, {
    key: "deleteIn",
    value: function(i) {
      var s = Fu(i), o = s[0], a = s.slice(1);
      if (a.length === 0) return this.delete(o);
      var l = this.get(o, !0);
      if (l instanceof r) return l.deleteIn(a);
      throw new Error("Expected YAML collection at ".concat(o, ". Remaining path: ").concat(a));
    }
  }, {
    key: "getIn",
    value: function(i, s) {
      var o = Fu(i), a = o[0], l = o.slice(1), p = this.get(a, !0);
      return l.length === 0 ? !s && p instanceof St ? p.value : p : p instanceof r ? p.getIn(l, s) : void 0;
    }
  }, {
    key: "hasAllNullValues",
    value: function() {
      return this.items.every(function(i) {
        if (!i || i.type !== "PAIR") return !1;
        var s = i.value;
        return s == null || s instanceof St && s.value == null && !s.commentBefore && !s.comment && !s.tag;
      });
    }
  }, {
    key: "hasIn",
    value: function(i) {
      var s = Fu(i), o = s[0], a = s.slice(1);
      if (a.length === 0) return this.has(o);
      var l = this.get(o, !0);
      return l instanceof r ? l.hasIn(a) : !1;
    }
  }, {
    key: "setIn",
    value: function(i, s) {
      var o = Fu(i), a = o[0], l = o.slice(1);
      if (l.length === 0)
        this.set(a, s);
      else {
        var p = this.get(a, !0);
        if (p instanceof r) p.setIn(l, s);
        else if (p === void 0 && this.schema) this.set(a, tO(this.schema, l, s));
        else throw new Error("Expected YAML collection at ".concat(a, ". Remaining path: ").concat(l));
      }
    }
    // overridden in implementations
    /* istanbul ignore next */
  }, {
    key: "toJSON",
    value: function() {
      return null;
    }
  }, {
    key: "toString",
    value: function(i, s, o, a) {
      var l = this, p = s.blockItem, f = s.flowChars, d = s.isMap, m = s.itemIndent, v = i, g = v.indent, S = v.indentStep, _ = v.stringify, x = this.type === _e.FLOW_MAP || this.type === _e.FLOW_SEQ || i.inFlow;
      x && (m += S);
      var y = d && this.hasAllNullValues();
      i = Object.assign({}, i, {
        allNullValues: y,
        indent: m,
        inFlow: x,
        type: null
      });
      var w = !1, k = !1, A = this.items.reduce(function(fe, G, Z) {
        var K;
        G && (!w && G.spaceBefore && fe.push({
          type: "comment",
          str: ""
        }), G.commentBefore && G.commentBefore.match(/^.*$/gm).forEach(function(te) {
          fe.push({
            type: "comment",
            str: "#".concat(te)
          });
        }), G.comment && (K = G.comment), x && (!w && G.spaceBefore || G.commentBefore || G.comment || G.key && (G.key.commentBefore || G.key.comment) || G.value && (G.value.commentBefore || G.value.comment)) && (k = !0)), w = !1;
        var z = _(G, i, function() {
          return K = null;
        }, function() {
          return w = !0;
        });
        return x && !k && z.includes(`
`) && (k = !0), x && Z < l.items.length - 1 && (z += ","), z = al(z, m, K), w && (K || x) && (w = !1), fe.push({
          type: "item",
          str: z
        }), fe;
      }, []), T;
      if (A.length === 0)
        T = f.start + f.end;
      else if (x) {
        var R = f.start, I = f.end, B = A.map(function(fe) {
          return fe.str;
        });
        if (k || B.reduce(function(fe, G) {
          return fe + G.length + 2;
        }, 2) > r.maxFlowStringSingleLineLength) {
          T = R;
          var L = At(B), Y;
          try {
            for (L.s(); !(Y = L.n()).done; ) {
              var Q = Y.value;
              T += Q ? `
`.concat(S).concat(g).concat(Q) : `
`;
            }
          } catch (fe) {
            L.e(fe);
          } finally {
            L.f();
          }
          T += `
`.concat(g).concat(I);
        } else
          T = "".concat(R, " ").concat(B.join(" "), " ").concat(I);
      } else {
        var re = A.map(p);
        T = re.shift();
        var oe = At(re), ce;
        try {
          for (oe.s(); !(ce = oe.n()).done; ) {
            var pe = ce.value;
            T += pe ? `
`.concat(g).concat(pe) : `
`;
          }
        } catch (fe) {
          oe.e(fe);
        } finally {
          oe.f();
        }
      }
      return this.comment ? (T += `
` + this.comment.replace(/^/gm, "".concat(g, "#")), o && o()) : w && a && a(), T;
    }
  }]), r;
}(Qr);
$r(br, "maxFlowStringSingleLineLength", 60);
function Uf(e) {
  var t = e instanceof St ? e.value : e;
  return t && typeof t == "string" && (t = Number(t)), Number.isInteger(t) && t >= 0 ? t : null;
}
var Pi = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "add",
    value: function(i) {
      this.items.push(i);
    }
  }, {
    key: "delete",
    value: function(i) {
      var s = Uf(i);
      if (typeof s != "number") return !1;
      var o = this.items.splice(s, 1);
      return o.length > 0;
    }
  }, {
    key: "get",
    value: function(i, s) {
      var o = Uf(i);
      if (typeof o == "number") {
        var a = this.items[o];
        return !s && a instanceof St ? a.value : a;
      }
    }
  }, {
    key: "has",
    value: function(i) {
      var s = Uf(i);
      return typeof s == "number" && s < this.items.length;
    }
  }, {
    key: "set",
    value: function(i, s) {
      var o = Uf(i);
      if (typeof o != "number") throw new Error("Expected a valid index, not ".concat(i, "."));
      this.items[o] = s;
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      var o = [];
      s && s.onCreate && s.onCreate(o);
      var a = 0, l = At(this.items), p;
      try {
        for (l.s(); !(p = l.n()).done; ) {
          var f = p.value;
          o.push(Jn(f, String(a++), s));
        }
      } catch (d) {
        l.e(d);
      } finally {
        l.f();
      }
      return o;
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      return i ? rn(xr(r.prototype), "toString", this).call(this, i, {
        blockItem: function(l) {
          return l.type === "comment" ? l.str : "- ".concat(l.str);
        },
        flowChars: {
          start: "[",
          end: "]"
        },
        isMap: !1,
        itemIndent: (i.indent || "") + "  "
      }, s, o) : JSON.stringify(this);
    }
  }]), r;
}(br), HB = function(t, r, n) {
  return r === null ? "" : hn(r) !== "object" ? String(r) : t instanceof Qr && n && n.doc ? t.toString({
    anchors: /* @__PURE__ */ Object.create(null),
    doc: n.doc,
    indent: "",
    indentStep: n.indentStep,
    inFlow: !0,
    inStringifyKey: !0,
    stringify: n.stringify
  }) : JSON.stringify(r);
}, pt = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n) {
    var i, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return ft(this, r), i = t.call(this), i.key = n, i.value = s, i.type = r.Type.PAIR, i;
  }
  return _t(r, [{
    key: "commentBefore",
    get: function() {
      return this.key instanceof Qr ? this.key.commentBefore : void 0;
    },
    set: function(i) {
      if (this.key == null && (this.key = new St(null)), this.key instanceof Qr) this.key.commentBefore = i;
      else {
        var s = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
        throw new Error(s);
      }
    }
  }, {
    key: "addToJSMap",
    value: function(i, s) {
      var o = Jn(this.key, "", i);
      if (s instanceof Map) {
        var a = Jn(this.value, o, i);
        s.set(o, a);
      } else if (s instanceof Set)
        s.add(o);
      else {
        var l = HB(this.key, o, i), p = Jn(this.value, l, i);
        l in s ? Object.defineProperty(s, l, {
          value: p,
          writable: !0,
          enumerable: !0,
          configurable: !0
        }) : s[l] = p;
      }
      return s;
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      var o = s && s.mapAsMap ? /* @__PURE__ */ new Map() : {};
      return this.addToJSMap(s, o);
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      if (!i || !i.doc) return JSON.stringify(this);
      var a = i.doc.options, l = a.indent, p = a.indentSeq, f = a.simpleKeys, d = this.key, m = this.value, v = d instanceof Qr && d.comment;
      if (f) {
        if (v)
          throw new Error("With simple keys, key nodes cannot have comments");
        if (d instanceof br) {
          var g = "With simple keys, collection cannot be used as a key value";
          throw new Error(g);
        }
      }
      var S = !f && (!d || v || (d instanceof Qr ? d instanceof br || d.type === _e.BLOCK_FOLDED || d.type === _e.BLOCK_LITERAL : hn(d) === "object")), _ = i, x = _.doc, y = _.indent, w = _.indentStep, k = _.stringify;
      i = Object.assign({}, i, {
        implicitKey: !S,
        indent: y + w
      });
      var A = !1, T = k(d, i, function() {
        return v = null;
      }, function() {
        return A = !0;
      });
      if (T = al(T, i.indent, v), !S && T.length > 1024) {
        if (f) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        S = !0;
      }
      if (i.allNullValues && !f)
        return this.comment ? (T = al(T, i.indent, this.comment), s && s()) : A && !v && o && o(), i.inFlow && !S ? T : "? ".concat(T);
      T = S ? "? ".concat(T, `
`).concat(y, ":") : "".concat(T, ":"), this.comment && (T = al(T, i.indent, this.comment), s && s());
      var R = "", I = null;
      if (m instanceof Qr) {
        if (m.spaceBefore && (R = `
`), m.commentBefore) {
          var B = m.commentBefore.replace(/^/gm, "".concat(i.indent, "#"));
          R += `
`.concat(B);
        }
        I = m.comment;
      } else m && hn(m) === "object" && (m = x.schema.createNode(m, !0));
      i.implicitKey = !1, !S && !this.comment && m instanceof St && (i.indentAtStart = T.length + 1), A = !1, !p && l >= 2 && !i.inFlow && !S && m instanceof Pi && m.type !== _e.FLOW_SEQ && !m.tag && !x.anchors.getName(m) && (i.indent = i.indent.substr(2));
      var L = k(m, i, function() {
        return I = null;
      }, function() {
        return A = !0;
      }), Y = " ";
      if (R || this.comment)
        Y = "".concat(R, `
`).concat(i.indent);
      else if (!S && m instanceof br) {
        var Q = L[0] === "[" || L[0] === "{";
        (!Q || L.includes(`
`)) && (Y = `
`.concat(i.indent));
      } else L[0] === `
` && (Y = "");
      return A && !I && o && o(), al(T + Y + L, i.indent, I);
    }
  }]), r;
}(Qr);
$r(pt, "Type", {
  PAIR: "PAIR",
  MERGE_PAIR: "MERGE_PAIR"
});
var QB = function e(t, r) {
  if (t instanceof co) {
    var n = r.get(t.source);
    return n.count * n.aliasCount;
  } else if (t instanceof br) {
    var i = 0, s = At(t.items), o;
    try {
      for (s.s(); !(o = s.n()).done; ) {
        var a = o.value, l = e(a, r);
        l > i && (i = l);
      }
    } catch (d) {
      s.e(d);
    } finally {
      s.f();
    }
    return i;
  } else if (t instanceof pt) {
    var p = e(t.key, r), f = e(t.value, r);
    return Math.max(p, f);
  }
  return 1;
}, co = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n) {
    var i;
    return ft(this, r), i = t.call(this), i.source = n, i.type = _e.ALIAS, i;
  }
  return _t(r, [{
    key: "tag",
    set: function(i) {
      throw new Error("Alias nodes cannot have tags");
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      if (!s) return Jn(this.source, i, s);
      var o = s.anchors, a = s.maxAliasCount, l = o.get(this.source);
      if (!l || l.res === void 0) {
        var p = "This should not happen: Alias anchor was not resolved?";
        throw this.cstNode ? new Uc(this.cstNode, p) : new ReferenceError(p);
      }
      if (a >= 0 && (l.count += 1, l.aliasCount === 0 && (l.aliasCount = QB(this.source, o)), l.count * l.aliasCount > a)) {
        var f = "Excessive alias count indicates a resource exhaustion attack";
        throw this.cstNode ? new Uc(this.cstNode, f) : new ReferenceError(f);
      }
      return l.res;
    }
    // Only called when stringifying an alias mapping key while constructing
    // Object output.
  }, {
    key: "toString",
    value: function(i) {
      return r.stringify(this, i);
    }
  }], [{
    key: "stringify",
    value: function(i, s) {
      var o = i.range, a = i.source, l = s.anchors, p = s.doc, f = s.implicitKey, d = s.inStringifyKey, m = Object.keys(l).find(function(g) {
        return l[g] === a;
      });
      if (!m && d && (m = p.anchors.getName(a) || p.anchors.newName()), m) return "*".concat(m).concat(f ? " " : "");
      var v = p.anchors.getName(a) ? "Alias node must be after source node" : "Source node not found for alias node";
      throw new Error("".concat(v, " [").concat(o, "]"));
    }
  }]), r;
}(Qr);
$r(co, "default", !0);
function Us(e, t) {
  var r = t instanceof St ? t.value : t, n = At(e), i;
  try {
    for (n.s(); !(i = n.n()).done; ) {
      var s = i.value;
      if (s instanceof pt && (s.key === t || s.key === r || s.key && s.key.value === r))
        return s;
    }
  } catch (o) {
    n.e(o);
  } finally {
    n.f();
  }
}
var Gr = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    return ft(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "add",
    value: function(i, s) {
      i ? i instanceof pt || (i = new pt(i.key || i, i.value)) : i = new pt(i);
      var o = Us(this.items, i.key), a = this.schema && this.schema.sortMapEntries;
      if (o)
        if (s) o.value = i.value;
        else throw new Error("Key ".concat(i.key, " already set"));
      else if (a) {
        var l = this.items.findIndex(function(p) {
          return a(i, p) < 0;
        });
        l === -1 ? this.items.push(i) : this.items.splice(l, 0, i);
      } else
        this.items.push(i);
    }
  }, {
    key: "delete",
    value: function(i) {
      var s = Us(this.items, i);
      if (!s) return !1;
      var o = this.items.splice(this.items.indexOf(s), 1);
      return o.length > 0;
    }
  }, {
    key: "get",
    value: function(i, s) {
      var o = Us(this.items, i), a = o && o.value;
      return !s && a instanceof St ? a.value : a;
    }
  }, {
    key: "has",
    value: function(i) {
      return !!Us(this.items, i);
    }
  }, {
    key: "set",
    value: function(i, s) {
      this.add(new pt(i, s), !0);
    }
    /**
     * @param {*} arg ignored
     * @param {*} ctx Conversion context, originally set in Document#toJSON()
     * @param {Class} Type If set, forces the returned collection type
     * @returns {*} Instance of Type, Map, or Object
     */
  }, {
    key: "toJSON",
    value: function(i, s, o) {
      var a = o ? new o() : s && s.mapAsMap ? /* @__PURE__ */ new Map() : {};
      s && s.onCreate && s.onCreate(a);
      var l = At(this.items), p;
      try {
        for (l.s(); !(p = l.n()).done; ) {
          var f = p.value;
          f.addToJSMap(s, a);
        }
      } catch (d) {
        l.e(d);
      } finally {
        l.f();
      }
      return a;
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      if (!i) return JSON.stringify(this);
      var a = At(this.items), l;
      try {
        for (a.s(); !(l = a.n()).done; ) {
          var p = l.value;
          if (!(p instanceof pt)) throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(p), " instead"));
        }
      } catch (f) {
        a.e(f);
      } finally {
        a.f();
      }
      return rn(xr(r.prototype), "toString", this).call(this, i, {
        blockItem: function(d) {
          return d.str;
        },
        flowChars: {
          start: "{",
          end: "}"
        },
        isMap: !0,
        itemIndent: i.indent || ""
      }, s, o);
    }
  }]), r;
}(br), ER = "<<", OR = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n) {
    var i;
    if (ft(this, r), n instanceof pt) {
      var s = n.value;
      s instanceof Pi || (s = new Pi(), s.items.push(n.value), s.range = n.value.range), i = t.call(this, n.key, s), i.range = n.range;
    } else
      i = t.call(this, new St(ER), new Pi());
    return i.type = pt.Type.MERGE_PAIR, vR(i);
  }
  return _t(r, [{
    key: "addToJSMap",
    value: function(i, s) {
      var o = At(this.value.items), a;
      try {
        for (o.s(); !(a = o.n()).done; ) {
          var l = a.value.source;
          if (!(l instanceof Gr)) throw new Error("Merge sources must be maps");
          var p = l.toJSON(null, i, Map), f = At(p), d;
          try {
            for (f.s(); !(d = f.n()).done; ) {
              var m = lp(d.value, 2), v = m[0], g = m[1];
              s instanceof Map ? s.has(v) || s.set(v, g) : s instanceof Set ? s.add(v) : Object.prototype.hasOwnProperty.call(s, v) || Object.defineProperty(s, v, {
                value: g,
                writable: !0,
                enumerable: !0,
                configurable: !0
              });
            }
          } catch (S) {
            f.e(S);
          } finally {
            f.f();
          }
        }
      } catch (S) {
        o.e(S);
      } finally {
        o.f();
      }
      return s;
    }
  }, {
    key: "toString",
    value: function(i, s) {
      var o = this.value;
      if (o.items.length > 1) return rn(xr(r.prototype), "toString", this).call(this, i, s);
      this.value = o.items[0];
      var a = rn(xr(r.prototype), "toString", this).call(this, i, s);
      return this.value = o, a;
    }
  }]), r;
}(pt), bc = {
  defaultType: _e.BLOCK_LITERAL,
  lineWidth: 76
}, ro = {
  trueStr: "true",
  falseStr: "false"
}, Zo = {
  asBigInt: !1
}, Al = {
  nullStr: "null"
}, po = {
  defaultType: _e.PLAIN,
  doubleQuoted: {
    jsonEncoding: !1,
    minMultiLineLength: 40
  },
  fold: {
    lineWidth: 80,
    minContentWidth: 20
  }
};
function Vw(e, t, r) {
  var n = At(t), i;
  try {
    for (n.s(); !(i = n.n()).done; ) {
      var s = i.value, o = s.format, a = s.test, l = s.resolve;
      if (a) {
        var p = e.match(a);
        if (p) {
          var f = l.apply(null, p);
          return f instanceof St || (f = new St(f)), o && (f.format = o), f;
        }
      }
    }
  } catch (d) {
    n.e(d);
  } finally {
    n.f();
  }
  return r && (e = r(e)), new St(e);
}
var kR = "flow", ab = "block", wh = "quoted", rO = function(t, r) {
  for (var n = t[r + 1]; n === " " || n === "	"; ) {
    do
      n = t[r += 1];
    while (n && n !== `
`);
    n = t[r + 1];
  }
  return r;
};
function Wm(e, t, r, n) {
  var i = n.indentAtStart, s = n.lineWidth, o = s === void 0 ? 80 : s, a = n.minContentWidth, l = a === void 0 ? 20 : a, p = n.onFold, f = n.onOverflow;
  if (!o || o < 0) return e;
  var d = Math.max(1 + l, 1 + o - t.length);
  if (e.length <= d) return e;
  var m = [], v = {}, g = o - t.length;
  typeof i == "number" && (i > o - Math.max(2, l) ? m.push(0) : g = o - i);
  var S = void 0, _ = void 0, x = !1, y = -1, w = -1, k = -1;
  r === ab && (y = rO(e, y), y !== -1 && (g = y + d));
  for (var A; A = e[y += 1]; ) {
    if (r === wh && A === "\\") {
      switch (w = y, e[y + 1]) {
        case "x":
          y += 3;
          break;
        case "u":
          y += 5;
          break;
        case "U":
          y += 9;
          break;
        default:
          y += 1;
      }
      k = y;
    }
    if (A === `
`)
      r === ab && (y = rO(e, y)), g = y + d, S = void 0;
    else {
      if (A === " " && _ && _ !== " " && _ !== `
` && _ !== "	") {
        var T = e[y + 1];
        T && T !== " " && T !== `
` && T !== "	" && (S = y);
      }
      if (y >= g)
        if (S)
          m.push(S), g = S + d, S = void 0;
        else if (r === wh) {
          for (; _ === " " || _ === "	"; )
            _ = A, A = e[y += 1], x = !0;
          var R = y > k + 1 ? y - 2 : w - 1;
          if (v[R]) return e;
          m.push(R), v[R] = !0, g = R + d, S = void 0;
        } else
          x = !0;
    }
    _ = A;
  }
  if (x && f && f(), m.length === 0) return e;
  p && p();
  for (var I = e.slice(0, m[0]), B = 0; B < m.length; ++B) {
    var L = m[B], Y = m[B + 1] || e.length;
    L === 0 ? I = `
`.concat(t).concat(e.slice(0, Y)) : (r === wh && v[L] && (I += "".concat(e[L], "\\")), I += `
`.concat(t).concat(e.slice(L + 1, Y)));
  }
  return I;
}
var Ww = function(t) {
  var r = t.indentAtStart;
  return r ? Object.assign({
    indentAtStart: r
  }, po.fold) : po.fold;
}, Hm = function(t) {
  return /^(%|---|\.\.\.)/m.test(t);
};
function YB(e, t, r) {
  if (!t || t < 0) return !1;
  var n = t - r, i = e.length;
  if (i <= n) return !1;
  for (var s = 0, o = 0; s < i; ++s)
    if (e[s] === `
`) {
      if (s - o > n) return !0;
      if (o = s + 1, i - o <= n) return !1;
    }
  return !0;
}
function Qs(e, t) {
  var r = t.implicitKey, n = po.doubleQuoted, i = n.jsonEncoding, s = n.minMultiLineLength, o = JSON.stringify(e);
  if (i) return o;
  for (var a = t.indent || (Hm(e) ? "  " : ""), l = "", p = 0, f = 0, d = o[f]; d; d = o[++f])
    if (d === " " && o[f + 1] === "\\" && o[f + 2] === "n" && (l += o.slice(p, f) + "\\ ", f += 1, p = f, d = "\\"), d === "\\") switch (o[f + 1]) {
      case "u":
        {
          l += o.slice(p, f);
          var m = o.substr(f + 2, 4);
          switch (m) {
            case "0000":
              l += "\\0";
              break;
            case "0007":
              l += "\\a";
              break;
            case "000b":
              l += "\\v";
              break;
            case "001b":
              l += "\\e";
              break;
            case "0085":
              l += "\\N";
              break;
            case "00a0":
              l += "\\_";
              break;
            case "2028":
              l += "\\L";
              break;
            case "2029":
              l += "\\P";
              break;
            default:
              m.substr(0, 2) === "00" ? l += "\\x" + m.substr(2) : l += o.substr(f, 6);
          }
          f += 5, p = f + 1;
        }
        break;
      case "n":
        if (r || o[f + 2] === '"' || o.length < s)
          f += 1;
        else {
          for (l += o.slice(p, f) + `

`; o[f + 2] === "\\" && o[f + 3] === "n" && o[f + 4] !== '"'; )
            l += `
`, f += 2;
          l += a, o[f + 2] === " " && (l += "\\"), f += 1, p = f + 1;
        }
        break;
      default:
        f += 1;
    }
  return l = p ? l + o.slice(p) : o, r ? l : Wm(l, a, wh, Ww(t));
}
function AR(e, t) {
  if (t.implicitKey) {
    if (/\n/.test(e)) return Qs(e, t);
  } else if (/[ \t]\n|\n[ \t]/.test(e)) return Qs(e, t);
  var r = t.indent || (Hm(e) ? "  " : ""), n = "'" + e.replace(/'/g, "''").replace(/\n+/g, `$&
`.concat(r)) + "'";
  return t.implicitKey ? n : Wm(n, r, kR, Ww(t));
}
function Sh(e, t, r, n) {
  var i = e.comment, s = e.type, o = e.value;
  if (/\n[\t ]+$/.test(o) || /^\s*$/.test(o))
    return Qs(o, t);
  var a = t.indent || (t.forceBlockIndent || Hm(o) ? "  " : ""), l = a ? "2" : "1", p = s === _e.BLOCK_FOLDED ? !1 : s === _e.BLOCK_LITERAL ? !0 : !YB(o, po.fold.lineWidth, a.length), f = p ? "|" : ">";
  if (!o) return f + `
`;
  var d = "", m = "";
  if (o = o.replace(/[\n\t ]*$/, function(g) {
    var S = g.indexOf(`
`);
    return S === -1 ? f += "-" : (o === g || S !== g.length - 1) && (f += "+", n && n()), m = g.replace(/\n$/, ""), "";
  }).replace(/^[\n ]*/, function(g) {
    g.indexOf(" ") !== -1 && (f += l);
    var S = g.match(/ +$/);
    return S ? (d = g.slice(0, -S[0].length), S[0]) : (d = g, "");
  }), m && (m = m.replace(/\n+(?!\n|$)/g, "$&".concat(a))), d && (d = d.replace(/\n+/g, "$&".concat(a))), i && (f += " #" + i.replace(/ ?[\r\n]+/g, " "), r && r()), !o) return "".concat(f).concat(l, `
`).concat(a).concat(m);
  if (p)
    return o = o.replace(/\n+/g, "$&".concat(a)), "".concat(f, `
`).concat(a).concat(d).concat(o).concat(m);
  o = o.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(a));
  var v = Wm("".concat(d).concat(o).concat(m), a, ab, po.fold);
  return "".concat(f, `
`).concat(a).concat(v);
}
function GB(e, t, r, n) {
  var i = e.comment, s = e.type, o = e.value, a = t.actualString, l = t.implicitKey, p = t.indent, f = t.inFlow;
  if (l && /[\n[\]{},]/.test(o) || f && /[[\]{},]/.test(o))
    return Qs(o, t);
  if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
    return l || f || o.indexOf(`
`) === -1 ? o.indexOf('"') !== -1 && o.indexOf("'") === -1 ? AR(o, t) : Qs(o, t) : Sh(e, t, r, n);
  if (!l && !f && s !== _e.PLAIN && o.indexOf(`
`) !== -1)
    return Sh(e, t, r, n);
  if (p === "" && Hm(o))
    return t.forceBlockIndent = !0, Sh(e, t, r, n);
  var d = o.replace(/\n+/g, `$&
`.concat(p));
  if (a) {
    var m = t.doc.schema.tags, v = Vw(d, m, m.scalarFallback).value;
    if (typeof v != "string") return Qs(o, t);
  }
  var g = l ? d : Wm(d, p, kR, Ww(t));
  return i && !f && (g.indexOf(`
`) !== -1 || i.indexOf(`
`) !== -1) ? (r && r(), WB(g, p, i)) : g;
}
function Hw(e, t, r, n) {
  var i = po.defaultType, s = t.implicitKey, o = t.inFlow, a = e, l = a.type, p = a.value;
  typeof p != "string" && (p = String(p), e = Object.assign({}, e, {
    value: p
  }));
  var f = function(v) {
    switch (v) {
      case _e.BLOCK_FOLDED:
      case _e.BLOCK_LITERAL:
        return Sh(e, t, r, n);
      case _e.QUOTE_DOUBLE:
        return Qs(p, t);
      case _e.QUOTE_SINGLE:
        return AR(p, t);
      case _e.PLAIN:
        return GB(e, t, r, n);
      default:
        return null;
    }
  };
  (l !== _e.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(p) || (s || o) && (l === _e.BLOCK_FOLDED || l === _e.BLOCK_LITERAL)) && (l = _e.QUOTE_DOUBLE);
  var d = f(l);
  if (d === null && (d = f(i), d === null))
    throw new Error("Unsupported default string type ".concat(i));
  return d;
}
function no(e) {
  var t = e.format, r = e.minFractionDigits, n = e.tag, i = e.value;
  if (typeof i == "bigint") return String(i);
  if (!isFinite(i)) return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  var s = JSON.stringify(i);
  if (!t && r && (!n || n === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
    var o = s.indexOf(".");
    o < 0 && (o = s.length, s += ".");
    for (var a = r - (s.length - o - 1); a-- > 0; )
      s += "0";
  }
  return s;
}
function PR(e, t) {
  var r, n;
  switch (t.type) {
    case _e.FLOW_MAP:
      r = "}", n = "flow map";
      break;
    case _e.FLOW_SEQ:
      r = "]", n = "flow sequence";
      break;
    default:
      e.push(new nt(t, "Not a flow collection!?"));
      return;
  }
  for (var i, s = t.items.length - 1; s >= 0; --s) {
    var o = t.items[s];
    if (!o || o.type !== _e.COMMENT) {
      i = o;
      break;
    }
  }
  if (i && i.char !== r) {
    var a = "Expected ".concat(n, " to end with ").concat(r), l;
    typeof i.offset == "number" ? (l = new nt(t, a), l.offset = i.offset + 1) : (l = new nt(i, a), i.range && i.range.end && (l.offset = i.range.end - i.range.start)), e.push(l);
  }
}
function CR(e, t) {
  var r = t.context.src[t.range.start - 1];
  if (r !== `
` && r !== "	" && r !== " ") {
    var n = "Comments must be separated from other tokens by white space characters";
    e.push(new nt(t, n));
  }
}
function TR(e, t) {
  var r = String(t), n = r.substr(0, 8) + "..." + r.substr(-8);
  return new nt(e, 'The "'.concat(n, '" key is too long'));
}
function $R(e, t) {
  var r = At(t), n;
  try {
    for (r.s(); !(n = r.n()).done; ) {
      var i = n.value, s = i.afterKey, o = i.before, a = i.comment, l = e.items[o];
      l ? (s && l.value && (l = l.value), a === void 0 ? (s || !l.commentBefore) && (l.spaceBefore = !0) : l.commentBefore ? l.commentBefore += `
` + a : l.commentBefore = a) : a !== void 0 && (e.comment ? e.comment += `
` + a : e.comment = a);
    }
  } catch (p) {
    r.e(p);
  } finally {
    r.f();
  }
}
function up(e, t) {
  var r = t.strValue;
  return r ? typeof r == "string" ? r : (r.errors.forEach(function(n) {
    n.source || (n.source = t), e.errors.push(n);
  }), r.str) : "";
}
function KB(e, t) {
  var r = t.tag, n = r.handle, i = r.suffix, s = e.tagPrefixes.find(function(l) {
    return l.handle === n;
  });
  if (!s) {
    var o = e.getDefaults().tagPrefixes;
    if (o && (s = o.find(function(l) {
      return l.handle === n;
    })), !s) throw new nt(t, "The ".concat(n, " tag handle is non-default and was not declared."));
  }
  if (!i) throw new nt(t, "The ".concat(n, " tag has no suffix."));
  if (n === "!" && (e.version || e.options.version) === "1.0") {
    if (i[0] === "^")
      return e.warnings.push(new Bl(t, "YAML 1.0 ^ tag expansion is not supported")), i;
    if (/[:/]/.test(i)) {
      var a = i.match(/^([a-z0-9-]+)\/(.*)/i);
      return a ? "tag:".concat(a[1], ".yaml.org,2002:").concat(a[2]) : "tag:".concat(i);
    }
  }
  return s.prefix + decodeURIComponent(i);
}
function XB(e, t) {
  var r = t.tag, n = t.type, i = !1;
  if (r) {
    var s = r.handle, o = r.suffix, a = r.verbatim;
    if (a) {
      if (a !== "!" && a !== "!!") return a;
      var l = "Verbatim tags aren't resolved, so ".concat(a, " is invalid.");
      e.errors.push(new nt(t, l));
    } else if (s === "!" && !o)
      i = !0;
    else
      try {
        return KB(e, t);
      } catch (p) {
        e.errors.push(p);
      }
  }
  switch (n) {
    case _e.BLOCK_FOLDED:
    case _e.BLOCK_LITERAL:
    case _e.QUOTE_DOUBLE:
    case _e.QUOTE_SINGLE:
      return Lo.STR;
    case _e.FLOW_MAP:
    case _e.MAP:
      return Lo.MAP;
    case _e.FLOW_SEQ:
    case _e.SEQ:
      return Lo.SEQ;
    case _e.PLAIN:
      return i ? Lo.STR : null;
    default:
      return null;
  }
}
function nO(e, t, r) {
  var n = e.schema.tags, i = [], s = At(n), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var a = o.value;
      if (a.tag === r)
        if (a.test) i.push(a);
        else {
          var l = a.resolve(e, t);
          return l instanceof br ? l : new St(l);
        }
    }
  } catch (f) {
    s.e(f);
  } finally {
    s.f();
  }
  var p = up(e, t);
  return typeof p == "string" && i.length > 0 ? Vw(p, i, n.scalarFallback) : null;
}
function JB(e) {
  var t = e.type;
  switch (t) {
    case _e.FLOW_MAP:
    case _e.MAP:
      return Lo.MAP;
    case _e.FLOW_SEQ:
    case _e.SEQ:
      return Lo.SEQ;
    default:
      return Lo.STR;
  }
}
function ZB(e, t, r) {
  try {
    var n = nO(e, t, r);
    if (n)
      return r && t.tag && (n.tag = r), n;
  } catch (l) {
    return l.source || (l.source = t), e.errors.push(l), null;
  }
  try {
    var i = JB(t);
    if (!i) throw new Error("The tag ".concat(r, " is unavailable"));
    var s = "The tag ".concat(r, " is unavailable, falling back to ").concat(i);
    e.warnings.push(new Bl(t, s));
    var o = nO(e, t, i);
    return o.tag = r, o;
  } catch (l) {
    var a = new Uc(t, l.message);
    return a.stack = l.stack, e.errors.push(a), null;
  }
}
var e3 = function(t) {
  if (!t) return !1;
  var r = t.type;
  return r === _e.MAP_KEY || r === _e.MAP_VALUE || r === _e.SEQ_ITEM;
};
function t3(e, t) {
  var r = {
    before: [],
    after: []
  }, n = !1, i = !1, s = e3(t.context.parent) ? t.context.parent.props.concat(t.props) : t.props, o = At(s), a;
  try {
    for (o.s(); !(a = o.n()).done; ) {
      var l = a.value, p = l.start, f = l.end;
      switch (t.context.src[p]) {
        case tr.COMMENT: {
          if (!t.commentHasRequiredWhitespace(p)) {
            var d = "Comments must be separated from other tokens by white space characters";
            e.push(new nt(t, d));
          }
          var m = t.header, v = t.valueRange, g = v && (p > v.start || m && p > m.start) ? r.after : r.before;
          g.push(t.context.src.slice(p + 1, f));
          break;
        }
        case tr.ANCHOR:
          if (n) {
            var S = "A node can have at most one anchor";
            e.push(new nt(t, S));
          }
          n = !0;
          break;
        case tr.TAG:
          if (i) {
            var _ = "A node can have at most one tag";
            e.push(new nt(t, _));
          }
          i = !0;
          break;
      }
    }
  } catch (x) {
    o.e(x);
  } finally {
    o.f();
  }
  return {
    comments: r,
    hasAnchor: n,
    hasTag: i
  };
}
function r3(e, t) {
  var r = e.anchors, n = e.errors, i = e.schema;
  if (t.type === _e.ALIAS) {
    var s = t.rawValue, o = r.getNode(s);
    if (!o) {
      var a = "Aliased anchor not found: ".concat(s);
      return n.push(new Uc(t, a)), null;
    }
    var l = new co(o);
    return r._cstAliases.push(l), l;
  }
  var p = XB(e, t);
  if (p) return ZB(e, t, p);
  if (t.type !== _e.PLAIN) {
    var f = "Failed to resolve ".concat(t.type, " node here");
    return n.push(new Ir(t, f)), null;
  }
  try {
    var d = up(e, t);
    return Vw(d, i.tags, i.tags.scalarFallback);
  } catch (m) {
    return m.source || (m.source = t), n.push(m), null;
  }
}
function Yo(e, t) {
  if (!t) return null;
  t.error && e.errors.push(t.error);
  var r = t3(e.errors, t), n = r.comments, i = r.hasAnchor, s = r.hasTag;
  if (i) {
    var o = e.anchors, a = t.anchor, l = o.getNode(a);
    l && (o.map[o.newName(a)] = l), o.map[a] = t;
  }
  if (t.type === _e.ALIAS && (i || s)) {
    var p = "An alias node must not specify any properties";
    e.errors.push(new nt(t, p));
  }
  var f = r3(e, t);
  if (f) {
    f.range = [t.range.start, t.range.end], e.options.keepCstNodes && (f.cstNode = t), e.options.keepNodeTypes && (f.type = t.type);
    var d = n.before.join(`
`);
    d && (f.commentBefore = f.commentBefore ? "".concat(f.commentBefore, `
`).concat(d) : d);
    var m = n.after.join(`
`);
    m && (f.comment = f.comment ? "".concat(f.comment, `
`).concat(m) : m);
  }
  return t.resolved = f;
}
function RR(e, t) {
  if (t.type !== _e.MAP && t.type !== _e.FLOW_MAP) {
    var r = "A ".concat(t.type, " node cannot be resolved as a mapping");
    return e.errors.push(new Ir(t, r)), null;
  }
  var n = t.type === _e.FLOW_MAP ? s3(e, t) : o3(e, t), i = n.comments, s = n.items, o = new Gr();
  o.items = s, $R(o, i);
  for (var a = !1, l = 0; l < s.length; ++l) {
    var p = s[l].key;
    if (p instanceof br && (a = !0), e.schema.merge && p && p.value === ER) {
      s[l] = new OR(s[l]);
      var f = s[l].value.items, d = null;
      f.some(function(_) {
        if (_ instanceof co) {
          var x = _.source.type;
          return x === _e.MAP || x === _e.FLOW_MAP ? !1 : d = "Merge nodes aliases can only point to maps";
        }
        return d = "Merge nodes can only have Alias nodes as values";
      }), d && e.errors.push(new nt(t, d));
    } else
      for (var m = l + 1; m < s.length; ++m) {
        var v = s[m].key;
        if (p === v || p && v && Object.prototype.hasOwnProperty.call(p, "value") && p.value === v.value) {
          var g = 'Map keys must be unique; "'.concat(p, '" is repeated');
          e.errors.push(new nt(t, g));
          break;
        }
      }
  }
  if (a && !e.options.mapAsMap) {
    var S = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    e.warnings.push(new Bl(t, S));
  }
  return t.resolved = o, o;
}
var n3 = function(t) {
  var r = t.context, n = r.lineStart, i = r.node, s = r.src, o = t.props;
  if (o.length === 0) return !1;
  var a = o[0].start;
  if (i && a > i.valueRange.start || s[a] !== tr.COMMENT) return !1;
  for (var l = n; l < a; ++l)
    if (s[l] === `
`) return !1;
  return !0;
};
function i3(e, t) {
  if (n3(e)) {
    var r = e.getPropValue(0, tr.COMMENT, !0), n = !1, i = t.value.commentBefore;
    if (i && i.startsWith(r))
      t.value.commentBefore = i.substr(r.length + 1), n = !0;
    else {
      var s = t.value.comment;
      !e.node && s && s.startsWith(r) && (t.value.comment = s.substr(r.length + 1), n = !0);
    }
    n && (t.comment = r);
  }
}
function o3(e, t) {
  for (var r = [], n = [], i = void 0, s = null, o = 0; o < t.items.length; ++o) {
    var a = t.items[o];
    switch (a.type) {
      case _e.BLANK_LINE:
        r.push({
          afterKey: !!i,
          before: n.length
        });
        break;
      case _e.COMMENT:
        r.push({
          afterKey: !!i,
          before: n.length,
          comment: a.comment
        });
        break;
      case _e.MAP_KEY:
        i !== void 0 && n.push(new pt(i)), a.error && e.errors.push(a.error), i = Yo(e, a.node), s = null;
        break;
      case _e.MAP_VALUE:
        {
          if (i === void 0 && (i = null), a.error && e.errors.push(a.error), !a.context.atLineStart && a.node && a.node.type === _e.MAP && !a.node.context.atLineStart) {
            var l = "Nested mappings are not allowed in compact mappings";
            e.errors.push(new nt(a.node, l));
          }
          var p = a.node;
          if (!p && a.props.length > 0) {
            p = new xR(_e.PLAIN, []), p.context = {
              parent: a,
              src: a.context.src
            };
            var f = a.range.start + 1;
            if (p.range = {
              start: f,
              end: f
            }, p.valueRange = {
              start: f,
              end: f
            }, typeof a.range.origStart == "number") {
              var d = a.range.origStart + 1;
              p.range.origStart = p.range.origEnd = d, p.valueRange.origStart = p.valueRange.origEnd = d;
            }
          }
          var m = new pt(i, Yo(e, p));
          i3(a, m), n.push(m), i && typeof s == "number" && a.range.start > s + 1024 && e.errors.push(TR(t, i)), i = void 0, s = null;
        }
        break;
      default:
        i !== void 0 && n.push(new pt(i)), i = Yo(e, a), s = a.range.start, a.error && e.errors.push(a.error);
        e: for (var v = o + 1; ; ++v) {
          var g = t.items[v];
          switch (g && g.type) {
            case _e.BLANK_LINE:
            case _e.COMMENT:
              continue e;
            case _e.MAP_VALUE:
              break e;
            default: {
              var S = "Implicit map keys need to be followed by map values";
              e.errors.push(new nt(a, S));
              break e;
            }
          }
        }
        if (a.valueRangeContainsNewline) {
          var _ = "Implicit map keys need to be on a single line";
          e.errors.push(new nt(a, _));
        }
    }
  }
  return i !== void 0 && n.push(new pt(i)), {
    comments: r,
    items: n
  };
}
function s3(e, t) {
  for (var r = [], n = [], i = void 0, s = !1, o = "{", a = 0; a < t.items.length; ++a) {
    var l = t.items[a];
    if (typeof l.char == "string") {
      var p = l.char, f = l.offset;
      if (p === "?" && i === void 0 && !s) {
        s = !0, o = ":";
        continue;
      }
      if (p === ":") {
        if (i === void 0 && (i = null), o === ":") {
          o = ",";
          continue;
        }
      } else if (s && (i === void 0 && p !== "," && (i = null), s = !1), i !== void 0 && (n.push(new pt(i)), i = void 0, p === ",")) {
        o = ":";
        continue;
      }
      if (p === "}") {
        if (a === t.items.length - 1) continue;
      } else if (p === o) {
        o = ":";
        continue;
      }
      var d = "Flow map contains an unexpected ".concat(p), m = new Ir(t, d);
      m.offset = f, e.errors.push(m);
    } else l.type === _e.BLANK_LINE ? r.push({
      afterKey: !!i,
      before: n.length
    }) : l.type === _e.COMMENT ? (CR(e.errors, l), r.push({
      afterKey: !!i,
      before: n.length,
      comment: l.comment
    })) : i === void 0 ? (o === "," && e.errors.push(new nt(l, "Separator , missing in flow map")), i = Yo(e, l)) : (o !== "," && e.errors.push(new nt(l, "Indicator : missing in flow map entry")), n.push(new pt(i, Yo(e, l))), i = void 0, s = !1);
  }
  return PR(e.errors, t), i !== void 0 && n.push(new pt(i)), {
    comments: r,
    items: n
  };
}
function IR(e, t) {
  if (t.type !== _e.SEQ && t.type !== _e.FLOW_SEQ) {
    var r = "A ".concat(t.type, " node cannot be resolved as a sequence");
    return e.errors.push(new Ir(t, r)), null;
  }
  var n = t.type === _e.FLOW_SEQ ? l3(e, t) : a3(e, t), i = n.comments, s = n.items, o = new Pi();
  if (o.items = s, $R(o, i), !e.options.mapAsMap && s.some(function(l) {
    return l instanceof pt && l.key instanceof br;
  })) {
    var a = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    e.warnings.push(new Bl(t, a));
  }
  return t.resolved = o, o;
}
function a3(e, t) {
  for (var r = [], n = [], i = 0; i < t.items.length; ++i) {
    var s = t.items[i];
    switch (s.type) {
      case _e.BLANK_LINE:
        r.push({
          before: n.length
        });
        break;
      case _e.COMMENT:
        r.push({
          comment: s.comment,
          before: n.length
        });
        break;
      case _e.SEQ_ITEM:
        if (s.error && e.errors.push(s.error), n.push(Yo(e, s.node)), s.hasProps) {
          var o = "Sequence items cannot have tags or anchors before the - indicator";
          e.errors.push(new nt(s, o));
        }
        break;
      default:
        s.error && e.errors.push(s.error), e.errors.push(new Ir(s, "Unexpected ".concat(s.type, " node in sequence")));
    }
  }
  return {
    comments: r,
    items: n
  };
}
function l3(e, t) {
  for (var r = [], n = [], i = !1, s = void 0, o = null, a = "[", l = null, p = 0; p < t.items.length; ++p) {
    var f = t.items[p];
    if (typeof f.char == "string") {
      var d = f.char, m = f.offset;
      if (d !== ":" && (i || s !== void 0) && (i && s === void 0 && (s = a ? n.pop() : null), n.push(new pt(s)), i = !1, s = void 0, o = null), d === a)
        a = null;
      else if (!a && d === "?")
        i = !0;
      else if (a !== "[" && d === ":" && s === void 0) {
        if (a === ",") {
          if (s = n.pop(), s instanceof pt) {
            var v = "Chaining flow sequence pairs is invalid", g = new nt(t, v);
            g.offset = m, e.errors.push(g);
          }
          if (!i && typeof o == "number") {
            var S = f.range ? f.range.start : f.offset;
            S > o + 1024 && e.errors.push(TR(t, s));
            for (var _ = l.context.src, x = o; x < S; ++x)
              if (_[x] === `
`) {
                var y = "Implicit keys of flow sequence pairs need to be on a single line";
                e.errors.push(new nt(l, y));
                break;
              }
          }
        } else
          s = null;
        o = null, i = !1, a = null;
      } else if (a === "[" || d !== "]" || p < t.items.length - 1) {
        var w = "Flow sequence contains an unexpected ".concat(d), k = new Ir(t, w);
        k.offset = m, e.errors.push(k);
      }
    } else if (f.type === _e.BLANK_LINE)
      r.push({
        before: n.length
      });
    else if (f.type === _e.COMMENT)
      CR(e.errors, f), r.push({
        comment: f.comment,
        before: n.length
      });
    else {
      if (a) {
        var A = "Expected a ".concat(a, " in flow sequence");
        e.errors.push(new nt(f, A));
      }
      var T = Yo(e, f);
      s === void 0 ? (n.push(T), l = f) : (n.push(new pt(s, T)), s = void 0), o = f.range.start, a = ",";
    }
  }
  return PR(e.errors, t), s !== void 0 && n.push(new pt(s)), {
    comments: r,
    items: n
  };
}
var jR = {
  identify: function(t) {
    return t instanceof Uint8Array;
  },
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: function(t, r) {
    var n = up(t, r);
    if (typeof Buffer == "function")
      return Buffer.from(n, "base64");
    if (typeof atob == "function") {
      for (var i = atob(n.replace(/[\n\r]/g, "")), s = new Uint8Array(i.length), o = 0; o < i.length; ++o)
        s[o] = i.charCodeAt(o);
      return s;
    } else {
      var a = "This environment does not support reading binary tags; either Buffer or atob is required";
      return t.errors.push(new Uc(r, a)), null;
    }
  },
  options: bc,
  stringify: function(t, r, n, i) {
    var s = t.comment, o = t.type, a = t.value, l;
    if (typeof Buffer == "function")
      l = a instanceof Buffer ? a.toString("base64") : Buffer.from(a.buffer).toString("base64");
    else if (typeof btoa == "function") {
      for (var p = "", f = 0; f < a.length; ++f)
        p += String.fromCharCode(a[f]);
      l = btoa(p);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (o || (o = bc.defaultType), o === _e.QUOTE_DOUBLE)
      a = l;
    else {
      for (var d = bc.lineWidth, m = Math.ceil(l.length / d), v = new Array(m), g = 0, S = 0; g < m; ++g, S += d)
        v[g] = l.substr(S, d);
      a = v.join(o === _e.BLOCK_LITERAL ? `
` : " ");
    }
    return Hw({
      comment: s,
      type: o,
      value: a
    }, r, n, i);
  }
};
function NR(e, t) {
  for (var r = IR(e, t), n = 0; n < r.items.length; ++n) {
    var i = r.items[n];
    if (!(i instanceof pt)) {
      if (i instanceof Gr) {
        if (i.items.length > 1) {
          var s = "Each pair must have its own sequence indicator";
          throw new nt(t, s);
        }
        var o = i.items[0] || new pt();
        i.commentBefore && (o.commentBefore = o.commentBefore ? "".concat(i.commentBefore, `
`).concat(o.commentBefore) : i.commentBefore), i.comment && (o.comment = o.comment ? "".concat(i.comment, `
`).concat(o.comment) : i.comment), i = o;
      }
      r.items[n] = i instanceof pt ? i : new pt(i);
    }
  }
  return r;
}
function LR(e, t, r) {
  var n = new Pi(e);
  n.tag = "tag:yaml.org,2002:pairs";
  var i = At(t), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value, a = void 0, l = void 0;
      if (Array.isArray(o))
        if (o.length === 2)
          a = o[0], l = o[1];
        else throw new TypeError("Expected [key, value] tuple: ".concat(o));
      else if (o && o instanceof Object) {
        var p = Object.keys(o);
        if (p.length === 1)
          a = p[0], l = o[a];
        else throw new TypeError("Expected { key: value } tuple: ".concat(o));
      } else
        a = o;
      var f = e.createPair(a, l, r);
      n.items.push(f);
    }
  } catch (d) {
    i.e(d);
  } finally {
    i.f();
  }
  return n;
}
var MR = {
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: NR,
  createNode: LR
}, Qm = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    var n;
    return ft(this, r), n = t.call(this), $r(kn(n), "add", Gr.prototype.add.bind(kn(n))), $r(kn(n), "delete", Gr.prototype.delete.bind(kn(n))), $r(kn(n), "get", Gr.prototype.get.bind(kn(n))), $r(kn(n), "has", Gr.prototype.has.bind(kn(n))), $r(kn(n), "set", Gr.prototype.set.bind(kn(n))), n.tag = r.tag, n;
  }
  return _t(r, [{
    key: "toJSON",
    value: function(i, s) {
      var o = /* @__PURE__ */ new Map();
      s && s.onCreate && s.onCreate(o);
      var a = At(this.items), l;
      try {
        for (a.s(); !(l = a.n()).done; ) {
          var p = l.value, f = void 0, d = void 0;
          if (p instanceof pt ? (f = Jn(p.key, "", s), d = Jn(p.value, f, s)) : f = Jn(p, "", s), o.has(f)) throw new Error("Ordered maps must not include duplicate keys");
          o.set(f, d);
        }
      } catch (m) {
        a.e(m);
      } finally {
        a.f();
      }
      return o;
    }
  }]), r;
}(Pi);
$r(Qm, "tag", "tag:yaml.org,2002:omap");
function u3(e, t) {
  var r = NR(e, t), n = [], i = At(r.items), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value.key;
      if (o instanceof St)
        if (n.includes(o.value)) {
          var a = "Ordered maps must not include duplicate keys";
          throw new nt(t, a);
        } else
          n.push(o.value);
    }
  } catch (l) {
    i.e(l);
  } finally {
    i.f();
  }
  return Object.assign(new Qm(), r);
}
function c3(e, t, r) {
  var n = LR(e, t, r), i = new Qm();
  return i.items = n.items, i;
}
var DR = {
  identify: function(t) {
    return t instanceof Map;
  },
  nodeClass: Qm,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve: u3,
  createNode: c3
}, Ym = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r() {
    var n;
    return ft(this, r), n = t.call(this), n.tag = r.tag, n;
  }
  return _t(r, [{
    key: "add",
    value: function(i) {
      var s = i instanceof pt ? i : new pt(i), o = Us(this.items, s.key);
      o || this.items.push(s);
    }
  }, {
    key: "get",
    value: function(i, s) {
      var o = Us(this.items, i);
      return !s && o instanceof pt ? o.key instanceof St ? o.key.value : o.key : o;
    }
  }, {
    key: "set",
    value: function(i, s) {
      if (typeof s != "boolean") throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(hn(s)));
      var o = Us(this.items, i);
      o && !s ? this.items.splice(this.items.indexOf(o), 1) : !o && s && this.items.push(new pt(i));
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      return rn(xr(r.prototype), "toJSON", this).call(this, i, s, Set);
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      if (!i) return JSON.stringify(this);
      if (this.hasAllNullValues()) return rn(xr(r.prototype), "toString", this).call(this, i, s, o);
      throw new Error("Set items must all have null values");
    }
  }]), r;
}(Gr);
$r(Ym, "tag", "tag:yaml.org,2002:set");
function p3(e, t) {
  var r = RR(e, t);
  if (!r.hasAllNullValues()) throw new nt(t, "Set items must all have null values");
  return Object.assign(new Ym(), r);
}
function f3(e, t, r) {
  var n = new Ym(), i = At(t), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value;
      n.items.push(e.createPair(o, null, r));
    }
  } catch (a) {
    i.e(a);
  } finally {
    i.f();
  }
  return n;
}
var FR = {
  identify: function(t) {
    return t instanceof Set;
  },
  nodeClass: Ym,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  resolve: p3,
  createNode: f3
}, Qw = function(t, r) {
  var n = r.split(":").reduce(function(i, s) {
    return i * 60 + Number(s);
  }, 0);
  return t === "-" ? -n : n;
}, zR = function(t) {
  var r = t.value;
  if (isNaN(r) || !isFinite(r)) return no(r);
  var n = "";
  r < 0 && (n = "-", r = Math.abs(r));
  var i = [r % 60];
  return r < 60 ? i.unshift(0) : (r = Math.round((r - i[0]) / 60), i.unshift(r % 60), r >= 60 && (r = Math.round((r - i[0]) / 60), i.unshift(r))), n + i.map(function(s) {
    return s < 10 ? "0" + String(s) : String(s);
  }).join(":").replace(/000000\d*$/, "");
}, qR = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: function(t, r, n) {
    return Qw(r, n.replace(/_/g, ""));
  },
  stringify: zR
}, BR = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: function(t, r, n) {
    return Qw(r, n.replace(/_/g, ""));
  },
  stringify: zR
}, UR = {
  identify: function(t) {
    return t instanceof Date;
  },
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
  resolve: function(t, r, n, i, s, o, a, l, p) {
    l && (l = (l + "00").substr(1, 3));
    var f = Date.UTC(r, n - 1, i, s || 0, o || 0, a || 0, l || 0);
    if (p && p !== "Z") {
      var d = Qw(p[0], p.slice(1));
      Math.abs(d) < 30 && (d *= 60), f -= 6e4 * d;
    }
    return new Date(f);
  },
  stringify: function(t) {
    var r = t.value;
    return r.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
  }
};
function VR(e) {
  var t = typeof process < "u" && process.env || {};
  return e ? typeof YAML_SILENCE_DEPRECATION_WARNINGS < "u" ? !YAML_SILENCE_DEPRECATION_WARNINGS : !t.YAML_SILENCE_DEPRECATION_WARNINGS : typeof YAML_SILENCE_WARNINGS < "u" ? !YAML_SILENCE_WARNINGS : !t.YAML_SILENCE_WARNINGS;
}
function WR(e, t) {
  if (VR(!1)) {
    var r = typeof process < "u" && process.emitWarning;
    r ? r(e, t) : console.warn(t ? "".concat(t, ": ").concat(e) : e);
  }
}
var iO = {};
function d3(e, t) {
  if (!iO[e] && VR(!0)) {
    iO[e] = !0;
    var r = "The option '".concat(e, "' will be removed in a future release");
    r += ", use '".concat(t, "' instead."), WR(r, "DeprecationWarning");
  }
}
function h3(e, t, r) {
  var n = new Gr(e);
  if (t instanceof Map) {
    var i = At(t), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = lp(s.value, 2), a = o[0], l = o[1];
        n.items.push(e.createPair(a, l, r));
      }
    } catch (m) {
      i.e(m);
    } finally {
      i.f();
    }
  } else if (t && hn(t) === "object")
    for (var p = 0, f = Object.keys(t); p < f.length; p++) {
      var d = f[p];
      n.items.push(e.createPair(d, t[d], r));
    }
  return typeof e.sortMapEntries == "function" && n.items.sort(e.sortMapEntries), n;
}
var Wc = {
  createNode: h3,
  default: !0,
  nodeClass: Gr,
  tag: "tag:yaml.org,2002:map",
  resolve: RR
};
function m3(e, t, r) {
  var n = new Pi(e);
  if (t && t[Symbol.iterator]) {
    var i = At(t), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = s.value, a = e.createNode(o, r.wrapScalars, null, r);
        n.items.push(a);
      }
    } catch (l) {
      i.e(l);
    } finally {
      i.f();
    }
  }
  return n;
}
var Gm = {
  createNode: m3,
  default: !0,
  nodeClass: Pi,
  tag: "tag:yaml.org,2002:seq",
  resolve: IR
}, g3 = {
  identify: function(t) {
    return typeof t == "string";
  },
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: up,
  stringify: function(t, r, n, i) {
    return r = Object.assign({
      actualString: !0
    }, r), Hw(t, r, n, i);
  },
  options: po
}, Yw = [Wc, Gm, g3], Km = function(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}, Gw = function(t, r, n) {
  return Zo.asBigInt ? BigInt(t) : parseInt(r, n);
};
function HR(e, t, r) {
  var n = e.value;
  return Km(n) && n >= 0 ? r + n.toString(t) : no(e);
}
var QR = {
  identify: function(t) {
    return t == null;
  },
  createNode: function(t, r, n) {
    return n.wrapScalars ? new St(null) : null;
  },
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: function() {
    return null;
  },
  options: Al,
  stringify: function() {
    return Al.nullStr;
  }
}, YR = {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: function(t) {
    return t[0] === "t" || t[0] === "T";
  },
  options: ro,
  stringify: function(t) {
    var r = t.value;
    return r ? ro.trueStr : ro.falseStr;
  }
}, GR = {
  identify: function(t) {
    return Km(t) && t >= 0;
  },
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o([0-7]+)$/,
  resolve: function(t, r) {
    return Gw(t, r, 8);
  },
  options: Zo,
  stringify: function(t) {
    return HR(t, 8, "0o");
  }
}, KR = {
  identify: Km,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: function(t) {
    return Gw(t, t, 10);
  },
  options: Zo,
  stringify: no
}, XR = {
  identify: function(t) {
    return Km(t) && t >= 0;
  },
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x([0-9a-fA-F]+)$/,
  resolve: function(t, r) {
    return Gw(t, r, 16);
  },
  options: Zo,
  stringify: function(t) {
    return HR(t, 16, "0x");
  }
}, JR = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: function(t, r) {
    return r ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  },
  stringify: no
}, ZR = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: function(t) {
    return parseFloat(t);
  },
  stringify: function(t) {
    var r = t.value;
    return Number(r).toExponential();
  }
}, eI = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
  resolve: function(t, r, n) {
    var i = r || n, s = new St(parseFloat(t));
    return i && i[i.length - 1] === "0" && (s.minFractionDigits = i.length), s;
  },
  stringify: no
}, y3 = Yw.concat([QR, YR, GR, KR, XR, JR, ZR, eI]), oO = function(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}, Vf = function(t) {
  var r = t.value;
  return JSON.stringify(r);
}, tI = [Wc, Gm, {
  identify: function(t) {
    return typeof t == "string";
  },
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: up,
  stringify: Vf
}, {
  identify: function(t) {
    return t == null;
  },
  createNode: function(t, r, n) {
    return n.wrapScalars ? new St(null) : null;
  },
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^null$/,
  resolve: function() {
    return null;
  },
  stringify: Vf
}, {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^true|false$/,
  resolve: function(t) {
    return t === "true";
  },
  stringify: Vf
}, {
  identify: oO,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: function(t) {
    return Zo.asBigInt ? BigInt(t) : parseInt(t, 10);
  },
  stringify: function(t) {
    var r = t.value;
    return oO(r) ? r.toString() : JSON.stringify(r);
  }
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: function(t) {
    return parseFloat(t);
  },
  stringify: Vf
}];
tI.scalarFallback = function(e) {
  throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(e)));
};
var sO = function(t) {
  var r = t.value;
  return r ? ro.trueStr : ro.falseStr;
}, sc = function(t) {
  return typeof t == "bigint" || Number.isInteger(t);
};
function Wf(e, t, r) {
  var n = t.replace(/_/g, "");
  if (Zo.asBigInt) {
    switch (r) {
      case 2:
        n = "0b".concat(n);
        break;
      case 8:
        n = "0o".concat(n);
        break;
      case 16:
        n = "0x".concat(n);
        break;
    }
    var i = BigInt(n);
    return e === "-" ? BigInt(-1) * i : i;
  }
  var s = parseInt(n, r);
  return e === "-" ? -1 * s : s;
}
function qy(e, t, r) {
  var n = e.value;
  if (sc(n)) {
    var i = n.toString(t);
    return n < 0 ? "-" + r + i.substr(1) : r + i;
  }
  return no(e);
}
var v3 = Yw.concat([{
  identify: function(t) {
    return t == null;
  },
  createNode: function(t, r, n) {
    return n.wrapScalars ? new St(null) : null;
  },
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: function() {
    return null;
  },
  options: Al,
  stringify: function() {
    return Al.nullStr;
  }
}, {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: function() {
    return !0;
  },
  options: ro,
  stringify: sO
}, {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: function() {
    return !1;
  },
  options: ro,
  stringify: sO
}, {
  identify: sc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^([-+]?)0b([0-1_]+)$/,
  resolve: function(t, r, n) {
    return Wf(r, n, 2);
  },
  stringify: function(t) {
    return qy(t, 2, "0b");
  }
}, {
  identify: sc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^([-+]?)0([0-7_]+)$/,
  resolve: function(t, r, n) {
    return Wf(r, n, 8);
  },
  stringify: function(t) {
    return qy(t, 8, "0");
  }
}, {
  identify: sc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^([-+]?)([0-9][0-9_]*)$/,
  resolve: function(t, r, n) {
    return Wf(r, n, 10);
  },
  stringify: no
}, {
  identify: sc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
  resolve: function(t, r, n) {
    return Wf(r, n, 16);
  },
  stringify: function(t) {
    return qy(t, 16, "0x");
  }
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: function(t, r) {
    return r ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  },
  stringify: no
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: function(t) {
    return parseFloat(t.replace(/_/g, ""));
  },
  stringify: function(t) {
    var r = t.value;
    return Number(r).toExponential();
  }
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
  resolve: function(t, r) {
    var n = new St(parseFloat(t.replace(/_/g, "")));
    if (r) {
      var i = r.replace(/_/g, "");
      i[i.length - 1] === "0" && (n.minFractionDigits = i.length);
    }
    return n;
  },
  stringify: no
}], jR, DR, MR, FR, qR, BR, UR), b3 = {
  core: y3,
  failsafe: Yw,
  json: tI,
  yaml11: v3
}, w3 = {
  binary: jR,
  bool: YR,
  float: eI,
  floatExp: ZR,
  floatNaN: JR,
  floatTime: BR,
  int: KR,
  intHex: XR,
  intOct: GR,
  intTime: qR,
  map: Wc,
  null: QR,
  omap: DR,
  pairs: MR,
  seq: Gm,
  set: FR,
  timestamp: UR
};
function S3(e, t, r) {
  if (t) {
    var n = r.filter(function(s) {
      return s.tag === t;
    }), i = n.find(function(s) {
      return !s.format;
    }) || n[0];
    if (!i) throw new Error("Tag ".concat(t, " not found"));
    return i;
  }
  return r.find(function(s) {
    return (s.identify && s.identify(e) || s.class && e instanceof s.class) && !s.format;
  });
}
function x3(e, t, r) {
  if (e instanceof Qr) return e;
  var n = r.defaultPrefix, i = r.onTagObj, s = r.prevObjects, o = r.schema, a = r.wrapScalars;
  t && t.startsWith("!!") && (t = n + t.slice(2));
  var l = S3(e, t, o.tags);
  if (!l) {
    if (typeof e.toJSON == "function" && (e = e.toJSON()), !e || hn(e) !== "object") return a ? new St(e) : e;
    l = e instanceof Map ? Wc : e[Symbol.iterator] ? Gm : Wc;
  }
  i && (i(l), delete r.onTagObj);
  var p = {
    value: void 0,
    node: void 0
  };
  if (e && hn(e) === "object" && s) {
    var f = s.get(e);
    if (f) {
      var d = new co(f);
      return r.aliasNodes.push(d), d;
    }
    p.value = e, s.set(e, p);
  }
  return p.node = l.createNode ? l.createNode(r.schema, e, r) : a ? new St(e) : e, t && p.node instanceof Qr && (p.node.tag = t), p.node;
}
function _3(e, t, r, n) {
  var i = e[n.replace(/\W/g, "")];
  if (!i) {
    var s = Object.keys(e).map(function(v) {
      return JSON.stringify(v);
    }).join(", ");
    throw new Error('Unknown schema "'.concat(n, '"; use one of ').concat(s));
  }
  if (Array.isArray(r)) {
    var o = At(r), a;
    try {
      for (o.s(); !(a = o.n()).done; ) {
        var l = a.value;
        i = i.concat(l);
      }
    } catch (v) {
      o.e(v);
    } finally {
      o.f();
    }
  } else typeof r == "function" && (i = r(i.slice()));
  for (var p = 0; p < i.length; ++p) {
    var f = i[p];
    if (typeof f == "string") {
      var d = t[f];
      if (!d) {
        var m = Object.keys(t).map(function(v) {
          return JSON.stringify(v);
        }).join(", ");
        throw new Error('Unknown custom tag "'.concat(f, '"; use one of ').concat(m));
      }
      i[p] = d;
    }
  }
  return i;
}
var E3 = function(t, r) {
  return t.key < r.key ? -1 : t.key > r.key ? 1 : 0;
}, Hc = /* @__PURE__ */ function() {
  function e(t) {
    var r = t.customTags, n = t.merge, i = t.schema, s = t.sortMapEntries, o = t.tags;
    ft(this, e), this.merge = !!n, this.name = i, this.sortMapEntries = s === !0 ? E3 : s || null, !r && o && d3("tags", "customTags"), this.tags = _3(b3, w3, r || o, i);
  }
  return _t(e, [{
    key: "createNode",
    value: function(r, n, i, s) {
      var o = {
        defaultPrefix: e.defaultPrefix,
        schema: this,
        wrapScalars: n
      }, a = s ? Object.assign(s, o) : o;
      return x3(r, i, a);
    }
  }, {
    key: "createPair",
    value: function(r, n, i) {
      i || (i = {
        wrapScalars: !0
      });
      var s = this.createNode(r, i.wrapScalars, null, i), o = this.createNode(n, i.wrapScalars, null, i);
      return new pt(s, o);
    }
  }]), e;
}();
$r(Hc, "defaultPrefix", bh);
$r(Hc, "defaultTags", Lo);
var nm = {
  anchorPrefix: "a",
  customTags: null,
  indent: 2,
  indentSeq: !0,
  keepCstNodes: !1,
  keepNodeTypes: !0,
  keepBlobsInJSON: !0,
  mapAsMap: !1,
  maxAliasCount: 100,
  prettyErrors: !1,
  // TODO Set true in v2
  simpleKeys: !1,
  version: "1.2"
}, O3 = {
  get binary() {
    return bc;
  },
  set binary(e) {
    Object.assign(bc, e);
  },
  get bool() {
    return ro;
  },
  set bool(e) {
    Object.assign(ro, e);
  },
  get int() {
    return Zo;
  },
  set int(e) {
    Object.assign(Zo, e);
  },
  get null() {
    return Al;
  },
  set null(e) {
    Object.assign(Al, e);
  },
  get str() {
    return po;
  },
  set str(e) {
    Object.assign(po, e);
  }
}, rI = {
  "1.0": {
    schema: "yaml-1.1",
    merge: !0,
    tagPrefixes: [{
      handle: "!",
      prefix: bh
    }, {
      handle: "!!",
      prefix: "tag:private.yaml.org,2002:"
    }]
  },
  1.1: {
    schema: "yaml-1.1",
    merge: !0,
    tagPrefixes: [{
      handle: "!",
      prefix: "!"
    }, {
      handle: "!!",
      prefix: bh
    }]
  },
  1.2: {
    schema: "core",
    merge: !1,
    tagPrefixes: [{
      handle: "!",
      prefix: "!"
    }, {
      handle: "!!",
      prefix: bh
    }]
  }
};
function aO(e, t) {
  if ((e.version || e.options.version) === "1.0") {
    var r = t.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (r) return "!" + r[1];
    var n = t.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return n ? "!".concat(n[1], "/").concat(n[2]) : "!".concat(t.replace(/^tag:/, ""));
  }
  var i = e.tagPrefixes.find(function(a) {
    return t.indexOf(a.prefix) === 0;
  });
  if (!i) {
    var s = e.getDefaults().tagPrefixes;
    i = s && s.find(function(a) {
      return t.indexOf(a.prefix) === 0;
    });
  }
  if (!i) return t[0] === "!" ? t : "!<".concat(t, ">");
  var o = t.substr(i.prefix.length).replace(/[!,[\]{}]/g, function(a) {
    return {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }[a];
  });
  return i.handle + o;
}
function k3(e, t) {
  if (t instanceof co) return co;
  if (t.tag) {
    var r = e.filter(function(a) {
      return a.tag === t.tag;
    });
    if (r.length > 0) return r.find(function(a) {
      return a.format === t.format;
    }) || r[0];
  }
  var n, i;
  if (t instanceof St) {
    i = t.value;
    var s = e.filter(function(a) {
      return a.identify && a.identify(i) || a.class && i instanceof a.class;
    });
    n = s.find(function(a) {
      return a.format === t.format;
    }) || s.find(function(a) {
      return !a.format;
    });
  } else
    i = t, n = e.find(function(a) {
      return a.nodeClass && i instanceof a.nodeClass;
    });
  if (!n) {
    var o = i && i.constructor ? i.constructor.name : hn(i);
    throw new Error("Tag not resolved for ".concat(o, " value"));
  }
  return n;
}
function A3(e, t, r) {
  var n = r.anchors, i = r.doc, s = [], o = i.anchors.getName(e);
  return o && (n[o] = e, s.push("&".concat(o))), e.tag ? s.push(aO(i, e.tag)) : t.default || s.push(aO(i, t.tag)), s.join(" ");
}
function Hf(e, t, r, n) {
  var i = t.doc, s = i.anchors, o = i.schema, a;
  if (!(e instanceof Qr)) {
    var l = {
      aliasNodes: [],
      onTagObj: function(_) {
        return a = _;
      },
      prevObjects: /* @__PURE__ */ new Map()
    };
    e = o.createNode(e, !0, null, l);
    var p = At(l.aliasNodes), f;
    try {
      for (p.s(); !(f = p.n()).done; ) {
        var d = f.value;
        d.source = d.source.node;
        var m = s.getName(d.source);
        m || (m = s.newName(), s.map[m] = d.source);
      }
    } catch (S) {
      p.e(S);
    } finally {
      p.f();
    }
  }
  if (e instanceof pt) return e.toString(t, r, n);
  a || (a = k3(o.tags, e));
  var v = A3(e, a, t);
  v.length > 0 && (t.indentAtStart = (t.indentAtStart || 0) + v.length + 1);
  var g = typeof a.stringify == "function" ? a.stringify(e, t, r, n) : e instanceof St ? Hw(e, t, r, n) : e.toString(t, r, n);
  return v ? e instanceof St || g[0] === "{" || g[0] === "[" ? "".concat(v, " ").concat(g) : "".concat(v, `
`).concat(t.indent).concat(g) : g;
}
var P3 = /* @__PURE__ */ function() {
  function e(t) {
    ft(this, e), $r(this, "map", /* @__PURE__ */ Object.create(null)), this.prefix = t;
  }
  return _t(e, [{
    key: "createAlias",
    value: function(r, n) {
      return this.setAnchor(r, n), new co(r);
    }
  }, {
    key: "createMergePair",
    value: function() {
      for (var r = this, n = new OR(), i = arguments.length, s = new Array(i), o = 0; o < i; o++)
        s[o] = arguments[o];
      return n.value.items = s.map(function(a) {
        if (a instanceof co) {
          if (a.source instanceof Gr) return a;
        } else if (a instanceof Gr)
          return r.createAlias(a);
        throw new Error("Merge sources must be Map nodes or their Aliases");
      }), n;
    }
  }, {
    key: "getName",
    value: function(r) {
      var n = this.map;
      return Object.keys(n).find(function(i) {
        return n[i] === r;
      });
    }
  }, {
    key: "getNames",
    value: function() {
      return Object.keys(this.map);
    }
  }, {
    key: "getNode",
    value: function(r) {
      return this.map[r];
    }
  }, {
    key: "newName",
    value: function(r) {
      r || (r = this.prefix);
      for (var n = Object.keys(this.map), i = 1; ; ++i) {
        var s = "".concat(r).concat(i);
        if (!n.includes(s)) return s;
      }
    }
    // During parsing, map & aliases contain CST nodes
  }, {
    key: "resolveNodes",
    value: function() {
      var r = this.map, n = this._cstAliases;
      Object.keys(r).forEach(function(i) {
        r[i] = r[i].resolved;
      }), n.forEach(function(i) {
        i.source = i.source.resolved;
      }), delete this._cstAliases;
    }
  }, {
    key: "setAnchor",
    value: function(r, n) {
      if (r != null && !e.validAnchorNode(r))
        throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
      if (n && /[\x00-\x19\s,[\]{}]/.test(n))
        throw new Error("Anchor names must not contain whitespace or control characters");
      var i = this.map, s = r && Object.keys(i).find(function(o) {
        return i[o] === r;
      });
      if (s)
        if (n)
          s !== n && (delete i[s], i[n] = r);
        else return s;
      else {
        if (!n) {
          if (!r) return null;
          n = this.newName();
        }
        i[n] = r;
      }
      return n;
    }
  }], [{
    key: "validAnchorNode",
    value: function(r) {
      return r instanceof St || r instanceof Pi || r instanceof Gr;
    }
  }]), e;
}(), C3 = function e(t, r) {
  if (t && hn(t) === "object") {
    var n = t.tag;
    t instanceof br ? (n && (r[n] = !0), t.items.forEach(function(i) {
      return e(i, r);
    })) : t instanceof pt ? (e(t.key, r), e(t.value, r)) : t instanceof St && n && (r[n] = !0);
  }
  return r;
}, T3 = function(t) {
  return Object.keys(C3(t, {}));
};
function $3(e, t) {
  var r = {
    before: [],
    after: []
  }, n = void 0, i = !1, s = At(t), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var a = o.value;
      if (a.valueRange) {
        if (n !== void 0) {
          var l = "Document contains trailing content not separated by a ... or --- line";
          e.errors.push(new Ir(a, l));
          break;
        }
        var p = Yo(e, a);
        i && (p.spaceBefore = !0, i = !1), n = p;
      } else if (a.comment !== null) {
        var f = n === void 0 ? r.before : r.after;
        f.push(a.comment);
      } else a.type === _e.BLANK_LINE && (i = !0, n === void 0 && r.before.length > 0 && !e.commentBefore && (e.commentBefore = r.before.join(`
`), r.before = []));
    }
  } catch (v) {
    s.e(v);
  } finally {
    s.f();
  }
  if (e.contents = n || null, !n)
    e.comment = r.before.concat(r.after).join(`
`) || null;
  else {
    var d = r.before.join(`
`);
    if (d) {
      var m = n instanceof br && n.items[0] ? n.items[0] : n;
      m.commentBefore = m.commentBefore ? "".concat(d, `
`).concat(m.commentBefore) : d;
    }
    e.comment = r.after.join(`
`) || null;
  }
}
function R3(e, t) {
  var r = e.tagPrefixes, n = lp(t.parameters, 2), i = n[0], s = n[1];
  if (!i || !s) {
    var o = "Insufficient parameters given for %TAG directive";
    throw new nt(t, o);
  }
  if (r.some(function(l) {
    return l.handle === i;
  })) {
    var a = "The %TAG directive must only be given at most once per handle in the same document.";
    throw new nt(t, a);
  }
  return {
    handle: i,
    prefix: s
  };
}
function I3(e, t) {
  var r = lp(t.parameters, 1), n = r[0];
  if (t.name === "YAML:1.0" && (n = "1.0"), !n) {
    var i = "Insufficient parameters given for %YAML directive";
    throw new nt(t, i);
  }
  if (!rI[n]) {
    var s = e.version || e.options.version, o = "Document will be parsed as YAML ".concat(s, " rather than YAML ").concat(n);
    e.warnings.push(new Bl(t, o));
  }
  return n;
}
function j3(e, t, r) {
  var n = [], i = !1, s = At(t), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var a = o.value, l = a.comment, p = a.name;
      switch (p) {
        case "TAG":
          try {
            e.tagPrefixes.push(R3(e, a));
          } catch (v) {
            e.errors.push(v);
          }
          i = !0;
          break;
        case "YAML":
        case "YAML:1.0":
          if (e.version) {
            var f = "The %YAML directive must only be given at most once per document.";
            e.errors.push(new nt(a, f));
          }
          try {
            e.version = I3(e, a);
          } catch (v) {
            e.errors.push(v);
          }
          i = !0;
          break;
        default:
          if (p) {
            var d = "YAML only supports %TAG and %YAML directives, and not %".concat(p);
            e.warnings.push(new Bl(a, d));
          }
      }
      l && n.push(l);
    }
  } catch (v) {
    s.e(v);
  } finally {
    s.f();
  }
  if (r && !i && (e.version || r.version || e.options.version) === "1.1") {
    var m = function(g) {
      var S = g.handle, _ = g.prefix;
      return {
        handle: S,
        prefix: _
      };
    };
    e.tagPrefixes = r.tagPrefixes.map(m), e.version = r.version;
  }
  e.commentBefore = n.join(`
`) || null;
}
function Ma(e) {
  if (e instanceof br) return !0;
  throw new Error("Expected a YAML collection as document contents");
}
var Kw = /* @__PURE__ */ function() {
  function e(t) {
    ft(this, e), this.anchors = new P3(t.anchorPrefix), this.commentBefore = null, this.comment = null, this.contents = null, this.directivesEndMarker = null, this.errors = [], this.options = t, this.schema = null, this.tagPrefixes = [], this.version = null, this.warnings = [];
  }
  return _t(e, [{
    key: "add",
    value: function(r) {
      return Ma(this.contents), this.contents.add(r);
    }
  }, {
    key: "addIn",
    value: function(r, n) {
      Ma(this.contents), this.contents.addIn(r, n);
    }
  }, {
    key: "delete",
    value: function(r) {
      return Ma(this.contents), this.contents.delete(r);
    }
  }, {
    key: "deleteIn",
    value: function(r) {
      return oc(r) ? this.contents == null ? !1 : (this.contents = null, !0) : (Ma(this.contents), this.contents.deleteIn(r));
    }
  }, {
    key: "getDefaults",
    value: function() {
      return e.defaults[this.version] || e.defaults[this.options.version] || {};
    }
  }, {
    key: "get",
    value: function(r, n) {
      return this.contents instanceof br ? this.contents.get(r, n) : void 0;
    }
  }, {
    key: "getIn",
    value: function(r, n) {
      return oc(r) ? !n && this.contents instanceof St ? this.contents.value : this.contents : this.contents instanceof br ? this.contents.getIn(r, n) : void 0;
    }
  }, {
    key: "has",
    value: function(r) {
      return this.contents instanceof br ? this.contents.has(r) : !1;
    }
  }, {
    key: "hasIn",
    value: function(r) {
      return oc(r) ? this.contents !== void 0 : this.contents instanceof br ? this.contents.hasIn(r) : !1;
    }
  }, {
    key: "set",
    value: function(r, n) {
      Ma(this.contents), this.contents.set(r, n);
    }
  }, {
    key: "setIn",
    value: function(r, n) {
      oc(r) ? this.contents = n : (Ma(this.contents), this.contents.setIn(r, n));
    }
  }, {
    key: "setSchema",
    value: function(r, n) {
      if (!(!r && !n && this.schema)) {
        typeof r == "number" && (r = r.toFixed(1)), r === "1.0" || r === "1.1" || r === "1.2" ? (this.version ? this.version = r : this.options.version = r, delete this.options.schema) : r && typeof r == "string" && (this.options.schema = r), Array.isArray(n) && (this.options.customTags = n);
        var i = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Hc(i);
      }
    }
  }, {
    key: "parse",
    value: function(r, n) {
      this.options.keepCstNodes && (this.cstNode = r), this.options.keepNodeTypes && (this.type = "DOCUMENT");
      var i = r.directives, s = i === void 0 ? [] : i, o = r.contents, a = o === void 0 ? [] : o, l = r.directivesEndMarker, p = r.error, f = r.valueRange;
      if (p && (p.source || (p.source = this), this.errors.push(p)), j3(this, s, n), l && (this.directivesEndMarker = !0), this.range = f ? [f.start, f.end] : null, this.setSchema(), this.anchors._cstAliases = [], $3(this, a), this.anchors.resolveNodes(), this.options.prettyErrors) {
        var d = At(this.errors), m;
        try {
          for (d.s(); !(m = d.n()).done; ) {
            var v = m.value;
            v instanceof kl && v.makePretty();
          }
        } catch (x) {
          d.e(x);
        } finally {
          d.f();
        }
        var g = At(this.warnings), S;
        try {
          for (g.s(); !(S = g.n()).done; ) {
            var _ = S.value;
            _ instanceof kl && _.makePretty();
          }
        } catch (x) {
          g.e(x);
        } finally {
          g.f();
        }
      }
      return this;
    }
  }, {
    key: "listNonDefaultTags",
    value: function() {
      return T3(this.contents).filter(function(r) {
        return r.indexOf(Hc.defaultPrefix) !== 0;
      });
    }
  }, {
    key: "setTagPrefix",
    value: function(r, n) {
      if (r[0] !== "!" || r[r.length - 1] !== "!") throw new Error("Handle must start and end with !");
      if (n) {
        var i = this.tagPrefixes.find(function(s) {
          return s.handle === r;
        });
        i ? i.prefix = n : this.tagPrefixes.push({
          handle: r,
          prefix: n
        });
      } else
        this.tagPrefixes = this.tagPrefixes.filter(function(s) {
          return s.handle !== r;
        });
    }
  }, {
    key: "toJSON",
    value: function(r, n) {
      var i = this, s = this.options, o = s.keepBlobsInJSON, a = s.mapAsMap, l = s.maxAliasCount, p = o && (typeof r != "string" || !(this.contents instanceof St)), f = {
        doc: this,
        indentStep: "  ",
        keep: p,
        mapAsMap: p && !!a,
        maxAliasCount: l,
        stringify: Hf
        // Requiring directly in Pair would create circular dependencies
      }, d = Object.keys(this.anchors.map);
      d.length > 0 && (f.anchors = new Map(d.map(function(y) {
        return [i.anchors.map[y], {
          alias: [],
          aliasCount: 0,
          count: 1
        }];
      })));
      var m = Jn(this.contents, r, f);
      if (typeof n == "function" && f.anchors) {
        var v = At(f.anchors.values()), g;
        try {
          for (v.s(); !(g = v.n()).done; ) {
            var S = g.value, _ = S.count, x = S.res;
            n(x, _);
          }
        } catch (y) {
          v.e(y);
        } finally {
          v.f();
        }
      }
      return m;
    }
  }, {
    key: "toString",
    value: function() {
      if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
      var r = this.options.indent;
      if (!Number.isInteger(r) || r <= 0) {
        var n = JSON.stringify(r);
        throw new Error('"indent" option must be a positive integer, not '.concat(n));
      }
      this.setSchema();
      var i = [], s = !1;
      if (this.version) {
        var o = "%YAML 1.2";
        this.schema.name === "yaml-1.1" && (this.version === "1.0" ? o = "%YAML:1.0" : this.version === "1.1" && (o = "%YAML 1.1")), i.push(o), s = !0;
      }
      var a = this.listNonDefaultTags();
      this.tagPrefixes.forEach(function(v) {
        var g = v.handle, S = v.prefix;
        a.some(function(_) {
          return _.indexOf(S) === 0;
        }) && (i.push("%TAG ".concat(g, " ").concat(S)), s = !0);
      }), (s || this.directivesEndMarker) && i.push("---"), this.commentBefore && ((s || !this.directivesEndMarker) && i.unshift(""), i.unshift(this.commentBefore.replace(/^/gm, "#")));
      var l = {
        anchors: /* @__PURE__ */ Object.create(null),
        doc: this,
        indent: "",
        indentStep: " ".repeat(r),
        stringify: Hf
        // Requiring directly in nodes would create circular dependencies
      }, p = !1, f = null;
      if (this.contents) {
        this.contents instanceof Qr && (this.contents.spaceBefore && (s || this.directivesEndMarker) && i.push(""), this.contents.commentBefore && i.push(this.contents.commentBefore.replace(/^/gm, "#")), l.forceBlockIndent = !!this.comment, f = this.contents.comment);
        var d = f ? null : function() {
          return p = !0;
        }, m = Hf(this.contents, l, function() {
          return f = null;
        }, d);
        i.push(al(m, "", f));
      } else this.contents !== void 0 && i.push(Hf(this.contents, l));
      return this.comment && ((!p || f) && i[i.length - 1] !== "" && i.push(""), i.push(this.comment.replace(/^/gm, "#"))), i.join(`
`) + `
`;
    }
  }]), e;
}();
$r(Kw, "defaults", rI);
function N3(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = arguments.length > 2 ? arguments[2] : void 0;
  r === void 0 && typeof t == "string" && (r = t, t = !0);
  var n = Object.assign({}, Kw.defaults[nm.version], nm), i = new Hc(n);
  return i.createNode(e, t, r);
}
var Xm = /* @__PURE__ */ function(e) {
  Pt(r, e);
  var t = Ct(r);
  function r(n) {
    return ft(this, r), t.call(this, Object.assign({}, nm, n));
  }
  return r;
}(Kw);
function L3(e, t) {
  var r = [], n, i = At(Uw(e)), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value, a = new Xm(t);
      a.parse(o, n), r.push(a), n = a;
    }
  } catch (l) {
    i.e(l);
  } finally {
    i.f();
  }
  return r;
}
function nI(e, t) {
  var r = Uw(e), n = new Xm(t).parse(r[0]);
  if (r.length > 1) {
    var i = "Source contains multiple documents; please use YAML.parseAllDocuments()";
    n.errors.unshift(new nt(r[1], i));
  }
  return n;
}
function M3(e, t) {
  var r = nI(e, t);
  if (r.warnings.forEach(function(n) {
    return WR(n);
  }), r.errors.length > 0) throw r.errors[0];
  return r.toJSON();
}
function D3(e, t) {
  var r = new Xm(t);
  return r.contents = e, String(r);
}
var F3 = {
  createNode: N3,
  defaultOptions: nm,
  Document: Xm,
  parse: M3,
  parseAllDocuments: L3,
  parseCST: Uw,
  parseDocument: nI,
  scalarOptions: O3,
  stringify: D3
};
const z3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  YAML: F3
}, Symbol.toStringTag, { value: "Module" })), q3 = /* @__PURE__ */ Ri(z3);
var By, lO;
function B3() {
  return lO || (lO = 1, By = q3.YAML), By;
}
function $t() {
  return $t = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, $t.apply(null, arguments);
}
function U3(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Qc(e, t) {
  return Qc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, Qc(e, t);
}
function V3(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Qc(e, t);
}
function lb(e) {
  return lb = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, lb(e);
}
function W3(e) {
  try {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  } catch {
    return typeof e == "function";
  }
}
function iI() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (iI = function() {
    return !!e;
  })();
}
function H3(e, t, r) {
  if (iI()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t);
  var i = new (e.bind.apply(e, n))();
  return r && Qc(i, r.prototype), i;
}
function ub(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return ub = function(n) {
    if (n === null || !W3(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (t !== void 0) {
      if (t.has(n)) return t.get(n);
      t.set(n, i);
    }
    function i() {
      return H3(n, arguments, lb(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Qc(i, n);
  }, ub(e);
}
function oI(e, t) {
  return t || (t = e.slice(0)), e.raw = t, e;
}
function uO() {
  var e;
  return e = arguments.length - 1, e < 0 || arguments.length <= e ? void 0 : arguments[e];
}
function Q3(e) {
  return -e;
}
function Y3(e, t) {
  return e + t;
}
function G3(e, t) {
  return e - t;
}
function K3(e, t) {
  return e * t;
}
function X3(e, t) {
  return e / t;
}
function J3() {
  return Math.max.apply(Math, arguments);
}
function Z3() {
  return Math.min.apply(Math, arguments);
}
function eU() {
  return Array.of.apply(Array, arguments);
}
var tU = {
  symbols: {
    "*": {
      infix: {
        symbol: "*",
        f: K3,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "*",
      regSymbol: "\\*"
    },
    "/": {
      infix: {
        symbol: "/",
        f: X3,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "/",
      regSymbol: "/"
    },
    "+": {
      infix: {
        symbol: "+",
        f: Y3,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "+",
        f: uO,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "+",
      regSymbol: "\\+"
    },
    "-": {
      infix: {
        symbol: "-",
        f: G3,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "-",
        f: Q3,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "-",
      regSymbol: "-"
    },
    ",": {
      infix: {
        symbol: ",",
        f: eU,
        notation: "infix",
        precedence: 1,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: ",",
      regSymbol: ","
    },
    "(": {
      prefix: {
        symbol: "(",
        f: uO,
        notation: "prefix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "(",
      regSymbol: "\\("
    },
    ")": {
      postfix: {
        symbol: ")",
        f: void 0,
        notation: "postfix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: ")",
      regSymbol: "\\)"
    },
    min: {
      func: {
        symbol: "min",
        f: Z3,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "min",
      regSymbol: "min\\b"
    },
    max: {
      func: {
        symbol: "max",
        f: J3,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "max",
      regSymbol: "max\\b"
    }
  }
}, cO = tU, Je = /* @__PURE__ */ function(e) {
  V3(t, e);
  function t(r) {
    var n;
    return n = e.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + r + " for more information.") || this, U3(n);
  }
  return t;
}(/* @__PURE__ */ ub(Error)), pO = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g;
function rU(e) {
  var t = {};
  return t.symbols = e ? $t({}, cO.symbols, e.symbols) : $t({}, cO.symbols), t;
}
function fO(e, t) {
  var r, n = e.pop();
  return t.push(n.f.apply(n, (r = []).concat.apply(r, t.splice(-n.argCount)))), n.precedence;
}
function nU(e, t) {
  var r = rU(t), n, i = [r.symbols["("].prefix], s = [], o = new RegExp(
    // Pattern for numbers
    "\\d+(?:\\.\\d+)?|" + // ...and patterns for individual operators/function names
    Object.keys(r.symbols).map(function(_) {
      return r.symbols[_];
    }).sort(function(_, x) {
      return x.symbol.length - _.symbol.length;
    }).map(function(_) {
      return _.regSymbol;
    }).join("|") + "|(\\S)",
    "g"
  );
  o.lastIndex = 0;
  var a = !1;
  do {
    n = o.exec(e);
    var l = n || [")", void 0], p = l[0], f = l[1], d = r.symbols[p], m = d && !d.prefix && !d.func, v = !d || !d.postfix && !d.infix;
    if (f || (a ? v : m))
      throw new Je(37, n ? n.index : e.length, e);
    if (a) {
      var g = d.postfix || d.infix;
      do {
        var S = i[i.length - 1];
        if ((g.precedence - S.precedence || S.rightToLeft) > 0) break;
      } while (fO(i, s));
      a = g.notation === "postfix", g.symbol !== ")" && (i.push(g), a && fO(i, s));
    } else if (d) {
      if (i.push(d.prefix || d.func), d.func && (n = o.exec(e), !n || n[0] !== "("))
        throw new Je(38, n ? n.index : e.length, e);
    } else
      s.push(+p), a = !0;
  } while (n && i.length);
  if (i.length)
    throw new Je(39, n ? n.index : e.length, e);
  if (n)
    throw new Je(40, n ? n.index : e.length, e);
  return s.pop();
}
function Uy(e) {
  return e.split("").reverse().join("");
}
function iU(e, t) {
  var r = Uy(e), n = r.match(pO);
  if (n && !n.every(function(s) {
    return s === n[0];
  }))
    throw new Je(41);
  var i = Uy(r.replace(pO, ""));
  return "" + nU(i, t) + (n ? Uy(n[0]) : "");
}
var oU = /--[\S]*/g;
function sU(e, t) {
  if (!e || !e.match(oU))
    throw new Je(73);
  var r;
  if (typeof document < "u" && document.documentElement !== null && (r = getComputedStyle(document.documentElement).getPropertyValue(e)), r)
    return r.trim();
  if (t)
    return t;
  throw new Je(74);
}
function wc(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var aU = ["Top", "Right", "Bottom", "Left"];
function lU(e, t) {
  if (!e) return t.toLowerCase();
  var r = e.split("-");
  if (r.length > 1)
    return r.splice(1, 0, t), r.reduce(function(i, s) {
      return "" + i + wc(s);
    });
  var n = e.replace(/([a-z])([A-Z])/g, "$1" + t + "$2");
  return e === n ? "" + e + t : n;
}
function uU(e, t) {
  for (var r = {}, n = 0; n < t.length; n += 1)
    (t[n] || t[n] === 0) && (r[lU(e, aU[n])] = t[n]);
  return r;
}
function es(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  var i = r[0], s = r[1], o = s === void 0 ? i : s, a = r[2], l = a === void 0 ? i : a, p = r[3], f = p === void 0 ? o : p, d = [i, o, l, f];
  return uU(e, d);
}
function dO(e, t) {
  return e.substr(-t.length) === t;
}
var cU = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function cb(e) {
  if (typeof e != "string") return e;
  var t = e.match(cU);
  return t ? parseFloat(e) : e;
}
var pU = function(t) {
  return function(r, n) {
    n === void 0 && (n = "16px");
    var i = r, s = n;
    if (typeof r == "string") {
      if (!dO(r, "px"))
        throw new Je(69, t, r);
      i = cb(r);
    }
    if (typeof n == "string") {
      if (!dO(n, "px"))
        throw new Je(70, t, n);
      s = cb(n);
    }
    if (typeof i == "string")
      throw new Je(71, r, t);
    if (typeof s == "string")
      throw new Je(72, n, t);
    return "" + i / s + t;
  };
}, sI = pU, fU = sI("em"), dU = fU, hU = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function _i(e) {
  if (typeof e != "string") return [e, ""];
  var t = e.match(hU);
  return t ? [parseFloat(e), t[2]] : [e, void 0];
}
function aI(e, t) {
  if (typeof e != "object" || e === null)
    throw new Je(75, typeof e);
  var r = {};
  return Object.keys(e).forEach(function(n) {
    typeof e[n] == "object" && e[n] !== null ? r[n] = aI(e[n], t) : !t || t && (t === n || t.indexOf(n) >= 0) ? r[n] = e[n] + " !important" : r[n] = e[n];
  }), r;
}
var lI = {
  minorSecond: 1.067,
  majorSecond: 1.125,
  minorThird: 1.2,
  majorThird: 1.25,
  perfectFourth: 1.333,
  augFourth: 1.414,
  perfectFifth: 1.5,
  minorSixth: 1.6,
  goldenSection: 1.618,
  majorSixth: 1.667,
  minorSeventh: 1.778,
  majorSeventh: 1.875,
  octave: 2,
  majorTenth: 2.5,
  majorEleventh: 2.667,
  majorTwelfth: 3,
  doubleOctave: 4
};
function mU(e) {
  return lI[e];
}
function gU(e, t, r) {
  if (t === void 0 && (t = "1em"), r === void 0 && (r = 1.333), typeof e != "number")
    throw new Je(42);
  if (typeof r == "string" && !lI[r])
    throw new Je(43);
  var n = typeof t == "string" ? _i(t) : [t, ""], i = n[0], s = n[1], o = typeof r == "string" ? mU(r) : r;
  if (typeof i == "string")
    throw new Je(44, t);
  return "" + i * Math.pow(o, e) + (s || "");
}
var yU = sI("rem"), vU = yU, pb = 16;
function uI(e) {
  var t = _i(e);
  if (t[1] === "px")
    return parseFloat(e);
  if (t[1] === "%")
    return parseFloat(e) / 100 * pb;
  throw new Je(78, t[1]);
}
function bU() {
  if (typeof document < "u" && document.documentElement !== null) {
    var e = getComputedStyle(document.documentElement).fontSize;
    return e ? uI(e) : pb;
  }
  return pb;
}
function wU(e, t) {
  var r = _i(e);
  if (r[1] !== "rem" && r[1] !== "")
    throw new Je(77, r[1]);
  var n = t ? uI(t) : bU();
  return r[0] * n + "px";
}
var SU = {
  back: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  circ: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  cubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  expo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  quad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  quart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  quint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  sine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)"
};
function xU(e) {
  return SU[e.toLowerCase().trim()];
}
var _U = {
  back: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  circ: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  cubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  expo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  quad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  quart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  quint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  sine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function EU(e) {
  return _U[e.toLowerCase().trim()];
}
var OU = {
  back: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  cubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  circ: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  expo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  quad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  quart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  quint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  sine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)"
};
function kU(e) {
  return OU[e.toLowerCase().trim()];
}
function fb(e, t, r, n) {
  r === void 0 && (r = "320px"), n === void 0 && (n = "1200px");
  var i = _i(e), s = i[0], o = i[1], a = _i(t), l = a[0], p = a[1], f = _i(r), d = f[0], m = f[1], v = _i(n), g = v[0], S = v[1];
  if (typeof d != "number" || typeof g != "number" || !m || !S || m !== S)
    throw new Je(47);
  if (typeof s != "number" || typeof l != "number" || o !== p)
    throw new Je(48);
  if (o !== m || p !== S)
    throw new Je(76);
  var _ = (s - l) / (d - g), x = l - _ * g;
  return "calc(" + x.toFixed(2) + (o || "") + " + " + (100 * _).toFixed(2) + "vw)";
}
function AU(e) {
  var t;
  e === void 0 && (e = "&");
  var r = e + "::after";
  return t = {}, t[r] = {
    clear: "both",
    content: '""',
    display: "table"
  }, t;
}
function PU(e) {
  return e === void 0 && (e = 0), {
    position: "absolute",
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function CU(e, t) {
  t === void 0 && (t = 1);
  var r = {
    display: "inline-block",
    maxWidth: e || "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  return t > 1 ? $t({}, r, {
    WebkitBoxOrient: "vertical",
    WebkitLineClamp: t,
    display: "-webkit-box",
    whiteSpace: "normal"
  }) : r;
}
function TU(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = $U(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function $U(e, t) {
  if (e) {
    if (typeof e == "string") return hO(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return hO(e, t);
  }
}
function hO(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function RU(e, t, r) {
  if (t === void 0 && (t = "320px"), r === void 0 && (r = "1200px"), !Array.isArray(e) && typeof e != "object" || e === null)
    throw new Je(49);
  if (Array.isArray(e)) {
    for (var n = {}, i = {}, s = TU(e), o; !(o = s()).done; ) {
      var a, l, p = o.value;
      if (!p.prop || !p.fromSize || !p.toSize)
        throw new Je(50);
      i[p.prop] = p.fromSize, n["@media (min-width: " + t + ")"] = $t({}, n["@media (min-width: " + t + ")"], (a = {}, a[p.prop] = fb(p.fromSize, p.toSize, t, r), a)), n["@media (min-width: " + r + ")"] = $t({}, n["@media (min-width: " + r + ")"], (l = {}, l[p.prop] = p.toSize, l));
    }
    return $t({}, i, n);
  } else {
    var f, d, m;
    if (!e.prop || !e.fromSize || !e.toSize)
      throw new Je(51);
    return m = {}, m[e.prop] = e.fromSize, m["@media (min-width: " + t + ")"] = (f = {}, f[e.prop] = fb(e.fromSize, e.toSize, t, r), f), m["@media (min-width: " + r + ")"] = (d = {}, d[e.prop] = e.toSize, d), m;
  }
}
var IU = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i, jU = {
  woff: "woff",
  woff2: "woff2",
  ttf: "truetype",
  otf: "opentype",
  eot: "embedded-opentype",
  svg: "svg",
  svgz: "svg"
};
function mO(e, t) {
  return t ? ' format("' + jU[e] + '")' : "";
}
function NU(e) {
  return !!e.replace(/\s+/g, " ").match(IU);
}
function LU(e, t, r) {
  if (NU(e))
    return 'url("' + e + '")' + mO(t[0], r);
  var n = t.map(function(i) {
    return 'url("' + e + "." + i + '")' + mO(i, r);
  });
  return n.join(", ");
}
function MU(e) {
  var t = e.map(function(r) {
    return 'local("' + r + '")';
  });
  return t.join(", ");
}
function DU(e, t, r, n) {
  var i = [];
  return t && i.push(MU(t)), e && i.push(LU(e, r, n)), i.join(", ");
}
function FU(e) {
  var t = e.fontFamily, r = e.fontFilePath, n = e.fontStretch, i = e.fontStyle, s = e.fontVariant, o = e.fontWeight, a = e.fileFormats, l = a === void 0 ? ["eot", "woff2", "woff", "ttf", "svg"] : a, p = e.formatHint, f = p === void 0 ? !1 : p, d = e.localFonts, m = d === void 0 ? [t] : d, v = e.unicodeRange, g = e.fontDisplay, S = e.fontVariationSettings, _ = e.fontFeatureSettings;
  if (!t) throw new Je(55);
  if (!r && !m)
    throw new Je(52);
  if (m && !Array.isArray(m))
    throw new Je(53);
  if (!Array.isArray(l))
    throw new Je(54);
  var x = {
    "@font-face": {
      fontFamily: t,
      src: DU(r, m, l, f),
      unicodeRange: v,
      fontStretch: n,
      fontStyle: i,
      fontVariant: s,
      fontWeight: o,
      fontDisplay: g,
      fontVariationSettings: S,
      fontFeatureSettings: _
    }
  };
  return JSON.parse(JSON.stringify(x));
}
function zU() {
  return {
    textIndent: "101%",
    overflow: "hidden",
    whiteSpace: "nowrap"
  };
}
function qU() {
  return {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
}
function cI(e) {
  return e === void 0 && (e = 1.3), `
    @media only screen and (-webkit-min-device-pixel-ratio: ` + e + `),
    only screen and (min--moz-device-pixel-ratio: ` + e + `),
    only screen and (-o-min-device-pixel-ratio: ` + e + `/1),
    only screen and (min-resolution: ` + Math.round(e * 96) + `dpi),
    only screen and (min-resolution: ` + e + `dppx)
  `;
}
function pI(e) {
  for (var t = "", r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
    n[i - 1] = arguments[i];
  for (var s = 0; s < e.length; s += 1)
    if (t += e[s], s === n.length - 1 && n[s]) {
      var o = n.filter(function(a) {
        return !!a;
      });
      o.length > 1 ? (t = t.slice(0, -1), t += ", " + n[s]) : o.length === 1 && (t += "" + n[s]);
    } else n[s] && (t += n[s] + " ");
  return t.trim();
}
var gO;
function BU(e) {
  var t = e.colorStops, r = e.fallback, n = e.toDirection, i = n === void 0 ? "" : n;
  if (!t || t.length < 2)
    throw new Je(56);
  return {
    backgroundColor: r || t[0].replace(/,\s+/g, ",").split(" ")[0].replace(/,(?=\S)/g, ", "),
    backgroundImage: pI(gO || (gO = oI(["linear-gradient(", "", ")"])), i, t.join(", ").replace(/,(?=\S)/g, ", "))
  };
}
function UU() {
  var e;
  return [(e = {
    html: {
      lineHeight: "1.15",
      textSizeAdjust: "100%"
    },
    body: {
      margin: "0"
    },
    main: {
      display: "block"
    },
    h1: {
      fontSize: "2em",
      margin: "0.67em 0"
    },
    hr: {
      boxSizing: "content-box",
      height: "0",
      overflow: "visible"
    },
    pre: {
      fontFamily: "monospace, monospace",
      fontSize: "1em"
    },
    a: {
      backgroundColor: "transparent"
    },
    "abbr[title]": {
      borderBottom: "none",
      textDecoration: "underline"
    }
  }, e[`b,
    strong`] = {
    fontWeight: "bolder"
  }, e[`code,
    kbd,
    samp`] = {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  }, e.small = {
    fontSize: "80%"
  }, e[`sub,
    sup`] = {
    fontSize: "75%",
    lineHeight: "0",
    position: "relative",
    verticalAlign: "baseline"
  }, e.sub = {
    bottom: "-0.25em"
  }, e.sup = {
    top: "-0.5em"
  }, e.img = {
    borderStyle: "none"
  }, e[`button,
    input,
    optgroup,
    select,
    textarea`] = {
    fontFamily: "inherit",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: "0"
  }, e[`button,
    input`] = {
    overflow: "visible"
  }, e[`button,
    select`] = {
    textTransform: "none"
  }, e[`button,
    html [type="button"],
    [type="reset"],
    [type="submit"]`] = {
    WebkitAppearance: "button"
  }, e[`button::-moz-focus-inner,
    [type="button"]::-moz-focus-inner,
    [type="reset"]::-moz-focus-inner,
    [type="submit"]::-moz-focus-inner`] = {
    borderStyle: "none",
    padding: "0"
  }, e[`button:-moz-focusring,
    [type="button"]:-moz-focusring,
    [type="reset"]:-moz-focusring,
    [type="submit"]:-moz-focusring`] = {
    outline: "1px dotted ButtonText"
  }, e.fieldset = {
    padding: "0.35em 0.625em 0.75em"
  }, e.legend = {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: "0",
    whiteSpace: "normal"
  }, e.progress = {
    verticalAlign: "baseline"
  }, e.textarea = {
    overflow: "auto"
  }, e[`[type="checkbox"],
    [type="radio"]`] = {
    boxSizing: "border-box",
    padding: "0"
  }, e[`[type="number"]::-webkit-inner-spin-button,
    [type="number"]::-webkit-outer-spin-button`] = {
    height: "auto"
  }, e['[type="search"]'] = {
    WebkitAppearance: "textfield",
    outlineOffset: "-2px"
  }, e['[type="search"]::-webkit-search-decoration'] = {
    WebkitAppearance: "none"
  }, e["::-webkit-file-upload-button"] = {
    WebkitAppearance: "button",
    font: "inherit"
  }, e.details = {
    display: "block"
  }, e.summary = {
    display: "list-item"
  }, e.template = {
    display: "none"
  }, e["[hidden]"] = {
    display: "none"
  }, e), {
    "abbr[title]": {
      textDecoration: "underline dotted"
    }
  }];
}
var yO;
function VU(e) {
  var t = e.colorStops, r = e.extent, n = r === void 0 ? "" : r, i = e.fallback, s = e.position, o = s === void 0 ? "" : s, a = e.shape, l = a === void 0 ? "" : a;
  if (!t || t.length < 2)
    throw new Je(57);
  return {
    backgroundColor: i || t[0].split(" ")[0],
    backgroundImage: pI(yO || (yO = oI(["radial-gradient(", "", "", "", ")"])), o, l, n, t.join(", "))
  };
}
function WU(e, t, r, n, i) {
  var s;
  if (r === void 0 && (r = "png"), i === void 0 && (i = "_2x"), !e)
    throw new Je(58);
  var o = r.replace(/^\./, ""), a = n ? n + "." + o : "" + e + i + "." + o;
  return s = {
    backgroundImage: "url(" + e + "." + o + ")"
  }, s[cI()] = $t({
    backgroundImage: "url(" + a + ")"
  }, t ? {
    backgroundSize: t
  } : {}), s;
}
var HU = {
  easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  easeInCirc: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  easeInCubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  easeInExpo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  easeInQuad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  easeInQuart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  easeInQuint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  easeInSine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)",
  easeOutBack: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  easeOutCubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  easeOutCirc: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  easeOutExpo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  easeOutQuad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  easeOutQuart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  easeOutQuint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  easeOutSine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)",
  easeInOutBack: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  easeInOutCirc: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  easeInOutCubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  easeInOutExpo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  easeInOutQuad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  easeInOutQuart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  easeInOutQuint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  easeInOutSine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function QU(e) {
  return HU[e];
}
function YU(e) {
  return QU(e);
}
var GU = function(t, r, n) {
  var i = "" + n[0] + (n[1] || ""), s = "" + n[0] / 2 + (n[1] || ""), o = "" + r[0] + (r[1] || ""), a = "" + r[0] / 2 + (r[1] || "");
  switch (t) {
    case "top":
      return "0 " + s + " " + o + " " + s;
    case "topLeft":
      return i + " " + o + " 0 0";
    case "left":
      return a + " " + i + " " + a + " 0";
    case "bottomLeft":
      return i + " 0 0 " + o;
    case "bottom":
      return o + " " + s + " 0 " + s;
    case "bottomRight":
      return "0 0 " + i + " " + o;
    case "right":
      return a + " 0 " + a + " " + i;
    case "topRight":
    default:
      return "0 " + i + " " + o + " 0";
  }
}, KU = function(t, r) {
  switch (t) {
    case "top":
    case "bottomRight":
      return {
        borderBottomColor: r
      };
    case "right":
    case "bottomLeft":
      return {
        borderLeftColor: r
      };
    case "bottom":
    case "topLeft":
      return {
        borderTopColor: r
      };
    case "left":
    case "topRight":
      return {
        borderRightColor: r
      };
    default:
      throw new Je(59);
  }
};
function XU(e) {
  var t = e.pointingDirection, r = e.height, n = e.width, i = e.foregroundColor, s = e.backgroundColor, o = s === void 0 ? "transparent" : s, a = _i(n), l = _i(r);
  if (isNaN(l[0]) || isNaN(a[0]))
    throw new Je(60);
  return $t({
    width: "0",
    height: "0",
    borderColor: o
  }, KU(t, i), {
    borderStyle: "solid",
    borderWidth: GU(t, l, a)
  });
}
function JU(e) {
  e === void 0 && (e = "break-word");
  var t = e === "break-word" ? "break-all" : e;
  return {
    overflowWrap: e,
    wordWrap: e,
    wordBreak: t
  };
}
function Vy(e) {
  return Math.round(e * 255);
}
function ZU(e, t, r) {
  return Vy(e) + "," + Vy(t) + "," + Vy(r);
}
function Yc(e, t, r, n) {
  if (n === void 0 && (n = ZU), t === 0)
    return n(r, r, r);
  var i = (e % 360 + 360) % 360 / 60, s = (1 - Math.abs(2 * r - 1)) * t, o = s * (1 - Math.abs(i % 2 - 1)), a = 0, l = 0, p = 0;
  i >= 0 && i < 1 ? (a = s, l = o) : i >= 1 && i < 2 ? (a = o, l = s) : i >= 2 && i < 3 ? (l = s, p = o) : i >= 3 && i < 4 ? (l = o, p = s) : i >= 4 && i < 5 ? (a = o, p = s) : i >= 5 && i < 6 && (a = s, p = o);
  var f = r - s / 2, d = a + f, m = l + f, v = p + f;
  return n(d, m, v);
}
var vO = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function e5(e) {
  if (typeof e != "string") return e;
  var t = e.toLowerCase();
  return vO[t] ? "#" + vO[t] : e;
}
var t5 = /^#[a-fA-F0-9]{6}$/, r5 = /^#[a-fA-F0-9]{8}$/, n5 = /^#[a-fA-F0-9]{3}$/, i5 = /^#[a-fA-F0-9]{4}$/, Wy = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, o5 = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, s5 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, a5 = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function fo(e) {
  if (typeof e != "string")
    throw new Je(3);
  var t = e5(e);
  if (t.match(t5))
    return {
      red: parseInt("" + t[1] + t[2], 16),
      green: parseInt("" + t[3] + t[4], 16),
      blue: parseInt("" + t[5] + t[6], 16)
    };
  if (t.match(r5)) {
    var r = parseFloat((parseInt("" + t[7] + t[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + t[1] + t[2], 16),
      green: parseInt("" + t[3] + t[4], 16),
      blue: parseInt("" + t[5] + t[6], 16),
      alpha: r
    };
  }
  if (t.match(n5))
    return {
      red: parseInt("" + t[1] + t[1], 16),
      green: parseInt("" + t[2] + t[2], 16),
      blue: parseInt("" + t[3] + t[3], 16)
    };
  if (t.match(i5)) {
    var n = parseFloat((parseInt("" + t[4] + t[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + t[1] + t[1], 16),
      green: parseInt("" + t[2] + t[2], 16),
      blue: parseInt("" + t[3] + t[3], 16),
      alpha: n
    };
  }
  var i = Wy.exec(t);
  if (i)
    return {
      red: parseInt("" + i[1], 10),
      green: parseInt("" + i[2], 10),
      blue: parseInt("" + i[3], 10)
    };
  var s = o5.exec(t.substring(0, 50));
  if (s)
    return {
      red: parseInt("" + s[1], 10),
      green: parseInt("" + s[2], 10),
      blue: parseInt("" + s[3], 10),
      alpha: parseFloat("" + s[4]) > 1 ? parseFloat("" + s[4]) / 100 : parseFloat("" + s[4])
    };
  var o = s5.exec(t);
  if (o) {
    var a = parseInt("" + o[1], 10), l = parseInt("" + o[2], 10) / 100, p = parseInt("" + o[3], 10) / 100, f = "rgb(" + Yc(a, l, p) + ")", d = Wy.exec(f);
    if (!d)
      throw new Je(4, t, f);
    return {
      red: parseInt("" + d[1], 10),
      green: parseInt("" + d[2], 10),
      blue: parseInt("" + d[3], 10)
    };
  }
  var m = a5.exec(t.substring(0, 50));
  if (m) {
    var v = parseInt("" + m[1], 10), g = parseInt("" + m[2], 10) / 100, S = parseInt("" + m[3], 10) / 100, _ = "rgb(" + Yc(v, g, S) + ")", x = Wy.exec(_);
    if (!x)
      throw new Je(4, t, _);
    return {
      red: parseInt("" + x[1], 10),
      green: parseInt("" + x[2], 10),
      blue: parseInt("" + x[3], 10),
      alpha: parseFloat("" + m[4]) > 1 ? parseFloat("" + m[4]) / 100 : parseFloat("" + m[4])
    };
  }
  throw new Je(5);
}
function l5(e) {
  var t = e.red / 255, r = e.green / 255, n = e.blue / 255, i = Math.max(t, r, n), s = Math.min(t, r, n), o = (i + s) / 2;
  if (i === s)
    return e.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: o,
      alpha: e.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: o
    };
  var a, l = i - s, p = o > 0.5 ? l / (2 - i - s) : l / (i + s);
  switch (i) {
    case t:
      a = (r - n) / l + (r < n ? 6 : 0);
      break;
    case r:
      a = (n - t) / l + 2;
      break;
    default:
      a = (t - r) / l + 4;
      break;
  }
  return a *= 60, e.alpha !== void 0 ? {
    hue: a,
    saturation: p,
    lightness: o,
    alpha: e.alpha
  } : {
    hue: a,
    saturation: p,
    lightness: o
  };
}
function oi(e) {
  return l5(fo(e));
}
var u5 = function(t) {
  return t.length === 7 && t[1] === t[2] && t[3] === t[4] && t[5] === t[6] ? "#" + t[1] + t[3] + t[5] : t;
}, db = u5;
function Ds(e) {
  var t = e.toString(16);
  return t.length === 1 ? "0" + t : t;
}
function Hy(e) {
  return Ds(Math.round(e * 255));
}
function c5(e, t, r) {
  return db("#" + Hy(e) + Hy(t) + Hy(r));
}
function im(e, t, r) {
  return Yc(e, t, r, c5);
}
function Xw(e, t, r) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number")
    return im(e, t, r);
  if (typeof e == "object" && t === void 0 && r === void 0)
    return im(e.hue, e.saturation, e.lightness);
  throw new Je(1);
}
function Jw(e, t, r, n) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof n == "number")
    return n >= 1 ? im(e, t, r) : "rgba(" + Yc(e, t, r) + "," + n + ")";
  if (typeof e == "object" && t === void 0 && r === void 0 && n === void 0)
    return e.alpha >= 1 ? im(e.hue, e.saturation, e.lightness) : "rgba(" + Yc(e.hue, e.saturation, e.lightness) + "," + e.alpha + ")";
  throw new Je(2);
}
function Gc(e, t, r) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number")
    return db("#" + Ds(e) + Ds(t) + Ds(r));
  if (typeof e == "object" && t === void 0 && r === void 0)
    return db("#" + Ds(e.red) + Ds(e.green) + Ds(e.blue));
  throw new Je(6);
}
function Ul(e, t, r, n) {
  if (typeof e == "string" && typeof t == "number") {
    var i = fo(e);
    return "rgba(" + i.red + "," + i.green + "," + i.blue + "," + t + ")";
  } else {
    if (typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof n == "number")
      return n >= 1 ? Gc(e, t, r) : "rgba(" + e + "," + t + "," + r + "," + n + ")";
    if (typeof e == "object" && t === void 0 && r === void 0 && n === void 0)
      return e.alpha >= 1 ? Gc(e.red, e.green, e.blue) : "rgba(" + e.red + "," + e.green + "," + e.blue + "," + e.alpha + ")";
  }
  throw new Je(7);
}
var p5 = function(t) {
  return typeof t.red == "number" && typeof t.green == "number" && typeof t.blue == "number" && (typeof t.alpha != "number" || typeof t.alpha > "u");
}, f5 = function(t) {
  return typeof t.red == "number" && typeof t.green == "number" && typeof t.blue == "number" && typeof t.alpha == "number";
}, d5 = function(t) {
  return typeof t.hue == "number" && typeof t.saturation == "number" && typeof t.lightness == "number" && (typeof t.alpha != "number" || typeof t.alpha > "u");
}, h5 = function(t) {
  return typeof t.hue == "number" && typeof t.saturation == "number" && typeof t.lightness == "number" && typeof t.alpha == "number";
};
function Dn(e) {
  if (typeof e != "object") throw new Je(8);
  if (f5(e)) return Ul(e);
  if (p5(e)) return Gc(e);
  if (h5(e)) return Jw(e);
  if (d5(e)) return Xw(e);
  throw new Je(8);
}
function fI(e, t, r) {
  return function() {
    var i = r.concat(Array.prototype.slice.call(arguments));
    return i.length >= t ? e.apply(this, i) : fI(e, t, i);
  };
}
function bn(e) {
  return fI(e, e.length, []);
}
function m5(e, t) {
  if (t === "transparent") return t;
  var r = oi(t);
  return Dn($t({}, r, {
    hue: r.hue + parseFloat(e)
  }));
}
var g5 = bn(m5), y5 = g5;
function v5(e) {
  if (e === "transparent") return e;
  var t = oi(e);
  return Dn($t({}, t, {
    hue: (t.hue + 180) % 360
  }));
}
function Vl(e, t, r) {
  return Math.max(e, Math.min(t, r));
}
function b5(e, t) {
  if (t === "transparent") return t;
  var r = oi(t);
  return Dn($t({}, r, {
    lightness: Vl(0, 1, r.lightness - parseFloat(e))
  }));
}
var w5 = bn(b5), S5 = w5;
function x5(e, t) {
  if (t === "transparent") return t;
  var r = oi(t);
  return Dn($t({}, r, {
    saturation: Vl(0, 1, r.saturation - parseFloat(e))
  }));
}
var _5 = bn(x5), E5 = _5;
function om(e) {
  if (e === "transparent") return 0;
  var t = fo(e), r = Object.keys(t).map(function(o) {
    var a = t[o] / 255;
    return a <= 0.03928 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
  }), n = r[0], i = r[1], s = r[2];
  return parseFloat((0.2126 * n + 0.7152 * i + 0.0722 * s).toFixed(3));
}
function Zw(e, t) {
  var r = om(e), n = om(t);
  return parseFloat((r > n ? (r + 0.05) / (n + 0.05) : (n + 0.05) / (r + 0.05)).toFixed(2));
}
function O5(e) {
  return e === "transparent" ? e : Dn($t({}, oi(e), {
    saturation: 0
  }));
}
function k5(e) {
  if (typeof e == "object" && typeof e.hue == "number" && typeof e.saturation == "number" && typeof e.lightness == "number")
    return e.alpha && typeof e.alpha == "number" ? Jw({
      hue: e.hue,
      saturation: e.saturation,
      lightness: e.lightness,
      alpha: e.alpha
    }) : Xw({
      hue: e.hue,
      saturation: e.saturation,
      lightness: e.lightness
    });
  throw new Je(45);
}
function A5(e) {
  if (e === "transparent") return e;
  var t = fo(e);
  return Dn($t({}, t, {
    red: 255 - t.red,
    green: 255 - t.green,
    blue: 255 - t.blue
  }));
}
function P5(e, t) {
  if (t === "transparent") return t;
  var r = oi(t);
  return Dn($t({}, r, {
    lightness: Vl(0, 1, r.lightness + parseFloat(e))
  }));
}
var C5 = bn(P5), T5 = C5;
function $5(e, t) {
  var r = Zw(e, t);
  return {
    AA: r >= 4.5,
    AALarge: r >= 3,
    AAA: r >= 7,
    AAALarge: r >= 4.5
  };
}
function R5(e, t, r) {
  if (t === "transparent") return r;
  if (r === "transparent") return t;
  if (e === 0) return r;
  var n = fo(t), i = $t({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), s = fo(r), o = $t({}, s, {
    alpha: typeof s.alpha == "number" ? s.alpha : 1
  }), a = i.alpha - o.alpha, l = parseFloat(e) * 2 - 1, p = l * a === -1 ? l : l + a, f = 1 + l * a, d = (p / f + 1) / 2, m = 1 - d, v = {
    red: Math.floor(i.red * d + o.red * m),
    green: Math.floor(i.green * d + o.green * m),
    blue: Math.floor(i.blue * d + o.blue * m),
    alpha: i.alpha * parseFloat(e) + o.alpha * (1 - parseFloat(e))
  };
  return Ul(v);
}
var I5 = bn(R5), eS = I5;
function j5(e, t) {
  if (t === "transparent") return t;
  var r = fo(t), n = typeof r.alpha == "number" ? r.alpha : 1, i = $t({}, r, {
    alpha: Vl(0, 1, (n * 100 + parseFloat(e) * 100) / 100)
  });
  return Ul(i);
}
var N5 = bn(j5), L5 = N5, bO = "#000", wO = "#fff";
function M5(e, t, r, n) {
  t === void 0 && (t = bO), r === void 0 && (r = wO), n === void 0 && (n = !0);
  var i = om(e) > 0.179, s = i ? t : r;
  return !n || Zw(e, s) >= 4.5 ? s : i ? bO : wO;
}
function D5(e) {
  if (typeof e == "object" && typeof e.red == "number" && typeof e.green == "number" && typeof e.blue == "number")
    return typeof e.alpha == "number" ? Ul({
      red: e.red,
      green: e.green,
      blue: e.blue,
      alpha: e.alpha
    }) : Gc({
      red: e.red,
      green: e.green,
      blue: e.blue
    });
  throw new Je(46);
}
function F5(e, t) {
  if (t === "transparent") return t;
  var r = oi(t);
  return Dn($t({}, r, {
    saturation: Vl(0, 1, r.saturation + parseFloat(e))
  }));
}
var z5 = bn(F5), q5 = z5;
function B5(e, t) {
  return t === "transparent" ? t : Dn($t({}, oi(t), {
    hue: parseFloat(e)
  }));
}
var U5 = bn(B5), V5 = U5;
function W5(e, t) {
  return t === "transparent" ? t : Dn($t({}, oi(t), {
    lightness: parseFloat(e)
  }));
}
var H5 = bn(W5), Q5 = H5;
function Y5(e, t) {
  return t === "transparent" ? t : Dn($t({}, oi(t), {
    saturation: parseFloat(e)
  }));
}
var G5 = bn(Y5), K5 = G5;
function X5(e, t) {
  return t === "transparent" ? t : eS(parseFloat(e), "rgb(0, 0, 0)", t);
}
var J5 = bn(X5), Z5 = J5;
function e4(e, t) {
  return t === "transparent" ? t : eS(parseFloat(e), "rgb(255, 255, 255)", t);
}
var t4 = bn(e4), r4 = t4;
function n4(e, t) {
  if (t === "transparent") return t;
  var r = fo(t), n = typeof r.alpha == "number" ? r.alpha : 1, i = $t({}, r, {
    alpha: Vl(0, 1, +(n * 100 - parseFloat(e) * 100).toFixed(2) / 100)
  });
  return Ul(i);
}
var i4 = bn(n4), o4 = i4;
function s4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = Array.isArray(t[0]);
  if (!n && t.length > 8)
    throw new Je(64);
  var i = t.map(function(s) {
    if (n && !Array.isArray(s) || !n && Array.isArray(s))
      throw new Je(65);
    if (Array.isArray(s) && s.length > 8)
      throw new Je(66);
    return Array.isArray(s) ? s.join(" ") : s;
  }).join(", ");
  return {
    animation: i
  };
}
function a4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return {
    backgroundImage: t.join(", ")
  };
}
function l4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return {
    background: t.join(", ")
  };
}
var u4 = ["top", "right", "bottom", "left"];
function c4(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  if (typeof e == "string" && u4.indexOf(e) >= 0) {
    var i;
    return i = {}, i["border" + wc(e) + "Width"] = r[0], i["border" + wc(e) + "Style"] = r[1], i["border" + wc(e) + "Color"] = r[2], i;
  } else
    return r.unshift(e), {
      borderWidth: r[0],
      borderStyle: r[1],
      borderColor: r[2]
    };
}
function p4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return es.apply(void 0, ["borderColor"].concat(t));
}
function f4(e, t) {
  var r = wc(e);
  if (!t && t !== 0)
    throw new Je(62);
  if (r === "Top" || r === "Bottom") {
    var n;
    return n = {}, n["border" + r + "RightRadius"] = t, n["border" + r + "LeftRadius"] = t, n;
  }
  if (r === "Left" || r === "Right") {
    var i;
    return i = {}, i["borderTop" + r + "Radius"] = t, i["borderBottom" + r + "Radius"] = t, i;
  }
  throw new Je(63);
}
function d4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return es.apply(void 0, ["borderStyle"].concat(t));
}
function h4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return es.apply(void 0, ["borderWidth"].concat(t));
}
function SO(e, t) {
  var r = t ? ":" + t : "";
  return e(r);
}
function dI(e, t, r) {
  if (!t) throw new Je(67);
  if (e.length === 0) return SO(t, null);
  for (var n = [], i = 0; i < e.length; i += 1) {
    if (r && r.indexOf(e[i]) < 0)
      throw new Je(68);
    n.push(SO(t, e[i]));
  }
  return n = n.join(","), n;
}
var m4 = [void 0, null, "active", "focus", "hover"];
function g4(e) {
  return "button" + e + `,
  input[type="button"]` + e + `,
  input[type="reset"]` + e + `,
  input[type="submit"]` + e;
}
function y4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return dI(t, g4, m4);
}
function v4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return es.apply(void 0, ["margin"].concat(t));
}
function b4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return es.apply(void 0, ["padding"].concat(t));
}
var w4 = ["absolute", "fixed", "relative", "static", "sticky"];
function S4(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return w4.indexOf(e) >= 0 && e ? $t({}, es.apply(void 0, [""].concat(r)), {
    position: e
  }) : es.apply(void 0, ["", e].concat(r));
}
function x4(e, t) {
  return t === void 0 && (t = e), {
    height: e,
    width: t
  };
}
var _4 = [void 0, null, "active", "focus", "hover"];
function E4(e) {
  return 'input[type="color"]' + e + `,
    input[type="date"]` + e + `,
    input[type="datetime"]` + e + `,
    input[type="datetime-local"]` + e + `,
    input[type="email"]` + e + `,
    input[type="month"]` + e + `,
    input[type="number"]` + e + `,
    input[type="password"]` + e + `,
    input[type="search"]` + e + `,
    input[type="tel"]` + e + `,
    input[type="text"]` + e + `,
    input[type="time"]` + e + `,
    input[type="url"]` + e + `,
    input[type="week"]` + e + `,
    input:not([type])` + e + `,
    textarea` + e;
}
function O4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return dI(t, E4, _4);
}
function k4() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (Array.isArray(t[0]) && t.length === 2) {
    var n = t[1];
    if (typeof n != "string")
      throw new Je(61);
    var i = t[0].map(function(s) {
      return s + " " + n;
    }).join(", ");
    return {
      transition: i
    };
  } else
    return {
      transition: t.join(", ")
    };
}
const A4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  adjustHue: y5,
  animation: s4,
  backgroundImages: a4,
  backgrounds: l4,
  between: fb,
  border: c4,
  borderColor: p4,
  borderRadius: f4,
  borderStyle: d4,
  borderWidth: h4,
  buttons: y4,
  clearFix: AU,
  complement: v5,
  cover: PU,
  cssVar: sU,
  darken: S5,
  desaturate: E5,
  directionalProperty: es,
  easeIn: xU,
  easeInOut: EU,
  easeOut: kU,
  ellipsis: CU,
  em: dU,
  fluidRange: RU,
  fontFace: FU,
  getContrast: Zw,
  getLuminance: om,
  getValueAndUnit: _i,
  grayscale: O5,
  hiDPI: cI,
  hideText: zU,
  hideVisually: qU,
  hsl: Xw,
  hslToColorString: k5,
  hsla: Jw,
  important: aI,
  invert: A5,
  lighten: T5,
  linearGradient: BU,
  margin: v4,
  math: iU,
  meetsContrastGuidelines: $5,
  mix: eS,
  modularScale: gU,
  normalize: UU,
  opacify: L5,
  padding: b4,
  parseToHsl: oi,
  parseToRgb: fo,
  position: S4,
  radialGradient: VU,
  readableColor: M5,
  rem: vU,
  remToPx: wU,
  retinaImage: WU,
  rgb: Gc,
  rgbToColorString: D5,
  rgba: Ul,
  saturate: q5,
  setHue: V5,
  setLightness: Q5,
  setSaturation: K5,
  shade: Z5,
  size: x4,
  stripUnit: cb,
  textInputs: O4,
  timingFunctions: YU,
  tint: r4,
  toColorString: Dn,
  transitions: k4,
  transparentize: o4,
  triangle: XU,
  wordWrap: JU
}, Symbol.toStringTag, { value: "Module" })), P4 = /* @__PURE__ */ Ri(A4);
var Qy = { exports: {} }, xO;
function C4() {
  return xO || (xO = 1, function(e, t) {
    (function(r, n, i) {
      e.exports = i(), e.exports.default = i();
    })("slugify", pn, function() {
      var r = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ō":"O","ō":"o","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","Ə":"E","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","ə":"e","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","‘":"'","’":"'","“":"\\"","”":"\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₺":"turkish lira","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial"}`), n = JSON.parse('{"de":{"Ä":"AE","ä":"ae","Ö":"OE","ö":"oe","Ü":"UE","ü":"ue","%":"prozent","&":"und","|":"oder","∑":"summe","∞":"unendlich","♥":"liebe"},"vi":{"Đ":"D","đ":"d"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","¢":"centime","£":"livre","¤":"devise","₣":"franc","∑":"somme","∞":"infini","♥":"amour"}}');
      function i(s, o) {
        if (typeof s != "string")
          throw new Error("slugify: string argument expected");
        o = typeof o == "string" ? { replacement: o } : o || {};
        var a = n[o.locale] || {}, l = o.replacement === void 0 ? "-" : o.replacement, p = s.split("").reduce(function(f, d) {
          return f + (a[d] || r[d] || d).replace(o.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "").trim().replace(new RegExp("[\\s" + l + "]+", "g"), l);
        return o.lower && (p = p.toLowerCase()), o.strict && (p = p.replace(new RegExp("[^a-zA-Z0-9" + l + "]", "g"), "").replace(new RegExp("[\\s" + l + "]+", "g"), l)), p;
      }
      return i.extend = function(s) {
        for (var o in s)
          r[o] = s[o];
      }, i;
    });
  }(Qy)), Qy.exports;
}
var or = function() {
  return or = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, or.apply(this, arguments);
};
function Pl(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, s; n < i; n++)
    (s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), s[n] = t[n]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var T4 = function(t, r, n, i) {
  var s = n ? n.call(i, t, r) : void 0;
  if (s !== void 0)
    return !!s;
  if (t === r)
    return !0;
  if (typeof t != "object" || !t || typeof r != "object" || !r)
    return !1;
  var o = Object.keys(t), a = Object.keys(r);
  if (o.length !== a.length)
    return !1;
  for (var l = Object.prototype.hasOwnProperty.bind(r), p = 0; p < o.length; p++) {
    var f = o[p];
    if (!l(f))
      return !1;
    var d = t[f], m = r[f];
    if (s = n ? n.call(i, d, m, f) : void 0, s === !1 || s === void 0 && d !== m)
      return !1;
  }
  return !0;
};
const $4 = /* @__PURE__ */ Hb(T4);
var jt = "-ms-", Sc = "-moz-", bt = "-webkit-", hI = "comm", Jm = "rule", tS = "decl", R4 = "@import", mI = "@keyframes", I4 = "@layer", gI = Math.abs, rS = String.fromCharCode, hb = Object.assign;
function j4(e, t) {
  return fr(e, 0) ^ 45 ? (((t << 2 ^ fr(e, 0)) << 2 ^ fr(e, 1)) << 2 ^ fr(e, 2)) << 2 ^ fr(e, 3) : 0;
}
function yI(e) {
  return e.trim();
}
function Ki(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function st(e, t, r) {
  return e.replace(t, r);
}
function xh(e, t, r) {
  return e.indexOf(t, r);
}
function fr(e, t) {
  return e.charCodeAt(t) | 0;
}
function Cl(e, t, r) {
  return e.slice(t, r);
}
function wi(e) {
  return e.length;
}
function vI(e) {
  return e.length;
}
function ac(e, t) {
  return t.push(e), e;
}
function N4(e, t) {
  return e.map(t).join("");
}
function _O(e, t) {
  return e.filter(function(r) {
    return !Ki(r, t);
  });
}
var Zm = 1, Tl = 1, bI = 0, Ln = 0, nr = 0, Wl = "";
function eg(e, t, r, n, i, s, o, a) {
  return { value: e, root: t, parent: r, type: n, props: i, children: s, line: Zm, column: Tl, length: o, return: "", siblings: a };
}
function Co(e, t) {
  return hb(eg("", null, null, "", null, null, 0, e.siblings), e, { length: -e.length }, t);
}
function Da(e) {
  for (; e.root; )
    e = Co(e.root, { children: [e] });
  ac(e, e.siblings);
}
function L4() {
  return nr;
}
function M4() {
  return nr = Ln > 0 ? fr(Wl, --Ln) : 0, Tl--, nr === 10 && (Tl = 1, Zm--), nr;
}
function Zn() {
  return nr = Ln < bI ? fr(Wl, Ln++) : 0, Tl++, nr === 10 && (Tl = 1, Zm++), nr;
}
function Ys() {
  return fr(Wl, Ln);
}
function _h() {
  return Ln;
}
function tg(e, t) {
  return Cl(Wl, e, t);
}
function mb(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function D4(e) {
  return Zm = Tl = 1, bI = wi(Wl = e), Ln = 0, [];
}
function F4(e) {
  return Wl = "", e;
}
function Yy(e) {
  return yI(tg(Ln - 1, gb(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function z4(e) {
  for (; (nr = Ys()) && nr < 33; )
    Zn();
  return mb(e) > 2 || mb(nr) > 3 ? "" : " ";
}
function q4(e, t) {
  for (; --t && Zn() && !(nr < 48 || nr > 102 || nr > 57 && nr < 65 || nr > 70 && nr < 97); )
    ;
  return tg(e, _h() + (t < 6 && Ys() == 32 && Zn() == 32));
}
function gb(e) {
  for (; Zn(); )
    switch (nr) {
      case e:
        return Ln;
      case 34:
      case 39:
        e !== 34 && e !== 39 && gb(nr);
        break;
      case 40:
        e === 41 && gb(e);
        break;
      case 92:
        Zn();
        break;
    }
  return Ln;
}
function B4(e, t) {
  for (; Zn() && e + nr !== 57; )
    if (e + nr === 84 && Ys() === 47)
      break;
  return "/*" + tg(t, Ln - 1) + "*" + rS(e === 47 ? e : Zn());
}
function U4(e) {
  for (; !mb(Ys()); )
    Zn();
  return tg(e, Ln);
}
function V4(e) {
  return F4(Eh("", null, null, null, [""], e = D4(e), 0, [0], e));
}
function Eh(e, t, r, n, i, s, o, a, l) {
  for (var p = 0, f = 0, d = o, m = 0, v = 0, g = 0, S = 1, _ = 1, x = 1, y = 0, w = "", k = i, A = s, T = n, R = w; _; )
    switch (g = y, y = Zn()) {
      case 40:
        if (g != 108 && fr(R, d - 1) == 58) {
          xh(R += st(Yy(y), "&", "&\f"), "&\f", gI(p ? a[p - 1] : 0)) != -1 && (x = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        R += Yy(y);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        R += z4(g);
        break;
      case 92:
        R += q4(_h() - 1, 7);
        continue;
      case 47:
        switch (Ys()) {
          case 42:
          case 47:
            ac(W4(B4(Zn(), _h()), t, r, l), l);
            break;
          default:
            R += "/";
        }
        break;
      case 123 * S:
        a[p++] = wi(R) * x;
      case 125 * S:
      case 59:
      case 0:
        switch (y) {
          case 0:
          case 125:
            _ = 0;
          case 59 + f:
            x == -1 && (R = st(R, /\f/g, "")), v > 0 && wi(R) - d && ac(v > 32 ? OO(R + ";", n, r, d - 1, l) : OO(st(R, " ", "") + ";", n, r, d - 2, l), l);
            break;
          case 59:
            R += ";";
          default:
            if (ac(T = EO(R, t, r, p, f, i, a, w, k = [], A = [], d, s), s), y === 123)
              if (f === 0)
                Eh(R, t, T, T, k, s, d, a, A);
              else
                switch (m === 99 && fr(R, 3) === 110 ? 100 : m) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Eh(e, T, T, n && ac(EO(e, T, T, 0, 0, i, a, w, i, k = [], d, A), A), i, A, d, a, n ? k : A);
                    break;
                  default:
                    Eh(R, T, T, T, [""], A, 0, a, A);
                }
        }
        p = f = v = 0, S = x = 1, w = R = "", d = o;
        break;
      case 58:
        d = 1 + wi(R), v = g;
      default:
        if (S < 1) {
          if (y == 123)
            --S;
          else if (y == 125 && S++ == 0 && M4() == 125)
            continue;
        }
        switch (R += rS(y), y * S) {
          case 38:
            x = f > 0 ? 1 : (R += "\f", -1);
            break;
          case 44:
            a[p++] = (wi(R) - 1) * x, x = 1;
            break;
          case 64:
            Ys() === 45 && (R += Yy(Zn())), m = Ys(), f = d = wi(w = R += U4(_h())), y++;
            break;
          case 45:
            g === 45 && wi(R) == 2 && (S = 0);
        }
    }
  return s;
}
function EO(e, t, r, n, i, s, o, a, l, p, f, d) {
  for (var m = i - 1, v = i === 0 ? s : [""], g = vI(v), S = 0, _ = 0, x = 0; S < n; ++S)
    for (var y = 0, w = Cl(e, m + 1, m = gI(_ = o[S])), k = e; y < g; ++y)
      (k = yI(_ > 0 ? v[y] + " " + w : st(w, /&\f/g, v[y]))) && (l[x++] = k);
  return eg(e, t, r, i === 0 ? Jm : a, l, p, f, d);
}
function W4(e, t, r, n) {
  return eg(e, t, r, hI, rS(L4()), Cl(e, 2, -2), 0, n);
}
function OO(e, t, r, n, i) {
  return eg(e, t, r, tS, Cl(e, 0, n), Cl(e, n + 1, -1), n, i);
}
function wI(e, t, r) {
  switch (j4(e, t)) {
    case 5103:
      return bt + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return bt + e + e;
    case 4789:
      return Sc + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return bt + e + Sc + e + jt + e + e;
    case 5936:
      switch (fr(e, t + 11)) {
        case 114:
          return bt + e + jt + st(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return bt + e + jt + st(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return bt + e + jt + st(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
    case 6828:
    case 4268:
    case 2903:
      return bt + e + jt + e + e;
    case 6165:
      return bt + e + jt + "flex-" + e + e;
    case 5187:
      return bt + e + st(e, /(\w+).+(:[^]+)/, bt + "box-$1$2" + jt + "flex-$1$2") + e;
    case 5443:
      return bt + e + jt + "flex-item-" + st(e, /flex-|-self/g, "") + (Ki(e, /flex-|baseline/) ? "" : jt + "grid-row-" + st(e, /flex-|-self/g, "")) + e;
    case 4675:
      return bt + e + jt + "flex-line-pack" + st(e, /align-content|flex-|-self/g, "") + e;
    case 5548:
      return bt + e + jt + st(e, "shrink", "negative") + e;
    case 5292:
      return bt + e + jt + st(e, "basis", "preferred-size") + e;
    case 6060:
      return bt + "box-" + st(e, "-grow", "") + bt + e + jt + st(e, "grow", "positive") + e;
    case 4554:
      return bt + st(e, /([^-])(transform)/g, "$1" + bt + "$2") + e;
    case 6187:
      return st(st(st(e, /(zoom-|grab)/, bt + "$1"), /(image-set)/, bt + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return st(e, /(image-set\([^]*)/, bt + "$1$`$1");
    case 4968:
      return st(st(e, /(.+:)(flex-)?(.*)/, bt + "box-pack:$3" + jt + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + bt + e + e;
    case 4200:
      if (!Ki(e, /flex-|baseline/)) return jt + "grid-column-align" + Cl(e, t) + e;
      break;
    case 2592:
    case 3360:
      return jt + st(e, "template-", "") + e;
    case 4384:
    case 3616:
      return r && r.some(function(n, i) {
        return t = i, Ki(n.props, /grid-\w+-end/);
      }) ? ~xh(e + (r = r[t].value), "span", 0) ? e : jt + st(e, "-start", "") + e + jt + "grid-row-span:" + (~xh(r, "span", 0) ? Ki(r, /\d+/) : +Ki(r, /\d+/) - +Ki(e, /\d+/)) + ";" : jt + st(e, "-start", "") + e;
    case 4896:
    case 4128:
      return r && r.some(function(n) {
        return Ki(n.props, /grid-\w+-start/);
      }) ? e : jt + st(st(e, "-end", "-span"), "span ", "") + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return st(e, /(.+)-inline(.+)/, bt + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (wi(e) - 1 - t > 6)
        switch (fr(e, t + 1)) {
          case 109:
            if (fr(e, t + 4) !== 45)
              break;
          case 102:
            return st(e, /(.+:)(.+)-([^]+)/, "$1" + bt + "$2-$3$1" + Sc + (fr(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~xh(e, "stretch", 0) ? wI(st(e, "stretch", "fill-available"), t, r) + e : e;
        }
      break;
    case 5152:
    case 5920:
      return st(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(n, i, s, o, a, l, p) {
        return jt + i + ":" + s + p + (o ? jt + i + "-span:" + (a ? l : +l - +s) + p : "") + e;
      });
    case 4949:
      if (fr(e, t + 6) === 121)
        return st(e, ":", ":" + bt) + e;
      break;
    case 6444:
      switch (fr(e, fr(e, 14) === 45 ? 18 : 11)) {
        case 120:
          return st(e, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + bt + (fr(e, 14) === 45 ? "inline-" : "") + "box$3$1" + bt + "$2$3$1" + jt + "$2box$3") + e;
        case 100:
          return st(e, ":", ":" + jt) + e;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return st(e, "scroll-", "scroll-snap-") + e;
  }
  return e;
}
function sm(e, t) {
  for (var r = "", n = 0; n < e.length; n++)
    r += t(e[n], n, e, t) || "";
  return r;
}
function H4(e, t, r, n) {
  switch (e.type) {
    case I4:
      if (e.children.length) break;
    case R4:
    case tS:
      return e.return = e.return || e.value;
    case hI:
      return "";
    case mI:
      return e.return = e.value + "{" + sm(e.children, n) + "}";
    case Jm:
      if (!wi(e.value = e.props.join(","))) return "";
  }
  return wi(r = sm(e.children, n)) ? e.return = e.value + "{" + r + "}" : "";
}
function Q4(e) {
  var t = vI(e);
  return function(r, n, i, s) {
    for (var o = "", a = 0; a < t; a++)
      o += e[a](r, n, i, s) || "";
    return o;
  };
}
function Y4(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function G4(e, t, r, n) {
  if (e.length > -1 && !e.return)
    switch (e.type) {
      case tS:
        e.return = wI(e.value, e.length, r);
        return;
      case mI:
        return sm([Co(e, { value: st(e.value, "@", "@" + bt) })], n);
      case Jm:
        if (e.length)
          return N4(r = e.props, function(i) {
            switch (Ki(i, n = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Da(Co(e, { props: [st(i, /:(read-\w+)/, ":" + Sc + "$1")] })), Da(Co(e, { props: [i] })), hb(e, { props: _O(r, n) });
                break;
              case "::placeholder":
                Da(Co(e, { props: [st(i, /:(plac\w+)/, ":" + bt + "input-$1")] })), Da(Co(e, { props: [st(i, /:(plac\w+)/, ":" + Sc + "$1")] })), Da(Co(e, { props: [st(i, /:(plac\w+)/, jt + "input-$1")] })), Da(Co(e, { props: [i] })), hb(e, { props: _O(r, n) });
                break;
            }
            return "";
          });
    }
}
var K4 = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, ts = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", SI = "active", am = "data-styled-version", ta = "6.1.13", nS = `/*!sc*/
`, lm = typeof window < "u" && "HTMLElement" in window, X4 = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" && process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY), J4 = {}, rg = Object.freeze([]), $l = Object.freeze({});
function iS(e, t, r) {
  return r === void 0 && (r = $l), e.theme !== r.theme && e.theme || t || r.theme;
}
var xI = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), Z4 = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, e6 = /(^-|-$)/g;
function kO(e) {
  return e.replace(Z4, "-").replace(e6, "");
}
var t6 = /(a)(d)/gi, Qf = 52, AO = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function yb(e) {
  var t, r = "";
  for (t = Math.abs(e); t > Qf; t = t / Qf | 0) r = AO(t % Qf) + r;
  return (AO(t % Qf) + r).replace(t6, "$1-$2");
}
var Gy, _I = 5381, ll = function(e, t) {
  for (var r = t.length; r; ) e = 33 * e ^ t.charCodeAt(--r);
  return e;
}, EI = function(e) {
  return ll(_I, e);
};
function oS(e) {
  return yb(EI(e) >>> 0);
}
function OI(e) {
  return e.displayName || e.name || "Component";
}
function Ky(e) {
  return typeof e == "string" && !0;
}
var kI = typeof Symbol == "function" && Symbol.for, AI = kI ? Symbol.for("react.memo") : 60115, r6 = kI ? Symbol.for("react.forward_ref") : 60112, n6 = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, i6 = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, PI = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, o6 = ((Gy = {})[r6] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, Gy[AI] = PI, Gy);
function PO(e) {
  return ("type" in (t = e) && t.type.$$typeof) === AI ? PI : "$$typeof" in e ? o6[e.$$typeof] : n6;
  var t;
}
var s6 = Object.defineProperty, a6 = Object.getOwnPropertyNames, CO = Object.getOwnPropertySymbols, l6 = Object.getOwnPropertyDescriptor, u6 = Object.getPrototypeOf, TO = Object.prototype;
function sS(e, t, r) {
  if (typeof t != "string") {
    if (TO) {
      var n = u6(t);
      n && n !== TO && sS(e, n, r);
    }
    var i = a6(t);
    CO && (i = i.concat(CO(t)));
    for (var s = PO(e), o = PO(t), a = 0; a < i.length; ++a) {
      var l = i[a];
      if (!(l in i6 || r && r[l] || o && l in o || s && l in s)) {
        var p = l6(t, l);
        try {
          s6(e, l, p);
        } catch {
        }
      }
    }
  }
  return e;
}
function ra(e) {
  return typeof e == "function";
}
function ng(e) {
  return typeof e == "object" && "styledComponentId" in e;
}
function Vs(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function Kc(e, t) {
  if (e.length === 0) return "";
  for (var r = e[0], n = 1; n < e.length; n++) r += t ? t + e[n] : e[n];
  return r;
}
function Xc(e) {
  return e !== null && typeof e == "object" && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function vb(e, t, r) {
  if (r === void 0 && (r = !1), !r && !Xc(e) && !Array.isArray(e)) return t;
  if (Array.isArray(t)) for (var n = 0; n < t.length; n++) e[n] = vb(e[n], t[n]);
  else if (Xc(t)) for (var n in t) e[n] = vb(e[n], t[n]);
  return e;
}
function aS(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
function Rn(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e, " for more information.").concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : ""));
}
var c6 = function() {
  function e(t) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t;
  }
  return e.prototype.indexOfGroup = function(t) {
    for (var r = 0, n = 0; n < t; n++) r += this.groupSizes[n];
    return r;
  }, e.prototype.insertRules = function(t, r) {
    if (t >= this.groupSizes.length) {
      for (var n = this.groupSizes, i = n.length, s = i; t >= s; ) if ((s <<= 1) < 0) throw Rn(16, "".concat(t));
      this.groupSizes = new Uint32Array(s), this.groupSizes.set(n), this.length = s;
      for (var o = i; o < s; o++) this.groupSizes[o] = 0;
    }
    for (var a = this.indexOfGroup(t + 1), l = (o = 0, r.length); o < l; o++) this.tag.insertRule(a, r[o]) && (this.groupSizes[t]++, a++);
  }, e.prototype.clearGroup = function(t) {
    if (t < this.length) {
      var r = this.groupSizes[t], n = this.indexOfGroup(t), i = n + r;
      this.groupSizes[t] = 0;
      for (var s = n; s < i; s++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(t) {
    var r = "";
    if (t >= this.length || this.groupSizes[t] === 0) return r;
    for (var n = this.groupSizes[t], i = this.indexOfGroup(t), s = i + n, o = i; o < s; o++) r += "".concat(this.tag.getRule(o)).concat(nS);
    return r;
  }, e;
}(), Oh = /* @__PURE__ */ new Map(), um = /* @__PURE__ */ new Map(), kh = 1, Yf = function(e) {
  if (Oh.has(e)) return Oh.get(e);
  for (; um.has(kh); ) kh++;
  var t = kh++;
  return Oh.set(e, t), um.set(t, e), t;
}, p6 = function(e, t) {
  kh = t + 1, Oh.set(e, t), um.set(t, e);
}, f6 = "style[".concat(ts, "][").concat(am, '="').concat(ta, '"]'), d6 = new RegExp("^".concat(ts, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), h6 = function(e, t, r) {
  for (var n, i = r.split(","), s = 0, o = i.length; s < o; s++) (n = i[s]) && e.registerName(t, n);
}, m6 = function(e, t) {
  for (var r, n = ((r = t.textContent) !== null && r !== void 0 ? r : "").split(nS), i = [], s = 0, o = n.length; s < o; s++) {
    var a = n[s].trim();
    if (a) {
      var l = a.match(d6);
      if (l) {
        var p = 0 | parseInt(l[1], 10), f = l[2];
        p !== 0 && (p6(f, p), h6(e, f, l[3]), e.getTag().insertRules(p, i)), i.length = 0;
      } else i.push(a);
    }
  }
}, $O = function(e) {
  for (var t = document.querySelectorAll(f6), r = 0, n = t.length; r < n; r++) {
    var i = t[r];
    i && i.getAttribute(ts) !== SI && (m6(e, i), i.parentNode && i.parentNode.removeChild(i));
  }
};
function bb() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var CI = function(e) {
  var t = document.head, r = e || t, n = document.createElement("style"), i = function(a) {
    var l = Array.from(a.querySelectorAll("style[".concat(ts, "]")));
    return l[l.length - 1];
  }(r), s = i !== void 0 ? i.nextSibling : null;
  n.setAttribute(ts, SI), n.setAttribute(am, ta);
  var o = bb();
  return o && n.setAttribute("nonce", o), r.insertBefore(n, s), n;
}, g6 = function() {
  function e(t) {
    this.element = CI(t), this.element.appendChild(document.createTextNode("")), this.sheet = function(r) {
      if (r.sheet) return r.sheet;
      for (var n = document.styleSheets, i = 0, s = n.length; i < s; i++) {
        var o = n[i];
        if (o.ownerNode === r) return o;
      }
      throw Rn(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    try {
      return this.sheet.insertRule(r, t), this.length++, !0;
    } catch {
      return !1;
    }
  }, e.prototype.deleteRule = function(t) {
    this.sheet.deleteRule(t), this.length--;
  }, e.prototype.getRule = function(t) {
    var r = this.sheet.cssRules[t];
    return r && r.cssText ? r.cssText : "";
  }, e;
}(), y6 = function() {
  function e(t) {
    this.element = CI(t), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    if (t <= this.length && t >= 0) {
      var n = document.createTextNode(r);
      return this.element.insertBefore(n, this.nodes[t] || null), this.length++, !0;
    }
    return !1;
  }, e.prototype.deleteRule = function(t) {
    this.element.removeChild(this.nodes[t]), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.nodes[t].textContent : "";
  }, e;
}(), v6 = function() {
  function e(t) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    return t <= this.length && (this.rules.splice(t, 0, r), this.length++, !0);
  }, e.prototype.deleteRule = function(t) {
    this.rules.splice(t, 1), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.rules[t] : "";
  }, e;
}(), RO = lm, b6 = { isServer: !lm, useCSSOMInjection: !X4 }, Rl = function() {
  function e(t, r, n) {
    t === void 0 && (t = $l), r === void 0 && (r = {});
    var i = this;
    this.options = or(or({}, b6), t), this.gs = r, this.names = new Map(n), this.server = !!t.isServer, !this.server && lm && RO && (RO = !1, $O(this)), aS(this, function() {
      return function(s) {
        for (var o = s.getTag(), a = o.length, l = "", p = function(d) {
          var m = function(x) {
            return um.get(x);
          }(d);
          if (m === void 0) return "continue";
          var v = s.names.get(m), g = o.getGroup(d);
          if (v === void 0 || !v.size || g.length === 0) return "continue";
          var S = "".concat(ts, ".g").concat(d, '[id="').concat(m, '"]'), _ = "";
          v !== void 0 && v.forEach(function(x) {
            x.length > 0 && (_ += "".concat(x, ","));
          }), l += "".concat(g).concat(S, '{content:"').concat(_, '"}').concat(nS);
        }, f = 0; f < a; f++) p(f);
        return l;
      }(i);
    });
  }
  return e.registerId = function(t) {
    return Yf(t);
  }, e.prototype.rehydrate = function() {
    !this.server && lm && $O(this);
  }, e.prototype.reconstructWithOptions = function(t, r) {
    return r === void 0 && (r = !0), new e(or(or({}, this.options), t), this.gs, r && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(t) {
    return this.gs[t] = (this.gs[t] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (t = function(r) {
      var n = r.useCSSOMInjection, i = r.target;
      return r.isServer ? new v6(i) : n ? new g6(i) : new y6(i);
    }(this.options), new c6(t)));
    var t;
  }, e.prototype.hasNameForId = function(t, r) {
    return this.names.has(t) && this.names.get(t).has(r);
  }, e.prototype.registerName = function(t, r) {
    if (Yf(t), this.names.has(t)) this.names.get(t).add(r);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(r), this.names.set(t, n);
    }
  }, e.prototype.insertRules = function(t, r, n) {
    this.registerName(t, r), this.getTag().insertRules(Yf(t), n);
  }, e.prototype.clearNames = function(t) {
    this.names.has(t) && this.names.get(t).clear();
  }, e.prototype.clearRules = function(t) {
    this.getTag().clearGroup(Yf(t)), this.clearNames(t);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}(), w6 = /&/g, S6 = /^\s*\/\/.*$/gm;
function TI(e, t) {
  return e.map(function(r) {
    return r.type === "rule" && (r.value = "".concat(t, " ").concat(r.value), r.value = r.value.replaceAll(",", ",".concat(t, " ")), r.props = r.props.map(function(n) {
      return "".concat(t, " ").concat(n);
    })), Array.isArray(r.children) && r.type !== "@keyframes" && (r.children = TI(r.children, t)), r;
  });
}
function $I(e) {
  var t, r, n, i = e === void 0 ? $l : e, s = i.options, o = s === void 0 ? $l : s, a = i.plugins, l = a === void 0 ? rg : a, p = function(m, v, g) {
    return g.startsWith(r) && g.endsWith(r) && g.replaceAll(r, "").length > 0 ? ".".concat(t) : m;
  }, f = l.slice();
  f.push(function(m) {
    m.type === Jm && m.value.includes("&") && (m.props[0] = m.props[0].replace(w6, r).replace(n, p));
  }), o.prefix && f.push(G4), f.push(H4);
  var d = function(m, v, g, S) {
    v === void 0 && (v = ""), g === void 0 && (g = ""), S === void 0 && (S = "&"), t = S, r = v, n = new RegExp("\\".concat(r, "\\b"), "g");
    var _ = m.replace(S6, ""), x = V4(g || v ? "".concat(g, " ").concat(v, " { ").concat(_, " }") : _);
    o.namespace && (x = TI(x, o.namespace));
    var y = [];
    return sm(x, Q4(f.concat(Y4(function(w) {
      return y.push(w);
    })))), y;
  };
  return d.hash = l.length ? l.reduce(function(m, v) {
    return v.name || Rn(15), ll(m, v.name);
  }, _I).toString() : "", d;
}
var RI = new Rl(), wb = $I(), ig = at.createContext({ shouldForwardProp: void 0, styleSheet: RI, stylis: wb }), x6 = ig.Consumer, _6 = at.createContext(void 0);
function cm() {
  return et.useContext(ig);
}
function II(e) {
  var t = et.useState(e.stylisPlugins), r = t[0], n = t[1], i = cm().styleSheet, s = et.useMemo(function() {
    var l = i;
    return e.sheet ? l = e.sheet : e.target && (l = l.reconstructWithOptions({ target: e.target }, !1)), e.disableCSSOMInjection && (l = l.reconstructWithOptions({ useCSSOMInjection: !1 })), l;
  }, [e.disableCSSOMInjection, e.sheet, e.target, i]), o = et.useMemo(function() {
    return $I({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: r });
  }, [e.enableVendorPrefixes, e.namespace, r]);
  et.useEffect(function() {
    $4(r, e.stylisPlugins) || n(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var a = et.useMemo(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: s, stylis: o };
  }, [e.shouldForwardProp, s, o]);
  return at.createElement(ig.Provider, { value: a }, at.createElement(_6.Provider, { value: o }, e.children));
}
var jI = function() {
  function e(t, r) {
    var n = this;
    this.inject = function(i, s) {
      s === void 0 && (s = wb);
      var o = n.name + s.hash;
      i.hasNameForId(n.id, o) || i.insertRules(n.id, o, s(n.rules, o, "@keyframes"));
    }, this.name = t, this.id = "sc-keyframes-".concat(t), this.rules = r, aS(this, function() {
      throw Rn(12, String(n.name));
    });
  }
  return e.prototype.getName = function(t) {
    return t === void 0 && (t = wb), this.name + t.hash;
  }, e;
}(), E6 = function(e) {
  return e >= "A" && e <= "Z";
};
function IO(e) {
  for (var t = "", r = 0; r < e.length; r++) {
    var n = e[r];
    if (r === 1 && n === "-" && e[0] === "-") return e;
    E6(n) ? t += "-" + n.toLowerCase() : t += n;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var NI = function(e) {
  return e == null || e === !1 || e === "";
}, LI = function(e) {
  var t, r, n = [];
  for (var i in e) {
    var s = e[i];
    e.hasOwnProperty(i) && !NI(s) && (Array.isArray(s) && s.isCss || ra(s) ? n.push("".concat(IO(i), ":"), s, ";") : Xc(s) ? n.push.apply(n, Pl(Pl(["".concat(i, " {")], LI(s), !1), ["}"], !1)) : n.push("".concat(IO(i), ": ").concat((t = i, (r = s) == null || typeof r == "boolean" || r === "" ? "" : typeof r != "number" || r === 0 || t in K4 || t.startsWith("--") ? String(r).trim() : "".concat(r, "px")), ";")));
  }
  return n;
};
function Go(e, t, r, n) {
  if (NI(e)) return [];
  if (ng(e)) return [".".concat(e.styledComponentId)];
  if (ra(e)) {
    if (!ra(s = e) || s.prototype && s.prototype.isReactComponent || !t) return [e];
    var i = e(t);
    return Go(i, t, r, n);
  }
  var s;
  return e instanceof jI ? r ? (e.inject(r, n), [e.getName(n)]) : [e] : Xc(e) ? LI(e) : Array.isArray(e) ? Array.prototype.concat.apply(rg, e.map(function(o) {
    return Go(o, t, r, n);
  })) : [e.toString()];
}
function MI(e) {
  for (var t = 0; t < e.length; t += 1) {
    var r = e[t];
    if (ra(r) && !ng(r)) return !1;
  }
  return !0;
}
var O6 = EI(ta), k6 = function() {
  function e(t, r, n) {
    this.rules = t, this.staticRulesId = "", this.isStatic = (n === void 0 || n.isStatic) && MI(t), this.componentId = r, this.baseHash = ll(O6, r), this.baseStyle = n, Rl.registerId(r);
  }
  return e.prototype.generateAndInjectStyles = function(t, r, n) {
    var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t, r, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && r.hasNameForId(this.componentId, this.staticRulesId)) i = Vs(i, this.staticRulesId);
    else {
      var s = Kc(Go(this.rules, t, r, n)), o = yb(ll(this.baseHash, s) >>> 0);
      if (!r.hasNameForId(this.componentId, o)) {
        var a = n(s, ".".concat(o), void 0, this.componentId);
        r.insertRules(this.componentId, o, a);
      }
      i = Vs(i, o), this.staticRulesId = o;
    }
    else {
      for (var l = ll(this.baseHash, n.hash), p = "", f = 0; f < this.rules.length; f++) {
        var d = this.rules[f];
        if (typeof d == "string") p += d;
        else if (d) {
          var m = Kc(Go(d, t, r, n));
          l = ll(l, m + f), p += m;
        }
      }
      if (p) {
        var v = yb(l >>> 0);
        r.hasNameForId(this.componentId, v) || r.insertRules(this.componentId, v, n(p, ".".concat(v), void 0, this.componentId)), i = Vs(i, v);
      }
    }
    return i;
  }, e;
}(), rs = at.createContext(void 0), A6 = rs.Consumer;
function P6() {
  var e = et.useContext(rs);
  if (!e) throw Rn(18);
  return e;
}
function C6(e) {
  var t = at.useContext(rs), r = et.useMemo(function() {
    return function(n, i) {
      if (!n) throw Rn(14);
      if (ra(n)) {
        var s = n(i);
        return s;
      }
      if (Array.isArray(n) || typeof n != "object") throw Rn(8);
      return i ? or(or({}, i), n) : n;
    }(e.theme, t);
  }, [e.theme, t]);
  return e.children ? at.createElement(rs.Provider, { value: r }, e.children) : null;
}
var Xy = {};
function T6(e, t, r) {
  var n = ng(e), i = e, s = !Ky(e), o = t.attrs, a = o === void 0 ? rg : o, l = t.componentId, p = l === void 0 ? function(k, A) {
    var T = typeof k != "string" ? "sc" : kO(k);
    Xy[T] = (Xy[T] || 0) + 1;
    var R = "".concat(T, "-").concat(oS(ta + T + Xy[T]));
    return A ? "".concat(A, "-").concat(R) : R;
  }(t.displayName, t.parentComponentId) : l, f = t.displayName, d = f === void 0 ? function(k) {
    return Ky(k) ? "styled.".concat(k) : "Styled(".concat(OI(k), ")");
  }(e) : f, m = t.displayName && t.componentId ? "".concat(kO(t.displayName), "-").concat(t.componentId) : t.componentId || p, v = n && i.attrs ? i.attrs.concat(a).filter(Boolean) : a, g = t.shouldForwardProp;
  if (n && i.shouldForwardProp) {
    var S = i.shouldForwardProp;
    if (t.shouldForwardProp) {
      var _ = t.shouldForwardProp;
      g = function(k, A) {
        return S(k, A) && _(k, A);
      };
    } else g = S;
  }
  var x = new k6(r, m, n ? i.componentStyle : void 0);
  function y(k, A) {
    return function(T, R, I) {
      var B = T.attrs, L = T.componentStyle, Y = T.defaultProps, Q = T.foldedComponentIds, re = T.styledComponentId, oe = T.target, ce = at.useContext(rs), pe = cm(), fe = T.shouldForwardProp || pe.shouldForwardProp, G = iS(R, ce, Y) || $l, Z = function(H, F, ue) {
        for (var ge, Ae = or(or({}, F), { className: void 0, theme: ue }), C = 0; C < H.length; C += 1) {
          var N = ra(ge = H[C]) ? ge(Ae) : ge;
          for (var J in N) Ae[J] = J === "className" ? Vs(Ae[J], N[J]) : J === "style" ? or(or({}, Ae[J]), N[J]) : N[J];
        }
        return F.className && (Ae.className = Vs(Ae.className, F.className)), Ae;
      }(B, R, G), K = Z.as || oe, z = {};
      for (var te in Z) Z[te] === void 0 || te[0] === "$" || te === "as" || te === "theme" && Z.theme === G || (te === "forwardedAs" ? z.as = Z.forwardedAs : fe && !fe(te, K) || (z[te] = Z[te]));
      var q = function(H, F) {
        var ue = cm(), ge = H.generateAndInjectStyles(F, ue.styleSheet, ue.stylis);
        return ge;
      }(L, Z), j = Vs(Q, re);
      return q && (j += " " + q), Z.className && (j += " " + Z.className), z[Ky(K) && !xI.has(K) ? "class" : "className"] = j, z.ref = I, et.createElement(K, z);
    }(w, k, A);
  }
  y.displayName = d;
  var w = at.forwardRef(y);
  return w.attrs = v, w.componentStyle = x, w.displayName = d, w.shouldForwardProp = g, w.foldedComponentIds = n ? Vs(i.foldedComponentIds, i.styledComponentId) : "", w.styledComponentId = m, w.target = n ? i.target : e, Object.defineProperty(w, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(k) {
    this._foldedDefaultProps = n ? function(A) {
      for (var T = [], R = 1; R < arguments.length; R++) T[R - 1] = arguments[R];
      for (var I = 0, B = T; I < B.length; I++) vb(A, B[I], !0);
      return A;
    }({}, i.defaultProps, k) : k;
  } }), aS(w, function() {
    return ".".concat(w.styledComponentId);
  }), s && sS(w, e, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), w;
}
function jO(e, t) {
  for (var r = [e[0]], n = 0, i = t.length; n < i; n += 1) r.push(t[n], e[n + 1]);
  return r;
}
var NO = function(e) {
  return Object.assign(e, { isCss: !0 });
};
function og(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  if (ra(e) || Xc(e)) return NO(Go(jO(rg, Pl([e], t, !0))));
  var n = e;
  return t.length === 0 && n.length === 1 && typeof n[0] == "string" ? Go(n) : NO(Go(jO(n, t)));
}
function Sb(e, t, r) {
  if (r === void 0 && (r = $l), !t) throw Rn(1, t);
  var n = function(i) {
    for (var s = [], o = 1; o < arguments.length; o++) s[o - 1] = arguments[o];
    return e(t, r, og.apply(void 0, Pl([i], s, !1)));
  };
  return n.attrs = function(i) {
    return Sb(e, t, or(or({}, r), { attrs: Array.prototype.concat(r.attrs, i).filter(Boolean) }));
  }, n.withConfig = function(i) {
    return Sb(e, t, or(or({}, r), i));
  }, n;
}
var DI = function(e) {
  return Sb(T6, e);
}, xb = DI;
xI.forEach(function(e) {
  xb[e] = DI(e);
});
var $6 = function() {
  function e(t, r) {
    this.rules = t, this.componentId = r, this.isStatic = MI(t), Rl.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(t, r, n, i) {
    var s = i(Kc(Go(this.rules, r, n, i)), ""), o = this.componentId + t;
    n.insertRules(o, o, s);
  }, e.prototype.removeStyles = function(t, r) {
    r.clearRules(this.componentId + t);
  }, e.prototype.renderStyles = function(t, r, n, i) {
    t > 2 && Rl.registerId(this.componentId + t), this.removeStyles(t, n), this.createStyles(t, r, n, i);
  }, e;
}();
function R6(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = og.apply(void 0, Pl([e], t, !1)), i = "sc-global-".concat(oS(JSON.stringify(n))), s = new $6(n, i), o = function(l) {
    var p = cm(), f = at.useContext(rs), d = at.useRef(p.styleSheet.allocateGSInstance(i)).current;
    return p.styleSheet.server && a(d, l, p.styleSheet, f, p.stylis), at.useLayoutEffect(function() {
      if (!p.styleSheet.server) return a(d, l, p.styleSheet, f, p.stylis), function() {
        return s.removeStyles(d, p.styleSheet);
      };
    }, [d, l, p.styleSheet, f, p.stylis]), null;
  };
  function a(l, p, f, d, m) {
    if (s.isStatic) s.renderStyles(l, J4, f, m);
    else {
      var v = or(or({}, p), { theme: iS(p, d, o.defaultProps) });
      s.renderStyles(l, v, f, m);
    }
  }
  return at.memo(o);
}
function I6(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = Kc(og.apply(void 0, Pl([e], t, !1))), i = oS(n);
  return new jI(i, n);
}
function j6(e) {
  var t = at.forwardRef(function(r, n) {
    var i = iS(r, at.useContext(rs), e.defaultProps);
    return at.createElement(e, or({}, r, { theme: i, ref: n }));
  });
  return t.displayName = "WithTheme(".concat(OI(e), ")"), sS(t, e);
}
var N6 = function() {
  function e() {
    var t = this;
    this._emitSheetCSS = function() {
      var r = t.instance.toString();
      if (!r) return "";
      var n = bb(), i = Kc([n && 'nonce="'.concat(n, '"'), "".concat(ts, '="true"'), "".concat(am, '="').concat(ta, '"')].filter(Boolean), " ");
      return "<style ".concat(i, ">").concat(r, "</style>");
    }, this.getStyleTags = function() {
      if (t.sealed) throw Rn(2);
      return t._emitSheetCSS();
    }, this.getStyleElement = function() {
      var r;
      if (t.sealed) throw Rn(2);
      var n = t.instance.toString();
      if (!n) return [];
      var i = ((r = {})[ts] = "", r[am] = ta, r.dangerouslySetInnerHTML = { __html: n }, r), s = bb();
      return s && (i.nonce = s), [at.createElement("style", or({}, i, { key: "sc-0-0" }))];
    }, this.seal = function() {
      t.sealed = !0;
    }, this.instance = new Rl({ isServer: !0 }), this.sealed = !1;
  }
  return e.prototype.collectStyles = function(t) {
    if (this.sealed) throw Rn(2);
    return at.createElement(II, { sheet: this.instance }, t);
  }, e.prototype.interleaveWithNodeStream = function(t) {
    throw Rn(3);
  }, e;
}(), L6 = { StyleSheet: Rl, mainSheet: RI };
const M6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ServerStyleSheet: N6,
  StyleSheetConsumer: x6,
  StyleSheetContext: ig,
  StyleSheetManager: II,
  ThemeConsumer: A6,
  ThemeContext: rs,
  ThemeProvider: C6,
  __PRIVATE__: L6,
  createGlobalStyle: R6,
  css: og,
  default: xb,
  isStyledComponent: ng,
  keyframes: I6,
  styled: xb,
  useTheme: P6,
  version: ta,
  withTheme: j6
}, Symbol.toStringTag, { value: "Module" })), D6 = /* @__PURE__ */ Ri(M6);
var Jy = { exports: {} }, Zy, LO;
function F6() {
  if (LO) return Zy;
  LO = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Zy = e, Zy;
}
var ev, MO;
function z6() {
  if (MO) return ev;
  MO = 1;
  var e = F6();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, ev = function() {
    function n(o, a, l, p, f, d) {
      if (d !== e) {
        var m = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw m.name = "Invariant Violation", m;
      }
    }
    n.isRequired = n;
    function i() {
      return n;
    }
    var s = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: i,
      element: n,
      elementType: n,
      instanceOf: i,
      node: n,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, ev;
}
var DO;
function FI() {
  return DO || (DO = 1, Jy.exports = z6()()), Jy.exports;
}
function tt(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  throw new Error(typeof e == "number" ? "[MobX] minified error nr: " + e + (r.length ? " " + r.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + e);
}
var q6 = {};
function lS() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : q6;
}
var zI = Object.assign, pm = Object.getOwnPropertyDescriptor, Ci = Object.defineProperty, cp = Object.prototype, _b = [];
Object.freeze(_b);
var uS = {};
Object.freeze(uS);
var B6 = typeof Proxy < "u", U6 = /* @__PURE__ */ Object.toString();
function qI() {
  B6 || tt("Proxy not available");
}
function BI(e) {
  var t = !1;
  return function() {
    if (!t)
      return t = !0, e.apply(this, arguments);
  };
}
var ul = function() {
};
function gn(e) {
  return typeof e == "function";
}
function na(e) {
  var t = typeof e;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function sg(e) {
  return e !== null && typeof e == "object";
}
function ho(e) {
  if (!sg(e))
    return !1;
  var t = Object.getPrototypeOf(e);
  if (t == null)
    return !0;
  var r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r.toString() === U6;
}
function UI(e) {
  var t = e == null ? void 0 : e.constructor;
  return t ? t.name === "GeneratorFunction" || t.displayName === "GeneratorFunction" : !1;
}
function pp(e, t, r) {
  Ci(e, t, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: r
  });
}
function VI(e, t, r) {
  Ci(e, t, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: r
  });
}
function ls(e, t) {
  var r = "isMobX" + e;
  return t.prototype[r] = !0, function(n) {
    return sg(n) && n[r] === !0;
  };
}
function Hl(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Map]";
}
function V6(e) {
  var t = Object.getPrototypeOf(e), r = Object.getPrototypeOf(t), n = Object.getPrototypeOf(r);
  return n === null;
}
function Ji(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Set]";
}
var WI = typeof Object.getOwnPropertySymbols < "u";
function W6(e) {
  var t = Object.keys(e);
  if (!WI)
    return t;
  var r = Object.getOwnPropertySymbols(e);
  return r.length ? [].concat(t, r.filter(function(n) {
    return cp.propertyIsEnumerable.call(e, n);
  })) : t;
}
var Il = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : WI ? function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function HI(e) {
  return e === null ? null : typeof e == "object" ? "" + e : e;
}
function io(e, t) {
  return cp.hasOwnProperty.call(e, t);
}
var H6 = Object.getOwnPropertyDescriptors || function(t) {
  var r = {};
  return Il(t).forEach(function(n) {
    r[n] = pm(t, n);
  }), r;
};
function un(e, t) {
  return !!(e & t);
}
function cn(e, t, r) {
  return r ? e |= t : e &= ~t, e;
}
function FO(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Q6(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, G6(n.key), n);
  }
}
function Ql(e, t, r) {
  return t && Q6(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function cl(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = K6(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? {
        done: !0
      } : {
        done: !1,
        value: e[n++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ns() {
  return ns = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, ns.apply(null, arguments);
}
function QI(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Eb(e, t);
}
function Eb(e, t) {
  return Eb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, Eb(e, t);
}
function Y6(e, t) {
  if (typeof e != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function G6(e) {
  var t = Y6(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function K6(e, t) {
  if (e) {
    if (typeof e == "string") return FO(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? FO(e, t) : void 0;
  }
}
var Ei = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function ei(e) {
  function t(r, n) {
    if (dp(n))
      return e.decorate_20223_(r, n);
    fp(r, n, e);
  }
  return Object.assign(t, e);
}
function fp(e, t, r) {
  io(e, Ei) || pp(e, Ei, ns({}, e[Ei])), oV(r) || (e[Ei][t] = r);
}
function X6(e) {
  return io(e, Ei) || pp(e, Ei, ns({}, e[Ei])), e[Ei];
}
function dp(e) {
  return typeof e == "object" && typeof e.kind == "string";
}
var Qe = /* @__PURE__ */ Symbol("mobx administration"), us = /* @__PURE__ */ function() {
  function e(r) {
    r === void 0 && (r = "Atom"), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = ht.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = r;
  }
  var t = e.prototype;
  return t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, t.reportObserved = function() {
    return pj(this);
  }, t.reportChanged = function() {
    Xr(), fj(this), Jr();
  }, t.toString = function() {
    return this.name_;
  }, Ql(e, [{
    key: "isBeingObserved",
    get: function() {
      return un(this.flags_, e.isBeingObservedMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isBeingObservedMask_, n);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return un(this.flags_, e.isPendingUnobservationMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isPendingUnobservationMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return un(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
us.isBeingObservedMask_ = 1;
us.isPendingUnobservationMask_ = 2;
us.diffValueMask_ = 4;
var cS = /* @__PURE__ */ ls("Atom", us);
function pS(e, t, r) {
  t === void 0 && (t = ul), r === void 0 && (r = ul);
  var n = new us(e);
  return t !== ul && wj(n, t), r !== ul && mS(n, r), n;
}
function J6(e, t) {
  return e === t;
}
function Z6(e, t) {
  return SS(e, t);
}
function eV(e, t) {
  return SS(e, t, 1);
}
function tV(e, t) {
  return Object.is ? Object.is(e, t) : e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
var ia = {
  identity: J6,
  structural: Z6,
  default: tV,
  shallow: eV
};
function oa(e, t, r) {
  return hg(e) ? e : Array.isArray(e) ? Qt.array(e, {
    name: r
  }) : ho(e) ? Qt.object(e, void 0, {
    name: r
  }) : Hl(e) ? Qt.map(e, {
    name: r
  }) : Ji(e) ? Qt.set(e, {
    name: r
  }) : typeof e == "function" && !Nl(e) && !Ll(e) ? UI(e) ? aa(e) : jl(r, e) : e;
}
function rV(e, t, r) {
  if (e == null || hr(e) || Br(e) || mr(e) || ur(e))
    return e;
  if (Array.isArray(e))
    return Qt.array(e, {
      name: r,
      deep: !1
    });
  if (ho(e))
    return Qt.object(e, void 0, {
      name: r,
      deep: !1
    });
  if (Hl(e))
    return Qt.map(e, {
      name: r,
      deep: !1
    });
  if (Ji(e))
    return Qt.set(e, {
      name: r,
      deep: !1
    });
}
function ag(e) {
  return e;
}
function nV(e, t) {
  return SS(e, t) ? t : e;
}
var YI = "override", iV = /* @__PURE__ */ ei({
  annotationType_: YI,
  make_: sV,
  extend_: aV,
  decorate_20223_: lV
});
function oV(e) {
  return e.annotationType_ === YI;
}
function sV(e, t) {
  return 0;
}
function aV(e, t, r, n) {
  tt("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function lV(e, t) {
  console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op");
}
function hp(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: uV,
    extend_: cV,
    decorate_20223_: pV
  };
}
function uV(e, t, r, n) {
  var i;
  if ((i = this.options_) != null && i.bound)
    return this.extend_(e, t, r, !1) === null ? 0 : 1;
  if (n === e.target_)
    return this.extend_(e, t, r, !1) === null ? 0 : 2;
  if (Nl(r.value))
    return 1;
  var s = GI(e, this, t, r, !1);
  return Ci(n, t, s), 2;
}
function cV(e, t, r, n) {
  var i = GI(e, this, t, r);
  return e.defineProperty_(t, i, n);
}
function pV(e, t) {
  var r = t.kind, n = t.name, i = t.addInitializer, s = this, o = function(p) {
    var f, d, m, v;
    return is((f = (d = s.options_) == null ? void 0 : d.name) != null ? f : n.toString(), p, (m = (v = s.options_) == null ? void 0 : v.autoAction) != null ? m : !1);
  };
  if (r == "field")
    return function(l) {
      var p, f = l;
      return Nl(f) || (f = o(f)), (p = s.options_) != null && p.bound && (f = f.bind(this), f.isMobxAction = !0), f;
    };
  if (r == "method") {
    var a;
    return Nl(e) || (e = o(e)), (a = this.options_) != null && a.bound && i(function() {
      var l = this, p = l[n].bind(l);
      p.isMobxAction = !0, l[n] = p;
    }), e;
  }
  tt("Cannot apply '" + s.annotationType_ + "' to '" + String(n) + "' (kind: " + r + "):" + (`
'` + s.annotationType_ + "' can only be used on properties with a function value."));
}
function fV(e, t, r, n) {
  t.annotationType_, n.value;
}
function GI(e, t, r, n, i) {
  var s, o, a, l, p, f, d;
  i === void 0 && (i = Ne.safeDescriptors), fV(e, t, r, n);
  var m = n.value;
  if ((s = t.options_) != null && s.bound) {
    var v;
    m = m.bind((v = e.proxy_) != null ? v : e.target_);
  }
  return {
    value: is(
      (o = (a = t.options_) == null ? void 0 : a.name) != null ? o : r.toString(),
      m,
      (l = (p = t.options_) == null ? void 0 : p.autoAction) != null ? l : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      (f = t.options_) != null && f.bound ? (d = e.proxy_) != null ? d : e.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: i ? e.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !i
  };
}
function KI(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: dV,
    extend_: hV,
    decorate_20223_: mV
  };
}
function dV(e, t, r, n) {
  var i;
  if (n === e.target_)
    return this.extend_(e, t, r, !1) === null ? 0 : 2;
  if ((i = this.options_) != null && i.bound && (!io(e.target_, t) || !Ll(e.target_[t])) && this.extend_(e, t, r, !1) === null)
    return 0;
  if (Ll(r.value))
    return 1;
  var s = XI(e, this, t, r, !1, !1);
  return Ci(n, t, s), 2;
}
function hV(e, t, r, n) {
  var i, s = XI(e, this, t, r, (i = this.options_) == null ? void 0 : i.bound);
  return e.defineProperty_(t, s, n);
}
function mV(e, t) {
  var r, n = t.name, i = t.addInitializer;
  return Ll(e) || (e = aa(e)), (r = this.options_) != null && r.bound && i(function() {
    var s = this, o = s[n].bind(s);
    o.isMobXFlow = !0, s[n] = o;
  }), e;
}
function gV(e, t, r, n) {
  t.annotationType_, n.value;
}
function XI(e, t, r, n, i, s) {
  s === void 0 && (s = Ne.safeDescriptors), gV(e, t, r, n);
  var o = n.value;
  if (Ll(o) || (o = aa(o)), i) {
    var a;
    o = o.bind((a = e.proxy_) != null ? a : e.target_), o.isMobXFlow = !0;
  }
  return {
    value: o,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: s ? e.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !s
  };
}
function fS(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: yV,
    extend_: vV,
    decorate_20223_: bV
  };
}
function yV(e, t, r) {
  return this.extend_(e, t, r, !1) === null ? 0 : 1;
}
function vV(e, t, r, n) {
  return wV(e, this, t, r), e.defineComputedProperty_(t, ns({}, this.options_, {
    get: r.get,
    set: r.set
  }), n);
}
function bV(e, t) {
  var r = this, n = t.name, i = t.addInitializer;
  return i(function() {
    var s = pa(this)[Qe], o = ns({}, r.options_, {
      get: e,
      context: this
    });
    o.name || (o.name = "ObservableObject." + n.toString()), s.values_.set(n, new ii(o));
  }), function() {
    return this[Qe].getObservablePropValue_(n);
  };
}
function wV(e, t, r, n) {
  t.annotationType_, n.get;
}
function lg(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: SV,
    extend_: xV,
    decorate_20223_: _V
  };
}
function SV(e, t, r) {
  return this.extend_(e, t, r, !1) === null ? 0 : 1;
}
function xV(e, t, r, n) {
  var i, s;
  return EV(e, this), e.defineObservableProperty_(t, r.value, (i = (s = this.options_) == null ? void 0 : s.enhancer) != null ? i : oa, n);
}
function _V(e, t) {
  var r = this, n = t.kind, i = t.name, s = /* @__PURE__ */ new WeakSet();
  function o(a, l) {
    var p, f, d = pa(a)[Qe], m = new Ko(l, (p = (f = r.options_) == null ? void 0 : f.enhancer) != null ? p : oa, "ObservableObject." + i.toString(), !1);
    d.values_.set(i, m), s.add(a);
  }
  if (n == "accessor")
    return {
      get: function() {
        return s.has(this) || o(this, e.get.call(this)), this[Qe].getObservablePropValue_(i);
      },
      set: function(l) {
        return s.has(this) || o(this, l), this[Qe].setObservablePropValue_(i, l);
      },
      init: function(l) {
        return s.has(this) || o(this, l), l;
      }
    };
}
function EV(e, t, r, n) {
  t.annotationType_;
}
var OV = "true", kV = /* @__PURE__ */ JI();
function JI(e) {
  return {
    annotationType_: OV,
    options_: e,
    make_: AV,
    extend_: PV,
    decorate_20223_: CV
  };
}
function AV(e, t, r, n) {
  var i, s;
  if (r.get)
    return mp.make_(e, t, r, n);
  if (r.set) {
    var o = is(t.toString(), r.set);
    return n === e.target_ ? e.defineProperty_(t, {
      configurable: Ne.safeDescriptors ? e.isPlainObject_ : !0,
      set: o
    }) === null ? 0 : 2 : (Ci(n, t, {
      configurable: !0,
      set: o
    }), 2);
  }
  if (n !== e.target_ && typeof r.value == "function") {
    var a;
    if (UI(r.value)) {
      var l, p = (l = this.options_) != null && l.autoBind ? aa.bound : aa;
      return p.make_(e, t, r, n);
    }
    var f = (a = this.options_) != null && a.autoBind ? jl.bound : jl;
    return f.make_(e, t, r, n);
  }
  var d = ((i = this.options_) == null ? void 0 : i.deep) === !1 ? Qt.ref : Qt;
  if (typeof r.value == "function" && (s = this.options_) != null && s.autoBind) {
    var m;
    r.value = r.value.bind((m = e.proxy_) != null ? m : e.target_);
  }
  return d.make_(e, t, r, n);
}
function PV(e, t, r, n) {
  var i, s;
  if (r.get)
    return mp.extend_(e, t, r, n);
  if (r.set)
    return e.defineProperty_(t, {
      configurable: Ne.safeDescriptors ? e.isPlainObject_ : !0,
      set: is(t.toString(), r.set)
    }, n);
  if (typeof r.value == "function" && (i = this.options_) != null && i.autoBind) {
    var o;
    r.value = r.value.bind((o = e.proxy_) != null ? o : e.target_);
  }
  var a = ((s = this.options_) == null ? void 0 : s.deep) === !1 ? Qt.ref : Qt;
  return a.extend_(e, t, r, n);
}
function CV(e, t) {
  tt("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var TV = "observable", $V = "observable.ref", RV = "observable.shallow", IV = "observable.struct", ZI = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(ZI);
function Gf(e) {
  return e || ZI;
}
var Ob = /* @__PURE__ */ lg(TV), jV = /* @__PURE__ */ lg($V, {
  enhancer: ag
}), NV = /* @__PURE__ */ lg(RV, {
  enhancer: rV
}), LV = /* @__PURE__ */ lg(IV, {
  enhancer: nV
}), ej = /* @__PURE__ */ ei(Ob);
function Kf(e) {
  return e.deep === !0 ? oa : e.deep === !1 ? ag : DV(e.defaultDecorator);
}
function MV(e) {
  var t;
  return e ? (t = e.defaultDecorator) != null ? t : JI(e) : void 0;
}
function DV(e) {
  var t, r;
  return e && (t = (r = e.options_) == null ? void 0 : r.enhancer) != null ? t : oa;
}
function tj(e, t, r) {
  if (dp(t))
    return Ob.decorate_20223_(e, t);
  if (na(t)) {
    fp(e, t, Ob);
    return;
  }
  return hg(e) ? e : ho(e) ? Qt.object(e, t, r) : Array.isArray(e) ? Qt.array(e, t) : Hl(e) ? Qt.map(e, t) : Ji(e) ? Qt.set(e, t) : typeof e == "object" && e !== null ? e : Qt.box(e, t);
}
zI(tj, ej);
var FV = {
  box: function(t, r) {
    var n = Gf(r);
    return new Ko(t, Kf(n), n.name, !0, n.equals);
  },
  array: function(t, r) {
    var n = Gf(r);
    return (Ne.useProxies === !1 || n.proxy === !1 ? rW : H8)(t, Kf(n), n.name);
  },
  map: function(t, r) {
    var n = Gf(r);
    return new vS(t, Kf(n), n.name);
  },
  set: function(t, r) {
    var n = Gf(r);
    return new bS(t, Kf(n), n.name);
  },
  object: function(t, r, n) {
    return cs(function() {
      return gS(Ne.useProxies === !1 || (n == null ? void 0 : n.proxy) === !1 ? pa({}, n) : B8({}, n), t, r);
    });
  },
  ref: /* @__PURE__ */ ei(jV),
  shallow: /* @__PURE__ */ ei(NV),
  deep: ej,
  struct: /* @__PURE__ */ ei(LV)
}, Qt = /* @__PURE__ */ zI(tj, FV), rj = "computed", zV = "computed.struct", kb = /* @__PURE__ */ fS(rj), qV = /* @__PURE__ */ fS(zV, {
  equals: ia.structural
}), mp = function(t, r) {
  if (dp(r))
    return kb.decorate_20223_(t, r);
  if (na(r))
    return fp(t, r, kb);
  if (ho(t))
    return ei(fS(rj, t));
  var n = ho(r) ? r : {};
  return n.get = t, n.name || (n.name = t.name || ""), new ii(n);
};
Object.assign(mp, kb);
mp.struct = /* @__PURE__ */ ei(qV);
var zO, qO, fm = 0, BV = 1, UV = (zO = (qO = /* @__PURE__ */ pm(function() {
}, "name")) == null ? void 0 : qO.configurable) != null ? zO : !1, BO = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function is(e, t, r, n) {
  r === void 0 && (r = !1);
  function i() {
    return nj(e, r, t, n || this, arguments);
  }
  return i.isMobxAction = !0, i.toString = function() {
    return t.toString();
  }, UV && (BO.value = e, Ci(i, "name", BO)), i;
}
function nj(e, t, r, n, i) {
  var s = ij(e, t);
  try {
    return r.apply(n, i);
  } catch (o) {
    throw s.error_ = o, o;
  } finally {
    oj(s);
  }
}
function ij(e, t, r, n) {
  var i = !1, s = 0, o = Ne.trackingDerivation, a = !t || !o;
  Xr();
  var l = Ne.allowStateChanges;
  a && (ca(), l = cg(!0));
  var p = fg(!0), f = {
    runAsAction_: a,
    prevDerivation_: o,
    prevAllowStateChanges_: l,
    prevAllowStateReads_: p,
    notifySpy_: i,
    startTime_: s,
    actionId_: BV++,
    parentActionId_: fm
  };
  return fm = f.actionId_, f;
}
function oj(e) {
  fm !== e.actionId_ && tt(30), fm = e.parentActionId_, e.error_ !== void 0 && (Ne.suppressReactionErrors = !0), pg(e.prevAllowStateChanges_), vl(e.prevAllowStateReads_), Jr(), e.runAsAction_ && oo(e.prevDerivation_), Ne.suppressReactionErrors = !1;
}
function ug(e, t) {
  var r = cg(e);
  try {
    return t();
  } finally {
    pg(r);
  }
}
function cg(e) {
  var t = Ne.allowStateChanges;
  return Ne.allowStateChanges = e, t;
}
function pg(e) {
  Ne.allowStateChanges = e;
}
var Ko = /* @__PURE__ */ function(e) {
  function t(n, i, s, o, a) {
    var l;
    return s === void 0 && (s = "ObservableValue"), a === void 0 && (a = ia.default), l = e.call(this, s) || this, l.enhancer = void 0, l.name_ = void 0, l.equals = void 0, l.hasUnreportedChange_ = !1, l.interceptors_ = void 0, l.changeListeners_ = void 0, l.value_ = void 0, l.dehancer = void 0, l.enhancer = i, l.name_ = s, l.equals = a, l.value_ = i(n, void 0, s), l;
  }
  QI(t, e);
  var r = t.prototype;
  return r.dehanceValue = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, r.set = function(i) {
    this.value_, i = this.prepareNewValue_(i), i !== Ne.UNCHANGED && this.setNewValue_(i);
  }, r.prepareNewValue_ = function(i) {
    if (Cn(this)) {
      var s = Tn(this, {
        object: this,
        type: Ti,
        newValue: i
      });
      if (!s)
        return Ne.UNCHANGED;
      i = s.newValue;
    }
    return i = this.enhancer(i, this.value_, this.name_), this.equals(this.value_, i) ? Ne.UNCHANGED : i;
  }, r.setNewValue_ = function(i) {
    var s = this.value_;
    this.value_ = i, this.reportChanged(), ti(this) && ri(this, {
      type: Ti,
      object: this,
      newValue: i,
      oldValue: s
    });
  }, r.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, r.intercept_ = function(i) {
    return gp(this, i);
  }, r.observe_ = function(i, s) {
    return s && i({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: Ti,
      newValue: this.value_,
      oldValue: void 0
    }), yp(this, i);
  }, r.raw = function() {
    return this.value_;
  }, r.toJSON = function() {
    return this.get();
  }, r.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, r.valueOf = function() {
    return HI(this.get());
  }, r[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, t;
}(us), dS = /* @__PURE__ */ ls("ObservableValue", Ko), ii = /* @__PURE__ */ function() {
  function e(r) {
    this.dependenciesState_ = ht.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = ht.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new hm(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = dm.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, r.get || tt(31), this.derivation = r.get, this.name_ = r.name || "ComputedValue", r.set && (this.setter_ = is("ComputedValue-setter", r.set)), this.equals_ = r.equals || (r.compareStructural || r.struct ? ia.structural : ia.default), this.scope_ = r.context, this.requiresReaction_ = r.requiresReaction, this.keepAlive_ = !!r.keepAlive;
  }
  var t = e.prototype;
  return t.onBecomeStale_ = function() {
    e8(this);
  }, t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, t.get = function() {
    if (this.isComputing && tt(32, this.name_, this.derivation), Ne.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      Ab(this) && (this.warnAboutUntrackedRead_(), Xr(), this.value_ = this.computeValue_(!1), Jr());
    else if (pj(this), Ab(this)) {
      var n = Ne.trackingContext;
      this.keepAlive_ && !n && (Ne.trackingContext = this), this.trackAndCompute() && ZV(this), Ne.trackingContext = n;
    }
    var i = this.value_;
    if (Ah(i))
      throw i.cause;
    return i;
  }, t.set = function(n) {
    if (this.setter_) {
      this.isRunningSetter && tt(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, n);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      tt(34, this.name_);
  }, t.trackAndCompute = function() {
    var n = this.value_, i = (
      /* see #1208 */
      this.dependenciesState_ === ht.NOT_TRACKING_
    ), s = this.computeValue_(!0), o = i || Ah(n) || Ah(s) || !this.equals_(n, s);
    return o && (this.value_ = s), o;
  }, t.computeValue_ = function(n) {
    this.isComputing = !0;
    var i = cg(!1), s;
    if (n)
      s = sj(this, this.derivation, this.scope_);
    else if (Ne.disableErrorBoundaries === !0)
      s = this.derivation.call(this.scope_);
    else
      try {
        s = this.derivation.call(this.scope_);
      } catch (o) {
        s = new hm(o);
      }
    return pg(i), this.isComputing = !1, s;
  }, t.suspend_ = function() {
    this.keepAlive_ || (Pb(this), this.value_ = void 0);
  }, t.observe_ = function(n, i) {
    var s = this, o = !0, a = void 0;
    return hS(function() {
      var l = s.get();
      if (!o || i) {
        var p = ca();
        n({
          observableKind: "computed",
          debugObjectName: s.name_,
          type: Ti,
          object: s,
          newValue: l,
          oldValue: a
        }), oo(p);
      }
      o = !1, a = l;
    });
  }, t.warnAboutUntrackedRead_ = function() {
  }, t.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, t.valueOf = function() {
    return HI(this.get());
  }, t[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, Ql(e, [{
    key: "isComputing",
    get: function() {
      return un(this.flags_, e.isComputingMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isComputingMask_, n);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return un(this.flags_, e.isRunningSetterMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isRunningSetterMask_, n);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return un(this.flags_, e.isBeingObservedMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isBeingObservedMask_, n);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return un(this.flags_, e.isPendingUnobservationMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isPendingUnobservationMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return un(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
ii.isComputingMask_ = 1;
ii.isRunningSetterMask_ = 2;
ii.isBeingObservedMask_ = 4;
ii.isPendingUnobservationMask_ = 8;
ii.diffValueMask_ = 16;
var sa = /* @__PURE__ */ ls("ComputedValue", ii), ht;
(function(e) {
  e[e.NOT_TRACKING_ = -1] = "NOT_TRACKING_", e[e.UP_TO_DATE_ = 0] = "UP_TO_DATE_", e[e.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", e[e.STALE_ = 2] = "STALE_";
})(ht || (ht = {}));
var dm;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.LOG = 1] = "LOG", e[e.BREAK = 2] = "BREAK";
})(dm || (dm = {}));
var hm = function(t) {
  this.cause = void 0, this.cause = t;
};
function Ah(e) {
  return e instanceof hm;
}
function Ab(e) {
  switch (e.dependenciesState_) {
    case ht.UP_TO_DATE_:
      return !1;
    case ht.NOT_TRACKING_:
    case ht.STALE_:
      return !0;
    case ht.POSSIBLY_STALE_: {
      for (var t = fg(!0), r = ca(), n = e.observing_, i = n.length, s = 0; s < i; s++) {
        var o = n[s];
        if (sa(o)) {
          if (Ne.disableErrorBoundaries)
            o.get();
          else
            try {
              o.get();
            } catch {
              return oo(r), vl(t), !0;
            }
          if (e.dependenciesState_ === ht.STALE_)
            return oo(r), vl(t), !0;
        }
      }
      return aj(e), oo(r), vl(t), !1;
    }
  }
}
function VV() {
  return Ne.trackingDerivation !== null;
}
function sj(e, t, r) {
  var n = fg(!0);
  aj(e), e.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    e.runId_ === 0 ? 100 : e.observing_.length
  ), e.unboundDepsCount_ = 0, e.runId_ = ++Ne.runId;
  var i = Ne.trackingDerivation;
  Ne.trackingDerivation = e, Ne.inBatch++;
  var s;
  if (Ne.disableErrorBoundaries === !0)
    s = t.call(r);
  else
    try {
      s = t.call(r);
    } catch (o) {
      s = new hm(o);
    }
  return Ne.inBatch--, Ne.trackingDerivation = i, WV(e), vl(n), s;
}
function WV(e) {
  for (var t = e.observing_, r = e.observing_ = e.newObserving_, n = ht.UP_TO_DATE_, i = 0, s = e.unboundDepsCount_, o = 0; o < s; o++) {
    var a = r[o];
    a.diffValue === 0 && (a.diffValue = 1, i !== o && (r[i] = a), i++), a.dependenciesState_ > n && (n = a.dependenciesState_);
  }
  for (r.length = i, e.newObserving_ = null, s = t.length; s--; ) {
    var l = t[s];
    l.diffValue === 0 && uj(l, e), l.diffValue = 0;
  }
  for (; i--; ) {
    var p = r[i];
    p.diffValue === 1 && (p.diffValue = 0, JV(p, e));
  }
  n !== ht.UP_TO_DATE_ && (e.dependenciesState_ = n, e.onBecomeStale_());
}
function Pb(e) {
  var t = e.observing_;
  e.observing_ = [];
  for (var r = t.length; r--; )
    uj(t[r], e);
  e.dependenciesState_ = ht.NOT_TRACKING_;
}
function Yl(e) {
  var t = ca();
  try {
    return e();
  } finally {
    oo(t);
  }
}
function ca() {
  var e = Ne.trackingDerivation;
  return Ne.trackingDerivation = null, e;
}
function oo(e) {
  Ne.trackingDerivation = e;
}
function fg(e) {
  var t = Ne.allowStateReads;
  return Ne.allowStateReads = e, t;
}
function vl(e) {
  Ne.allowStateReads = e;
}
function aj(e) {
  if (e.dependenciesState_ !== ht.UP_TO_DATE_) {
    e.dependenciesState_ = ht.UP_TO_DATE_;
    for (var t = e.observing_, r = t.length; r--; )
      t[r].lowestObserverState_ = ht.UP_TO_DATE_;
  }
}
var HV = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"], xc = function() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, Ph = !0, lj = !1, Ne = /* @__PURE__ */ function() {
  var e = /* @__PURE__ */ lS();
  return e.__mobxInstanceCount > 0 && !e.__mobxGlobals && (Ph = !1), e.__mobxGlobals && e.__mobxGlobals.version !== new xc().version && (Ph = !1), Ph ? e.__mobxGlobals ? (e.__mobxInstanceCount += 1, e.__mobxGlobals.UNCHANGED || (e.__mobxGlobals.UNCHANGED = {}), e.__mobxGlobals) : (e.__mobxInstanceCount = 1, e.__mobxGlobals = /* @__PURE__ */ new xc()) : (setTimeout(function() {
    lj || tt(35);
  }, 1), new xc());
}();
function QV() {
  if ((Ne.pendingReactions.length || Ne.inBatch || Ne.isRunningReactions) && tt(36), lj = !0, Ph) {
    var e = lS();
    --e.__mobxInstanceCount === 0 && (e.__mobxGlobals = void 0), Ne = new xc();
  }
}
function YV() {
  return Ne;
}
function GV() {
  var e = new xc();
  for (var t in e)
    HV.indexOf(t) === -1 && (Ne[t] = e[t]);
  Ne.allowStateChanges = !Ne.enforceActions;
}
function KV(e) {
  return e.observers_ && e.observers_.size > 0;
}
function XV(e) {
  return e.observers_;
}
function JV(e, t) {
  e.observers_.add(t), e.lowestObserverState_ > t.dependenciesState_ && (e.lowestObserverState_ = t.dependenciesState_);
}
function uj(e, t) {
  e.observers_.delete(t), e.observers_.size === 0 && cj(e);
}
function cj(e) {
  e.isPendingUnobservation === !1 && (e.isPendingUnobservation = !0, Ne.pendingUnobservations.push(e));
}
function Xr() {
  Ne.inBatch++;
}
function Jr() {
  if (--Ne.inBatch === 0) {
    dj();
    for (var e = Ne.pendingUnobservations, t = 0; t < e.length; t++) {
      var r = e[t];
      r.isPendingUnobservation = !1, r.observers_.size === 0 && (r.isBeingObserved && (r.isBeingObserved = !1, r.onBUO()), r instanceof ii && r.suspend_());
    }
    Ne.pendingUnobservations = [];
  }
}
function pj(e) {
  var t = Ne.trackingDerivation;
  return t !== null ? (t.runId_ !== e.lastAccessedBy_ && (e.lastAccessedBy_ = t.runId_, t.newObserving_[t.unboundDepsCount_++] = e, !e.isBeingObserved && Ne.trackingContext && (e.isBeingObserved = !0, e.onBO())), e.isBeingObserved) : (e.observers_.size === 0 && Ne.inBatch > 0 && cj(e), !1);
}
function fj(e) {
  e.lowestObserverState_ !== ht.STALE_ && (e.lowestObserverState_ = ht.STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === ht.UP_TO_DATE_ && t.onBecomeStale_(), t.dependenciesState_ = ht.STALE_;
  }));
}
function ZV(e) {
  e.lowestObserverState_ !== ht.STALE_ && (e.lowestObserverState_ = ht.STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === ht.POSSIBLY_STALE_ ? t.dependenciesState_ = ht.STALE_ : t.dependenciesState_ === ht.UP_TO_DATE_ && (e.lowestObserverState_ = ht.UP_TO_DATE_);
  }));
}
function e8(e) {
  e.lowestObserverState_ === ht.UP_TO_DATE_ && (e.lowestObserverState_ = ht.POSSIBLY_STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === ht.UP_TO_DATE_ && (t.dependenciesState_ = ht.POSSIBLY_STALE_, t.onBecomeStale_());
  }));
}
var Mn = /* @__PURE__ */ function() {
  function e(r, n, i, s) {
    r === void 0 && (r = "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = ht.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = dm.NONE, this.name_ = r, this.onInvalidate_ = n, this.errorHandler_ = i, this.requiresObservable_ = s;
  }
  var t = e.prototype;
  return t.onBecomeStale_ = function() {
    this.schedule_();
  }, t.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, Ne.pendingReactions.push(this), dj());
  }, t.runReaction_ = function() {
    if (!this.isDisposed) {
      Xr(), this.isScheduled = !1;
      var n = Ne.trackingContext;
      if (Ne.trackingContext = this, Ab(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_();
        } catch (i) {
          this.reportExceptionInDerivation_(i);
        }
      }
      Ne.trackingContext = n, Jr();
    }
  }, t.track = function(n) {
    if (!this.isDisposed) {
      Xr(), this.isRunning = !0;
      var i = Ne.trackingContext;
      Ne.trackingContext = this;
      var s = sj(this, n, void 0);
      Ne.trackingContext = i, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && Pb(this), Ah(s) && this.reportExceptionInDerivation_(s.cause), Jr();
    }
  }, t.reportExceptionInDerivation_ = function(n) {
    var i = this;
    if (this.errorHandler_) {
      this.errorHandler_(n, this);
      return;
    }
    if (Ne.disableErrorBoundaries)
      throw n;
    var s = "[mobx] uncaught error in '" + this + "'";
    Ne.suppressReactionErrors || console.error(s, n), Ne.globalReactionErrorHandlers.forEach(function(o) {
      return o(n, i);
    });
  }, t.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (Xr(), Pb(this), Jr()));
  }, t.getDisposer_ = function(n) {
    var i = this, s = function o() {
      i.dispose(), n == null || n.removeEventListener == null || n.removeEventListener("abort", o);
    };
    return n == null || n.addEventListener == null || n.addEventListener("abort", s), s[Qe] = this, s;
  }, t.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, t.trace = function(n) {
  }, Ql(e, [{
    key: "isDisposed",
    get: function() {
      return un(this.flags_, e.isDisposedMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isDisposedMask_, n);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return un(this.flags_, e.isScheduledMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isScheduledMask_, n);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return un(this.flags_, e.isTrackPendingMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isTrackPendingMask_, n);
    }
  }, {
    key: "isRunning",
    get: function() {
      return un(this.flags_, e.isRunningMask_);
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.isRunningMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return un(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = cn(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
Mn.isDisposedMask_ = 1;
Mn.isScheduledMask_ = 2;
Mn.isTrackPendingMask_ = 4;
Mn.isRunningMask_ = 8;
Mn.diffValueMask_ = 16;
function t8(e) {
  return Ne.globalReactionErrorHandlers.push(e), function() {
    var t = Ne.globalReactionErrorHandlers.indexOf(e);
    t >= 0 && Ne.globalReactionErrorHandlers.splice(t, 1);
  };
}
var r8 = 100, Cb = function(t) {
  return t();
};
function dj() {
  Ne.inBatch > 0 || Ne.isRunningReactions || Cb(n8);
}
function n8() {
  Ne.isRunningReactions = !0;
  for (var e = Ne.pendingReactions, t = 0; e.length > 0; ) {
    ++t === r8 && (console.error("[mobx] cycle in reaction: " + e[0]), e.splice(0));
    for (var r = e.splice(0), n = 0, i = r.length; n < i; n++)
      r[n].runReaction_();
  }
  Ne.isRunningReactions = !1;
}
var mm = /* @__PURE__ */ ls("Reaction", Mn);
function i8(e) {
  var t = Cb;
  Cb = function(n) {
    return e(function() {
      return t(n);
    });
  };
}
function _c() {
  return !1;
}
function hj(e) {
  return console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  };
}
var mj = "action", o8 = "action.bound", gj = "autoAction", s8 = "autoAction.bound", yj = "<unnamed action>", Tb = /* @__PURE__ */ hp(mj), a8 = /* @__PURE__ */ hp(o8, {
  bound: !0
}), $b = /* @__PURE__ */ hp(gj, {
  autoAction: !0
}), l8 = /* @__PURE__ */ hp(s8, {
  autoAction: !0,
  bound: !0
});
function vj(e) {
  var t = function(n, i) {
    if (gn(n))
      return is(n.name || yj, n, e);
    if (gn(i))
      return is(n, i, e);
    if (dp(i))
      return (e ? $b : Tb).decorate_20223_(n, i);
    if (na(i))
      return fp(n, i, e ? $b : Tb);
    if (na(n))
      return ei(hp(e ? gj : mj, {
        name: n,
        autoAction: e
      }));
  };
  return t;
}
var Mo = /* @__PURE__ */ vj(!1);
Object.assign(Mo, Tb);
var jl = /* @__PURE__ */ vj(!0);
Object.assign(jl, $b);
Mo.bound = /* @__PURE__ */ ei(a8);
jl.bound = /* @__PURE__ */ ei(l8);
function Rb(e) {
  return nj(e.name || yj, !1, e, this, void 0);
}
function Nl(e) {
  return gn(e) && e.isMobxAction === !0;
}
function hS(e, t) {
  var r, n, i, s;
  t === void 0 && (t = uS);
  var o = (r = (n = t) == null ? void 0 : n.name) != null ? r : "Autorun", a = !t.scheduler && !t.delay, l;
  if (a)
    l = new Mn(o, function() {
      this.track(d);
    }, t.onError, t.requiresObservable);
  else {
    var p = bj(t), f = !1;
    l = new Mn(o, function() {
      f || (f = !0, p(function() {
        f = !1, l.isDisposed || l.track(d);
      }));
    }, t.onError, t.requiresObservable);
  }
  function d() {
    e(l);
  }
  return (i = t) != null && (i = i.signal) != null && i.aborted || l.schedule_(), l.getDisposer_((s = t) == null ? void 0 : s.signal);
}
var u8 = function(t) {
  return t();
};
function bj(e) {
  return e.scheduler ? e.scheduler : e.delay ? function(t) {
    return setTimeout(t, e.delay);
  } : u8;
}
function c8(e, t, r) {
  var n, i, s;
  r === void 0 && (r = uS);
  var o = (n = r.name) != null ? n : "Reaction", a = Mo(o, r.onError ? p8(r.onError, t) : t), l = !r.scheduler && !r.delay, p = bj(r), f = !0, d = !1, m, v = r.compareStructural ? ia.structural : r.equals || ia.default, g = new Mn(o, function() {
    f || l ? S() : d || (d = !0, p(S));
  }, r.onError, r.requiresObservable);
  function S() {
    if (d = !1, !g.isDisposed) {
      var _ = !1, x = m;
      g.track(function() {
        var y = ug(!1, function() {
          return e(g);
        });
        _ = f || !v(m, y), m = y;
      }), (f && r.fireImmediately || !f && _) && a(m, x, g), f = !1;
    }
  }
  return (i = r) != null && (i = i.signal) != null && i.aborted || g.schedule_(), g.getDisposer_((s = r) == null ? void 0 : s.signal);
}
function p8(e, t) {
  return function() {
    try {
      return t.apply(this, arguments);
    } catch (r) {
      e.call(this, r);
    }
  };
}
var f8 = "onBO", d8 = "onBUO";
function wj(e, t, r) {
  return Sj(f8, e, t, r);
}
function mS(e, t, r) {
  return Sj(d8, e, t, r);
}
function Sj(e, t, r, n) {
  var i = typeof n == "function" ? mo(t, r) : mo(t), s = gn(n) ? n : r, o = e + "L";
  return i[o] ? i[o].add(s) : i[o] = /* @__PURE__ */ new Set([s]), function() {
    var a = i[o];
    a && (a.delete(s), a.size === 0 && delete i[o]);
  };
}
var h8 = "never", Xf = "always", m8 = "observed";
function xj(e) {
  e.isolateGlobalState === !0 && QV();
  var t = e.useProxies, r = e.enforceActions;
  if (t !== void 0 && (Ne.useProxies = t === Xf ? !0 : t === h8 ? !1 : typeof Proxy < "u"), t === "ifavailable" && (Ne.verifyProxies = !0), r !== void 0) {
    var n = r === Xf ? Xf : r === m8;
    Ne.enforceActions = n, Ne.allowStateChanges = !(n === !0 || n === Xf);
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(i) {
    i in e && (Ne[i] = !!e[i]);
  }), Ne.allowStateReads = !Ne.observableRequiresReaction, e.reactionScheduler && i8(e.reactionScheduler);
}
function gS(e, t, r, n) {
  var i = H6(t);
  return cs(function() {
    var s = pa(e, n)[Qe];
    Il(i).forEach(function(o) {
      s.extend_(
        o,
        i[o],
        // must pass "undefined" for { key: undefined }
        r && o in r ? r[o] : !0
      );
    });
  }), e;
}
function _j(e, t) {
  return Ej(mo(e, t));
}
function Ej(e) {
  var t = {
    name: e.name_
  };
  return e.observing_ && e.observing_.length > 0 && (t.dependencies = y8(e.observing_).map(Ej)), t;
}
function g8(e, t) {
  return Oj(mo(e, t));
}
function Oj(e) {
  var t = {
    name: e.name_
  };
  return KV(e) && (t.observers = Array.from(XV(e)).map(Oj)), t;
}
function y8(e) {
  return Array.from(new Set(e));
}
var v8 = 0;
function dg() {
  this.message = "FLOW_CANCELLED";
}
dg.prototype = /* @__PURE__ */ Object.create(Error.prototype);
function b8(e) {
  return e instanceof dg;
}
var tv = /* @__PURE__ */ KI("flow"), w8 = /* @__PURE__ */ KI("flow.bound", {
  bound: !0
}), aa = /* @__PURE__ */ Object.assign(function(t, r) {
  if (dp(r))
    return tv.decorate_20223_(t, r);
  if (na(r))
    return fp(t, r, tv);
  var n = t, i = n.name || "<unnamed flow>", s = function() {
    var a = this, l = arguments, p = ++v8, f = Mo(i + " - runid: " + p + " - init", n).apply(a, l), d, m = void 0, v = new Promise(function(g, S) {
      var _ = 0;
      d = S;
      function x(k) {
        m = void 0;
        var A;
        try {
          A = Mo(i + " - runid: " + p + " - yield " + _++, f.next).call(f, k);
        } catch (T) {
          return S(T);
        }
        w(A);
      }
      function y(k) {
        m = void 0;
        var A;
        try {
          A = Mo(i + " - runid: " + p + " - yield " + _++, f.throw).call(f, k);
        } catch (T) {
          return S(T);
        }
        w(A);
      }
      function w(k) {
        if (gn(k == null ? void 0 : k.then)) {
          k.then(w, S);
          return;
        }
        return k.done ? g(k.value) : (m = Promise.resolve(k.value), m.then(x, y));
      }
      x(void 0);
    });
    return v.cancel = Mo(i + " - runid: " + p + " - cancel", function() {
      try {
        m && UO(m);
        var g = f.return(void 0), S = Promise.resolve(g.value);
        S.then(ul, ul), UO(S), d(new dg());
      } catch (_) {
        d(_);
      }
    }), v;
  };
  return s.isMobXFlow = !0, s;
}, tv);
aa.bound = /* @__PURE__ */ ei(w8);
function UO(e) {
  gn(e.cancel) && e.cancel();
}
function S8(e) {
  return e;
}
function Ll(e) {
  return (e == null ? void 0 : e.isMobXFlow) === !0;
}
function x8(e, t, r) {
  var n;
  return mr(e) || Br(e) || dS(e) ? n = go(e) : hr(e) && (n = go(e, t)), n.dehancer = typeof t == "function" ? t : r, function() {
    n.dehancer = void 0;
  };
}
function _8(e, t, r) {
  return gn(r) ? O8(e, t, r) : E8(e, t);
}
function E8(e, t) {
  return go(e).intercept_(t);
}
function O8(e, t, r) {
  return go(e, t).intercept_(r);
}
function kj(e, t) {
  if (t === void 0)
    return sa(e);
  if (hr(e) === !1 || !e[Qe].values_.has(t))
    return !1;
  var r = mo(e, t);
  return sa(r);
}
function k8(e) {
  return kj(e);
}
function A8(e, t) {
  return kj(e, t);
}
function Aj(e, t) {
  return e ? t !== void 0 ? hr(e) ? e[Qe].values_.has(t) : !1 : hr(e) || !!e[Qe] || cS(e) || mm(e) || sa(e) : !1;
}
function hg(e) {
  return Aj(e);
}
function P8(e, t) {
  return Aj(e, t);
}
function Jc(e) {
  if (hr(e))
    return e[Qe].keys_();
  if (mr(e) || ur(e))
    return Array.from(e.keys());
  if (Br(e))
    return e.map(function(t, r) {
      return r;
    });
  tt(5);
}
function C8(e) {
  if (hr(e))
    return Jc(e).map(function(t) {
      return e[t];
    });
  if (mr(e))
    return Jc(e).map(function(t) {
      return e.get(t);
    });
  if (ur(e))
    return Array.from(e.values());
  if (Br(e))
    return e.slice();
  tt(6);
}
function T8(e) {
  if (hr(e))
    return Jc(e).map(function(t) {
      return [t, e[t]];
    });
  if (mr(e))
    return Jc(e).map(function(t) {
      return [t, e.get(t)];
    });
  if (ur(e))
    return Array.from(e.entries());
  if (Br(e))
    return e.map(function(t, r) {
      return [r, t];
    });
  tt(7);
}
function Pj(e, t, r) {
  if (arguments.length === 2 && !ur(e)) {
    Xr();
    var n = t;
    try {
      for (var i in n)
        Pj(e, i, n[i]);
    } finally {
      Jr();
    }
    return;
  }
  hr(e) ? e[Qe].set_(t, r) : mr(e) ? e.set(t, r) : ur(e) ? e.add(t) : Br(e) ? (typeof t != "number" && (t = parseInt(t, 10)), t < 0 && tt("Invalid index: '" + t + "'"), Xr(), t >= e.length && (e.length = t + 1), e[t] = r, Jr()) : tt(8);
}
function $8(e, t) {
  hr(e) ? e[Qe].delete_(t) : mr(e) || ur(e) ? e.delete(t) : Br(e) ? (typeof t != "number" && (t = parseInt(t, 10)), e.splice(t, 1)) : tt(9);
}
function Cj(e, t) {
  if (hr(e))
    return e[Qe].has_(t);
  if (mr(e))
    return e.has(t);
  if (ur(e))
    return e.has(t);
  if (Br(e))
    return t >= 0 && t < e.length;
  tt(10);
}
function R8(e, t) {
  if (Cj(e, t)) {
    if (hr(e))
      return e[Qe].get_(t);
    if (mr(e))
      return e.get(t);
    if (Br(e))
      return e[t];
    tt(11);
  }
}
function I8(e, t, r) {
  if (hr(e))
    return e[Qe].defineProperty_(t, r);
  tt(39);
}
function Tj(e) {
  if (hr(e))
    return e[Qe].ownKeys_();
  tt(38);
}
function j8(e, t, r, n) {
  return gn(r) ? L8(e, t, r, n) : N8(e, t, r);
}
function N8(e, t, r) {
  return go(e).observe_(t, r);
}
function L8(e, t, r, n) {
  return go(e, t).observe_(r, n);
}
function Jf(e, t, r) {
  return e.set(t, r), r;
}
function Qa(e, t) {
  if (e == null || typeof e != "object" || e instanceof Date || !hg(e))
    return e;
  if (dS(e) || sa(e))
    return Qa(e.get(), t);
  if (t.has(e))
    return t.get(e);
  if (Br(e)) {
    var r = Jf(t, e, new Array(e.length));
    return e.forEach(function(o, a) {
      r[a] = Qa(o, t);
    }), r;
  }
  if (ur(e)) {
    var n = Jf(t, e, /* @__PURE__ */ new Set());
    return e.forEach(function(o) {
      n.add(Qa(o, t));
    }), n;
  }
  if (mr(e)) {
    var i = Jf(t, e, /* @__PURE__ */ new Map());
    return e.forEach(function(o, a) {
      i.set(a, Qa(o, t));
    }), i;
  } else {
    var s = Jf(t, e, {});
    return Tj(e).forEach(function(o) {
      cp.propertyIsEnumerable.call(e, o) && (s[o] = Qa(e[o], t));
    }), s;
  }
}
function M8(e, t) {
  return Qa(e, /* @__PURE__ */ new Map());
}
function D8() {
}
function xi(e, t) {
  t === void 0 && (t = void 0), Xr();
  try {
    return e.apply(t);
  } finally {
    Jr();
  }
}
function F8(e, t, r) {
  return arguments.length === 1 || t && typeof t == "object" ? z8(e, t) : $j(e, t, r || {});
}
function $j(e, t, r) {
  var n;
  if (typeof r.timeout == "number") {
    var i = new Error("WHEN_TIMEOUT");
    n = setTimeout(function() {
      if (!o[Qe].isDisposed)
        if (o(), r.onError)
          r.onError(i);
        else
          throw i;
    }, r.timeout);
  }
  r.name = "When";
  var s = is("When-effect", t), o = hS(function(a) {
    var l = ug(!1, e);
    l && (a.dispose(), n && clearTimeout(n), s());
  }, r);
  return o;
}
function z8(e, t) {
  var r;
  if (t != null && (r = t.signal) != null && r.aborted)
    return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
      cancel: function() {
        return null;
      }
    });
  var n, i, s = new Promise(function(o, a) {
    var l, p = $j(e, o, ns({}, t, {
      onError: a
    }));
    n = function() {
      p(), a(new Error("WHEN_CANCELLED"));
    }, i = function() {
      p(), a(new Error("WHEN_ABORTED"));
    }, t == null || (l = t.signal) == null || l.addEventListener == null || l.addEventListener("abort", i);
  }).finally(function() {
    var o;
    return t == null || (o = t.signal) == null || o.removeEventListener == null ? void 0 : o.removeEventListener("abort", i);
  });
  return s.cancel = n, s;
}
function Fa(e) {
  return e[Qe];
}
var q8 = {
  has: function(t, r) {
    return Fa(t).has_(r);
  },
  get: function(t, r) {
    return Fa(t).get_(r);
  },
  set: function(t, r, n) {
    var i;
    return na(r) ? (i = Fa(t).set_(r, n, !0)) != null ? i : !0 : !1;
  },
  deleteProperty: function(t, r) {
    var n;
    return na(r) ? (n = Fa(t).delete_(r, !0)) != null ? n : !0 : !1;
  },
  defineProperty: function(t, r, n) {
    var i;
    return (i = Fa(t).defineProperty_(r, n)) != null ? i : !0;
  },
  ownKeys: function(t) {
    return Fa(t).ownKeys_();
  },
  preventExtensions: function(t) {
    tt(13);
  }
};
function B8(e, t) {
  var r, n;
  return qI(), e = pa(e, t), (n = (r = e[Qe]).proxy_) != null ? n : r.proxy_ = new Proxy(e, q8);
}
function Cn(e) {
  return e.interceptors_ !== void 0 && e.interceptors_.length > 0;
}
function gp(e, t) {
  var r = e.interceptors_ || (e.interceptors_ = []);
  return r.push(t), BI(function() {
    var n = r.indexOf(t);
    n !== -1 && r.splice(n, 1);
  });
}
function Tn(e, t) {
  var r = ca();
  try {
    for (var n = [].concat(e.interceptors_ || []), i = 0, s = n.length; i < s && (t = n[i](t), t && !t.type && tt(14), !!t); i++)
      ;
    return t;
  } finally {
    oo(r);
  }
}
function ti(e) {
  return e.changeListeners_ !== void 0 && e.changeListeners_.length > 0;
}
function yp(e, t) {
  var r = e.changeListeners_ || (e.changeListeners_ = []);
  return r.push(t), BI(function() {
    var n = r.indexOf(t);
    n !== -1 && r.splice(n, 1);
  });
}
function ri(e, t) {
  var r = ca(), n = e.changeListeners_;
  if (n) {
    n = n.slice();
    for (var i = 0, s = n.length; i < s; i++)
      n[i](t);
    oo(r);
  }
}
function Rj(e, t, r) {
  return cs(function() {
    var n, i = pa(e, r)[Qe];
    (n = t) != null || (t = X6(e)), Il(t).forEach(function(s) {
      return i.make_(s, t[s]);
    });
  }), e;
}
var rv = /* @__PURE__ */ Symbol("mobx-keys");
function U8(e, t, r) {
  return ho(e) ? gS(e, e, t, r) : (cs(function() {
    var n = pa(e, r)[Qe];
    if (!e[rv]) {
      var i = Object.getPrototypeOf(e), s = new Set([].concat(Il(e), Il(i)));
      s.delete("constructor"), s.delete(Qe), pp(i, rv, s);
    }
    e[rv].forEach(function(o) {
      return n.make_(
        o,
        // must pass "undefined" for { key: undefined }
        t && o in t ? t[o] : !0
      );
    });
  }), e);
}
var VO = "splice", Ti = "update", V8 = 1e4, W8 = {
  get: function(t, r) {
    var n = t[Qe];
    return r === Qe ? n : r === "length" ? n.getArrayLength_() : typeof r == "string" && !isNaN(r) ? n.get_(parseInt(r)) : io(gm, r) ? gm[r] : t[r];
  },
  set: function(t, r, n) {
    var i = t[Qe];
    return r === "length" && i.setArrayLength_(n), typeof r == "symbol" || isNaN(r) ? t[r] = n : i.set_(parseInt(r), n), !0;
  },
  preventExtensions: function() {
    tt(15);
  }
}, yS = /* @__PURE__ */ function() {
  function e(r, n, i, s) {
    r === void 0 && (r = "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = i, this.legacyMode_ = s, this.atom_ = new us(r), this.enhancer_ = function(o, a) {
      return n(o, a, "ObservableArray[..]");
    };
  }
  var t = e.prototype;
  return t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.dehanceValues_ = function(n) {
    return this.dehancer !== void 0 && n.length > 0 ? n.map(this.dehancer) : n;
  }, t.intercept_ = function(n) {
    return gp(this, n);
  }, t.observe_ = function(n, i) {
    return i === void 0 && (i = !1), i && n({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), yp(this, n);
  }, t.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, t.setArrayLength_ = function(n) {
    (typeof n != "number" || isNaN(n) || n < 0) && tt("Out of range: " + n);
    var i = this.values_.length;
    if (n !== i)
      if (n > i) {
        for (var s = new Array(n - i), o = 0; o < n - i; o++)
          s[o] = void 0;
        this.spliceWithArray_(i, 0, s);
      } else
        this.spliceWithArray_(n, i - n);
  }, t.updateArrayLength_ = function(n, i) {
    n !== this.lastKnownLength_ && tt(16), this.lastKnownLength_ += i, this.legacyMode_ && i > 0 && Mj(n + i + 1);
  }, t.spliceWithArray_ = function(n, i, s) {
    var o = this;
    this.atom_;
    var a = this.values_.length;
    if (n === void 0 ? n = 0 : n > a ? n = a : n < 0 && (n = Math.max(0, a + n)), arguments.length === 1 ? i = a - n : i == null ? i = 0 : i = Math.max(0, Math.min(i, a - n)), s === void 0 && (s = _b), Cn(this)) {
      var l = Tn(this, {
        object: this.proxy_,
        type: VO,
        index: n,
        removedCount: i,
        added: s
      });
      if (!l)
        return _b;
      i = l.removedCount, s = l.added;
    }
    if (s = s.length === 0 ? s : s.map(function(d) {
      return o.enhancer_(d, void 0);
    }), this.legacyMode_) {
      var p = s.length - i;
      this.updateArrayLength_(a, p);
    }
    var f = this.spliceItemsIntoValues_(n, i, s);
    return (i !== 0 || s.length !== 0) && this.notifyArraySplice_(n, s, f), this.dehanceValues_(f);
  }, t.spliceItemsIntoValues_ = function(n, i, s) {
    if (s.length < V8) {
      var o;
      return (o = this.values_).splice.apply(o, [n, i].concat(s));
    } else {
      var a = this.values_.slice(n, n + i), l = this.values_.slice(n + i);
      this.values_.length += s.length - i;
      for (var p = 0; p < s.length; p++)
        this.values_[n + p] = s[p];
      for (var f = 0; f < l.length; f++)
        this.values_[n + s.length + f] = l[f];
      return a;
    }
  }, t.notifyArrayChildUpdate_ = function(n, i, s) {
    var o = !this.owned_ && _c(), a = ti(this), l = a || o ? {
      observableKind: "array",
      object: this.proxy_,
      type: Ti,
      debugObjectName: this.atom_.name_,
      index: n,
      newValue: i,
      oldValue: s
    } : null;
    this.atom_.reportChanged(), a && ri(this, l);
  }, t.notifyArraySplice_ = function(n, i, s) {
    var o = !this.owned_ && _c(), a = ti(this), l = a || o ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: VO,
      index: n,
      removed: s,
      added: i,
      removedCount: s.length,
      addedCount: i.length
    } : null;
    this.atom_.reportChanged(), a && ri(this, l);
  }, t.get_ = function(n) {
    if (this.legacyMode_ && n >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + n);
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[n]);
  }, t.set_ = function(n, i) {
    var s = this.values_;
    if (this.legacyMode_ && n > s.length && tt(17, n, s.length), n < s.length) {
      this.atom_;
      var o = s[n];
      if (Cn(this)) {
        var a = Tn(this, {
          type: Ti,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: n,
          newValue: i
        });
        if (!a)
          return;
        i = a.newValue;
      }
      i = this.enhancer_(i, o);
      var l = i !== o;
      l && (s[n] = i, this.notifyArrayChildUpdate_(n, i, o));
    } else {
      for (var p = new Array(n + 1 - s.length), f = 0; f < p.length - 1; f++)
        p[f] = void 0;
      p[p.length - 1] = i, this.spliceWithArray_(s.length, 0, p);
    }
  }, e;
}();
function H8(e, t, r, n) {
  return r === void 0 && (r = "ObservableArray"), n === void 0 && (n = !1), qI(), cs(function() {
    var i = new yS(r, t, n, !1);
    VI(i.values_, Qe, i);
    var s = new Proxy(i.values_, W8);
    return i.proxy_ = s, e && e.length && i.spliceWithArray_(0, 0, e), s;
  });
}
var gm = {
  clear: function() {
    return this.splice(0);
  },
  replace: function(t) {
    var r = this[Qe];
    return r.spliceWithArray_(0, r.values_.length, t);
  },
  // Used by JSON.stringify
  toJSON: function() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function(t, r) {
    for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
      i[s - 2] = arguments[s];
    var o = this[Qe];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return o.spliceWithArray_(t);
      case 2:
        return o.spliceWithArray_(t, r);
    }
    return o.spliceWithArray_(t, r, i);
  },
  spliceWithArray: function(t, r, n) {
    return this[Qe].spliceWithArray_(t, r, n);
  },
  push: function() {
    for (var t = this[Qe], r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    return t.spliceWithArray_(t.values_.length, 0, n), t.values_.length;
  },
  pop: function() {
    return this.splice(Math.max(this[Qe].values_.length - 1, 0), 1)[0];
  },
  shift: function() {
    return this.splice(0, 1)[0];
  },
  unshift: function() {
    for (var t = this[Qe], r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    return t.spliceWithArray_(0, 0, n), t.values_.length;
  },
  reverse: function() {
    return Ne.trackingDerivation && tt(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function() {
    Ne.trackingDerivation && tt(37, "sort");
    var t = this.slice();
    return t.sort.apply(t, arguments), this.replace(t), this;
  },
  remove: function(t) {
    var r = this[Qe], n = r.dehanceValues_(r.values_).indexOf(t);
    return n > -1 ? (this.splice(n, 1), !0) : !1;
  }
};
Rt("at", wn);
Rt("concat", wn);
Rt("flat", wn);
Rt("includes", wn);
Rt("indexOf", wn);
Rt("join", wn);
Rt("lastIndexOf", wn);
Rt("slice", wn);
Rt("toString", wn);
Rt("toLocaleString", wn);
Rt("toSorted", wn);
Rt("toSpliced", wn);
Rt("with", wn);
Rt("every", si);
Rt("filter", si);
Rt("find", si);
Rt("findIndex", si);
Rt("findLast", si);
Rt("findLastIndex", si);
Rt("flatMap", si);
Rt("forEach", si);
Rt("map", si);
Rt("some", si);
Rt("toReversed", si);
Rt("reduce", Ij);
Rt("reduceRight", Ij);
function Rt(e, t) {
  typeof Array.prototype[e] == "function" && (gm[e] = t(e));
}
function wn(e) {
  return function() {
    var t = this[Qe];
    t.atom_.reportObserved();
    var r = t.dehanceValues_(t.values_);
    return r[e].apply(r, arguments);
  };
}
function si(e) {
  return function(t, r) {
    var n = this, i = this[Qe];
    i.atom_.reportObserved();
    var s = i.dehanceValues_(i.values_);
    return s[e](function(o, a) {
      return t.call(r, o, a, n);
    });
  };
}
function Ij(e) {
  return function() {
    var t = this, r = this[Qe];
    r.atom_.reportObserved();
    var n = r.dehanceValues_(r.values_), i = arguments[0];
    return arguments[0] = function(s, o, a) {
      return i(s, o, a, t);
    }, n[e].apply(n, arguments);
  };
}
var Q8 = /* @__PURE__ */ ls("ObservableArrayAdministration", yS);
function Br(e) {
  return sg(e) && Q8(e[Qe]);
}
var Y8 = {}, Do = "add", ym = "delete", vS = /* @__PURE__ */ function() {
  function e(r, n, i) {
    var s = this;
    n === void 0 && (n = oa), i === void 0 && (i = "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[Qe] = Y8, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = n, this.name_ = i, gn(Map) || tt(18), cs(function() {
      s.keysAtom_ = pS("ObservableMap.keys()"), s.data_ = /* @__PURE__ */ new Map(), s.hasMap_ = /* @__PURE__ */ new Map(), r && s.merge(r);
    });
  }
  var t = e.prototype;
  return t.has_ = function(n) {
    return this.data_.has(n);
  }, t.has = function(n) {
    var i = this;
    if (!Ne.trackingDerivation)
      return this.has_(n);
    var s = this.hasMap_.get(n);
    if (!s) {
      var o = s = new Ko(this.has_(n), ag, "ObservableMap.key?", !1);
      this.hasMap_.set(n, o), mS(o, function() {
        return i.hasMap_.delete(n);
      });
    }
    return s.get();
  }, t.set = function(n, i) {
    var s = this.has_(n);
    if (Cn(this)) {
      var o = Tn(this, {
        type: s ? Ti : Do,
        object: this,
        newValue: i,
        name: n
      });
      if (!o)
        return this;
      i = o.newValue;
    }
    return s ? this.updateValue_(n, i) : this.addValue_(n, i), this;
  }, t.delete = function(n) {
    var i = this;
    if (this.keysAtom_, Cn(this)) {
      var s = Tn(this, {
        type: ym,
        object: this,
        name: n
      });
      if (!s)
        return !1;
    }
    if (this.has_(n)) {
      var o = _c(), a = ti(this), l = a || o ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: ym,
        object: this,
        oldValue: this.data_.get(n).value_,
        name: n
      } : null;
      return xi(function() {
        var p;
        i.keysAtom_.reportChanged(), (p = i.hasMap_.get(n)) == null || p.setNewValue_(!1);
        var f = i.data_.get(n);
        f.setNewValue_(void 0), i.data_.delete(n);
      }), a && ri(this, l), !0;
    }
    return !1;
  }, t.updateValue_ = function(n, i) {
    var s = this.data_.get(n);
    if (i = s.prepareNewValue_(i), i !== Ne.UNCHANGED) {
      var o = _c(), a = ti(this), l = a || o ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: Ti,
        object: this,
        oldValue: s.value_,
        name: n,
        newValue: i
      } : null;
      s.setNewValue_(i), a && ri(this, l);
    }
  }, t.addValue_ = function(n, i) {
    var s = this;
    this.keysAtom_, xi(function() {
      var p, f = new Ko(i, s.enhancer_, "ObservableMap.key", !1);
      s.data_.set(n, f), i = f.value_, (p = s.hasMap_.get(n)) == null || p.setNewValue_(!0), s.keysAtom_.reportChanged();
    });
    var o = _c(), a = ti(this), l = a || o ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: Do,
      object: this,
      name: n,
      newValue: i
    } : null;
    a && ri(this, l);
  }, t.get = function(n) {
    return this.has(n) ? this.dehanceValue_(this.data_.get(n).get()) : this.dehanceValue_(void 0);
  }, t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, t.values = function() {
    var n = this, i = this.keys();
    return Zc({
      next: function() {
        var o = i.next(), a = o.done, l = o.value;
        return {
          done: a,
          value: a ? void 0 : n.get(l)
        };
      }
    });
  }, t.entries = function() {
    var n = this, i = this.keys();
    return Zc({
      next: function() {
        var o = i.next(), a = o.done, l = o.value;
        return {
          done: a,
          value: a ? void 0 : [l, n.get(l)]
        };
      }
    });
  }, t[Symbol.iterator] = function() {
    return this.entries();
  }, t.forEach = function(n, i) {
    for (var s = cl(this), o; !(o = s()).done; ) {
      var a = o.value, l = a[0], p = a[1];
      n.call(i, p, l, this);
    }
  }, t.merge = function(n) {
    var i = this;
    return mr(n) && (n = new Map(n)), xi(function() {
      ho(n) ? W6(n).forEach(function(s) {
        return i.set(s, n[s]);
      }) : Array.isArray(n) ? n.forEach(function(s) {
        var o = s[0], a = s[1];
        return i.set(o, a);
      }) : Hl(n) ? (V6(n) || tt(19, n), n.forEach(function(s, o) {
        return i.set(o, s);
      })) : n != null && tt(20, n);
    }), this;
  }, t.clear = function() {
    var n = this;
    xi(function() {
      Yl(function() {
        for (var i = cl(n.keys()), s; !(s = i()).done; ) {
          var o = s.value;
          n.delete(o);
        }
      });
    });
  }, t.replace = function(n) {
    var i = this;
    return xi(function() {
      for (var s = G8(n), o = /* @__PURE__ */ new Map(), a = !1, l = cl(i.data_.keys()), p; !(p = l()).done; ) {
        var f = p.value;
        if (!s.has(f)) {
          var d = i.delete(f);
          if (d)
            a = !0;
          else {
            var m = i.data_.get(f);
            o.set(f, m);
          }
        }
      }
      for (var v = cl(s.entries()), g; !(g = v()).done; ) {
        var S = g.value, _ = S[0], x = S[1], y = i.data_.has(_);
        if (i.set(_, x), i.data_.has(_)) {
          var w = i.data_.get(_);
          o.set(_, w), y || (a = !0);
        }
      }
      if (!a)
        if (i.data_.size !== o.size)
          i.keysAtom_.reportChanged();
        else
          for (var k = i.data_.keys(), A = o.keys(), T = k.next(), R = A.next(); !T.done; ) {
            if (T.value !== R.value) {
              i.keysAtom_.reportChanged();
              break;
            }
            T = k.next(), R = A.next();
          }
      i.data_ = o;
    }), this;
  }, t.toString = function() {
    return "[object ObservableMap]";
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.observe_ = function(n, i) {
    return yp(this, n);
  }, t.intercept_ = function(n) {
    return gp(this, n);
  }, Ql(e, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
}(), mr = /* @__PURE__ */ ls("ObservableMap", vS);
function G8(e) {
  if (Hl(e) || mr(e))
    return e;
  if (Array.isArray(e))
    return new Map(e);
  if (ho(e)) {
    var t = /* @__PURE__ */ new Map();
    for (var r in e)
      t.set(r, e[r]);
    return t;
  } else
    return tt(21, e);
}
var K8 = {}, bS = /* @__PURE__ */ function() {
  function e(r, n, i) {
    var s = this;
    n === void 0 && (n = oa), i === void 0 && (i = "ObservableSet"), this.name_ = void 0, this[Qe] = K8, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = i, gn(Set) || tt(22), this.enhancer_ = function(o, a) {
      return n(o, a, i);
    }, cs(function() {
      s.atom_ = pS(s.name_), r && s.replace(r);
    });
  }
  var t = e.prototype;
  return t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.clear = function() {
    var n = this;
    xi(function() {
      Yl(function() {
        for (var i = cl(n.data_.values()), s; !(s = i()).done; ) {
          var o = s.value;
          n.delete(o);
        }
      });
    });
  }, t.forEach = function(n, i) {
    for (var s = cl(this), o; !(o = s()).done; ) {
      var a = o.value;
      n.call(i, a, a, this);
    }
  }, t.add = function(n) {
    var i = this;
    if (this.atom_, Cn(this)) {
      var s = Tn(this, {
        type: Do,
        object: this,
        newValue: n
      });
      if (!s)
        return this;
    }
    if (!this.has(n)) {
      xi(function() {
        i.data_.add(i.enhancer_(n, void 0)), i.atom_.reportChanged();
      });
      var o = !1, a = ti(this), l = a || o ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: Do,
        object: this,
        newValue: n
      } : null;
      a && ri(this, l);
    }
    return this;
  }, t.delete = function(n) {
    var i = this;
    if (Cn(this)) {
      var s = Tn(this, {
        type: ym,
        object: this,
        oldValue: n
      });
      if (!s)
        return !1;
    }
    if (this.has(n)) {
      var o = !1, a = ti(this), l = a || o ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ym,
        object: this,
        oldValue: n
      } : null;
      return xi(function() {
        i.atom_.reportChanged(), i.data_.delete(n);
      }), a && ri(this, l), !0;
    }
    return !1;
  }, t.has = function(n) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(n));
  }, t.entries = function() {
    var n = 0, i = Array.from(this.keys()), s = Array.from(this.values());
    return Zc({
      next: function() {
        var a = n;
        return n += 1, a < s.length ? {
          value: [i[a], s[a]],
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, t.keys = function() {
    return this.values();
  }, t.values = function() {
    this.atom_.reportObserved();
    var n = this, i = 0, s = Array.from(this.data_.values());
    return Zc({
      next: function() {
        return i < s.length ? {
          value: n.dehanceValue_(s[i++]),
          done: !1
        } : {
          done: !0
        };
      }
    });
  }, t.intersection = function(n) {
    if (Ji(n) && !ur(n))
      return n.intersection(this);
    var i = new Set(this);
    return i.intersection(n);
  }, t.union = function(n) {
    if (Ji(n) && !ur(n))
      return n.union(this);
    var i = new Set(this);
    return i.union(n);
  }, t.difference = function(n) {
    return new Set(this).difference(n);
  }, t.symmetricDifference = function(n) {
    if (Ji(n) && !ur(n))
      return n.symmetricDifference(this);
    var i = new Set(this);
    return i.symmetricDifference(n);
  }, t.isSubsetOf = function(n) {
    return new Set(this).isSubsetOf(n);
  }, t.isSupersetOf = function(n) {
    return new Set(this).isSupersetOf(n);
  }, t.isDisjointFrom = function(n) {
    if (Ji(n) && !ur(n))
      return n.isDisjointFrom(this);
    var i = new Set(this);
    return i.isDisjointFrom(n);
  }, t.replace = function(n) {
    var i = this;
    return ur(n) && (n = new Set(n)), xi(function() {
      Array.isArray(n) ? (i.clear(), n.forEach(function(s) {
        return i.add(s);
      })) : Ji(n) ? (i.clear(), n.forEach(function(s) {
        return i.add(s);
      })) : n != null && tt("Cannot initialize set from " + n);
    }), this;
  }, t.observe_ = function(n, i) {
    return yp(this, n);
  }, t.intercept_ = function(n) {
    return gp(this, n);
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.toString = function() {
    return "[object ObservableSet]";
  }, t[Symbol.iterator] = function() {
    return this.values();
  }, Ql(e, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
}(), ur = /* @__PURE__ */ ls("ObservableSet", bS), WO = /* @__PURE__ */ Object.create(null), HO = "remove", jj = /* @__PURE__ */ function() {
  function e(r, n, i, s) {
    n === void 0 && (n = /* @__PURE__ */ new Map()), s === void 0 && (s = kV), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = r, this.values_ = n, this.name_ = i, this.defaultAnnotation_ = s, this.keysAtom_ = new us("ObservableObject.keys"), this.isPlainObject_ = ho(this.target_);
  }
  var t = e.prototype;
  return t.getObservablePropValue_ = function(n) {
    return this.values_.get(n).get();
  }, t.setObservablePropValue_ = function(n, i) {
    var s = this.values_.get(n);
    if (s instanceof ii)
      return s.set(i), !0;
    if (Cn(this)) {
      var o = Tn(this, {
        type: Ti,
        object: this.proxy_ || this.target_,
        name: n,
        newValue: i
      });
      if (!o)
        return null;
      i = o.newValue;
    }
    if (i = s.prepareNewValue_(i), i !== Ne.UNCHANGED) {
      var a = ti(this), l = !1, p = a || l ? {
        type: Ti,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: s.value_,
        name: n,
        newValue: i
      } : null;
      s.setNewValue_(i), a && ri(this, p);
    }
    return !0;
  }, t.get_ = function(n) {
    return Ne.trackingDerivation && !io(this.target_, n) && this.has_(n), this.target_[n];
  }, t.set_ = function(n, i, s) {
    return s === void 0 && (s = !1), io(this.target_, n) ? this.values_.has(n) ? this.setObservablePropValue_(n, i) : s ? Reflect.set(this.target_, n, i) : (this.target_[n] = i, !0) : this.extend_(n, {
      value: i,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, s);
  }, t.has_ = function(n) {
    if (!Ne.trackingDerivation)
      return n in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var i = this.pendingKeys_.get(n);
    return i || (i = new Ko(n in this.target_, ag, "ObservableObject.key?", !1), this.pendingKeys_.set(n, i)), i.get();
  }, t.make_ = function(n, i) {
    if (i === !0 && (i = this.defaultAnnotation_), i !== !1) {
      if (!(n in this.target_)) {
        var s;
        if ((s = this.target_[Ei]) != null && s[n])
          return;
        tt(1, i.annotationType_, this.name_ + "." + n.toString());
      }
      for (var o = this.target_; o && o !== cp; ) {
        var a = pm(o, n);
        if (a) {
          var l = i.make_(this, n, a, o);
          if (l === 0)
            return;
          if (l === 1)
            break;
        }
        o = Object.getPrototypeOf(o);
      }
      YO(this, i, n);
    }
  }, t.extend_ = function(n, i, s, o) {
    if (o === void 0 && (o = !1), s === !0 && (s = this.defaultAnnotation_), s === !1)
      return this.defineProperty_(n, i, o);
    var a = s.extend_(this, n, i, o);
    return a && YO(this, s, n), a;
  }, t.defineProperty_ = function(n, i, s) {
    s === void 0 && (s = !1), this.keysAtom_;
    try {
      Xr();
      var o = this.delete_(n);
      if (!o)
        return o;
      if (Cn(this)) {
        var a = Tn(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: Do,
          newValue: i.value
        });
        if (!a)
          return null;
        var l = a.newValue;
        i.value !== l && (i = ns({}, i, {
          value: l
        }));
      }
      if (s) {
        if (!Reflect.defineProperty(this.target_, n, i))
          return !1;
      } else
        Ci(this.target_, n, i);
      this.notifyPropertyAddition_(n, i.value);
    } finally {
      Jr();
    }
    return !0;
  }, t.defineObservableProperty_ = function(n, i, s, o) {
    o === void 0 && (o = !1), this.keysAtom_;
    try {
      Xr();
      var a = this.delete_(n);
      if (!a)
        return a;
      if (Cn(this)) {
        var l = Tn(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: Do,
          newValue: i
        });
        if (!l)
          return null;
        i = l.newValue;
      }
      var p = QO(n), f = {
        configurable: Ne.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: p.get,
        set: p.set
      };
      if (o) {
        if (!Reflect.defineProperty(this.target_, n, f))
          return !1;
      } else
        Ci(this.target_, n, f);
      var d = new Ko(i, s, "ObservableObject.key", !1);
      this.values_.set(n, d), this.notifyPropertyAddition_(n, d.value_);
    } finally {
      Jr();
    }
    return !0;
  }, t.defineComputedProperty_ = function(n, i, s) {
    s === void 0 && (s = !1), this.keysAtom_;
    try {
      Xr();
      var o = this.delete_(n);
      if (!o)
        return o;
      if (Cn(this)) {
        var a = Tn(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: Do,
          newValue: void 0
        });
        if (!a)
          return null;
      }
      i.name || (i.name = "ObservableObject.key"), i.context = this.proxy_ || this.target_;
      var l = QO(n), p = {
        configurable: Ne.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: l.get,
        set: l.set
      };
      if (s) {
        if (!Reflect.defineProperty(this.target_, n, p))
          return !1;
      } else
        Ci(this.target_, n, p);
      this.values_.set(n, new ii(i)), this.notifyPropertyAddition_(n, void 0);
    } finally {
      Jr();
    }
    return !0;
  }, t.delete_ = function(n, i) {
    if (i === void 0 && (i = !1), this.keysAtom_, !io(this.target_, n))
      return !0;
    if (Cn(this)) {
      var s = Tn(this, {
        object: this.proxy_ || this.target_,
        name: n,
        type: HO
      });
      if (!s)
        return null;
    }
    try {
      var o;
      Xr();
      var a = ti(this), l = !1, p = this.values_.get(n), f = void 0;
      if (!p && (a || l)) {
        var d;
        f = (d = pm(this.target_, n)) == null ? void 0 : d.value;
      }
      if (i) {
        if (!Reflect.deleteProperty(this.target_, n))
          return !1;
      } else
        delete this.target_[n];
      if (p && (this.values_.delete(n), p instanceof Ko && (f = p.value_), fj(p)), this.keysAtom_.reportChanged(), (o = this.pendingKeys_) == null || (o = o.get(n)) == null || o.set(n in this.target_), a || l) {
        var m = {
          type: HO,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: f,
          name: n
        };
        a && ri(this, m);
      }
    } finally {
      Jr();
    }
    return !0;
  }, t.observe_ = function(n, i) {
    return yp(this, n);
  }, t.intercept_ = function(n) {
    return gp(this, n);
  }, t.notifyPropertyAddition_ = function(n, i) {
    var s, o = ti(this), a = !1;
    if (o || a) {
      var l = o || a ? {
        type: Do,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: n,
        newValue: i
      } : null;
      o && ri(this, l);
    }
    (s = this.pendingKeys_) == null || (s = s.get(n)) == null || s.set(!0), this.keysAtom_.reportChanged();
  }, t.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), Il(this.target_);
  }, t.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, e;
}();
function pa(e, t) {
  var r;
  if (io(e, Qe))
    return e;
  var n = (r = t == null ? void 0 : t.name) != null ? r : "ObservableObject", i = new jj(e, /* @__PURE__ */ new Map(), String(n), MV(t));
  return pp(e, Qe, i), e;
}
var X8 = /* @__PURE__ */ ls("ObservableObjectAdministration", jj);
function QO(e) {
  return WO[e] || (WO[e] = {
    get: function() {
      return this[Qe].getObservablePropValue_(e);
    },
    set: function(r) {
      return this[Qe].setObservablePropValue_(e, r);
    }
  });
}
function hr(e) {
  return sg(e) ? X8(e[Qe]) : !1;
}
function YO(e, t, r) {
  var n;
  (n = e.target_[Ei]) == null || delete n[r];
}
var J8 = /* @__PURE__ */ Lj(0), Z8 = /* @__PURE__ */ function() {
  var e = !1, t = {};
  return Object.defineProperty(t, "0", {
    set: function() {
      e = !0;
    }
  }), Object.create(t)[0] = 1, e === !1;
}(), nv = 0, Nj = function() {
};
function eW(e, t) {
  Object.setPrototypeOf ? Object.setPrototypeOf(e.prototype, t) : e.prototype.__proto__ !== void 0 ? e.prototype.__proto__ = t : e.prototype = t;
}
eW(Nj, Array.prototype);
var wS = /* @__PURE__ */ function(e) {
  function t(n, i, s, o) {
    var a;
    return s === void 0 && (s = "ObservableArray"), o === void 0 && (o = !1), a = e.call(this) || this, cs(function() {
      var l = new yS(s, i, o, !0);
      l.proxy_ = a, VI(a, Qe, l), n && n.length && a.spliceWithArray(0, 0, n), Z8 && Object.defineProperty(a, "0", J8);
    }), a;
  }
  QI(t, e);
  var r = t.prototype;
  return r.concat = function() {
    this[Qe].atom_.reportObserved();
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      s.map(function(a) {
        return Br(a) ? a.slice() : a;
      })
    );
  }, r[Symbol.iterator] = function() {
    var n = this, i = 0;
    return Zc({
      next: function() {
        return i < n.length ? {
          value: n[i++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, Ql(t, [{
    key: "length",
    get: function() {
      return this[Qe].getArrayLength_();
    },
    set: function(i) {
      this[Qe].setArrayLength_(i);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
}(Nj);
Object.entries(gm).forEach(function(e) {
  var t = e[0], r = e[1];
  t !== "concat" && pp(wS.prototype, t, r);
});
function Lj(e) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[Qe].get_(e);
    },
    set: function(r) {
      this[Qe].set_(e, r);
    }
  };
}
function tW(e) {
  Ci(wS.prototype, "" + e, Lj(e));
}
function Mj(e) {
  if (e > nv) {
    for (var t = nv; t < e + 100; t++)
      tW(t);
    nv = e;
  }
}
Mj(1e3);
function rW(e, t, r) {
  return new wS(e, t, r);
}
function mo(e, t) {
  if (typeof e == "object" && e !== null) {
    if (Br(e))
      return t !== void 0 && tt(23), e[Qe].atom_;
    if (ur(e))
      return e.atom_;
    if (mr(e)) {
      if (t === void 0)
        return e.keysAtom_;
      var r = e.data_.get(t) || e.hasMap_.get(t);
      return r || tt(25, t, vm(e)), r;
    }
    if (hr(e)) {
      if (!t)
        return tt(26);
      var n = e[Qe].values_.get(t);
      return n || tt(27, t, vm(e)), n;
    }
    if (cS(e) || sa(e) || mm(e))
      return e;
  } else if (gn(e) && mm(e[Qe]))
    return e[Qe];
  tt(28);
}
function go(e, t) {
  if (e || tt(29), t !== void 0)
    return go(mo(e, t));
  if (cS(e) || sa(e) || mm(e) || mr(e) || ur(e))
    return e;
  if (e[Qe])
    return e[Qe];
  tt(24, e);
}
function vm(e, t) {
  var r;
  if (t !== void 0)
    r = mo(e, t);
  else {
    if (Nl(e))
      return e.name;
    hr(e) || mr(e) || ur(e) ? r = go(e) : r = mo(e);
  }
  return r.name_;
}
function cs(e) {
  var t = ca(), r = cg(!0);
  Xr();
  try {
    return e();
  } finally {
    Jr(), pg(r), oo(t);
  }
}
var GO = cp.toString;
function SS(e, t, r) {
  return r === void 0 && (r = -1), Ib(e, t, r);
}
function Ib(e, t, r, n, i) {
  if (e === t)
    return e !== 0 || 1 / e === 1 / t;
  if (e == null || t == null)
    return !1;
  if (e !== e)
    return t !== t;
  var s = typeof e;
  if (s !== "function" && s !== "object" && typeof t != "object")
    return !1;
  var o = GO.call(e);
  if (o !== GO.call(t))
    return !1;
  switch (o) {
    case "[object RegExp]":
    case "[object String]":
      return "" + e == "" + t;
    case "[object Number]":
      return +e != +e ? +t != +t : +e == 0 ? 1 / +e === 1 / t : +e == +t;
    case "[object Date]":
    case "[object Boolean]":
      return +e == +t;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(e) === Symbol.valueOf.call(t);
    case "[object Map]":
    case "[object Set]":
      r >= 0 && r++;
      break;
  }
  e = KO(e), t = KO(t);
  var a = o === "[object Array]";
  if (!a) {
    if (typeof e != "object" || typeof t != "object")
      return !1;
    var l = e.constructor, p = t.constructor;
    if (l !== p && !(gn(l) && l instanceof l && gn(p) && p instanceof p) && "constructor" in e && "constructor" in t)
      return !1;
  }
  if (r === 0)
    return !1;
  r < 0 && (r = -1), n = n || [], i = i || [];
  for (var f = n.length; f--; )
    if (n[f] === e)
      return i[f] === t;
  if (n.push(e), i.push(t), a) {
    if (f = e.length, f !== t.length)
      return !1;
    for (; f--; )
      if (!Ib(e[f], t[f], r - 1, n, i))
        return !1;
  } else {
    var d = Object.keys(e), m;
    if (f = d.length, Object.keys(t).length !== f)
      return !1;
    for (; f--; )
      if (m = d[f], !(io(t, m) && Ib(e[m], t[m], r - 1, n, i)))
        return !1;
  }
  return n.pop(), i.pop(), !0;
}
function KO(e) {
  return Br(e) ? e.slice() : Hl(e) || mr(e) || Ji(e) || ur(e) ? Array.from(e.entries()) : e;
}
function Zc(e) {
  return e[Symbol.iterator] = nW, e;
}
function nW() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(e) {
  var t = lS();
  typeof t[e] > "u" && tt("MobX requires global '" + e + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy: hj,
  extras: {
    getDebugName: vm
  },
  $mobx: Qe
});
const iW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $mobx: Qe,
  FlowCancellationError: dg,
  ObservableMap: vS,
  ObservableSet: bS,
  Reaction: Mn,
  _allowStateChanges: ug,
  _allowStateChangesInsideComputed: Rb,
  _allowStateReadsEnd: vl,
  _allowStateReadsStart: fg,
  _autoAction: jl,
  _endAction: oj,
  _getAdministration: go,
  _getGlobalState: YV,
  _interceptReads: x8,
  _isComputingDerivation: VV,
  _resetGlobalState: GV,
  _startAction: ij,
  action: Mo,
  autorun: hS,
  comparer: ia,
  computed: mp,
  configure: xj,
  createAtom: pS,
  defineProperty: I8,
  entries: T8,
  extendObservable: gS,
  flow: aa,
  flowResult: S8,
  get: R8,
  getAtom: mo,
  getDebugName: vm,
  getDependencyTree: _j,
  getObserverTree: g8,
  has: Cj,
  intercept: _8,
  isAction: Nl,
  isBoxedObservable: dS,
  isComputed: k8,
  isComputedProp: A8,
  isFlow: Ll,
  isFlowCancellationError: b8,
  isObservable: hg,
  isObservableArray: Br,
  isObservableMap: mr,
  isObservableObject: hr,
  isObservableProp: P8,
  isObservableSet: ur,
  keys: Jc,
  makeAutoObservable: U8,
  makeObservable: Rj,
  observable: Qt,
  observe: j8,
  onBecomeObserved: wj,
  onBecomeUnobserved: mS,
  onReactionError: t8,
  override: iV,
  ownKeys: Tj,
  reaction: c8,
  remove: $8,
  runInAction: Rb,
  set: Pj,
  spy: hj,
  toJS: M8,
  trace: D8,
  transaction: xi,
  untracked: Yl,
  values: C8,
  when: F8
}, Symbol.toStringTag, { value: "Module" })), oW = /* @__PURE__ */ Ri(iW);
var yi = {}, Wr = {};
const sW = {}, aW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: sW
}, Symbol.toStringTag, { value: "Module" })), Gs = /* @__PURE__ */ Ri(aW);
var iv, XO;
function xS() {
  if (XO) return iv;
  XO = 1;
  function e(i) {
    if (typeof i != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(i));
  }
  function t(i, s) {
    for (var o = "", a = 0, l = -1, p = 0, f, d = 0; d <= i.length; ++d) {
      if (d < i.length)
        f = i.charCodeAt(d);
      else {
        if (f === 47)
          break;
        f = 47;
      }
      if (f === 47) {
        if (!(l === d - 1 || p === 1)) if (l !== d - 1 && p === 2) {
          if (o.length < 2 || a !== 2 || o.charCodeAt(o.length - 1) !== 46 || o.charCodeAt(o.length - 2) !== 46) {
            if (o.length > 2) {
              var m = o.lastIndexOf("/");
              if (m !== o.length - 1) {
                m === -1 ? (o = "", a = 0) : (o = o.slice(0, m), a = o.length - 1 - o.lastIndexOf("/")), l = d, p = 0;
                continue;
              }
            } else if (o.length === 2 || o.length === 1) {
              o = "", a = 0, l = d, p = 0;
              continue;
            }
          }
          s && (o.length > 0 ? o += "/.." : o = "..", a = 2);
        } else
          o.length > 0 ? o += "/" + i.slice(l + 1, d) : o = i.slice(l + 1, d), a = d - l - 1;
        l = d, p = 0;
      } else f === 46 && p !== -1 ? ++p : p = -1;
    }
    return o;
  }
  function r(i, s) {
    var o = s.dir || s.root, a = s.base || (s.name || "") + (s.ext || "");
    return o ? o === s.root ? o + a : o + i + a : a;
  }
  var n = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var s = "", o = !1, a, l = arguments.length - 1; l >= -1 && !o; l--) {
        var p;
        l >= 0 ? p = arguments[l] : (a === void 0 && (a = process.cwd()), p = a), e(p), p.length !== 0 && (s = p + "/" + s, o = p.charCodeAt(0) === 47);
      }
      return s = t(s, !o), o ? s.length > 0 ? "/" + s : "/" : s.length > 0 ? s : ".";
    },
    normalize: function(s) {
      if (e(s), s.length === 0) return ".";
      var o = s.charCodeAt(0) === 47, a = s.charCodeAt(s.length - 1) === 47;
      return s = t(s, !o), s.length === 0 && !o && (s = "."), s.length > 0 && a && (s += "/"), o ? "/" + s : s;
    },
    isAbsolute: function(s) {
      return e(s), s.length > 0 && s.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var s, o = 0; o < arguments.length; ++o) {
        var a = arguments[o];
        e(a), a.length > 0 && (s === void 0 ? s = a : s += "/" + a);
      }
      return s === void 0 ? "." : n.normalize(s);
    },
    relative: function(s, o) {
      if (e(s), e(o), s === o || (s = n.resolve(s), o = n.resolve(o), s === o)) return "";
      for (var a = 1; a < s.length && s.charCodeAt(a) === 47; ++a)
        ;
      for (var l = s.length, p = l - a, f = 1; f < o.length && o.charCodeAt(f) === 47; ++f)
        ;
      for (var d = o.length, m = d - f, v = p < m ? p : m, g = -1, S = 0; S <= v; ++S) {
        if (S === v) {
          if (m > v) {
            if (o.charCodeAt(f + S) === 47)
              return o.slice(f + S + 1);
            if (S === 0)
              return o.slice(f + S);
          } else p > v && (s.charCodeAt(a + S) === 47 ? g = S : S === 0 && (g = 0));
          break;
        }
        var _ = s.charCodeAt(a + S), x = o.charCodeAt(f + S);
        if (_ !== x)
          break;
        _ === 47 && (g = S);
      }
      var y = "";
      for (S = a + g + 1; S <= l; ++S)
        (S === l || s.charCodeAt(S) === 47) && (y.length === 0 ? y += ".." : y += "/..");
      return y.length > 0 ? y + o.slice(f + g) : (f += g, o.charCodeAt(f) === 47 && ++f, o.slice(f));
    },
    _makeLong: function(s) {
      return s;
    },
    dirname: function(s) {
      if (e(s), s.length === 0) return ".";
      for (var o = s.charCodeAt(0), a = o === 47, l = -1, p = !0, f = s.length - 1; f >= 1; --f)
        if (o = s.charCodeAt(f), o === 47) {
          if (!p) {
            l = f;
            break;
          }
        } else
          p = !1;
      return l === -1 ? a ? "/" : "." : a && l === 1 ? "//" : s.slice(0, l);
    },
    basename: function(s, o) {
      if (o !== void 0 && typeof o != "string") throw new TypeError('"ext" argument must be a string');
      e(s);
      var a = 0, l = -1, p = !0, f;
      if (o !== void 0 && o.length > 0 && o.length <= s.length) {
        if (o.length === s.length && o === s) return "";
        var d = o.length - 1, m = -1;
        for (f = s.length - 1; f >= 0; --f) {
          var v = s.charCodeAt(f);
          if (v === 47) {
            if (!p) {
              a = f + 1;
              break;
            }
          } else
            m === -1 && (p = !1, m = f + 1), d >= 0 && (v === o.charCodeAt(d) ? --d === -1 && (l = f) : (d = -1, l = m));
        }
        return a === l ? l = m : l === -1 && (l = s.length), s.slice(a, l);
      } else {
        for (f = s.length - 1; f >= 0; --f)
          if (s.charCodeAt(f) === 47) {
            if (!p) {
              a = f + 1;
              break;
            }
          } else l === -1 && (p = !1, l = f + 1);
        return l === -1 ? "" : s.slice(a, l);
      }
    },
    extname: function(s) {
      e(s);
      for (var o = -1, a = 0, l = -1, p = !0, f = 0, d = s.length - 1; d >= 0; --d) {
        var m = s.charCodeAt(d);
        if (m === 47) {
          if (!p) {
            a = d + 1;
            break;
          }
          continue;
        }
        l === -1 && (p = !1, l = d + 1), m === 46 ? o === -1 ? o = d : f !== 1 && (f = 1) : o !== -1 && (f = -1);
      }
      return o === -1 || l === -1 || // We saw a non-dot character immediately before the dot
      f === 0 || // The (right-most) trimmed path component is exactly '..'
      f === 1 && o === l - 1 && o === a + 1 ? "" : s.slice(o, l);
    },
    format: function(s) {
      if (s === null || typeof s != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof s);
      return r("/", s);
    },
    parse: function(s) {
      e(s);
      var o = { root: "", dir: "", base: "", ext: "", name: "" };
      if (s.length === 0) return o;
      var a = s.charCodeAt(0), l = a === 47, p;
      l ? (o.root = "/", p = 1) : p = 0;
      for (var f = -1, d = 0, m = -1, v = !0, g = s.length - 1, S = 0; g >= p; --g) {
        if (a = s.charCodeAt(g), a === 47) {
          if (!v) {
            d = g + 1;
            break;
          }
          continue;
        }
        m === -1 && (v = !1, m = g + 1), a === 46 ? f === -1 ? f = g : S !== 1 && (S = 1) : f !== -1 && (S = -1);
      }
      return f === -1 || m === -1 || // We saw a non-dot character immediately before the dot
      S === 0 || // The (right-most) trimmed path component is exactly '..'
      S === 1 && f === m - 1 && f === d + 1 ? m !== -1 && (d === 0 && l ? o.base = o.name = s.slice(1, m) : o.base = o.name = s.slice(d, m)) : (d === 0 && l ? (o.name = s.slice(1, f), o.base = s.slice(1, m)) : (o.name = s.slice(d, f), o.base = s.slice(d, m)), o.ext = s.slice(f, m)), d > 0 ? o.dir = s.slice(0, d - 1) : l && (o.dir = "/"), o;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return n.posix = n, iv = n, iv;
}
var Ar = {}, ov = {}, sv, JO;
function lW() {
  return JO || (JO = 1, sv = typeof process == "object" && process && process.platform === "win32" ? { sep: "\\" } : { sep: "/" }), sv;
}
var av, ZO;
function uW() {
  if (ZO) return av;
  ZO = 1, av = e;
  function e(n, i, s) {
    n instanceof RegExp && (n = t(n, s)), i instanceof RegExp && (i = t(i, s));
    var o = r(n, i, s);
    return o && {
      start: o[0],
      end: o[1],
      pre: s.slice(0, o[0]),
      body: s.slice(o[0] + n.length, o[1]),
      post: s.slice(o[1] + i.length)
    };
  }
  function t(n, i) {
    var s = i.match(n);
    return s ? s[0] : null;
  }
  e.range = r;
  function r(n, i, s) {
    var o, a, l, p, f, d = s.indexOf(n), m = s.indexOf(i, d + 1), v = d;
    if (d >= 0 && m > 0) {
      if (n === i)
        return [d, m];
      for (o = [], l = s.length; v >= 0 && !f; )
        v == d ? (o.push(v), d = s.indexOf(n, v + 1)) : o.length == 1 ? f = [o.pop(), m] : (a = o.pop(), a < l && (l = a, p = m), m = s.indexOf(i, v + 1)), v = d < m && d >= 0 ? d : m;
      o.length && (f = [l, p]);
    }
    return f;
  }
  return av;
}
var lv, ek;
function cW() {
  if (ek) return lv;
  ek = 1;
  var e = uW();
  lv = f;
  var t = "\0SLASH" + Math.random() + "\0", r = "\0OPEN" + Math.random() + "\0", n = "\0CLOSE" + Math.random() + "\0", i = "\0COMMA" + Math.random() + "\0", s = "\0PERIOD" + Math.random() + "\0";
  function o(_) {
    return parseInt(_, 10) == _ ? parseInt(_, 10) : _.charCodeAt(0);
  }
  function a(_) {
    return _.split("\\\\").join(t).split("\\{").join(r).split("\\}").join(n).split("\\,").join(i).split("\\.").join(s);
  }
  function l(_) {
    return _.split(t).join("\\").split(r).join("{").split(n).join("}").split(i).join(",").split(s).join(".");
  }
  function p(_) {
    if (!_)
      return [""];
    var x = [], y = e("{", "}", _);
    if (!y)
      return _.split(",");
    var w = y.pre, k = y.body, A = y.post, T = w.split(",");
    T[T.length - 1] += "{" + k + "}";
    var R = p(A);
    return A.length && (T[T.length - 1] += R.shift(), T.push.apply(T, R)), x.push.apply(x, T), x;
  }
  function f(_) {
    return _ ? (_.substr(0, 2) === "{}" && (_ = "\\{\\}" + _.substr(2)), S(a(_), !0).map(l)) : [];
  }
  function d(_) {
    return "{" + _ + "}";
  }
  function m(_) {
    return /^-?0\d/.test(_);
  }
  function v(_, x) {
    return _ <= x;
  }
  function g(_, x) {
    return _ >= x;
  }
  function S(_, x) {
    var y = [], w = e("{", "}", _);
    if (!w) return [_];
    var k = w.pre, A = w.post.length ? S(w.post, !1) : [""];
    if (/\$$/.test(w.pre))
      for (var T = 0; T < A.length; T++) {
        var R = k + "{" + w.body + "}" + A[T];
        y.push(R);
      }
    else {
      var I = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(w.body), B = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(w.body), L = I || B, Y = w.body.indexOf(",") >= 0;
      if (!L && !Y)
        return w.post.match(/,.*\}/) ? (_ = w.pre + "{" + w.body + n + w.post, S(_)) : [_];
      var Q;
      if (L)
        Q = w.body.split(/\.\./);
      else if (Q = p(w.body), Q.length === 1 && (Q = S(Q[0], !1).map(d), Q.length === 1))
        return A.map(function(F) {
          return w.pre + Q[0] + F;
        });
      var re;
      if (L) {
        var oe = o(Q[0]), ce = o(Q[1]), pe = Math.max(Q[0].length, Q[1].length), fe = Q.length == 3 ? Math.abs(o(Q[2])) : 1, G = v, Z = ce < oe;
        Z && (fe *= -1, G = g);
        var K = Q.some(m);
        re = [];
        for (var z = oe; G(z, ce); z += fe) {
          var te;
          if (B)
            te = String.fromCharCode(z), te === "\\" && (te = "");
          else if (te = String(z), K) {
            var q = pe - te.length;
            if (q > 0) {
              var j = new Array(q + 1).join("0");
              z < 0 ? te = "-" + j + te.slice(1) : te = j + te;
            }
          }
          re.push(te);
        }
      } else {
        re = [];
        for (var H = 0; H < Q.length; H++)
          re.push.apply(re, S(Q[H], !1));
      }
      for (var H = 0; H < re.length; H++)
        for (var T = 0; T < A.length; T++) {
          var R = k + re[H] + A[T];
          (!x || L || R) && y.push(R);
        }
    }
    return y;
  }
  return lv;
}
var Zf, tk;
function pW() {
  if (tk) return Zf;
  tk = 1;
  const e = Zf = (R, I, B = {}) => (_(I), !B.nocomment && I.charAt(0) === "#" ? !1 : new T(I, B).match(R));
  Zf = e;
  const t = lW();
  e.sep = t.sep;
  const r = Symbol("globstar **");
  e.GLOBSTAR = r;
  const n = cW(), i = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, s = "[^/]", o = s + "*?", a = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", l = "(?:(?!(?:\\/|^)\\.).)*?", p = (R) => R.split("").reduce((I, B) => (I[B] = !0, I), {}), f = p("().*{}+?[]^$\\!"), d = p("[.("), m = /\/+/;
  e.filter = (R, I = {}) => (B, L, Y) => e(B, R, I);
  const v = (R, I = {}) => {
    const B = {};
    return Object.keys(R).forEach((L) => B[L] = R[L]), Object.keys(I).forEach((L) => B[L] = I[L]), B;
  };
  e.defaults = (R) => {
    if (!R || typeof R != "object" || !Object.keys(R).length)
      return e;
    const I = e, B = (L, Y, Q) => I(L, Y, v(R, Q));
    return B.Minimatch = class extends I.Minimatch {
      constructor(Y, Q) {
        super(Y, v(R, Q));
      }
    }, B.Minimatch.defaults = (L) => I.defaults(v(R, L)).Minimatch, B.filter = (L, Y) => I.filter(L, v(R, Y)), B.defaults = (L) => I.defaults(v(R, L)), B.makeRe = (L, Y) => I.makeRe(L, v(R, Y)), B.braceExpand = (L, Y) => I.braceExpand(L, v(R, Y)), B.match = (L, Y, Q) => I.match(L, Y, v(R, Q)), B;
  }, e.braceExpand = (R, I) => g(R, I);
  const g = (R, I = {}) => (_(R), I.nobrace || !/\{(?:(?!\{).)*\}/.test(R) ? [R] : n(R)), S = 1024 * 64, _ = (R) => {
    if (typeof R != "string")
      throw new TypeError("invalid pattern");
    if (R.length > S)
      throw new TypeError("pattern is too long");
  }, x = Symbol("subparse");
  e.makeRe = (R, I) => new T(R, I || {}).makeRe(), e.match = (R, I, B = {}) => {
    const L = new T(I, B);
    return R = R.filter((Y) => L.match(Y)), L.options.nonull && !R.length && R.push(I), R;
  };
  const y = (R) => R.replace(/\\(.)/g, "$1"), w = (R) => R.replace(/\\([^-\]])/g, "$1"), k = (R) => R.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), A = (R) => R.replace(/[[\]\\]/g, "\\$&");
  class T {
    constructor(I, B) {
      _(I), B || (B = {}), this.options = B, this.set = [], this.pattern = I, this.windowsPathsNoEscape = !!B.windowsPathsNoEscape || B.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!B.partial, this.make();
    }
    debug() {
    }
    make() {
      const I = this.pattern, B = this.options;
      if (!B.nocomment && I.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!I) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      let L = this.globSet = this.braceExpand();
      B.debug && (this.debug = (...Y) => console.error(...Y)), this.debug(this.pattern, L), L = this.globParts = L.map((Y) => Y.split(m)), this.debug(this.pattern, L), L = L.map((Y, Q, re) => Y.map(this.parse, this)), this.debug(this.pattern, L), L = L.filter((Y) => Y.indexOf(!1) === -1), this.debug(this.pattern, L), this.set = L;
    }
    parseNegate() {
      if (this.options.nonegate) return;
      const I = this.pattern;
      let B = !1, L = 0;
      for (let Y = 0; Y < I.length && I.charAt(Y) === "!"; Y++)
        B = !B, L++;
      L && (this.pattern = I.slice(L)), this.negate = B;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(I, B, L) {
      var Y = this.options;
      this.debug(
        "matchOne",
        { this: this, file: I, pattern: B }
      ), this.debug("matchOne", I.length, B.length);
      for (var Q = 0, re = 0, oe = I.length, ce = B.length; Q < oe && re < ce; Q++, re++) {
        this.debug("matchOne loop");
        var pe = B[re], fe = I[Q];
        if (this.debug(B, pe, fe), pe === !1) return !1;
        if (pe === r) {
          this.debug("GLOBSTAR", [B, pe, fe]);
          var G = Q, Z = re + 1;
          if (Z === ce) {
            for (this.debug("** at the end"); Q < oe; Q++)
              if (I[Q] === "." || I[Q] === ".." || !Y.dot && I[Q].charAt(0) === ".") return !1;
            return !0;
          }
          for (; G < oe; ) {
            var K = I[G];
            if (this.debug(`
globstar while`, I, G, B, Z, K), this.matchOne(I.slice(G), B.slice(Z), L))
              return this.debug("globstar found match!", G, oe, K), !0;
            if (K === "." || K === ".." || !Y.dot && K.charAt(0) === ".") {
              this.debug("dot detected!", I, G, B, Z);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), G++;
          }
          return !!(L && (this.debug(`
>>> no match, partial?`, I, G, B, Z), G === oe));
        }
        var z;
        if (typeof pe == "string" ? (z = fe === pe, this.debug("string match", pe, fe, z)) : (z = fe.match(pe), this.debug("pattern match", pe, fe, z)), !z) return !1;
      }
      if (Q === oe && re === ce)
        return !0;
      if (Q === oe)
        return L;
      if (re === ce)
        return Q === oe - 1 && I[Q] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return g(this.pattern, this.options);
    }
    parse(I, B) {
      _(I);
      const L = this.options;
      if (I === "**")
        if (L.noglobstar)
          I = "*";
        else
          return r;
      if (I === "") return "";
      let Y = "", Q = !1, re = !1;
      const oe = [], ce = [];
      let pe, fe = !1, G = -1, Z = -1, K, z, te, q = I.charAt(0) === ".", j = L.dot || q;
      const H = () => q ? "" : j ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", F = (C) => C.charAt(0) === "." ? "" : L.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", ue = () => {
        if (pe) {
          switch (pe) {
            case "*":
              Y += o, Q = !0;
              break;
            case "?":
              Y += s, Q = !0;
              break;
            default:
              Y += "\\" + pe;
              break;
          }
          this.debug("clearStateChar %j %j", pe, Y), pe = !1;
        }
      };
      for (let C = 0, N; C < I.length && (N = I.charAt(C)); C++) {
        if (this.debug("%s	%s %s %j", I, C, Y, N), re) {
          if (N === "/")
            return !1;
          f[N] && (Y += "\\"), Y += N, re = !1;
          continue;
        }
        switch (N) {
          case "/":
            return !1;
          case "\\":
            if (fe && I.charAt(C + 1) === "-") {
              Y += N;
              continue;
            }
            ue(), re = !0;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s	%s %s %j <-- stateChar", I, C, Y, N), fe) {
              this.debug("  in class"), N === "!" && C === Z + 1 && (N = "^"), Y += N;
              continue;
            }
            this.debug("call clearStateChar %j", pe), ue(), pe = N, L.noext && ue();
            continue;
          case "(": {
            if (fe) {
              Y += "(";
              continue;
            }
            if (!pe) {
              Y += "\\(";
              continue;
            }
            const J = {
              type: pe,
              start: C - 1,
              reStart: Y.length,
              open: i[pe].open,
              close: i[pe].close
            };
            this.debug(this.pattern, "	", J), oe.push(J), Y += J.open, J.start === 0 && J.type !== "!" && (q = !0, Y += F(I.slice(C + 1))), this.debug("plType %j %j", pe, Y), pe = !1;
            continue;
          }
          case ")": {
            const J = oe[oe.length - 1];
            if (fe || !J) {
              Y += "\\)";
              continue;
            }
            oe.pop(), ue(), Q = !0, z = J, Y += z.close, z.type === "!" && ce.push(Object.assign(z, { reEnd: Y.length }));
            continue;
          }
          case "|": {
            const J = oe[oe.length - 1];
            if (fe || !J) {
              Y += "\\|";
              continue;
            }
            ue(), Y += "|", J.start === 0 && J.type !== "!" && (q = !0, Y += F(I.slice(C + 1)));
            continue;
          }
          case "[":
            if (ue(), fe) {
              Y += "\\" + N;
              continue;
            }
            fe = !0, Z = C, G = Y.length, Y += N;
            continue;
          case "]":
            if (C === Z + 1 || !fe) {
              Y += "\\" + N;
              continue;
            }
            K = I.substring(Z + 1, C);
            try {
              RegExp("[" + A(w(K)) + "]"), Y += N;
            } catch {
              Y = Y.substring(0, G) + "(?:$.)";
            }
            Q = !0, fe = !1;
            continue;
          default:
            ue(), f[N] && !(N === "^" && fe) && (Y += "\\"), Y += N;
            break;
        }
      }
      for (fe && (K = I.slice(Z + 1), te = this.parse(K, x), Y = Y.substring(0, G) + "\\[" + te[0], Q = Q || te[1]), z = oe.pop(); z; z = oe.pop()) {
        let C;
        C = Y.slice(z.reStart + z.open.length), this.debug("setting tail", Y, z), C = C.replace(/((?:\\{2}){0,64})(\\?)\|/g, (J, X, ae) => (ae || (ae = "\\"), X + X + ae + "|")), this.debug(`tail=%j
   %s`, C, C, z, Y);
        const N = z.type === "*" ? o : z.type === "?" ? s : "\\" + z.type;
        Q = !0, Y = Y.slice(0, z.reStart) + N + "\\(" + C;
      }
      ue(), re && (Y += "\\\\");
      const ge = d[Y.charAt(0)];
      for (let C = ce.length - 1; C > -1; C--) {
        const N = ce[C], J = Y.slice(0, N.reStart), X = Y.slice(N.reStart, N.reEnd - 8);
        let ae = Y.slice(N.reEnd);
        const U = Y.slice(N.reEnd - 8, N.reEnd) + ae, W = J.split(")").length, ve = J.split("(").length - W;
        let he = ae;
        for (let Se = 0; Se < ve; Se++)
          he = he.replace(/\)[+*?]?/, "");
        ae = he;
        const Te = ae === "" && B !== x ? "(?:$|\\/)" : "";
        Y = J + X + ae + Te + U;
      }
      if (Y !== "" && Q && (Y = "(?=.)" + Y), ge && (Y = H() + Y), B === x)
        return [Y, Q];
      if (L.nocase && !Q && (Q = I.toUpperCase() !== I.toLowerCase()), !Q)
        return y(I);
      const Ae = L.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + Y + "$", Ae), {
          _glob: I,
          _src: Y
        });
      } catch {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      const I = this.set;
      if (!I.length)
        return this.regexp = !1, this.regexp;
      const B = this.options, L = B.noglobstar ? o : B.dot ? a : l, Y = B.nocase ? "i" : "";
      let Q = I.map((re) => (re = re.map(
        (oe) => typeof oe == "string" ? k(oe) : oe === r ? r : oe._src
      ).reduce((oe, ce) => (oe[oe.length - 1] === r && ce === r || oe.push(ce), oe), []), re.forEach((oe, ce) => {
        oe !== r || re[ce - 1] === r || (ce === 0 ? re.length > 1 ? re[ce + 1] = "(?:\\/|" + L + "\\/)?" + re[ce + 1] : re[ce] = L : ce === re.length - 1 ? re[ce - 1] += "(?:\\/|" + L + ")?" : (re[ce - 1] += "(?:\\/|\\/" + L + "\\/)" + re[ce + 1], re[ce + 1] = r));
      }), re.filter((oe) => oe !== r).join("/"))).join("|");
      Q = "^(?:" + Q + ")$", this.negate && (Q = "^(?!" + Q + ").*$");
      try {
        this.regexp = new RegExp(Q, Y);
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    match(I, B = this.partial) {
      if (this.debug("match", I, this.pattern), this.comment) return !1;
      if (this.empty) return I === "";
      if (I === "/" && B) return !0;
      const L = this.options;
      t.sep !== "/" && (I = I.split(t.sep).join("/")), I = I.split(m), this.debug(this.pattern, "split", I);
      const Y = this.set;
      this.debug(this.pattern, "set", Y);
      let Q;
      for (let re = I.length - 1; re >= 0 && (Q = I[re], !Q); re--)
        ;
      for (let re = 0; re < Y.length; re++) {
        const oe = Y[re];
        let ce = I;
        if (L.matchBase && oe.length === 1 && (ce = [Q]), this.matchOne(ce, oe, B))
          return L.flipNegate ? !0 : !this.negate;
      }
      return L.flipNegate ? !1 : this.negate;
    }
    static defaults(I) {
      return e.defaults(I).Minimatch;
    }
  }
  return e.Minimatch = T, Zf;
}
var Cs = {}, Pr = {}, ed = {}, Ao = {}, rk;
function vp() {
  if (rk) return Ao;
  rk = 1;
  function e(o) {
    return typeof o > "u" || o === null;
  }
  function t(o) {
    return typeof o == "object" && o !== null;
  }
  function r(o) {
    return Array.isArray(o) ? o : e(o) ? [] : [o];
  }
  function n(o, a) {
    var l, p, f, d;
    if (a)
      for (d = Object.keys(a), l = 0, p = d.length; l < p; l += 1)
        f = d[l], o[f] = a[f];
    return o;
  }
  function i(o, a) {
    var l = "", p;
    for (p = 0; p < a; p += 1)
      l += o;
    return l;
  }
  function s(o) {
    return o === 0 && Number.NEGATIVE_INFINITY === 1 / o;
  }
  return Ao.isNothing = e, Ao.isObject = t, Ao.toArray = r, Ao.repeat = i, Ao.isNegativeZero = s, Ao.extend = n, Ao;
}
var uv, nk;
function bp() {
  if (nk) return uv;
  nk = 1;
  function e(r, n) {
    var i = "", s = r.reason || "(unknown reason)";
    return r.mark ? (r.mark.name && (i += 'in "' + r.mark.name + '" '), i += "(" + (r.mark.line + 1) + ":" + (r.mark.column + 1) + ")", !n && r.mark.snippet && (i += `

` + r.mark.snippet), s + " " + i) : s;
  }
  function t(r, n) {
    Error.call(this), this.name = "YAMLException", this.reason = r, this.mark = n, this.message = e(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t.prototype.toString = function(n) {
    return this.name + ": " + e(this, n);
  }, uv = t, uv;
}
var cv, ik;
function fW() {
  if (ik) return cv;
  ik = 1;
  var e = vp();
  function t(i, s, o, a, l) {
    var p = "", f = "", d = Math.floor(l / 2) - 1;
    return a - s > d && (p = " ... ", s = a - d + p.length), o - a > d && (f = " ...", o = a + d - f.length), {
      str: p + i.slice(s, o).replace(/\t/g, "→") + f,
      pos: a - s + p.length
      // relative position
    };
  }
  function r(i, s) {
    return e.repeat(" ", s - i.length) + i;
  }
  function n(i, s) {
    if (s = Object.create(s || null), !i.buffer) return null;
    s.maxLength || (s.maxLength = 79), typeof s.indent != "number" && (s.indent = 1), typeof s.linesBefore != "number" && (s.linesBefore = 3), typeof s.linesAfter != "number" && (s.linesAfter = 2);
    for (var o = /\r?\n|\r|\0/g, a = [0], l = [], p, f = -1; p = o.exec(i.buffer); )
      l.push(p.index), a.push(p.index + p[0].length), i.position <= p.index && f < 0 && (f = a.length - 2);
    f < 0 && (f = a.length - 1);
    var d = "", m, v, g = Math.min(i.line + s.linesAfter, l.length).toString().length, S = s.maxLength - (s.indent + g + 3);
    for (m = 1; m <= s.linesBefore && !(f - m < 0); m++)
      v = t(
        i.buffer,
        a[f - m],
        l[f - m],
        i.position - (a[f] - a[f - m]),
        S
      ), d = e.repeat(" ", s.indent) + r((i.line - m + 1).toString(), g) + " | " + v.str + `
` + d;
    for (v = t(i.buffer, a[f], l[f], i.position, S), d += e.repeat(" ", s.indent) + r((i.line + 1).toString(), g) + " | " + v.str + `
`, d += e.repeat("-", s.indent + g + 3 + v.pos) + `^
`, m = 1; m <= s.linesAfter && !(f + m >= l.length); m++)
      v = t(
        i.buffer,
        a[f + m],
        l[f + m],
        i.position - (a[f] - a[f + m]),
        S
      ), d += e.repeat(" ", s.indent) + r((i.line + m + 1).toString(), g) + " | " + v.str + `
`;
    return d.replace(/\n$/, "");
  }
  return cv = n, cv;
}
var pv, ok;
function Ur() {
  if (ok) return pv;
  ok = 1;
  var e = bp(), t = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], r = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function n(s) {
    var o = {};
    return s !== null && Object.keys(s).forEach(function(a) {
      s[a].forEach(function(l) {
        o[String(l)] = a;
      });
    }), o;
  }
  function i(s, o) {
    if (o = o || {}, Object.keys(o).forEach(function(a) {
      if (t.indexOf(a) === -1)
        throw new e('Unknown option "' + a + '" is met in definition of "' + s + '" YAML type.');
    }), this.options = o, this.tag = s, this.kind = o.kind || null, this.resolve = o.resolve || function() {
      return !0;
    }, this.construct = o.construct || function(a) {
      return a;
    }, this.instanceOf = o.instanceOf || null, this.predicate = o.predicate || null, this.represent = o.represent || null, this.representName = o.representName || null, this.defaultStyle = o.defaultStyle || null, this.multi = o.multi || !1, this.styleAliases = n(o.styleAliases || null), r.indexOf(this.kind) === -1)
      throw new e('Unknown kind "' + this.kind + '" is specified for "' + s + '" YAML type.');
  }
  return pv = i, pv;
}
var fv, sk;
function Dj() {
  if (sk) return fv;
  sk = 1;
  var e = bp(), t = Ur();
  function r(s, o) {
    var a = [];
    return s[o].forEach(function(l) {
      var p = a.length;
      a.forEach(function(f, d) {
        f.tag === l.tag && f.kind === l.kind && f.multi === l.multi && (p = d);
      }), a[p] = l;
    }), a;
  }
  function n() {
    var s = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, o, a;
    function l(p) {
      p.multi ? (s.multi[p.kind].push(p), s.multi.fallback.push(p)) : s[p.kind][p.tag] = s.fallback[p.tag] = p;
    }
    for (o = 0, a = arguments.length; o < a; o += 1)
      arguments[o].forEach(l);
    return s;
  }
  function i(s) {
    return this.extend(s);
  }
  return i.prototype.extend = function(o) {
    var a = [], l = [];
    if (o instanceof t)
      l.push(o);
    else if (Array.isArray(o))
      l = l.concat(o);
    else if (o && (Array.isArray(o.implicit) || Array.isArray(o.explicit)))
      o.implicit && (a = a.concat(o.implicit)), o.explicit && (l = l.concat(o.explicit));
    else
      throw new e("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    a.forEach(function(f) {
      if (!(f instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (f.loadKind && f.loadKind !== "scalar")
        throw new e("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (f.multi)
        throw new e("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), l.forEach(function(f) {
      if (!(f instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var p = Object.create(i.prototype);
    return p.implicit = (this.implicit || []).concat(a), p.explicit = (this.explicit || []).concat(l), p.compiledImplicit = r(p, "implicit"), p.compiledExplicit = r(p, "explicit"), p.compiledTypeMap = n(p.compiledImplicit, p.compiledExplicit), p;
  }, fv = i, fv;
}
var dv, ak;
function Fj() {
  if (ak) return dv;
  ak = 1;
  var e = Ur();
  return dv = new e("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(t) {
      return t !== null ? t : "";
    }
  }), dv;
}
var hv, lk;
function zj() {
  if (lk) return hv;
  lk = 1;
  var e = Ur();
  return hv = new e("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(t) {
      return t !== null ? t : [];
    }
  }), hv;
}
var mv, uk;
function qj() {
  if (uk) return mv;
  uk = 1;
  var e = Ur();
  return mv = new e("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(t) {
      return t !== null ? t : {};
    }
  }), mv;
}
var gv, ck;
function Bj() {
  if (ck) return gv;
  ck = 1;
  var e = Dj();
  return gv = new e({
    explicit: [
      Fj(),
      zj(),
      qj()
    ]
  }), gv;
}
var yv, pk;
function Uj() {
  if (pk) return yv;
  pk = 1;
  var e = Ur();
  function t(i) {
    if (i === null) return !0;
    var s = i.length;
    return s === 1 && i === "~" || s === 4 && (i === "null" || i === "Null" || i === "NULL");
  }
  function r() {
    return null;
  }
  function n(i) {
    return i === null;
  }
  return yv = new e("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  }), yv;
}
var vv, fk;
function Vj() {
  if (fk) return vv;
  fk = 1;
  var e = Ur();
  function t(i) {
    if (i === null) return !1;
    var s = i.length;
    return s === 4 && (i === "true" || i === "True" || i === "TRUE") || s === 5 && (i === "false" || i === "False" || i === "FALSE");
  }
  function r(i) {
    return i === "true" || i === "True" || i === "TRUE";
  }
  function n(i) {
    return Object.prototype.toString.call(i) === "[object Boolean]";
  }
  return vv = new e("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      lowercase: function(i) {
        return i ? "true" : "false";
      },
      uppercase: function(i) {
        return i ? "TRUE" : "FALSE";
      },
      camelcase: function(i) {
        return i ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), vv;
}
var bv, dk;
function Wj() {
  if (dk) return bv;
  dk = 1;
  var e = vp(), t = Ur();
  function r(l) {
    return 48 <= l && l <= 57 || 65 <= l && l <= 70 || 97 <= l && l <= 102;
  }
  function n(l) {
    return 48 <= l && l <= 55;
  }
  function i(l) {
    return 48 <= l && l <= 57;
  }
  function s(l) {
    if (l === null) return !1;
    var p = l.length, f = 0, d = !1, m;
    if (!p) return !1;
    if (m = l[f], (m === "-" || m === "+") && (m = l[++f]), m === "0") {
      if (f + 1 === p) return !0;
      if (m = l[++f], m === "b") {
        for (f++; f < p; f++)
          if (m = l[f], m !== "_") {
            if (m !== "0" && m !== "1") return !1;
            d = !0;
          }
        return d && m !== "_";
      }
      if (m === "x") {
        for (f++; f < p; f++)
          if (m = l[f], m !== "_") {
            if (!r(l.charCodeAt(f))) return !1;
            d = !0;
          }
        return d && m !== "_";
      }
      if (m === "o") {
        for (f++; f < p; f++)
          if (m = l[f], m !== "_") {
            if (!n(l.charCodeAt(f))) return !1;
            d = !0;
          }
        return d && m !== "_";
      }
    }
    if (m === "_") return !1;
    for (; f < p; f++)
      if (m = l[f], m !== "_") {
        if (!i(l.charCodeAt(f)))
          return !1;
        d = !0;
      }
    return !(!d || m === "_");
  }
  function o(l) {
    var p = l, f = 1, d;
    if (p.indexOf("_") !== -1 && (p = p.replace(/_/g, "")), d = p[0], (d === "-" || d === "+") && (d === "-" && (f = -1), p = p.slice(1), d = p[0]), p === "0") return 0;
    if (d === "0") {
      if (p[1] === "b") return f * parseInt(p.slice(2), 2);
      if (p[1] === "x") return f * parseInt(p.slice(2), 16);
      if (p[1] === "o") return f * parseInt(p.slice(2), 8);
    }
    return f * parseInt(p, 10);
  }
  function a(l) {
    return Object.prototype.toString.call(l) === "[object Number]" && l % 1 === 0 && !e.isNegativeZero(l);
  }
  return bv = new t("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: s,
    construct: o,
    predicate: a,
    represent: {
      binary: function(l) {
        return l >= 0 ? "0b" + l.toString(2) : "-0b" + l.toString(2).slice(1);
      },
      octal: function(l) {
        return l >= 0 ? "0o" + l.toString(8) : "-0o" + l.toString(8).slice(1);
      },
      decimal: function(l) {
        return l.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(l) {
        return l >= 0 ? "0x" + l.toString(16).toUpperCase() : "-0x" + l.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), bv;
}
var wv, hk;
function Hj() {
  if (hk) return wv;
  hk = 1;
  var e = vp(), t = Ur(), r = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function n(l) {
    return !(l === null || !r.test(l) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    l[l.length - 1] === "_");
  }
  function i(l) {
    var p, f;
    return p = l.replace(/_/g, "").toLowerCase(), f = p[0] === "-" ? -1 : 1, "+-".indexOf(p[0]) >= 0 && (p = p.slice(1)), p === ".inf" ? f === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : p === ".nan" ? NaN : f * parseFloat(p, 10);
  }
  var s = /^[-+]?[0-9]+e/;
  function o(l, p) {
    var f;
    if (isNaN(l))
      switch (p) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === l)
      switch (p) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === l)
      switch (p) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (e.isNegativeZero(l))
      return "-0.0";
    return f = l.toString(10), s.test(f) ? f.replace("e", ".e") : f;
  }
  function a(l) {
    return Object.prototype.toString.call(l) === "[object Number]" && (l % 1 !== 0 || e.isNegativeZero(l));
  }
  return wv = new t("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: n,
    construct: i,
    predicate: a,
    represent: o,
    defaultStyle: "lowercase"
  }), wv;
}
var Sv, mk;
function Qj() {
  return mk || (mk = 1, Sv = Bj().extend({
    implicit: [
      Uj(),
      Vj(),
      Wj(),
      Hj()
    ]
  })), Sv;
}
var xv, gk;
function Yj() {
  return gk || (gk = 1, xv = Qj()), xv;
}
var _v, yk;
function Gj() {
  if (yk) return _v;
  yk = 1;
  var e = Ur(), t = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), r = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function n(o) {
    return o === null ? !1 : t.exec(o) !== null || r.exec(o) !== null;
  }
  function i(o) {
    var a, l, p, f, d, m, v, g = 0, S = null, _, x, y;
    if (a = t.exec(o), a === null && (a = r.exec(o)), a === null) throw new Error("Date resolve error");
    if (l = +a[1], p = +a[2] - 1, f = +a[3], !a[4])
      return new Date(Date.UTC(l, p, f));
    if (d = +a[4], m = +a[5], v = +a[6], a[7]) {
      for (g = a[7].slice(0, 3); g.length < 3; )
        g += "0";
      g = +g;
    }
    return a[9] && (_ = +a[10], x = +(a[11] || 0), S = (_ * 60 + x) * 6e4, a[9] === "-" && (S = -S)), y = new Date(Date.UTC(l, p, f, d, m, v, g)), S && y.setTime(y.getTime() - S), y;
  }
  function s(o) {
    return o.toISOString();
  }
  return _v = new e("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: n,
    construct: i,
    instanceOf: Date,
    represent: s
  }), _v;
}
var Ev, vk;
function Kj() {
  if (vk) return Ev;
  vk = 1;
  var e = Ur();
  function t(r) {
    return r === "<<" || r === null;
  }
  return Ev = new e("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: t
  }), Ev;
}
var Ov, bk;
function Xj() {
  if (bk) return Ov;
  bk = 1;
  var e = Ur(), t = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function r(o) {
    if (o === null) return !1;
    var a, l, p = 0, f = o.length, d = t;
    for (l = 0; l < f; l++)
      if (a = d.indexOf(o.charAt(l)), !(a > 64)) {
        if (a < 0) return !1;
        p += 6;
      }
    return p % 8 === 0;
  }
  function n(o) {
    var a, l, p = o.replace(/[\r\n=]/g, ""), f = p.length, d = t, m = 0, v = [];
    for (a = 0; a < f; a++)
      a % 4 === 0 && a && (v.push(m >> 16 & 255), v.push(m >> 8 & 255), v.push(m & 255)), m = m << 6 | d.indexOf(p.charAt(a));
    return l = f % 4 * 6, l === 0 ? (v.push(m >> 16 & 255), v.push(m >> 8 & 255), v.push(m & 255)) : l === 18 ? (v.push(m >> 10 & 255), v.push(m >> 2 & 255)) : l === 12 && v.push(m >> 4 & 255), new Uint8Array(v);
  }
  function i(o) {
    var a = "", l = 0, p, f, d = o.length, m = t;
    for (p = 0; p < d; p++)
      p % 3 === 0 && p && (a += m[l >> 18 & 63], a += m[l >> 12 & 63], a += m[l >> 6 & 63], a += m[l & 63]), l = (l << 8) + o[p];
    return f = d % 3, f === 0 ? (a += m[l >> 18 & 63], a += m[l >> 12 & 63], a += m[l >> 6 & 63], a += m[l & 63]) : f === 2 ? (a += m[l >> 10 & 63], a += m[l >> 4 & 63], a += m[l << 2 & 63], a += m[64]) : f === 1 && (a += m[l >> 2 & 63], a += m[l << 4 & 63], a += m[64], a += m[64]), a;
  }
  function s(o) {
    return Object.prototype.toString.call(o) === "[object Uint8Array]";
  }
  return Ov = new e("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: r,
    construct: n,
    predicate: s,
    represent: i
  }), Ov;
}
var kv, wk;
function Jj() {
  if (wk) return kv;
  wk = 1;
  var e = Ur(), t = Object.prototype.hasOwnProperty, r = Object.prototype.toString;
  function n(s) {
    if (s === null) return !0;
    var o = [], a, l, p, f, d, m = s;
    for (a = 0, l = m.length; a < l; a += 1) {
      if (p = m[a], d = !1, r.call(p) !== "[object Object]") return !1;
      for (f in p)
        if (t.call(p, f))
          if (!d) d = !0;
          else return !1;
      if (!d) return !1;
      if (o.indexOf(f) === -1) o.push(f);
      else return !1;
    }
    return !0;
  }
  function i(s) {
    return s !== null ? s : [];
  }
  return kv = new e("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: n,
    construct: i
  }), kv;
}
var Av, Sk;
function Zj() {
  if (Sk) return Av;
  Sk = 1;
  var e = Ur(), t = Object.prototype.toString;
  function r(i) {
    if (i === null) return !0;
    var s, o, a, l, p, f = i;
    for (p = new Array(f.length), s = 0, o = f.length; s < o; s += 1) {
      if (a = f[s], t.call(a) !== "[object Object]" || (l = Object.keys(a), l.length !== 1)) return !1;
      p[s] = [l[0], a[l[0]]];
    }
    return !0;
  }
  function n(i) {
    if (i === null) return [];
    var s, o, a, l, p, f = i;
    for (p = new Array(f.length), s = 0, o = f.length; s < o; s += 1)
      a = f[s], l = Object.keys(a), p[s] = [l[0], a[l[0]]];
    return p;
  }
  return Av = new e("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: r,
    construct: n
  }), Av;
}
var Pv, xk;
function eN() {
  if (xk) return Pv;
  xk = 1;
  var e = Ur(), t = Object.prototype.hasOwnProperty;
  function r(i) {
    if (i === null) return !0;
    var s, o = i;
    for (s in o)
      if (t.call(o, s) && o[s] !== null)
        return !1;
    return !0;
  }
  function n(i) {
    return i !== null ? i : {};
  }
  return Pv = new e("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: r,
    construct: n
  }), Pv;
}
var Cv, _k;
function _S() {
  return _k || (_k = 1, Cv = Yj().extend({
    implicit: [
      Gj(),
      Kj()
    ],
    explicit: [
      Xj(),
      Jj(),
      Zj(),
      eN()
    ]
  })), Cv;
}
var Ek;
function dW() {
  if (Ek) return ed;
  Ek = 1;
  var e = vp(), t = bp(), r = fW(), n = _S(), i = Object.prototype.hasOwnProperty, s = 1, o = 2, a = 3, l = 4, p = 1, f = 2, d = 3, m = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, v = /[\x85\u2028\u2029]/, g = /[,\[\]\{\}]/, S = /^(?:!|!!|![a-z\-]+!)$/i, _ = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function x(O) {
    return Object.prototype.toString.call(O);
  }
  function y(O) {
    return O === 10 || O === 13;
  }
  function w(O) {
    return O === 9 || O === 32;
  }
  function k(O) {
    return O === 9 || O === 32 || O === 10 || O === 13;
  }
  function A(O) {
    return O === 44 || O === 91 || O === 93 || O === 123 || O === 125;
  }
  function T(O) {
    var M;
    return 48 <= O && O <= 57 ? O - 48 : (M = O | 32, 97 <= M && M <= 102 ? M - 97 + 10 : -1);
  }
  function R(O) {
    return O === 120 ? 2 : O === 117 ? 4 : O === 85 ? 8 : 0;
  }
  function I(O) {
    return 48 <= O && O <= 57 ? O - 48 : -1;
  }
  function B(O) {
    return O === 48 ? "\0" : O === 97 ? "\x07" : O === 98 ? "\b" : O === 116 || O === 9 ? "	" : O === 110 ? `
` : O === 118 ? "\v" : O === 102 ? "\f" : O === 114 ? "\r" : O === 101 ? "\x1B" : O === 32 ? " " : O === 34 ? '"' : O === 47 ? "/" : O === 92 ? "\\" : O === 78 ? "" : O === 95 ? " " : O === 76 ? "\u2028" : O === 80 ? "\u2029" : "";
  }
  function L(O) {
    return O <= 65535 ? String.fromCharCode(O) : String.fromCharCode(
      (O - 65536 >> 10) + 55296,
      (O - 65536 & 1023) + 56320
    );
  }
  for (var Y = new Array(256), Q = new Array(256), re = 0; re < 256; re++)
    Y[re] = B(re) ? 1 : 0, Q[re] = B(re);
  function oe(O, M) {
    this.input = O, this.filename = M.filename || null, this.schema = M.schema || n, this.onWarning = M.onWarning || null, this.legacy = M.legacy || !1, this.json = M.json || !1, this.listener = M.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = O.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function ce(O, M) {
    var le = {
      name: O.filename,
      buffer: O.input.slice(0, -1),
      // omit trailing \0
      position: O.position,
      line: O.line,
      column: O.position - O.lineStart
    };
    return le.snippet = r(le), new t(M, le);
  }
  function pe(O, M) {
    throw ce(O, M);
  }
  function fe(O, M) {
    O.onWarning && O.onWarning.call(null, ce(O, M));
  }
  var G = {
    YAML: function(M, le, ye) {
      var be, Pe, ke;
      M.version !== null && pe(M, "duplication of %YAML directive"), ye.length !== 1 && pe(M, "YAML directive accepts exactly one argument"), be = /^([0-9]+)\.([0-9]+)$/.exec(ye[0]), be === null && pe(M, "ill-formed argument of the YAML directive"), Pe = parseInt(be[1], 10), ke = parseInt(be[2], 10), Pe !== 1 && pe(M, "unacceptable YAML version of the document"), M.version = ye[0], M.checkLineBreaks = ke < 2, ke !== 1 && ke !== 2 && fe(M, "unsupported YAML version of the document");
    },
    TAG: function(M, le, ye) {
      var be, Pe;
      ye.length !== 2 && pe(M, "TAG directive accepts exactly two arguments"), be = ye[0], Pe = ye[1], S.test(be) || pe(M, "ill-formed tag handle (first argument) of the TAG directive"), i.call(M.tagMap, be) && pe(M, 'there is a previously declared suffix for "' + be + '" tag handle'), _.test(Pe) || pe(M, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        Pe = decodeURIComponent(Pe);
      } catch {
        pe(M, "tag prefix is malformed: " + Pe);
      }
      M.tagMap[be] = Pe;
    }
  };
  function Z(O, M, le, ye) {
    var be, Pe, ke, Me;
    if (M < le) {
      if (Me = O.input.slice(M, le), ye)
        for (be = 0, Pe = Me.length; be < Pe; be += 1)
          ke = Me.charCodeAt(be), ke === 9 || 32 <= ke && ke <= 1114111 || pe(O, "expected valid JSON character");
      else m.test(Me) && pe(O, "the stream contains non-printable characters");
      O.result += Me;
    }
  }
  function K(O, M, le, ye) {
    var be, Pe, ke, Me;
    for (e.isObject(le) || pe(O, "cannot merge mappings; the provided source object is unacceptable"), be = Object.keys(le), ke = 0, Me = be.length; ke < Me; ke += 1)
      Pe = be[ke], i.call(M, Pe) || (M[Pe] = le[Pe], ye[Pe] = !0);
  }
  function z(O, M, le, ye, be, Pe, ke, Me, We) {
    var Xe, Ge;
    if (Array.isArray(be))
      for (be = Array.prototype.slice.call(be), Xe = 0, Ge = be.length; Xe < Ge; Xe += 1)
        Array.isArray(be[Xe]) && pe(O, "nested arrays are not supported inside keys"), typeof be == "object" && x(be[Xe]) === "[object Object]" && (be[Xe] = "[object Object]");
    if (typeof be == "object" && x(be) === "[object Object]" && (be = "[object Object]"), be = String(be), M === null && (M = {}), ye === "tag:yaml.org,2002:merge")
      if (Array.isArray(Pe))
        for (Xe = 0, Ge = Pe.length; Xe < Ge; Xe += 1)
          K(O, M, Pe[Xe], le);
      else
        K(O, M, Pe, le);
    else
      !O.json && !i.call(le, be) && i.call(M, be) && (O.line = ke || O.line, O.lineStart = Me || O.lineStart, O.position = We || O.position, pe(O, "duplicated mapping key")), be === "__proto__" ? Object.defineProperty(M, be, {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: Pe
      }) : M[be] = Pe, delete le[be];
    return M;
  }
  function te(O) {
    var M;
    M = O.input.charCodeAt(O.position), M === 10 ? O.position++ : M === 13 ? (O.position++, O.input.charCodeAt(O.position) === 10 && O.position++) : pe(O, "a line break is expected"), O.line += 1, O.lineStart = O.position, O.firstTabInLine = -1;
  }
  function q(O, M, le) {
    for (var ye = 0, be = O.input.charCodeAt(O.position); be !== 0; ) {
      for (; w(be); )
        be === 9 && O.firstTabInLine === -1 && (O.firstTabInLine = O.position), be = O.input.charCodeAt(++O.position);
      if (M && be === 35)
        do
          be = O.input.charCodeAt(++O.position);
        while (be !== 10 && be !== 13 && be !== 0);
      if (y(be))
        for (te(O), be = O.input.charCodeAt(O.position), ye++, O.lineIndent = 0; be === 32; )
          O.lineIndent++, be = O.input.charCodeAt(++O.position);
      else
        break;
    }
    return le !== -1 && ye !== 0 && O.lineIndent < le && fe(O, "deficient indentation"), ye;
  }
  function j(O) {
    var M = O.position, le;
    return le = O.input.charCodeAt(M), !!((le === 45 || le === 46) && le === O.input.charCodeAt(M + 1) && le === O.input.charCodeAt(M + 2) && (M += 3, le = O.input.charCodeAt(M), le === 0 || k(le)));
  }
  function H(O, M) {
    M === 1 ? O.result += " " : M > 1 && (O.result += e.repeat(`
`, M - 1));
  }
  function F(O, M, le) {
    var ye, be, Pe, ke, Me, We, Xe, Ge, Ue = O.kind, Et = O.result, D;
    if (D = O.input.charCodeAt(O.position), k(D) || A(D) || D === 35 || D === 38 || D === 42 || D === 33 || D === 124 || D === 62 || D === 39 || D === 34 || D === 37 || D === 64 || D === 96 || (D === 63 || D === 45) && (be = O.input.charCodeAt(O.position + 1), k(be) || le && A(be)))
      return !1;
    for (O.kind = "scalar", O.result = "", Pe = ke = O.position, Me = !1; D !== 0; ) {
      if (D === 58) {
        if (be = O.input.charCodeAt(O.position + 1), k(be) || le && A(be))
          break;
      } else if (D === 35) {
        if (ye = O.input.charCodeAt(O.position - 1), k(ye))
          break;
      } else {
        if (O.position === O.lineStart && j(O) || le && A(D))
          break;
        if (y(D))
          if (We = O.line, Xe = O.lineStart, Ge = O.lineIndent, q(O, !1, -1), O.lineIndent >= M) {
            Me = !0, D = O.input.charCodeAt(O.position);
            continue;
          } else {
            O.position = ke, O.line = We, O.lineStart = Xe, O.lineIndent = Ge;
            break;
          }
      }
      Me && (Z(O, Pe, ke, !1), H(O, O.line - We), Pe = ke = O.position, Me = !1), w(D) || (ke = O.position + 1), D = O.input.charCodeAt(++O.position);
    }
    return Z(O, Pe, ke, !1), O.result ? !0 : (O.kind = Ue, O.result = Et, !1);
  }
  function ue(O, M) {
    var le, ye, be;
    if (le = O.input.charCodeAt(O.position), le !== 39)
      return !1;
    for (O.kind = "scalar", O.result = "", O.position++, ye = be = O.position; (le = O.input.charCodeAt(O.position)) !== 0; )
      if (le === 39)
        if (Z(O, ye, O.position, !0), le = O.input.charCodeAt(++O.position), le === 39)
          ye = O.position, O.position++, be = O.position;
        else
          return !0;
      else y(le) ? (Z(O, ye, be, !0), H(O, q(O, !1, M)), ye = be = O.position) : O.position === O.lineStart && j(O) ? pe(O, "unexpected end of the document within a single quoted scalar") : (O.position++, be = O.position);
    pe(O, "unexpected end of the stream within a single quoted scalar");
  }
  function ge(O, M) {
    var le, ye, be, Pe, ke, Me;
    if (Me = O.input.charCodeAt(O.position), Me !== 34)
      return !1;
    for (O.kind = "scalar", O.result = "", O.position++, le = ye = O.position; (Me = O.input.charCodeAt(O.position)) !== 0; ) {
      if (Me === 34)
        return Z(O, le, O.position, !0), O.position++, !0;
      if (Me === 92) {
        if (Z(O, le, O.position, !0), Me = O.input.charCodeAt(++O.position), y(Me))
          q(O, !1, M);
        else if (Me < 256 && Y[Me])
          O.result += Q[Me], O.position++;
        else if ((ke = R(Me)) > 0) {
          for (be = ke, Pe = 0; be > 0; be--)
            Me = O.input.charCodeAt(++O.position), (ke = T(Me)) >= 0 ? Pe = (Pe << 4) + ke : pe(O, "expected hexadecimal character");
          O.result += L(Pe), O.position++;
        } else
          pe(O, "unknown escape sequence");
        le = ye = O.position;
      } else y(Me) ? (Z(O, le, ye, !0), H(O, q(O, !1, M)), le = ye = O.position) : O.position === O.lineStart && j(O) ? pe(O, "unexpected end of the document within a double quoted scalar") : (O.position++, ye = O.position);
    }
    pe(O, "unexpected end of the stream within a double quoted scalar");
  }
  function Ae(O, M) {
    var le = !0, ye, be, Pe, ke = O.tag, Me, We = O.anchor, Xe, Ge, Ue, Et, D, we = /* @__PURE__ */ Object.create(null), Oe, Ee, Ce, $e;
    if ($e = O.input.charCodeAt(O.position), $e === 91)
      Ge = 93, D = !1, Me = [];
    else if ($e === 123)
      Ge = 125, D = !0, Me = {};
    else
      return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = Me), $e = O.input.charCodeAt(++O.position); $e !== 0; ) {
      if (q(O, !0, M), $e = O.input.charCodeAt(O.position), $e === Ge)
        return O.position++, O.tag = ke, O.anchor = We, O.kind = D ? "mapping" : "sequence", O.result = Me, !0;
      le ? $e === 44 && pe(O, "expected the node content, but found ','") : pe(O, "missed comma between flow collection entries"), Ee = Oe = Ce = null, Ue = Et = !1, $e === 63 && (Xe = O.input.charCodeAt(O.position + 1), k(Xe) && (Ue = Et = !0, O.position++, q(O, !0, M))), ye = O.line, be = O.lineStart, Pe = O.position, W(O, M, s, !1, !0), Ee = O.tag, Oe = O.result, q(O, !0, M), $e = O.input.charCodeAt(O.position), (Et || O.line === ye) && $e === 58 && (Ue = !0, $e = O.input.charCodeAt(++O.position), q(O, !0, M), W(O, M, s, !1, !0), Ce = O.result), D ? z(O, Me, we, Ee, Oe, Ce, ye, be, Pe) : Ue ? Me.push(z(O, null, we, Ee, Oe, Ce, ye, be, Pe)) : Me.push(Oe), q(O, !0, M), $e = O.input.charCodeAt(O.position), $e === 44 ? (le = !0, $e = O.input.charCodeAt(++O.position)) : le = !1;
    }
    pe(O, "unexpected end of the stream within a flow collection");
  }
  function C(O, M) {
    var le, ye, be = p, Pe = !1, ke = !1, Me = M, We = 0, Xe = !1, Ge, Ue;
    if (Ue = O.input.charCodeAt(O.position), Ue === 124)
      ye = !1;
    else if (Ue === 62)
      ye = !0;
    else
      return !1;
    for (O.kind = "scalar", O.result = ""; Ue !== 0; )
      if (Ue = O.input.charCodeAt(++O.position), Ue === 43 || Ue === 45)
        p === be ? be = Ue === 43 ? d : f : pe(O, "repeat of a chomping mode identifier");
      else if ((Ge = I(Ue)) >= 0)
        Ge === 0 ? pe(O, "bad explicit indentation width of a block scalar; it cannot be less than one") : ke ? pe(O, "repeat of an indentation width identifier") : (Me = M + Ge - 1, ke = !0);
      else
        break;
    if (w(Ue)) {
      do
        Ue = O.input.charCodeAt(++O.position);
      while (w(Ue));
      if (Ue === 35)
        do
          Ue = O.input.charCodeAt(++O.position);
        while (!y(Ue) && Ue !== 0);
    }
    for (; Ue !== 0; ) {
      for (te(O), O.lineIndent = 0, Ue = O.input.charCodeAt(O.position); (!ke || O.lineIndent < Me) && Ue === 32; )
        O.lineIndent++, Ue = O.input.charCodeAt(++O.position);
      if (!ke && O.lineIndent > Me && (Me = O.lineIndent), y(Ue)) {
        We++;
        continue;
      }
      if (O.lineIndent < Me) {
        be === d ? O.result += e.repeat(`
`, Pe ? 1 + We : We) : be === p && Pe && (O.result += `
`);
        break;
      }
      for (ye ? w(Ue) ? (Xe = !0, O.result += e.repeat(`
`, Pe ? 1 + We : We)) : Xe ? (Xe = !1, O.result += e.repeat(`
`, We + 1)) : We === 0 ? Pe && (O.result += " ") : O.result += e.repeat(`
`, We) : O.result += e.repeat(`
`, Pe ? 1 + We : We), Pe = !0, ke = !0, We = 0, le = O.position; !y(Ue) && Ue !== 0; )
        Ue = O.input.charCodeAt(++O.position);
      Z(O, le, O.position, !1);
    }
    return !0;
  }
  function N(O, M) {
    var le, ye = O.tag, be = O.anchor, Pe = [], ke, Me = !1, We;
    if (O.firstTabInLine !== -1) return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = Pe), We = O.input.charCodeAt(O.position); We !== 0 && (O.firstTabInLine !== -1 && (O.position = O.firstTabInLine, pe(O, "tab characters must not be used in indentation")), !(We !== 45 || (ke = O.input.charCodeAt(O.position + 1), !k(ke)))); ) {
      if (Me = !0, O.position++, q(O, !0, -1) && O.lineIndent <= M) {
        Pe.push(null), We = O.input.charCodeAt(O.position);
        continue;
      }
      if (le = O.line, W(O, M, a, !1, !0), Pe.push(O.result), q(O, !0, -1), We = O.input.charCodeAt(O.position), (O.line === le || O.lineIndent > M) && We !== 0)
        pe(O, "bad indentation of a sequence entry");
      else if (O.lineIndent < M)
        break;
    }
    return Me ? (O.tag = ye, O.anchor = be, O.kind = "sequence", O.result = Pe, !0) : !1;
  }
  function J(O, M, le) {
    var ye, be, Pe, ke, Me, We, Xe = O.tag, Ge = O.anchor, Ue = {}, Et = /* @__PURE__ */ Object.create(null), D = null, we = null, Oe = null, Ee = !1, Ce = !1, $e;
    if (O.firstTabInLine !== -1) return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = Ue), $e = O.input.charCodeAt(O.position); $e !== 0; ) {
      if (!Ee && O.firstTabInLine !== -1 && (O.position = O.firstTabInLine, pe(O, "tab characters must not be used in indentation")), ye = O.input.charCodeAt(O.position + 1), Pe = O.line, ($e === 63 || $e === 58) && k(ye))
        $e === 63 ? (Ee && (z(O, Ue, Et, D, we, null, ke, Me, We), D = we = Oe = null), Ce = !0, Ee = !0, be = !0) : Ee ? (Ee = !1, be = !0) : pe(O, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), O.position += 1, $e = ye;
      else {
        if (ke = O.line, Me = O.lineStart, We = O.position, !W(O, le, o, !1, !0))
          break;
        if (O.line === Pe) {
          for ($e = O.input.charCodeAt(O.position); w($e); )
            $e = O.input.charCodeAt(++O.position);
          if ($e === 58)
            $e = O.input.charCodeAt(++O.position), k($e) || pe(O, "a whitespace character is expected after the key-value separator within a block mapping"), Ee && (z(O, Ue, Et, D, we, null, ke, Me, We), D = we = Oe = null), Ce = !0, Ee = !1, be = !1, D = O.tag, we = O.result;
          else if (Ce)
            pe(O, "can not read an implicit mapping pair; a colon is missed");
          else
            return O.tag = Xe, O.anchor = Ge, !0;
        } else if (Ce)
          pe(O, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return O.tag = Xe, O.anchor = Ge, !0;
      }
      if ((O.line === Pe || O.lineIndent > M) && (Ee && (ke = O.line, Me = O.lineStart, We = O.position), W(O, M, l, !0, be) && (Ee ? we = O.result : Oe = O.result), Ee || (z(O, Ue, Et, D, we, Oe, ke, Me, We), D = we = Oe = null), q(O, !0, -1), $e = O.input.charCodeAt(O.position)), (O.line === Pe || O.lineIndent > M) && $e !== 0)
        pe(O, "bad indentation of a mapping entry");
      else if (O.lineIndent < M)
        break;
    }
    return Ee && z(O, Ue, Et, D, we, null, ke, Me, We), Ce && (O.tag = Xe, O.anchor = Ge, O.kind = "mapping", O.result = Ue), Ce;
  }
  function X(O) {
    var M, le = !1, ye = !1, be, Pe, ke;
    if (ke = O.input.charCodeAt(O.position), ke !== 33) return !1;
    if (O.tag !== null && pe(O, "duplication of a tag property"), ke = O.input.charCodeAt(++O.position), ke === 60 ? (le = !0, ke = O.input.charCodeAt(++O.position)) : ke === 33 ? (ye = !0, be = "!!", ke = O.input.charCodeAt(++O.position)) : be = "!", M = O.position, le) {
      do
        ke = O.input.charCodeAt(++O.position);
      while (ke !== 0 && ke !== 62);
      O.position < O.length ? (Pe = O.input.slice(M, O.position), ke = O.input.charCodeAt(++O.position)) : pe(O, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ke !== 0 && !k(ke); )
        ke === 33 && (ye ? pe(O, "tag suffix cannot contain exclamation marks") : (be = O.input.slice(M - 1, O.position + 1), S.test(be) || pe(O, "named tag handle cannot contain such characters"), ye = !0, M = O.position + 1)), ke = O.input.charCodeAt(++O.position);
      Pe = O.input.slice(M, O.position), g.test(Pe) && pe(O, "tag suffix cannot contain flow indicator characters");
    }
    Pe && !_.test(Pe) && pe(O, "tag name cannot contain such characters: " + Pe);
    try {
      Pe = decodeURIComponent(Pe);
    } catch {
      pe(O, "tag name is malformed: " + Pe);
    }
    return le ? O.tag = Pe : i.call(O.tagMap, be) ? O.tag = O.tagMap[be] + Pe : be === "!" ? O.tag = "!" + Pe : be === "!!" ? O.tag = "tag:yaml.org,2002:" + Pe : pe(O, 'undeclared tag handle "' + be + '"'), !0;
  }
  function ae(O) {
    var M, le;
    if (le = O.input.charCodeAt(O.position), le !== 38) return !1;
    for (O.anchor !== null && pe(O, "duplication of an anchor property"), le = O.input.charCodeAt(++O.position), M = O.position; le !== 0 && !k(le) && !A(le); )
      le = O.input.charCodeAt(++O.position);
    return O.position === M && pe(O, "name of an anchor node must contain at least one character"), O.anchor = O.input.slice(M, O.position), !0;
  }
  function U(O) {
    var M, le, ye;
    if (ye = O.input.charCodeAt(O.position), ye !== 42) return !1;
    for (ye = O.input.charCodeAt(++O.position), M = O.position; ye !== 0 && !k(ye) && !A(ye); )
      ye = O.input.charCodeAt(++O.position);
    return O.position === M && pe(O, "name of an alias node must contain at least one character"), le = O.input.slice(M, O.position), i.call(O.anchorMap, le) || pe(O, 'unidentified alias "' + le + '"'), O.result = O.anchorMap[le], q(O, !0, -1), !0;
  }
  function W(O, M, le, ye, be) {
    var Pe, ke, Me, We = 1, Xe = !1, Ge = !1, Ue, Et, D, we, Oe, Ee;
    if (O.listener !== null && O.listener("open", O), O.tag = null, O.anchor = null, O.kind = null, O.result = null, Pe = ke = Me = l === le || a === le, ye && q(O, !0, -1) && (Xe = !0, O.lineIndent > M ? We = 1 : O.lineIndent === M ? We = 0 : O.lineIndent < M && (We = -1)), We === 1)
      for (; X(O) || ae(O); )
        q(O, !0, -1) ? (Xe = !0, Me = Pe, O.lineIndent > M ? We = 1 : O.lineIndent === M ? We = 0 : O.lineIndent < M && (We = -1)) : Me = !1;
    if (Me && (Me = Xe || be), (We === 1 || l === le) && (s === le || o === le ? Oe = M : Oe = M + 1, Ee = O.position - O.lineStart, We === 1 ? Me && (N(O, Ee) || J(O, Ee, Oe)) || Ae(O, Oe) ? Ge = !0 : (ke && C(O, Oe) || ue(O, Oe) || ge(O, Oe) ? Ge = !0 : U(O) ? (Ge = !0, (O.tag !== null || O.anchor !== null) && pe(O, "alias node should not have any properties")) : F(O, Oe, s === le) && (Ge = !0, O.tag === null && (O.tag = "?")), O.anchor !== null && (O.anchorMap[O.anchor] = O.result)) : We === 0 && (Ge = Me && N(O, Ee))), O.tag === null)
      O.anchor !== null && (O.anchorMap[O.anchor] = O.result);
    else if (O.tag === "?") {
      for (O.result !== null && O.kind !== "scalar" && pe(O, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + O.kind + '"'), Ue = 0, Et = O.implicitTypes.length; Ue < Et; Ue += 1)
        if (we = O.implicitTypes[Ue], we.resolve(O.result)) {
          O.result = we.construct(O.result), O.tag = we.tag, O.anchor !== null && (O.anchorMap[O.anchor] = O.result);
          break;
        }
    } else if (O.tag !== "!") {
      if (i.call(O.typeMap[O.kind || "fallback"], O.tag))
        we = O.typeMap[O.kind || "fallback"][O.tag];
      else
        for (we = null, D = O.typeMap.multi[O.kind || "fallback"], Ue = 0, Et = D.length; Ue < Et; Ue += 1)
          if (O.tag.slice(0, D[Ue].tag.length) === D[Ue].tag) {
            we = D[Ue];
            break;
          }
      we || pe(O, "unknown tag !<" + O.tag + ">"), O.result !== null && we.kind !== O.kind && pe(O, "unacceptable node kind for !<" + O.tag + '> tag; it should be "' + we.kind + '", not "' + O.kind + '"'), we.resolve(O.result, O.tag) ? (O.result = we.construct(O.result, O.tag), O.anchor !== null && (O.anchorMap[O.anchor] = O.result)) : pe(O, "cannot resolve a node with !<" + O.tag + "> explicit tag");
    }
    return O.listener !== null && O.listener("close", O), O.tag !== null || O.anchor !== null || Ge;
  }
  function ve(O) {
    var M = O.position, le, ye, be, Pe = !1, ke;
    for (O.version = null, O.checkLineBreaks = O.legacy, O.tagMap = /* @__PURE__ */ Object.create(null), O.anchorMap = /* @__PURE__ */ Object.create(null); (ke = O.input.charCodeAt(O.position)) !== 0 && (q(O, !0, -1), ke = O.input.charCodeAt(O.position), !(O.lineIndent > 0 || ke !== 37)); ) {
      for (Pe = !0, ke = O.input.charCodeAt(++O.position), le = O.position; ke !== 0 && !k(ke); )
        ke = O.input.charCodeAt(++O.position);
      for (ye = O.input.slice(le, O.position), be = [], ye.length < 1 && pe(O, "directive name must not be less than one character in length"); ke !== 0; ) {
        for (; w(ke); )
          ke = O.input.charCodeAt(++O.position);
        if (ke === 35) {
          do
            ke = O.input.charCodeAt(++O.position);
          while (ke !== 0 && !y(ke));
          break;
        }
        if (y(ke)) break;
        for (le = O.position; ke !== 0 && !k(ke); )
          ke = O.input.charCodeAt(++O.position);
        be.push(O.input.slice(le, O.position));
      }
      ke !== 0 && te(O), i.call(G, ye) ? G[ye](O, ye, be) : fe(O, 'unknown document directive "' + ye + '"');
    }
    if (q(O, !0, -1), O.lineIndent === 0 && O.input.charCodeAt(O.position) === 45 && O.input.charCodeAt(O.position + 1) === 45 && O.input.charCodeAt(O.position + 2) === 45 ? (O.position += 3, q(O, !0, -1)) : Pe && pe(O, "directives end mark is expected"), W(O, O.lineIndent - 1, l, !1, !0), q(O, !0, -1), O.checkLineBreaks && v.test(O.input.slice(M, O.position)) && fe(O, "non-ASCII line breaks are interpreted as content"), O.documents.push(O.result), O.position === O.lineStart && j(O)) {
      O.input.charCodeAt(O.position) === 46 && (O.position += 3, q(O, !0, -1));
      return;
    }
    if (O.position < O.length - 1)
      pe(O, "end of the stream or a document separator is expected");
    else
      return;
  }
  function he(O, M) {
    O = String(O), M = M || {}, O.length !== 0 && (O.charCodeAt(O.length - 1) !== 10 && O.charCodeAt(O.length - 1) !== 13 && (O += `
`), O.charCodeAt(0) === 65279 && (O = O.slice(1)));
    var le = new oe(O, M), ye = O.indexOf("\0");
    for (ye !== -1 && (le.position = ye, pe(le, "null byte is not allowed in input")), le.input += "\0"; le.input.charCodeAt(le.position) === 32; )
      le.lineIndent += 1, le.position += 1;
    for (; le.position < le.length - 1; )
      ve(le);
    return le.documents;
  }
  function Te(O, M, le) {
    M !== null && typeof M == "object" && typeof le > "u" && (le = M, M = null);
    var ye = he(O, le);
    if (typeof M != "function")
      return ye;
    for (var be = 0, Pe = ye.length; be < Pe; be += 1)
      M(ye[be]);
  }
  function Se(O, M) {
    var le = he(O, M);
    if (le.length !== 0) {
      if (le.length === 1)
        return le[0];
      throw new t("expected a single document in the stream, but found more");
    }
  }
  return ed.loadAll = Te, ed.load = Se, ed;
}
var Tv = {}, Ok;
function hW() {
  if (Ok) return Tv;
  Ok = 1;
  var e = vp(), t = bp(), r = _S(), n = Object.prototype.toString, i = Object.prototype.hasOwnProperty, s = 65279, o = 9, a = 10, l = 13, p = 32, f = 33, d = 34, m = 35, v = 37, g = 38, S = 39, _ = 42, x = 44, y = 45, w = 58, k = 61, A = 62, T = 63, R = 64, I = 91, B = 93, L = 96, Y = 123, Q = 124, re = 125, oe = {};
  oe[0] = "\\0", oe[7] = "\\a", oe[8] = "\\b", oe[9] = "\\t", oe[10] = "\\n", oe[11] = "\\v", oe[12] = "\\f", oe[13] = "\\r", oe[27] = "\\e", oe[34] = '\\"', oe[92] = "\\\\", oe[133] = "\\N", oe[160] = "\\_", oe[8232] = "\\L", oe[8233] = "\\P";
  var ce = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], pe = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function fe(D, we) {
    var Oe, Ee, Ce, $e, Fe, xe, Le;
    if (we === null) return {};
    for (Oe = {}, Ee = Object.keys(we), Ce = 0, $e = Ee.length; Ce < $e; Ce += 1)
      Fe = Ee[Ce], xe = String(we[Fe]), Fe.slice(0, 2) === "!!" && (Fe = "tag:yaml.org,2002:" + Fe.slice(2)), Le = D.compiledTypeMap.fallback[Fe], Le && i.call(Le.styleAliases, xe) && (xe = Le.styleAliases[xe]), Oe[Fe] = xe;
    return Oe;
  }
  function G(D) {
    var we, Oe, Ee;
    if (we = D.toString(16).toUpperCase(), D <= 255)
      Oe = "x", Ee = 2;
    else if (D <= 65535)
      Oe = "u", Ee = 4;
    else if (D <= 4294967295)
      Oe = "U", Ee = 8;
    else
      throw new t("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + Oe + e.repeat("0", Ee - we.length) + we;
  }
  var Z = 1, K = 2;
  function z(D) {
    this.schema = D.schema || r, this.indent = Math.max(1, D.indent || 2), this.noArrayIndent = D.noArrayIndent || !1, this.skipInvalid = D.skipInvalid || !1, this.flowLevel = e.isNothing(D.flowLevel) ? -1 : D.flowLevel, this.styleMap = fe(this.schema, D.styles || null), this.sortKeys = D.sortKeys || !1, this.lineWidth = D.lineWidth || 80, this.noRefs = D.noRefs || !1, this.noCompatMode = D.noCompatMode || !1, this.condenseFlow = D.condenseFlow || !1, this.quotingType = D.quotingType === '"' ? K : Z, this.forceQuotes = D.forceQuotes || !1, this.replacer = typeof D.replacer == "function" ? D.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function te(D, we) {
    for (var Oe = e.repeat(" ", we), Ee = 0, Ce = -1, $e = "", Fe, xe = D.length; Ee < xe; )
      Ce = D.indexOf(`
`, Ee), Ce === -1 ? (Fe = D.slice(Ee), Ee = xe) : (Fe = D.slice(Ee, Ce + 1), Ee = Ce + 1), Fe.length && Fe !== `
` && ($e += Oe), $e += Fe;
    return $e;
  }
  function q(D, we) {
    return `
` + e.repeat(" ", D.indent * we);
  }
  function j(D, we) {
    var Oe, Ee, Ce;
    for (Oe = 0, Ee = D.implicitTypes.length; Oe < Ee; Oe += 1)
      if (Ce = D.implicitTypes[Oe], Ce.resolve(we))
        return !0;
    return !1;
  }
  function H(D) {
    return D === p || D === o;
  }
  function F(D) {
    return 32 <= D && D <= 126 || 161 <= D && D <= 55295 && D !== 8232 && D !== 8233 || 57344 <= D && D <= 65533 && D !== s || 65536 <= D && D <= 1114111;
  }
  function ue(D) {
    return F(D) && D !== s && D !== l && D !== a;
  }
  function ge(D, we, Oe) {
    var Ee = ue(D), Ce = Ee && !H(D);
    return (
      // ns-plain-safe
      (Oe ? (
        // c = flow-in
        Ee
      ) : Ee && D !== x && D !== I && D !== B && D !== Y && D !== re) && D !== m && !(we === w && !Ce) || ue(we) && !H(we) && D === m || we === w && Ce
    );
  }
  function Ae(D) {
    return F(D) && D !== s && !H(D) && D !== y && D !== T && D !== w && D !== x && D !== I && D !== B && D !== Y && D !== re && D !== m && D !== g && D !== _ && D !== f && D !== Q && D !== k && D !== A && D !== S && D !== d && D !== v && D !== R && D !== L;
  }
  function C(D) {
    return !H(D) && D !== w;
  }
  function N(D, we) {
    var Oe = D.charCodeAt(we), Ee;
    return Oe >= 55296 && Oe <= 56319 && we + 1 < D.length && (Ee = D.charCodeAt(we + 1), Ee >= 56320 && Ee <= 57343) ? (Oe - 55296) * 1024 + Ee - 56320 + 65536 : Oe;
  }
  function J(D) {
    var we = /^\n* /;
    return we.test(D);
  }
  var X = 1, ae = 2, U = 3, W = 4, ve = 5;
  function he(D, we, Oe, Ee, Ce, $e, Fe, xe) {
    var Le, Ye = 0, mt = null, rt = !1, ut = !1, gt = Ee !== -1, Jt = -1, Fn = Ae(N(D, 0)) && C(N(D, D.length - 1));
    if (we || Fe)
      for (Le = 0; Le < D.length; Ye >= 65536 ? Le += 2 : Le++) {
        if (Ye = N(D, Le), !F(Ye))
          return ve;
        Fn = Fn && ge(Ye, mt, xe), mt = Ye;
      }
    else {
      for (Le = 0; Le < D.length; Ye >= 65536 ? Le += 2 : Le++) {
        if (Ye = N(D, Le), Ye === a)
          rt = !0, gt && (ut = ut || // Foldable line = too long, and not more-indented.
          Le - Jt - 1 > Ee && D[Jt + 1] !== " ", Jt = Le);
        else if (!F(Ye))
          return ve;
        Fn = Fn && ge(Ye, mt, xe), mt = Ye;
      }
      ut = ut || gt && Le - Jt - 1 > Ee && D[Jt + 1] !== " ";
    }
    return !rt && !ut ? Fn && !Fe && !Ce(D) ? X : $e === K ? ve : ae : Oe > 9 && J(D) ? ve : Fe ? $e === K ? ve : ae : ut ? W : U;
  }
  function Te(D, we, Oe, Ee, Ce) {
    D.dump = function() {
      if (we.length === 0)
        return D.quotingType === K ? '""' : "''";
      if (!D.noCompatMode && (ce.indexOf(we) !== -1 || pe.test(we)))
        return D.quotingType === K ? '"' + we + '"' : "'" + we + "'";
      var $e = D.indent * Math.max(1, Oe), Fe = D.lineWidth === -1 ? -1 : Math.max(Math.min(D.lineWidth, 40), D.lineWidth - $e), xe = Ee || D.flowLevel > -1 && Oe >= D.flowLevel;
      function Le(Ye) {
        return j(D, Ye);
      }
      switch (he(
        we,
        xe,
        D.indent,
        Fe,
        Le,
        D.quotingType,
        D.forceQuotes && !Ee,
        Ce
      )) {
        case X:
          return we;
        case ae:
          return "'" + we.replace(/'/g, "''") + "'";
        case U:
          return "|" + Se(we, D.indent) + O(te(we, $e));
        case W:
          return ">" + Se(we, D.indent) + O(te(M(we, Fe), $e));
        case ve:
          return '"' + ye(we) + '"';
        default:
          throw new t("impossible error: invalid scalar style");
      }
    }();
  }
  function Se(D, we) {
    var Oe = J(D) ? String(we) : "", Ee = D[D.length - 1] === `
`, Ce = Ee && (D[D.length - 2] === `
` || D === `
`), $e = Ce ? "+" : Ee ? "" : "-";
    return Oe + $e + `
`;
  }
  function O(D) {
    return D[D.length - 1] === `
` ? D.slice(0, -1) : D;
  }
  function M(D, we) {
    for (var Oe = /(\n+)([^\n]*)/g, Ee = function() {
      var Ye = D.indexOf(`
`);
      return Ye = Ye !== -1 ? Ye : D.length, Oe.lastIndex = Ye, le(D.slice(0, Ye), we);
    }(), Ce = D[0] === `
` || D[0] === " ", $e, Fe; Fe = Oe.exec(D); ) {
      var xe = Fe[1], Le = Fe[2];
      $e = Le[0] === " ", Ee += xe + (!Ce && !$e && Le !== "" ? `
` : "") + le(Le, we), Ce = $e;
    }
    return Ee;
  }
  function le(D, we) {
    if (D === "" || D[0] === " ") return D;
    for (var Oe = / [^ ]/g, Ee, Ce = 0, $e, Fe = 0, xe = 0, Le = ""; Ee = Oe.exec(D); )
      xe = Ee.index, xe - Ce > we && ($e = Fe > Ce ? Fe : xe, Le += `
` + D.slice(Ce, $e), Ce = $e + 1), Fe = xe;
    return Le += `
`, D.length - Ce > we && Fe > Ce ? Le += D.slice(Ce, Fe) + `
` + D.slice(Fe + 1) : Le += D.slice(Ce), Le.slice(1);
  }
  function ye(D) {
    for (var we = "", Oe = 0, Ee, Ce = 0; Ce < D.length; Oe >= 65536 ? Ce += 2 : Ce++)
      Oe = N(D, Ce), Ee = oe[Oe], !Ee && F(Oe) ? (we += D[Ce], Oe >= 65536 && (we += D[Ce + 1])) : we += Ee || G(Oe);
    return we;
  }
  function be(D, we, Oe) {
    var Ee = "", Ce = D.tag, $e, Fe, xe;
    for ($e = 0, Fe = Oe.length; $e < Fe; $e += 1)
      xe = Oe[$e], D.replacer && (xe = D.replacer.call(Oe, String($e), xe)), (Xe(D, we, xe, !1, !1) || typeof xe > "u" && Xe(D, we, null, !1, !1)) && (Ee !== "" && (Ee += "," + (D.condenseFlow ? "" : " ")), Ee += D.dump);
    D.tag = Ce, D.dump = "[" + Ee + "]";
  }
  function Pe(D, we, Oe, Ee) {
    var Ce = "", $e = D.tag, Fe, xe, Le;
    for (Fe = 0, xe = Oe.length; Fe < xe; Fe += 1)
      Le = Oe[Fe], D.replacer && (Le = D.replacer.call(Oe, String(Fe), Le)), (Xe(D, we + 1, Le, !0, !0, !1, !0) || typeof Le > "u" && Xe(D, we + 1, null, !0, !0, !1, !0)) && ((!Ee || Ce !== "") && (Ce += q(D, we)), D.dump && a === D.dump.charCodeAt(0) ? Ce += "-" : Ce += "- ", Ce += D.dump);
    D.tag = $e, D.dump = Ce || "[]";
  }
  function ke(D, we, Oe) {
    var Ee = "", Ce = D.tag, $e = Object.keys(Oe), Fe, xe, Le, Ye, mt;
    for (Fe = 0, xe = $e.length; Fe < xe; Fe += 1)
      mt = "", Ee !== "" && (mt += ", "), D.condenseFlow && (mt += '"'), Le = $e[Fe], Ye = Oe[Le], D.replacer && (Ye = D.replacer.call(Oe, Le, Ye)), Xe(D, we, Le, !1, !1) && (D.dump.length > 1024 && (mt += "? "), mt += D.dump + (D.condenseFlow ? '"' : "") + ":" + (D.condenseFlow ? "" : " "), Xe(D, we, Ye, !1, !1) && (mt += D.dump, Ee += mt));
    D.tag = Ce, D.dump = "{" + Ee + "}";
  }
  function Me(D, we, Oe, Ee) {
    var Ce = "", $e = D.tag, Fe = Object.keys(Oe), xe, Le, Ye, mt, rt, ut;
    if (D.sortKeys === !0)
      Fe.sort();
    else if (typeof D.sortKeys == "function")
      Fe.sort(D.sortKeys);
    else if (D.sortKeys)
      throw new t("sortKeys must be a boolean or a function");
    for (xe = 0, Le = Fe.length; xe < Le; xe += 1)
      ut = "", (!Ee || Ce !== "") && (ut += q(D, we)), Ye = Fe[xe], mt = Oe[Ye], D.replacer && (mt = D.replacer.call(Oe, Ye, mt)), Xe(D, we + 1, Ye, !0, !0, !0) && (rt = D.tag !== null && D.tag !== "?" || D.dump && D.dump.length > 1024, rt && (D.dump && a === D.dump.charCodeAt(0) ? ut += "?" : ut += "? "), ut += D.dump, rt && (ut += q(D, we)), Xe(D, we + 1, mt, !0, rt) && (D.dump && a === D.dump.charCodeAt(0) ? ut += ":" : ut += ": ", ut += D.dump, Ce += ut));
    D.tag = $e, D.dump = Ce || "{}";
  }
  function We(D, we, Oe) {
    var Ee, Ce, $e, Fe, xe, Le;
    for (Ce = Oe ? D.explicitTypes : D.implicitTypes, $e = 0, Fe = Ce.length; $e < Fe; $e += 1)
      if (xe = Ce[$e], (xe.instanceOf || xe.predicate) && (!xe.instanceOf || typeof we == "object" && we instanceof xe.instanceOf) && (!xe.predicate || xe.predicate(we))) {
        if (Oe ? xe.multi && xe.representName ? D.tag = xe.representName(we) : D.tag = xe.tag : D.tag = "?", xe.represent) {
          if (Le = D.styleMap[xe.tag] || xe.defaultStyle, n.call(xe.represent) === "[object Function]")
            Ee = xe.represent(we, Le);
          else if (i.call(xe.represent, Le))
            Ee = xe.represent[Le](we, Le);
          else
            throw new t("!<" + xe.tag + '> tag resolver accepts not "' + Le + '" style');
          D.dump = Ee;
        }
        return !0;
      }
    return !1;
  }
  function Xe(D, we, Oe, Ee, Ce, $e, Fe) {
    D.tag = null, D.dump = Oe, We(D, Oe, !1) || We(D, Oe, !0);
    var xe = n.call(D.dump), Le = Ee, Ye;
    Ee && (Ee = D.flowLevel < 0 || D.flowLevel > we);
    var mt = xe === "[object Object]" || xe === "[object Array]", rt, ut;
    if (mt && (rt = D.duplicates.indexOf(Oe), ut = rt !== -1), (D.tag !== null && D.tag !== "?" || ut || D.indent !== 2 && we > 0) && (Ce = !1), ut && D.usedDuplicates[rt])
      D.dump = "*ref_" + rt;
    else {
      if (mt && ut && !D.usedDuplicates[rt] && (D.usedDuplicates[rt] = !0), xe === "[object Object]")
        Ee && Object.keys(D.dump).length !== 0 ? (Me(D, we, D.dump, Ce), ut && (D.dump = "&ref_" + rt + D.dump)) : (ke(D, we, D.dump), ut && (D.dump = "&ref_" + rt + " " + D.dump));
      else if (xe === "[object Array]")
        Ee && D.dump.length !== 0 ? (D.noArrayIndent && !Fe && we > 0 ? Pe(D, we - 1, D.dump, Ce) : Pe(D, we, D.dump, Ce), ut && (D.dump = "&ref_" + rt + D.dump)) : (be(D, we, D.dump), ut && (D.dump = "&ref_" + rt + " " + D.dump));
      else if (xe === "[object String]")
        D.tag !== "?" && Te(D, D.dump, we, $e, Le);
      else {
        if (xe === "[object Undefined]")
          return !1;
        if (D.skipInvalid) return !1;
        throw new t("unacceptable kind of an object to dump " + xe);
      }
      D.tag !== null && D.tag !== "?" && (Ye = encodeURI(
        D.tag[0] === "!" ? D.tag.slice(1) : D.tag
      ).replace(/!/g, "%21"), D.tag[0] === "!" ? Ye = "!" + Ye : Ye.slice(0, 18) === "tag:yaml.org,2002:" ? Ye = "!!" + Ye.slice(18) : Ye = "!<" + Ye + ">", D.dump = Ye + " " + D.dump);
    }
    return !0;
  }
  function Ge(D, we) {
    var Oe = [], Ee = [], Ce, $e;
    for (Ue(D, Oe, Ee), Ce = 0, $e = Ee.length; Ce < $e; Ce += 1)
      we.duplicates.push(Oe[Ee[Ce]]);
    we.usedDuplicates = new Array($e);
  }
  function Ue(D, we, Oe) {
    var Ee, Ce, $e;
    if (D !== null && typeof D == "object")
      if (Ce = we.indexOf(D), Ce !== -1)
        Oe.indexOf(Ce) === -1 && Oe.push(Ce);
      else if (we.push(D), Array.isArray(D))
        for (Ce = 0, $e = D.length; Ce < $e; Ce += 1)
          Ue(D[Ce], we, Oe);
      else
        for (Ee = Object.keys(D), Ce = 0, $e = Ee.length; Ce < $e; Ce += 1)
          Ue(D[Ee[Ce]], we, Oe);
  }
  function Et(D, we) {
    we = we || {};
    var Oe = new z(we);
    Oe.noRefs || Ge(D, Oe);
    var Ee = D;
    return Oe.replacer && (Ee = Oe.replacer.call({ "": Ee }, "", Ee)), Xe(Oe, 0, Ee, !0, !0) ? Oe.dump + `
` : "";
  }
  return Tv.dump = Et, Tv;
}
var kk;
function mW() {
  if (kk) return Pr;
  kk = 1;
  var e = dW(), t = hW();
  function r(n, i) {
    return function() {
      throw new Error("Function yaml." + n + " is removed in js-yaml 4. Use yaml." + i + " instead, which is now safe by default.");
    };
  }
  return Pr.Type = Ur(), Pr.Schema = Dj(), Pr.FAILSAFE_SCHEMA = Bj(), Pr.JSON_SCHEMA = Qj(), Pr.CORE_SCHEMA = Yj(), Pr.DEFAULT_SCHEMA = _S(), Pr.load = e.load, Pr.loadAll = e.loadAll, Pr.dump = t.dump, Pr.YAMLException = bp(), Pr.types = {
    binary: Xj(),
    float: Hj(),
    map: qj(),
    null: Uj(),
    pairs: Zj(),
    set: eN(),
    timestamp: Gj(),
    bool: Vj(),
    int: Wj(),
    merge: Kj(),
    omap: Jj(),
    seq: zj(),
    str: Fj()
  }, Pr.safeLoad = r("safeLoad", "load"), Pr.safeLoadAll = r("safeLoadAll", "loadAll"), Pr.safeDump = r("safeDump", "dump"), Pr;
}
var Ak;
function jb() {
  if (Ak) return Cs;
  Ak = 1, Object.defineProperty(Cs, "__esModule", { value: !0 }), Cs.stringifyYaml = Cs.parseYaml = void 0;
  const e = mW(), t = e.JSON_SCHEMA.extend({
    implicit: [e.types.merge],
    explicit: [e.types.binary, e.types.omap, e.types.pairs, e.types.set]
  }), r = (i, s) => (0, e.load)(i, { schema: t, ...s });
  Cs.parseYaml = r;
  const n = (i, s) => (0, e.dump)(i, s);
  return Cs.stringifyYaml = n, Cs;
}
var $v = {}, Pk;
function ES() {
  return Pk || (Pk = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.env = e.isBrowser = void 0, e.isBrowser = typeof window < "u" || typeof process > "u" || (process == null ? void 0 : process.platform) === "browser", e.env = e.isBrowser ? {} : process.env || {};
  }($v)), $v;
}
var Rv = {}, Ck;
function tN() {
  return Ck || (Ck = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.logger = e.colorize = e.colorOptions = void 0;
    const t = Gs, r = ES(), n = Sn();
    var i = Gs;
    Object.defineProperty(e, "colorOptions", { enumerable: !0, get: function() {
      return i.options;
    } }), e.colorize = new Proxy(t, {
      get(o, a) {
        return r.isBrowser ? n.identity : o[a];
      }
    });
    class s {
      stderr(a) {
        return process.stderr.write(a);
      }
      info(a) {
        return r.isBrowser ? console.log(a) : this.stderr(a);
      }
      warn(a) {
        return r.isBrowser ? console.warn(a) : this.stderr(e.colorize.yellow(a));
      }
      error(a) {
        return r.isBrowser ? console.error(a) : this.stderr(e.colorize.red(a));
      }
    }
    e.logger = new s();
  }(Rv)), Rv;
}
function gW(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Iv = { exports: {} }, Tk;
function yW() {
  return Tk || (Tk = 1, function(e, t) {
    (function(r, n) {
      typeof gW == "function" ? e.exports = n() : r.pluralize = n();
    })(pn, function() {
      var r = [], n = [], i = {}, s = {}, o = {};
      function a(S) {
        return typeof S == "string" ? new RegExp("^" + S + "$", "i") : S;
      }
      function l(S, _) {
        return S === _ ? _ : S === S.toLowerCase() ? _.toLowerCase() : S === S.toUpperCase() ? _.toUpperCase() : S[0] === S[0].toUpperCase() ? _.charAt(0).toUpperCase() + _.substr(1).toLowerCase() : _.toLowerCase();
      }
      function p(S, _) {
        return S.replace(/\$(\d{1,2})/g, function(x, y) {
          return _[y] || "";
        });
      }
      function f(S, _) {
        return S.replace(_[0], function(x, y) {
          var w = p(_[1], arguments);
          return l(x === "" ? S[y - 1] : x, w);
        });
      }
      function d(S, _, x) {
        if (!S.length || i.hasOwnProperty(S))
          return _;
        for (var y = x.length; y--; ) {
          var w = x[y];
          if (w[0].test(_)) return f(_, w);
        }
        return _;
      }
      function m(S, _, x) {
        return function(y) {
          var w = y.toLowerCase();
          return _.hasOwnProperty(w) ? l(y, w) : S.hasOwnProperty(w) ? l(y, S[w]) : d(w, y, x);
        };
      }
      function v(S, _, x, y) {
        return function(w) {
          var k = w.toLowerCase();
          return _.hasOwnProperty(k) ? !0 : S.hasOwnProperty(k) ? !1 : d(k, k, x) === k;
        };
      }
      function g(S, _, x) {
        var y = _ === 1 ? g.singular(S) : g.plural(S);
        return (x ? _ + " " : "") + y;
      }
      return g.plural = m(
        o,
        s,
        r
      ), g.isPlural = v(
        o,
        s,
        r
      ), g.singular = m(
        s,
        o,
        n
      ), g.isSingular = v(
        s,
        o,
        n
      ), g.addPluralRule = function(S, _) {
        r.push([a(S), _]);
      }, g.addSingularRule = function(S, _) {
        n.push([a(S), _]);
      }, g.addUncountableRule = function(S) {
        if (typeof S == "string") {
          i[S.toLowerCase()] = !0;
          return;
        }
        g.addPluralRule(S, "$0"), g.addSingularRule(S, "$0");
      }, g.addIrregularRule = function(S, _) {
        _ = _.toLowerCase(), S = S.toLowerCase(), o[S] = _, s[_] = S;
      }, [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(S) {
        return g.addIrregularRule(S[0], S[1]);
      }), [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(S) {
        return g.addPluralRule(S[0], S[1]);
      }), [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(S) {
        return g.addSingularRule(S[0], S[1]);
      }), [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(g.addUncountableRule), g;
    });
  }(Iv)), Iv.exports;
}
var $k;
function Sn() {
  return $k || ($k = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.stringifyYaml = e.parseYaml = void 0, e.pushStack = d, e.pluralize = m, e.popStack = v, e.loadYaml = g, e.isDefined = S, e.isPlainObject = _, e.isEmptyObject = x, e.isNotEmptyObject = y, e.isEmptyArray = w, e.isNotEmptyArray = k, e.readFileFromUrl = A, e.pickObjectProps = R, e.omitObjectProps = I, e.splitCamelCaseIntoWords = B, e.validateMimeType = L, e.validateMimeTypeOAS3 = Y, e.readFileAsStringSync = Q, e.yamlAndJsonSyncReader = re, e.isPathParameter = oe, e.slash = ce, e.isString = pe, e.isNotString = fe, e.assignExisting = G, e.getMatchingStatusCodeRange = Z, e.isCustomRuleId = K, e.doesYamlFileExist = z, e.showWarningForDeprecatedField = te, e.showErrorForDeprecatedField = q, e.isTruthy = j, e.identity = H, e.keysOf = F, e.pickDefined = ue, e.nextTick = ge, e.pause = Ae, e.getProxyAgent = N, e.dequal = J;
    const t = Gs, r = xS(), n = pW(), i = Gs, s = jb(), o = ES(), a = tN(), l = Gs, p = yW();
    var f = jb();
    Object.defineProperty(e, "parseYaml", { enumerable: !0, get: function() {
      return f.parseYaml;
    } }), Object.defineProperty(e, "stringifyYaml", { enumerable: !0, get: function() {
      return f.stringifyYaml;
    } });
    function d(X, ae) {
      return { prev: X, value: ae };
    }
    function m(X, ae, U) {
      return X.split(" ").map((W) => p(W, ae, U)).join(" ");
    }
    function v(X) {
      return (X == null ? void 0 : X.prev) ?? null;
    }
    async function g(X) {
      const ae = await t.promises.readFile(X, "utf-8");
      return (0, s.parseYaml)(ae);
    }
    function S(X) {
      return X !== void 0;
    }
    function _(X) {
      return X !== null && typeof X == "object" && !Array.isArray(X);
    }
    function x(X) {
      return _(X) && Object.keys(X).length === 0;
    }
    function y(X) {
      return _(X) && !x(X);
    }
    function w(X) {
      return Array.isArray(X) && X.length === 0;
    }
    function k(X) {
      return !!X && Array.isArray(X) && !!X.length;
    }
    async function A(X, ae) {
      const U = {};
      for (const ve of ae.headers)
        T(X, ve.matches) && (U[ve.name] = ve.envVariable !== void 0 ? o.env[ve.envVariable] || "" : ve.value);
      const W = await (ae.customFetch || i.default)(X, {
        headers: U
      });
      if (!W.ok)
        throw new Error(`Failed to load ${X}: ${W.status} ${W.statusText}`);
      return { body: await W.text(), mimeType: W.headers.get("content-type") };
    }
    function T(X, ae) {
      return ae.match(/^https?:\/\//) || (X = X.replace(/^https?:\/\//, "")), n(X, ae);
    }
    function R(X, ae) {
      return Object.fromEntries(ae.filter((U) => U in X).map((U) => [U, X[U]]));
    }
    function I(X, ae) {
      return Object.fromEntries(Object.entries(X).filter(([U]) => !ae.includes(U)));
    }
    function B(X) {
      const ae = X.split(/(?:[-._])|([A-Z][a-z]+)/).filter(j).map((W) => W.toLocaleLowerCase()), U = X.split(/([A-Z]{2,})/).filter((W) => W && W === W.toUpperCase()).map((W) => W.toLocaleLowerCase());
      return /* @__PURE__ */ new Set([...ae, ...U]);
    }
    function L({ type: X, value: ae }, { report: U, location: W }, ve) {
      const he = X === "consumes" ? "request" : "response";
      if (!ve)
        throw new Error(`Parameter "allowedValues" is not provided for "${he}-mime-type" rule`);
      if (ae[X])
        for (const Te of ae[X])
          ve.includes(Te) || U({
            message: `Mime type "${Te}" is not allowed`,
            location: W.child(ae[X].indexOf(Te)).key()
          });
    }
    function Y({ type: X, value: ae }, { report: U, location: W }, ve) {
      const he = X === "consumes" ? "request" : "response";
      if (!ve)
        throw new Error(`Parameter "allowedValues" is not provided for "${he}-mime-type" rule`);
      if (ae.content)
        for (const Te of Object.keys(ae.content))
          ve.includes(Te) || U({
            message: `Mime type "${Te}" is not allowed`,
            location: W.child("content").child(Te).key()
          });
    }
    function Q(X) {
      return t.readFileSync(X, "utf-8");
    }
    function re(X) {
      const ae = t.readFileSync(X, "utf-8");
      return (0, s.parseYaml)(ae);
    }
    function oe(X) {
      return X.startsWith("{") && X.endsWith("}");
    }
    function ce(X) {
      return /^\\\\\?\\/.test(X) ? X : X.replace(/\\/g, "/");
    }
    function pe(X) {
      return typeof X == "string";
    }
    function fe(X) {
      return !pe(X);
    }
    function G(X, ae) {
      for (const U of Object.keys(ae))
        X.hasOwnProperty(U) && (X[U] = ae[U]);
    }
    function Z(X) {
      return `${X}`.replace(/^(\d)\d\d$/, (ae, U) => `${U}XX`);
    }
    function K(X) {
      return X.includes("/");
    }
    function z(X) {
      var ae;
      return ((0, r.extname)(X) === ".yaml" || (0, r.extname)(X) === ".yml") && ((ae = t == null ? void 0 : t.hasOwnProperty) == null ? void 0 : ae.call(t, "existsSync")) && t.existsSync(X);
    }
    function te(X, ae, U) {
      a.logger.warn(`The '${a.colorize.red(X)}' field is deprecated. ${ae ? `Use ${a.colorize.green(C(ae, U))} instead. ` : ""}Read more about this change: https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties
`);
    }
    function q(X, ae, U) {
      throw new Error(`Do not use '${X}' field. ${ae ? `Use '${C(ae, U)}' instead. ` : ""}
`);
    }
    function j(X) {
      return !!X;
    }
    function H(X) {
      return X;
    }
    function F(X) {
      return X ? Object.keys(X) : [];
    }
    function ue(X) {
      if (!X)
        return;
      const ae = {};
      for (const U in X)
        X[U] !== void 0 && (ae[U] = X[U]);
      return ae;
    }
    function ge() {
      return new Promise((X) => {
        setTimeout(X);
      });
    }
    async function Ae(X) {
      return new Promise((ae) => setTimeout(ae, X));
    }
    function C(X, ae) {
      return `${typeof ae < "u" ? `${ae}.` : ""}${X}`;
    }
    function N() {
      const X = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
      return X ? new l.HttpsProxyAgent(X) : void 0;
    }
    function J(X, ae) {
      let U, W;
      if (X === ae)
        return !0;
      if (X && ae && (U = X.constructor) === ae.constructor) {
        if (U === Date)
          return X.getTime() === ae.getTime();
        if (U === RegExp)
          return X.toString() === ae.toString();
        if (U === Array) {
          if ((W = X.length) === ae.length)
            for (; W-- && J(X[W], ae[W]); )
              ;
          return W === -1;
        }
        if (!U || typeof X == "object") {
          W = 0;
          for (U in X)
            if (Object.prototype.hasOwnProperty.call(X, U) && ++W && !Object.prototype.hasOwnProperty.call(ae, U) || !(U in ae) || !J(X[U], ae[U]))
              return !1;
          return Object.keys(ae).length === W;
        }
      }
      return X !== X && ae !== ae;
    }
  }(ov)), ov;
}
var Rk;
function Gl() {
  if (Rk) return Ar;
  Rk = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.Location = void 0, Ar.joinPointer = t, Ar.isRef = r, Ar.unescapePointer = i, Ar.escapePointer = s, Ar.parseRef = o, Ar.parsePointer = a, Ar.pointerBaseName = l, Ar.refBaseName = p, Ar.isAbsoluteUrl = f, Ar.isMappingRef = d, Ar.isAnchor = m;
  const e = Sn();
  function t(v, g) {
    return v === "" && (v = "#/"), v[v.length - 1] === "/" ? v + g : v + "/" + g;
  }
  function r(v) {
    return v && typeof v.$ref == "string";
  }
  class n {
    constructor(g, S) {
      this.source = g, this.pointer = S;
    }
    child(g) {
      return new n(this.source, t(this.pointer, (Array.isArray(g) ? g : [g]).map(s).join("/")));
    }
    key() {
      return { ...this, reportOnKey: !0 };
    }
    get absolutePointer() {
      return this.source.absoluteRef + (this.pointer === "#/" ? "" : this.pointer);
    }
  }
  Ar.Location = n;
  function i(v) {
    return decodeURIComponent(v.replace(/~1/g, "/").replace(/~0/g, "~"));
  }
  function s(v) {
    return typeof v == "number" ? v : v.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function o(v) {
    const [g, S = ""] = v.split("#/");
    return {
      uri: (g.endsWith("#") ? g.slice(0, -1) : g) || null,
      pointer: a(S)
    };
  }
  function a(v) {
    return v.split("/").map(i).filter(e.isTruthy);
  }
  function l(v) {
    const g = v.split("/");
    return g[g.length - 1];
  }
  function p(v) {
    const g = v.split(/[\/\\]/);
    return g[g.length - 1].replace(/\.[^.]+$/, "");
  }
  function f(v) {
    return v.startsWith("http://") || v.startsWith("https://");
  }
  function d(v) {
    return v.startsWith("#") || v.startsWith("https://") || v.startsWith("http://") || v.startsWith("./") || v.startsWith("../") || v.indexOf("/") > -1;
  }
  function m(v) {
    return /^#[A-Za-z][A-Za-z0-9\-_:.]*$/.test(v);
  }
  return Ar;
}
var jv = {}, Ik;
function ai() {
  return Ik || (Ik = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpecExtension = void 0, e.listOf = t, e.mapOf = r, e.normalizeTypes = n, e.isNamedType = i;
    function t(s) {
      return {
        name: `${s}List`,
        properties: {},
        items: s
      };
    }
    function r(s) {
      return {
        name: `${s}Map`,
        properties: {},
        additionalProperties: () => s
      };
    }
    e.SpecExtension = {
      name: "SpecExtension",
      properties: {},
      // skip validation of additional properties for unknown extensions
      additionalProperties: { resolvable: !0 }
    };
    function n(s, o = {}) {
      const a = {};
      for (const f of Object.keys(s))
        a[f] = {
          ...s[f],
          name: f
        };
      for (const f of Object.values(a))
        l(f);
      return a.SpecExtension = e.SpecExtension, a;
      function l(f) {
        if (f.additionalProperties && (f.additionalProperties = p(f.additionalProperties)), f.items && (f.items = p(f.items)), f.properties) {
          const d = {};
          for (const [m, v] of Object.entries(f.properties))
            d[m] = p(v), o.doNotResolveExamples && v && v.isExample && (d[m] = {
              ...v,
              resolvable: !1
            });
          f.properties = d;
        }
      }
      function p(f) {
        if (typeof f == "string") {
          if (!a[f])
            throw new Error(`Unknown type name found: ${f}`);
          return a[f];
        } else return typeof f == "function" ? (d, m) => p(f(d, m)) : f && f.name ? (f = { ...f }, l(f), f) : f && f.directResolveAs ? {
          ...f,
          directResolveAs: p(f.directResolveAs)
        } : f;
      }
    }
    function i(s) {
      return typeof (s == null ? void 0 : s.name) == "string";
    }
  }(jv)), jv;
}
var jk;
function OS() {
  if (jk) return Wr;
  jk = 1, Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.BaseResolver = Wr.YamlParseError = Wr.ResolveError = Wr.Source = void 0, Wr.makeRefId = p, Wr.makeDocumentFromString = f, Wr.resolveDocument = _;
  const e = Gs, t = xS(), r = Gl(), n = ai(), i = Sn();
  class s {
    constructor(y, w, k) {
      this.absoluteRef = y, this.body = w, this.mimeType = k;
    }
    // pass safeLoad as argument to separate it from browser bundle
    getAst(y) {
      return this._ast === void 0 && (this._ast = y(this.body, { filename: this.absoluteRef }) ?? void 0, this._ast && this._ast.kind === 0 && // KIND.scalar = 0
      this._ast.value === "" && this._ast.startPosition !== 1 && (this._ast.startPosition = 1, this._ast.endPosition = 1)), this._ast;
    }
    getLines() {
      return this._lines === void 0 && (this._lines = this.body.split(/\r\n|[\n\r]/g)), this._lines;
    }
  }
  Wr.Source = s;
  class o extends Error {
    constructor(y) {
      super(y.message), this.originalError = y, Object.setPrototypeOf(this, o.prototype);
    }
  }
  Wr.ResolveError = o;
  const a = /\((\d+):(\d+)\)$/;
  class l extends Error {
    constructor(y, w) {
      super(y.message.split(`
`)[0]), this.originalError = y, this.source = w, Object.setPrototypeOf(this, l.prototype);
      const [, k, A] = this.message.match(a) || [];
      this.line = parseInt(k, 10), this.col = parseInt(A, 10);
    }
  }
  Wr.YamlParseError = l;
  function p(x, y) {
    return x + "::" + y;
  }
  function f(x, y) {
    const w = new s(y, x);
    try {
      return {
        source: w,
        parsed: (0, i.parseYaml)(x, { filename: y })
      };
    } catch (k) {
      throw new l(k, w);
    }
  }
  class d {
    constructor(y = { http: { headers: [] } }) {
      this.config = y, this.cache = /* @__PURE__ */ new Map();
    }
    getFiles() {
      return new Set(Array.from(this.cache.keys()));
    }
    resolveExternalRef(y, w) {
      return (0, r.isAbsoluteUrl)(w) ? w : y && (0, r.isAbsoluteUrl)(y) ? new URL(w, y).href : t.resolve(y ? t.dirname(y) : process.cwd(), w);
    }
    async loadExternalRef(y) {
      try {
        if ((0, r.isAbsoluteUrl)(y)) {
          const { body: w, mimeType: k } = await (0, i.readFileFromUrl)(y, this.config.http);
          return new s(y, w, k);
        } else {
          if (e.lstatSync(y).isDirectory())
            throw new Error(`Expected a file but received a folder at ${y}`);
          const w = await e.promises.readFile(y, "utf-8");
          return new s(y, w.replace(/\r\n/g, `
`));
        }
      } catch (w) {
        throw w.message = w.message.replace(", lstat", ""), new o(w);
      }
    }
    parseDocument(y, w = !1) {
      var A;
      const k = y.absoluteRef.substr(y.absoluteRef.lastIndexOf("."));
      if (![".json", ".json", ".yml", ".yaml"].includes(k) && !((A = y.mimeType) != null && A.match(/(json|yaml|openapi)/)) && !w)
        return { source: y, parsed: y.body };
      try {
        return {
          source: y,
          parsed: (0, i.parseYaml)(y.body, { filename: y.absoluteRef })
        };
      } catch (T) {
        throw new l(T, y);
      }
    }
    async resolveDocument(y, w, k = !1) {
      const A = this.resolveExternalRef(y, w), T = this.cache.get(A);
      if (T)
        return T;
      const R = this.loadExternalRef(A).then((I) => this.parseDocument(I, k));
      return this.cache.set(A, R), R;
    }
  }
  Wr.BaseResolver = d;
  function m(x, y) {
    return {
      prev: x,
      node: y
    };
  }
  function v(x, y) {
    for (; x; ) {
      if (x.node === y)
        return !0;
      x = x.prev;
    }
    return !1;
  }
  const g = { name: "unknown", properties: {} }, S = { name: "scalar", properties: {} };
  async function _(x) {
    const { rootDocument: y, externalRefResolver: w, rootType: k } = x, A = /* @__PURE__ */ new Map(), T = /* @__PURE__ */ new Set(), R = [];
    B(y.parsed, y, "#/", k);
    let I;
    do
      I = await Promise.all(R);
    while (R.length !== I.length);
    return A;
    function B(L, Y, Q, re) {
      const oe = Y.source.absoluteRef, ce = /* @__PURE__ */ new Map();
      pe(L, re, oe + Q);
      function pe(G, Z, K) {
        if (typeof G != "object" || G === null)
          return;
        const z = `${Z.name}::${K}`;
        if (T.has(z))
          return;
        T.add(z);
        const [te, q] = Object.entries(G).find(([j]) => j === "$anchor") || [];
        if (q && ce.set(`#${q}`, G), Array.isArray(G)) {
          const j = Z.items;
          if (j === void 0 && Z !== g && Z !== n.SpecExtension)
            return;
          const H = typeof j == "function";
          for (let F = 0; F < G.length; F++) {
            const ue = H ? j(G[F], (0, r.joinPointer)(K, F)) : j;
            ue === void 0 && Z !== g && Z !== n.SpecExtension || pe(G[F], (0, n.isNamedType)(ue) ? ue : g, (0, r.joinPointer)(K, F));
          }
          return;
        }
        for (const j of Object.keys(G)) {
          let H = G[j], F = Z.properties[j];
          F === void 0 && (F = Z.additionalProperties), typeof F == "function" && (F = F(H, j)), F === void 0 && (F = g), Z.extensionsPrefix && j.startsWith(Z.extensionsPrefix) && F === g && (F = n.SpecExtension), !(0, n.isNamedType)(F) && (F != null && F.directResolveAs) && (F = F.directResolveAs, H = { $ref: H }), F && F.name === void 0 && F.resolvable !== !1 && (F = S), !(!(0, n.isNamedType)(F) || typeof H != "object") && pe(H, F, (0, r.joinPointer)(K, (0, r.escapePointer)(j)));
        }
        if ((0, r.isRef)(G)) {
          const j = fe(Y, G, {
            prev: null,
            node: G
          }).then((H) => {
            H.resolved && B(H.node, H.document, H.nodePointer, Z);
          });
          R.push(j);
        }
      }
      async function fe(G, Z, K) {
        if (v(K.prev, Z))
          throw new Error("Self-referencing circular pointer");
        if ((0, r.isAnchor)(Z.$ref)) {
          await (0, i.nextTick)();
          const Ae = {
            resolved: !0,
            isRemote: !1,
            node: ce.get(Z.$ref),
            document: G,
            nodePointer: Z.$ref
          }, C = p(G.source.absoluteRef, Z.$ref);
          return A.set(C, Ae), Ae;
        }
        const { uri: z, pointer: te } = (0, r.parseRef)(Z.$ref), q = z !== null;
        let j;
        try {
          j = q ? await w.resolveDocument(G.source.absoluteRef, z) : G;
        } catch (Ae) {
          const C = {
            resolved: !1,
            isRemote: q,
            document: void 0,
            error: Ae
          }, N = p(G.source.absoluteRef, Z.$ref);
          return A.set(N, C), C;
        }
        let H = {
          resolved: !0,
          document: j,
          isRemote: q,
          node: G.parsed,
          nodePointer: "#/"
        }, F = j.parsed;
        const ue = te;
        for (const Ae of ue)
          if (typeof F != "object") {
            F = void 0;
            break;
          } else if (F[Ae] !== void 0)
            F = F[Ae], H.nodePointer = (0, r.joinPointer)(H.nodePointer, (0, r.escapePointer)(Ae));
          else if ((0, r.isRef)(F)) {
            if (H = await fe(j, F, m(K, F)), j = H.document || j, typeof H.node != "object") {
              F = void 0;
              break;
            }
            F = H.node[Ae], H.nodePointer = (0, r.joinPointer)(H.nodePointer, (0, r.escapePointer)(Ae));
          } else {
            F = void 0;
            break;
          }
        H.node = F, H.document = j;
        const ge = p(G.source.absoluteRef, Z.$ref);
        return H.document && (0, r.isRef)(F) && (H = await fe(H.document, F, m(K, F))), A.set(ge, H), { ...H };
      }
    }
  }
  return Wr;
}
var td = {}, Nk;
function vW() {
  if (Nk) return td;
  Nk = 1, Object.defineProperty(td, "__esModule", { value: !0 }), td.normalizeVisitors = r;
  const e = ai(), t = {
    Root: "DefinitionRoot",
    ServerVariablesMap: "ServerVariableMap",
    Paths: ["PathMap", "PathsMap"],
    CallbacksMap: "CallbackMap",
    MediaTypesMap: "MediaTypeMap",
    ExamplesMap: "ExampleMap",
    EncodingMap: "EncodingsMap",
    HeadersMap: "HeaderMap",
    LinksMap: "LinkMap",
    OAuth2Flows: "SecuritySchemeFlows",
    Responses: "ResponsesMap"
  };
  function r(n, i) {
    const s = {};
    s.any = {
      enter: [],
      leave: []
    };
    for (const p of Object.keys(i))
      s[p] = {
        enter: [],
        leave: []
      };
    s.ref = {
      enter: [],
      leave: []
    };
    for (const { ruleId: p, severity: f, visitor: d } of n)
      l({ ruleId: p, severity: f }, d, null);
    for (const p of Object.keys(s))
      s[p].enter.sort((f, d) => d.depth - f.depth), s[p].leave.sort((f, d) => f.depth - d.depth);
    return s;
    function o(p, f, d, m, v = []) {
      if (v.includes(f))
        return;
      v = [...v, f];
      const g = /* @__PURE__ */ new Set();
      for (const _ of Object.values(f.properties)) {
        if (_ === d) {
          S(p, v);
          continue;
        }
        typeof _ == "object" && _ !== null && _.name && g.add(_);
      }
      f.additionalProperties && typeof f.additionalProperties != "function" && (f.additionalProperties === d ? S(p, v) : f.additionalProperties.name !== void 0 && g.add(f.additionalProperties)), f.items && typeof f.items != "function" && (f.items === d ? S(p, v) : f.items.name !== void 0 && g.add(f.items)), f.extensionsPrefix && g.add(e.SpecExtension);
      for (const _ of Array.from(g.values()))
        o(p, _, d, m, v);
      function S(_, x) {
        for (const y of x.slice(1))
          s[y.name] = s[y.name] || {
            enter: [],
            leave: []
          }, s[y.name].enter.push({
            ..._,
            visit: () => {
            },
            depth: 0,
            context: {
              isSkippedLevel: !0,
              seen: /* @__PURE__ */ new Set(),
              parent: m
            }
          });
      }
    }
    function a(p, f) {
      if (Array.isArray(f)) {
        const d = f.find((m) => p[m]) || void 0;
        return d && p[d];
      }
      return p[f];
    }
    function l(p, f, d, m = 0) {
      const v = Object.keys(i);
      if (m === 0)
        v.push("any"), v.push("ref");
      else {
        if (f.any)
          throw new Error("any() is allowed only on top level");
        if (f.ref)
          throw new Error("ref() is allowed only on top level");
      }
      for (const g of v) {
        const S = f[g] || a(f, t[g]), _ = s[g];
        if (!S)
          continue;
        let x, y, w;
        const k = typeof S == "object";
        if (g === "ref" && k && S.skip)
          throw new Error("ref() visitor does not support skip");
        typeof S == "function" ? x = S : k && (x = S.enter, y = S.leave, w = S.skip);
        const A = {
          activatedOn: null,
          type: i[g],
          parent: d,
          isSkippedLevel: !1
        };
        if (typeof S == "object" && l(p, S, A, m + 1), d && o(p, d.type, i[g], d), x || k) {
          if (x && typeof x != "function")
            throw new Error("DEV: should be function");
          _.enter.push({
            ...p,
            visit: x || (() => {
            }),
            skip: w,
            depth: m,
            context: A
          });
        }
        if (y) {
          if (typeof y != "function")
            throw new Error("DEV: should be function");
          _.leave.push({
            ...p,
            visit: y,
            depth: m,
            context: A
          });
        }
      }
    }
  }
  return td;
}
var rd = {}, Lk;
function bW() {
  if (Lk) return rd;
  Lk = 1, Object.defineProperty(rd, "__esModule", { value: !0 }), rd.walkDocument = o;
  const e = Gl(), t = Sn(), r = OS(), n = ai();
  function i(a) {
    var p;
    const l = {};
    for (; a.parent; )
      l[a.parent.type.name] = (p = a.parent.activatedOn) == null ? void 0 : p.value.node, a = a.parent;
    return l;
  }
  function s(a) {
    var p, f;
    const l = {};
    for (; a.parent; )
      (p = a.parent.activatedOn) != null && p.value.location && (l[a.parent.type.name] = (f = a.parent.activatedOn) == null ? void 0 : f.value.location), a = a.parent;
    return l;
  }
  function o(a) {
    const { document: l, rootType: p, normalizedVisitors: f, resolvedRefMap: d, ctx: m } = a, v = {}, g = /* @__PURE__ */ new Set();
    S(l.parsed, p, new e.Location(l.source, "#/"), void 0, "");
    function S(_, x, y, w, k) {
      var ce, pe, fe, G, Z, K, z, te, q, j;
      const A = (H, F = R.source.absoluteRef) => {
        if (!(0, e.isRef)(H))
          return { location: y, node: H };
        const ue = (0, r.makeRefId)(F, H.$ref), ge = d.get(ue);
        if (!ge)
          return {
            location: void 0,
            node: void 0
          };
        const { resolved: Ae, node: C, document: N, nodePointer: J, error: X } = ge;
        return { location: Ae ? new e.Location(N.source, J) : X instanceof r.YamlParseError ? new e.Location(X.source, "") : void 0, node: C, error: X };
      }, T = y;
      let R = y;
      const { node: I, location: B, error: L } = A(_), Y = /* @__PURE__ */ new Set();
      if ((0, e.isRef)(_)) {
        const H = f.ref.enter;
        for (const { visit: F, ruleId: ue, severity: ge, context: Ae } of H) {
          Y.add(Ae);
          const C = re.bind(void 0, ue, ge);
          F(_, {
            report: C,
            resolve: A,
            rawNode: _,
            rawLocation: T,
            location: y,
            type: x,
            parent: w,
            key: k,
            parentLocations: {},
            oasVersion: m.oasVersion,
            getVisitorData: oe.bind(void 0, ue)
          }, { node: I, location: B, error: L }), B != null && B.source.absoluteRef && m.refTypes && m.refTypes.set(B == null ? void 0 : B.source.absoluteRef, x);
        }
      }
      if (I !== void 0 && B && x.name !== "scalar") {
        R = B;
        const H = (pe = (ce = v[x.name]) == null ? void 0 : ce.has) == null ? void 0 : pe.call(ce, I);
        let F = !1;
        const ge = f.any.enter.concat(((fe = f[x.name]) == null ? void 0 : fe.enter) || []), Ae = [];
        for (const { context: J, visit: X, skip: ae, ruleId: U, severity: W } of ge) {
          if (g.has(`${R.absolutePointer}${R.pointer}`))
            break;
          if (J.isSkippedLevel)
            J.parent.activatedOn && !J.parent.activatedOn.value.nextLevelTypeActivated && !J.seen.has(_) && (J.seen.add(_), F = !0, Ae.push(J));
          else if (J.parent && // if nested
          J.parent.activatedOn && ((G = J.activatedOn) == null ? void 0 : G.value.withParentNode) !== J.parent.activatedOn.value.node && // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)
          ((Z = J.parent.activatedOn.value.nextLevelTypeActivated) == null ? void 0 : Z.value) !== x || !J.parent && !H) {
            Ae.push(J);
            const ve = {
              node: I,
              location: B,
              nextLevelTypeActivated: null,
              withParentNode: (z = (K = J.parent) == null ? void 0 : K.activatedOn) == null ? void 0 : z.value.node,
              skipped: (((q = (te = J.parent) == null ? void 0 : te.activatedOn) == null ? void 0 : q.value.skipped) || (ae == null ? void 0 : ae(I, k, {
                location: y,
                rawLocation: T,
                resolve: A,
                rawNode: _
              }))) ?? !1
            };
            J.activatedOn = (0, t.pushStack)(J.activatedOn, ve);
            let he = J.parent;
            for (; he; )
              he.activatedOn.value.nextLevelTypeActivated = (0, t.pushStack)(he.activatedOn.value.nextLevelTypeActivated, x), he = he.parent;
            ve.skipped || (F = !0, Y.add(J), Q(X, I, _, J, U, W));
          }
        }
        if (F || !H) {
          if (v[x.name] = v[x.name] || /* @__PURE__ */ new Set(), v[x.name].add(I), Array.isArray(I)) {
            const J = x.items;
            if (J !== void 0) {
              const X = typeof J == "function";
              for (let ae = 0; ae < I.length; ae++) {
                const U = X ? J(I[ae], B.child([ae]).absolutePointer) : J;
                (0, n.isNamedType)(U) && S(I[ae], U, B.child([ae]), I, ae);
              }
            }
          } else if (typeof I == "object" && I !== null) {
            const J = Object.keys(x.properties);
            x.additionalProperties ? J.push(...Object.keys(I).filter((X) => !J.includes(X))) : x.extensionsPrefix && J.push(...Object.keys(I).filter((X) => X.startsWith(x.extensionsPrefix))), (0, e.isRef)(_) && J.push(...Object.keys(_).filter((X) => X !== "$ref" && !J.includes(X)));
            for (const X of J) {
              let ae = I[X], U = B;
              ae === void 0 && (ae = _[X], U = y);
              let W = x.properties[X];
              W === void 0 && (W = x.additionalProperties), typeof W == "function" && (W = W(ae, X)), W === void 0 && x.extensionsPrefix && X.startsWith(x.extensionsPrefix) && (W = n.SpecExtension), !(0, n.isNamedType)(W) && (W != null && W.directResolveAs) && (W = W.directResolveAs, ae = { $ref: ae }), W && W.name === void 0 && W.resolvable !== !1 && (W = { name: "scalar", properties: {} }), !(!(0, n.isNamedType)(W) || W.name === "scalar" && !(0, e.isRef)(ae)) && S(ae, W, U.child([X]), I, X);
            }
          }
        }
        const C = f.any.leave, N = (((j = f[x.name]) == null ? void 0 : j.leave) || []).concat(C);
        for (const J of Ae.reverse())
          if (J.isSkippedLevel)
            J.seen.delete(I);
          else if (J.activatedOn = (0, t.popStack)(J.activatedOn), J.parent) {
            let X = J.parent;
            for (; X; )
              X.activatedOn.value.nextLevelTypeActivated = (0, t.popStack)(X.activatedOn.value.nextLevelTypeActivated), X = X.parent;
          }
        for (const { context: J, visit: X, ruleId: ae, severity: U } of N)
          !J.isSkippedLevel && Y.has(J) && Q(X, I, _, J, ae, U);
      }
      if (R = y, (0, e.isRef)(_)) {
        const H = f.ref.leave;
        for (const { visit: F, ruleId: ue, severity: ge, context: Ae } of H)
          if (Y.has(Ae)) {
            const C = re.bind(void 0, ue, ge);
            F(_, {
              report: C,
              resolve: A,
              rawNode: _,
              rawLocation: T,
              location: y,
              type: x,
              parent: w,
              key: k,
              parentLocations: {},
              oasVersion: m.oasVersion,
              getVisitorData: oe.bind(void 0, ue)
            }, { node: I, location: B, error: L });
          }
      }
      function Q(H, F, ue, ge, Ae, C) {
        const N = re.bind(void 0, Ae, C);
        H(F, {
          report: N,
          resolve: A,
          rawNode: ue,
          location: R,
          rawLocation: T,
          type: x,
          parent: w,
          key: k,
          parentLocations: s(ge),
          oasVersion: m.oasVersion,
          ignoreNextVisitorsOnNode: () => {
            g.add(`${R.absolutePointer}${R.pointer}`);
          },
          getVisitorData: oe.bind(void 0, Ae)
        }, i(ge), ge);
      }
      function re(H, F, ue) {
        const Ae = (ue.location ? Array.isArray(ue.location) ? ue.location : [ue.location] : [{ ...R, reportOnKey: !1 }]).map((N) => ({
          ...R,
          reportOnKey: !1,
          ...N
        })), C = ue.forceSeverity || F;
        C !== "off" && m.problems.push({
          ruleId: ue.ruleId || H,
          severity: C,
          ...ue,
          suggest: ue.suggest || [],
          location: Ae
        });
      }
      function oe(H) {
        return m.visitorsData[H] = m.visitorsData[H] || {}, m.visitorsData[H];
      }
    }
  }
  return rd;
}
var vi = {}, zu = {}, Mk;
function wW() {
  if (Mk) return zu;
  Mk = 1, Object.defineProperty(zu, "__esModule", { value: !0 }), zu.Oas2Types = void 0;
  const e = ai(), t = /^[0-9][0-9Xx]{2}$/, r = {
    properties: {
      swagger: { type: "string" },
      info: "Info",
      host: { type: "string" },
      basePath: { type: "string" },
      schemes: { type: "array", items: { type: "string" } },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      paths: "Paths",
      definitions: "NamedSchemas",
      parameters: "NamedParameters",
      responses: "NamedResponses",
      securityDefinitions: "NamedSecuritySchemes",
      security: "SecurityRequirementList",
      tags: "TagList",
      externalDocs: "ExternalDocs",
      "x-servers": "XServerList",
      "x-tagGroups": "TagGroups",
      "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
    },
    required: ["swagger", "paths", "info"],
    extensionsPrefix: "x-"
  }, n = {
    properties: {
      title: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      version: { type: "string" },
      "x-logo": "Logo"
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, i = {
    properties: {
      url: { type: "string" },
      altText: { type: "string" },
      backgroundColor: { type: "string" },
      href: { type: "string" }
    },
    extensionsPrefix: "x-"
  }, s = {
    properties: {
      name: { type: "string" },
      url: { type: "string" },
      email: { type: "string" }
    },
    extensionsPrefix: "x-"
  }, o = {
    properties: {
      name: { type: "string" },
      url: { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  }, a = {
    properties: {},
    additionalProperties: (Q, re) => re.startsWith("/") ? "PathItem" : void 0
  }, l = {
    properties: {
      $ref: { type: "string" },
      // TODO: verify special $ref handling for Path Item
      parameters: "ParameterList",
      get: "Operation",
      put: "Operation",
      post: "Operation",
      delete: "Operation",
      options: "Operation",
      head: "Operation",
      patch: "Operation"
    },
    extensionsPrefix: "x-"
  }, p = {
    properties: {
      tags: { type: "array", items: { type: "string" } },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      parameters: "ParameterList",
      responses: "Responses",
      schemes: { type: "array", items: { type: "string" } },
      deprecated: { type: "boolean" },
      security: "SecurityRequirementList",
      "x-codeSamples": "XCodeSampleList",
      "x-code-samples": "XCodeSampleList",
      // deprecated
      "x-hideTryItPanel": { type: "boolean" }
    },
    required: ["responses"],
    extensionsPrefix: "x-"
  }, f = {
    properties: {
      lang: { type: "string" },
      label: { type: "string" },
      source: { type: "string" }
    }
  }, d = {
    properties: {
      url: { type: "string" },
      description: { type: "string" }
    },
    required: ["url"]
  }, m = {
    properties: {
      description: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    extensionsPrefix: "x-"
  }, v = {
    properties: {
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "path", "formData", "body"] },
      description: { type: "string" },
      required: { type: "boolean" },
      schema: "Schema",
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array", "file"] },
      format: { type: "string" },
      allowEmptyValue: { type: "boolean" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" },
      "x-example": "Example",
      "x-examples": "ExamplesMap"
    },
    required(Q) {
      return !Q || !Q.in ? ["name", "in"] : Q.in === "body" ? ["name", "in", "schema"] : Q.type === "array" ? ["name", "in", "type", "items"] : ["name", "in", "type"];
    },
    extensionsPrefix: "x-"
  }, g = {
    properties: {
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(Q) {
      return Q && Q.type === "array" ? ["type", "items"] : ["type"];
    },
    extensionsPrefix: "x-"
  }, S = {
    properties: {
      default: "Response"
    },
    additionalProperties: (Q, re) => t.test(re) ? "Response" : void 0
  }, _ = {
    properties: {
      description: { type: "string" },
      schema: "Schema",
      headers: (0, e.mapOf)("Header"),
      examples: "Examples",
      "x-summary": { type: "string" }
    },
    required: ["description"],
    extensionsPrefix: "x-"
  }, x = {
    properties: {},
    additionalProperties: { isExample: !0 }
  }, y = {
    properties: {
      description: { type: "string" },
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(Q) {
      return Q && Q.type === "array" ? ["type", "items"] : ["type"];
    },
    extensionsPrefix: "x-"
  }, w = {
    properties: {
      name: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      "x-traitTag": { type: "boolean" },
      "x-displayName": { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  }, k = {
    properties: {
      name: { type: "string" },
      tags: { type: "array", items: { type: "string" } }
    }
  }, A = {
    properties: {
      format: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: null,
      multipleOf: { type: "number" },
      maximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMaximum: { type: "boolean" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "number" },
      minLength: { type: "number" },
      pattern: { type: "string" },
      maxItems: { type: "number" },
      minItems: { type: "number" },
      uniqueItems: { type: "boolean" },
      maxProperties: { type: "number" },
      minProperties: { type: "number" },
      required: { type: "array", items: { type: "string" } },
      enum: { type: "array" },
      type: {
        type: "string",
        enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
      },
      items: (Q) => Array.isArray(Q) ? (0, e.listOf)("Schema") : "Schema",
      allOf: (0, e.listOf)("Schema"),
      properties: "SchemaProperties",
      additionalProperties: (Q) => typeof Q == "boolean" ? { type: "boolean" } : "Schema",
      discriminator: { type: "string" },
      readOnly: { type: "boolean" },
      xml: "Xml",
      externalDocs: "ExternalDocs",
      example: { isExample: !0 },
      "x-tags": { type: "array", items: { type: "string" } },
      "x-nullable": { type: "boolean" },
      "x-extendedDiscriminator": { type: "string" },
      "x-additionalPropertiesName": { type: "string" },
      "x-explicitMappingOnly": { type: "boolean" },
      "x-enumDescriptions": "EnumDescriptions"
    },
    extensionsPrefix: "x-"
  }, T = {
    properties: {},
    additionalProperties: { type: "string" }
  }, R = {
    properties: {},
    additionalProperties: "Schema"
  }, I = {
    properties: {
      name: { type: "string" },
      namespace: { type: "string" },
      prefix: { type: "string" },
      attribute: { type: "boolean" },
      wrapped: { type: "boolean" }
    },
    extensionsPrefix: "x-"
  }, B = {
    properties: {
      type: { enum: ["basic", "apiKey", "oauth2"] },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header"] },
      flow: { enum: ["implicit", "password", "application", "accessCode"] },
      authorizationUrl: { type: "string" },
      tokenUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      "x-defaultClientId": { type: "string" }
    },
    required(Q) {
      switch (Q == null ? void 0 : Q.type) {
        case "apiKey":
          return ["type", "name", "in"];
        case "oauth2":
          switch (Q == null ? void 0 : Q.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "scopes"];
            default:
              return ["type", "flow", "scopes"];
          }
        default:
          return ["type"];
      }
    },
    allowed(Q) {
      switch (Q == null ? void 0 : Q.type) {
        case "basic":
          return ["type", "description"];
        case "apiKey":
          return ["type", "name", "in", "description"];
        case "oauth2":
          switch (Q == null ? void 0 : Q.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "description", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "description", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "description", "scopes"];
            default:
              return ["type", "flow", "tokenUrl", "authorizationUrl", "description", "scopes"];
          }
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  }, L = {
    properties: {},
    additionalProperties: { type: "array", items: { type: "string" } }
  }, Y = {
    properties: {
      value: { isExample: !0 },
      summary: { type: "string" },
      description: { type: "string" },
      externalValue: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  return zu.Oas2Types = {
    Root: r,
    Tag: w,
    TagList: (0, e.listOf)("Tag"),
    TagGroups: (0, e.listOf)("TagGroup"),
    TagGroup: k,
    ExternalDocs: m,
    Example: Y,
    ExamplesMap: (0, e.mapOf)("Example"),
    EnumDescriptions: T,
    SecurityRequirement: L,
    SecurityRequirementList: (0, e.listOf)("SecurityRequirement"),
    Info: n,
    Contact: s,
    License: o,
    Logo: i,
    Paths: a,
    PathItem: l,
    Parameter: v,
    ParameterItems: g,
    ParameterList: (0, e.listOf)("Parameter"),
    Operation: p,
    Examples: x,
    Header: y,
    Responses: S,
    Response: _,
    Schema: A,
    Xml: I,
    SchemaProperties: R,
    NamedSchemas: (0, e.mapOf)("Schema"),
    NamedResponses: (0, e.mapOf)("Response"),
    NamedParameters: (0, e.mapOf)("Parameter"),
    NamedSecuritySchemes: (0, e.mapOf)("SecurityScheme"),
    SecurityScheme: B,
    XCodeSample: f,
    XCodeSampleList: (0, e.listOf)("XCodeSample"),
    XServerList: (0, e.listOf)("XServer"),
    XServer: d
  }, zu;
}
var Nv = {}, Dk;
function kS() {
  return Dk || (Dk = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Oas3Types = e.Discriminator = e.DiscriminatorMapping = e.Xml = e.ExternalDocs = void 0;
    const t = ai(), r = Gl(), n = /^[0-9][0-9Xx]{2}$/, i = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        components: "Components",
        "x-webhooks": "WebhooksMap",
        "x-tagGroups": "TagGroups",
        "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
      },
      required: ["openapi", "paths", "info"],
      extensionsPrefix: "x-"
    }, s = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        "x-traitTag": { type: "boolean" },
        "x-displayName": { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, o = {
      properties: {
        name: { type: "string" },
        tags: { type: "array", items: { type: "string" } }
      },
      extensionsPrefix: "x-"
    };
    e.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"],
      extensionsPrefix: "x-"
    };
    const a = {
      properties: {
        url: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap"
      },
      required: ["url"],
      extensionsPrefix: "x-"
    }, l = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" }
      },
      required: ["default"],
      extensionsPrefix: "x-"
    }, p = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, f = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    }, d = {
      properties: {
        url: { type: "string" },
        altText: { type: "string" },
        backgroundColor: { type: "string" },
        href: { type: "string" }
      }
    }, m = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, v = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, g = {
      properties: {},
      additionalProperties: (j, H) => H.startsWith("/") ? "PathItem" : void 0
    }, S = {
      properties: {},
      additionalProperties: () => "PathItem"
    }, _ = {
      properties: {
        $ref: { type: "string" },
        // TODO: verify special $ref handling for Path Item
        servers: "ServerList",
        parameters: "ParameterList",
        summary: { type: "string" },
        description: { type: "string" },
        get: "Operation",
        put: "Operation",
        post: "Operation",
        delete: "Operation",
        options: "Operation",
        head: "Operation",
        patch: "Operation",
        trace: "Operation"
      },
      extensionsPrefix: "x-"
    }, x = {
      properties: {
        name: { type: "string" },
        in: { enum: ["query", "header", "path", "cookie"] },
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      required: ["name", "in"],
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    }, y = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      required: ["responses"],
      extensionsPrefix: "x-"
    }, w = {
      properties: {
        lang: { type: "string" },
        label: { type: "string" },
        source: { type: "string" }
      }
    }, k = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        content: "MediaTypesMap"
      },
      required: ["content"],
      extensionsPrefix: "x-"
    }, A = {
      properties: {},
      additionalProperties: "MediaType"
    }, T = {
      properties: {
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        encoding: "EncodingMap"
      },
      extensionsPrefix: "x-"
    }, R = {
      properties: {
        value: { isExample: !0 },
        summary: { type: "string" },
        description: { type: "string" },
        externalValue: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, I = {
      properties: {
        contentType: { type: "string" },
        headers: "HeadersMap",
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    }, B = {
      properties: {},
      additionalProperties: { type: "string" }
    }, L = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    }, Y = {
      properties: { default: "Response" },
      additionalProperties: (j, H) => n.test(H) ? "Response" : void 0
    }, Q = {
      properties: {
        description: { type: "string" },
        headers: "HeadersMap",
        content: "MediaTypesMap",
        links: "LinksMap",
        "x-summary": { type: "string" }
      },
      required: ["description"],
      extensionsPrefix: "x-"
    }, re = {
      properties: {
        operationRef: { type: "string" },
        operationId: { type: "string" },
        parameters: null,
        // TODO: figure out how to describe/validate this
        requestBody: null,
        // TODO: figure out how to describe/validate this
        description: { type: "string" },
        server: "Server"
      },
      extensionsPrefix: "x-"
    }, oe = {
      properties: {
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "boolean" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: {
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        properties: "SchemaProperties",
        items: (j) => Array.isArray(j) ? (0, t.listOf)("Schema") : "Schema",
        additionalProperties: (j) => typeof j == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        default: null,
        nullable: { type: "boolean" },
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        "x-tags": { type: "array", items: { type: "string" } },
        "x-additionalPropertiesName": { type: "string" },
        "x-explicitMappingOnly": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    e.Xml = {
      properties: {
        name: { type: "string" },
        namespace: { type: "string" },
        prefix: { type: "string" },
        attribute: { type: "boolean" },
        wrapped: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    const ce = {
      properties: {},
      additionalProperties: "Schema"
    };
    e.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (j) => (0, r.isMappingRef)(j) ? { type: "string", directResolveAs: "Schema" } : { type: "string" }
    }, e.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"],
      extensionsPrefix: "x-"
    };
    const pe = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks"
      },
      extensionsPrefix: "x-"
    }, fe = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"],
      extensionsPrefix: "x-"
    }, G = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, Z = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, K = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" },
        "x-usePkce": (j) => typeof j == "boolean" ? { type: "boolean" } : "XUsePkce"
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, z = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      },
      extensionsPrefix: "x-"
    }, te = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" },
        "x-defaultClientId": { type: "string" }
      },
      required(j) {
        switch (j == null ? void 0 : j.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(j) {
        switch (j == null ? void 0 : j.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    }, q = {
      properties: {
        disableManualConfiguration: { type: "boolean" },
        hideClientSecretInput: { type: "boolean" }
      }
    };
    e.Oas3Types = {
      Root: i,
      Tag: s,
      TagList: (0, t.listOf)("Tag"),
      TagGroups: (0, t.listOf)("TagGroup"),
      TagGroup: o,
      ExternalDocs: e.ExternalDocs,
      Server: a,
      ServerList: (0, t.listOf)("Server"),
      ServerVariable: l,
      ServerVariablesMap: (0, t.mapOf)("ServerVariable"),
      SecurityRequirement: p,
      SecurityRequirementList: (0, t.listOf)("SecurityRequirement"),
      Info: f,
      Contact: m,
      License: v,
      Paths: g,
      PathItem: _,
      Parameter: x,
      ParameterList: (0, t.listOf)("Parameter"),
      Operation: y,
      Callback: (0, t.mapOf)("PathItem"),
      CallbacksMap: (0, t.mapOf)("Callback"),
      RequestBody: k,
      MediaTypesMap: A,
      MediaType: T,
      Example: R,
      ExamplesMap: (0, t.mapOf)("Example"),
      Encoding: I,
      EncodingMap: (0, t.mapOf)("Encoding"),
      EnumDescriptions: B,
      Header: L,
      HeadersMap: (0, t.mapOf)("Header"),
      Responses: Y,
      Response: Q,
      Link: re,
      Logo: d,
      Schema: oe,
      Xml: e.Xml,
      SchemaProperties: ce,
      DiscriminatorMapping: e.DiscriminatorMapping,
      Discriminator: e.Discriminator,
      Components: pe,
      LinksMap: (0, t.mapOf)("Link"),
      NamedSchemas: (0, t.mapOf)("Schema"),
      NamedResponses: (0, t.mapOf)("Response"),
      NamedParameters: (0, t.mapOf)("Parameter"),
      NamedExamples: (0, t.mapOf)("Example"),
      NamedRequestBodies: (0, t.mapOf)("RequestBody"),
      NamedHeaders: (0, t.mapOf)("Header"),
      NamedSecuritySchemes: (0, t.mapOf)("SecurityScheme"),
      NamedLinks: (0, t.mapOf)("Link"),
      NamedCallbacks: (0, t.mapOf)("Callback"),
      ImplicitFlow: fe,
      PasswordFlow: G,
      ClientCredentials: Z,
      AuthorizationCode: K,
      OAuth2Flows: z,
      SecurityScheme: te,
      XCodeSample: w,
      XCodeSampleList: (0, t.listOf)("XCodeSample"),
      XUsePkce: q,
      WebhooksMap: S
    };
  }(Nv)), Nv;
}
var Lv = {}, Fk;
function rN() {
  return Fk || (Fk = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Oas3_1Types = e.DependentRequired = e.SchemaProperties = e.Schema = void 0;
    const t = ai(), r = kS(), n = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        webhooks: "WebhooksMap",
        components: "Components",
        jsonSchemaDialect: { type: "string" }
      },
      required: ["openapi", "info"],
      requiredOneOf: ["paths", "components", "webhooks"],
      extensionsPrefix: "x-"
    }, i = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        identifier: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, s = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        summary: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    }, o = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks",
        pathItems: "NamedPathItems"
      },
      extensionsPrefix: "x-"
    }, a = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    e.Schema = {
      properties: {
        $id: { type: "string" },
        $anchor: { type: "string" },
        id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        $defs: "NamedSchemas",
        $vocabulary: { type: "string" },
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (p) => Array.isArray(p) ? {
          type: "array",
          items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
        } : {
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        dependentSchemas: (0, t.mapOf)("Schema"),
        dependentRequired: "DependentRequired",
        prefixItems: (0, t.listOf)("Schema"),
        contains: "Schema",
        minContains: { type: "integer", minimum: 0 },
        maxContains: { type: "integer", minimum: 0 },
        patternProperties: "PatternProperties",
        propertyNames: "Schema",
        unevaluatedItems: (p) => typeof p == "boolean" ? { type: "boolean" } : "Schema",
        unevaluatedProperties: (p) => typeof p == "boolean" ? { type: "boolean" } : "Schema",
        summary: { type: "string" },
        properties: "SchemaProperties",
        items: (p) => typeof p == "boolean" ? { type: "boolean" } : "Schema",
        additionalProperties: (p) => typeof p == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        contentSchema: "Schema",
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        examples: { type: "array" },
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        "x-tags": { type: "array", items: { type: "string" } }
      },
      extensionsPrefix: "x-"
    }, e.SchemaProperties = {
      properties: {},
      additionalProperties: (p) => typeof p == "boolean" ? { type: "boolean" } : "Schema"
    };
    const l = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect", "mutualTLS"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" }
      },
      required(p) {
        switch (p == null ? void 0 : p.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(p) {
        switch (p == null ? void 0 : p.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            switch (p == null ? void 0 : p.flows) {
              case "implicit":
                return ["type", "flows", "authorizationUrl", "refreshUrl", "description", "scopes"];
              case "password":
              case "clientCredentials":
                return ["type", "flows", "tokenUrl", "refreshUrl", "description", "scopes"];
              case "authorizationCode":
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
              default:
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
            }
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          case "mutualTLS":
            return ["type", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    e.DependentRequired = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, e.Oas3_1Types = {
      ...r.Oas3Types,
      Info: s,
      Root: n,
      Schema: e.Schema,
      SchemaProperties: e.SchemaProperties,
      PatternProperties: e.SchemaProperties,
      License: i,
      Components: o,
      NamedPathItems: (0, t.mapOf)("PathItem"),
      SecurityScheme: l,
      Operation: a,
      DependentRequired: e.DependentRequired
    };
  }(Lv)), Lv;
}
var Mv = {}, zk;
function nN() {
  return zk || (zk = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AsyncApi2Types = e.AsyncApi2Bindings = e.Dependencies = e.SecuritySchemeFlows = e.Discriminator = e.DiscriminatorMapping = e.SchemaProperties = e.Schema = e.MessageExample = e.CorrelationId = e.License = e.Contact = e.ServerVariable = e.ServerMap = e.ExternalDocs = e.Tag = void 0;
    const t = ai(), r = Gl(), n = {
      properties: {
        asyncapi: null,
        // TODO: validate semver format and supported version
        info: "Info",
        id: { type: "string" },
        servers: "ServerMap",
        channels: "ChannelMap",
        components: "Components",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        defaultContentType: { type: "string" }
      },
      required: ["asyncapi", "channels", "info"]
    }, i = {
      properties: {
        description: { type: "string" },
        subscribe: "Operation",
        publish: "Operation",
        parameters: "ParametersMap",
        bindings: "ChannelBindings",
        servers: { type: "array", items: { type: "string" } }
      }
    }, s = {
      properties: {},
      additionalProperties: "Channel"
    }, o = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    };
    e.Tag = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs"
      },
      required: ["name"]
    }, e.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"]
    };
    const a = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, l = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, p = {
      properties: {
        url: { type: "string" },
        protocol: { type: "string" },
        protocolVersion: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap",
        security: "SecurityRequirementList",
        bindings: "ServerBindings",
        tags: "TagList"
      },
      required: ["url", "protocol"]
    };
    e.ServerMap = {
      properties: {},
      additionalProperties: (gt, Jt) => (
        // eslint-disable-next-line no-useless-escape
        Jt.match(/^[A-Za-z0-9_\-]+$/) ? "Server" : void 0
      )
    }, e.ServerVariable = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" },
        examples: {
          type: "array",
          items: { type: "string" }
        }
      },
      required: []
    };
    const f = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License"
      },
      required: ["title", "version"]
    };
    e.Contact = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      }
    }, e.License = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"]
    };
    const d = {
      properties: {
        description: { type: "string" },
        schema: "Schema",
        location: { type: "string" }
      }
    };
    e.CorrelationId = {
      properties: {
        description: { type: "string" },
        location: { type: "string" }
      },
      required: ["location"]
    };
    const m = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        payload: "Schema",
        // TODO: strictly this does not cover all cases
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        // TODO: support official list of schema formats and custom values
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList",
        traits: "MessageTraitList"
      },
      additionalProperties: {}
    }, v = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, g = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, S = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings"
      },
      required: []
    }, _ = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList"
      },
      additionalProperties: {}
    }, x = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings",
        traits: "OperationTraitList",
        message: "Message"
      },
      required: []
    };
    e.MessageExample = {
      properties: {
        payload: { isExample: !0 },
        summary: { type: "string" },
        name: { type: "string" },
        headers: { type: "object" }
      }
    }, e.Schema = {
      properties: {
        $id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        myArbitraryKeyword: { type: "boolean" },
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (gt) => Array.isArray(gt) ? {
          type: "array",
          items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
        } : {
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        contains: "Schema",
        patternProperties: { type: "object" },
        propertyNames: "Schema",
        properties: "SchemaProperties",
        items: (gt) => Array.isArray(gt) ? (0, t.listOf)("Schema") : "Schema",
        additionalProperties: (gt) => typeof gt == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        examples: { type: "array" },
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        additionalItems: (gt) => typeof gt == "boolean" ? { type: "boolean" } : "Schema",
        dependencies: "Dependencies"
      }
    }, e.SchemaProperties = {
      properties: {},
      additionalProperties: (gt) => typeof gt == "boolean" ? { type: "boolean" } : "Schema"
    }, e.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (gt) => (0, r.isMappingRef)(gt) ? { type: "string", directResolveAs: "Schema" } : { type: "string" }
    }, e.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"]
    };
    const y = {
      properties: {
        messages: "NamedMessages",
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        correlationIds: "NamedCorrelationIds",
        messageTraits: "NamedMessageTraits",
        operationTraits: "NamedOperationTraits",
        securitySchemes: "NamedSecuritySchemes",
        servers: "ServerMap",
        serverVariables: "ServerVariablesMap",
        channels: "ChannelMap",
        serverBindings: "ServerBindings",
        channelBindings: "ChannelBindings",
        operationBindings: "OperationBindings",
        messageBindings: "MessageBindings"
      }
    }, w = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"]
    }, k = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    }, A = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    }, T = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"]
    };
    e.SecuritySchemeFlows = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      }
    };
    const R = {
      properties: {
        type: {
          enum: [
            "userPassword",
            "apiKey",
            "X509",
            "symmetricEncryption",
            "asymmetricEncryption",
            "httpApiKey",
            "http",
            "oauth2",
            "openIdConnect",
            "plain",
            "scramSha256",
            "scramSha512",
            "gssapi"
          ]
        },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "SecuritySchemeFlows",
        openIdConnectUrl: { type: "string" }
      },
      required(gt) {
        switch (gt == null ? void 0 : gt.type) {
          case "apiKey":
            return ["type", "in"];
          case "httpApiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(gt) {
        switch (gt == null ? void 0 : gt.type) {
          case "apiKey":
            return ["type", "in", "description"];
          case "httpApiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    e.Dependencies = {
      properties: {},
      additionalProperties: (gt) => Array.isArray(gt) ? { type: "array", items: { type: "string" } } : "Schema"
    };
    const I = {
      properties: {}
      // empty object
    };
    o.properties.http = I;
    const B = {
      properties: {}
      // empty object
    };
    l.properties.http = B;
    const L = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    v.properties.http = L;
    const Y = {
      properties: {
        type: { type: "string" },
        method: {
          type: "string",
          enum: ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS", "CONNECT", "TRACE"]
        },
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    g.properties.http = Y;
    const Q = {
      properties: {
        method: { type: "string" },
        query: "Schema",
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    o.properties.ws = Q;
    const re = {
      properties: {}
      // empty object
    };
    l.properties.ws = re;
    const oe = {
      properties: {}
      // empty object
    };
    v.properties.ws = oe;
    const ce = {
      properties: {}
      // empty object
    };
    g.properties.ws = ce;
    const pe = {
      properties: {
        "cleanup.policy": { type: "array", items: { enum: ["delete", "compact"] } },
        "retention.ms": { type: "integer" },
        "retention.bytes": { type: "integer" },
        "delete.retention.ms": { type: "integer" },
        "max.message.bytes": { type: "integer" }
      }
    }, fe = {
      properties: {
        topic: { type: "string" },
        partitions: { type: "integer" },
        replicas: { type: "integer" },
        topicConfiguration: "KafkaTopicConfiguration",
        bindingVersion: { type: "string" }
      }
    };
    o.properties.kafka = fe;
    const G = {
      properties: {}
      // empty object
    };
    l.properties.kafka = G;
    const Z = {
      properties: {
        key: "Schema",
        // TODO: add avro support
        schemaIdLocation: { type: "string" },
        schemaIdPayloadEncoding: { type: "string" },
        schemaLookupStrategy: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    v.properties.kafka = Z;
    const K = {
      properties: {
        groupId: "Schema",
        clientId: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    g.properties.kafka = K;
    const z = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    o.properties.anypointmq = z;
    const te = {
      properties: {}
      // empty object
    };
    l.properties.anypointmq = te;
    const q = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    v.properties.anypointmq = q;
    const j = {
      properties: {}
      // empty object
    };
    g.properties.anypointmq = j;
    const H = {
      properties: {}
      // empty object
    };
    o.properties.amqp = H;
    const F = {
      properties: {}
      // empty object
    };
    l.properties.amqp = F;
    const ue = {
      properties: {
        contentEncoding: { type: "string" },
        messageType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    v.properties.amqp = ue;
    const ge = {
      // TODO: some fields are subscribe only
      properties: {
        expiration: { type: "integer" },
        userId: { type: "string" },
        cc: { type: "array", items: { type: "string" } },
        priority: { type: "integer" },
        deliveryMode: { type: "integer" },
        // TODO: enum: [1, 2]
        mandatory: { type: "boolean" },
        bcc: { type: "array", items: { type: "string" } },
        replyTo: { type: "string" },
        timestamp: { type: "boolean" },
        ack: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    g.properties.amqp = ge;
    const Ae = {
      properties: {}
      // empty object
    };
    o.properties.amqp1 = Ae;
    const C = {
      properties: {}
      // empty object
    };
    l.properties.amqp1 = C;
    const N = {
      properties: {}
      // empty object
    };
    v.properties.amqp1 = N;
    const J = {
      properties: {}
      // empty object
    };
    g.properties.amqp1 = J;
    const X = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    o.properties.mqtt = X;
    const ae = {
      properties: {
        topic: { type: "string" },
        qos: { type: "integer" },
        message: { type: "string" },
        retain: { type: "boolean" }
      }
    }, U = {
      properties: {
        clientId: { type: "string" },
        cleanSession: { type: "boolean" },
        lastWill: "MqttServerBindingLastWill",
        keepAlive: { type: "integer" },
        bindingVersion: { type: "string" }
      }
    };
    l.properties.mqtt = U;
    const W = {
      properties: {
        bindingVersion: { type: "string" }
      }
    };
    v.properties.mqtt = W;
    const ve = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    g.properties.mqtt = ve;
    const he = {
      properties: {}
      // empty object
    };
    o.properties.mqtt5 = he;
    const Te = {
      properties: {}
      // empty object
    };
    l.properties.mqtt5 = Te;
    const Se = {
      properties: {}
      // empty object
    };
    v.properties.mqtt5 = Se;
    const O = {
      properties: {}
      // empty object
    };
    g.properties.mqtt5 = O;
    const M = {
      properties: {}
      // empty object
    };
    o.properties.nats = M;
    const le = {
      properties: {}
      // empty object
    };
    l.properties.nats = le;
    const ye = {
      properties: {}
      // empty object
    };
    v.properties.nats = ye;
    const be = {
      properties: {
        queue: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    g.properties.nats = be;
    const Pe = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    o.properties.jms = Pe;
    const ke = {
      properties: {}
      // empty object
    };
    l.properties.jms = ke;
    const Me = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    v.properties.jms = Me;
    const We = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    g.properties.jms = We;
    const Xe = {
      properties: {}
      // empty object
    };
    o.properties.solace = Xe;
    const Ge = {
      properties: {
        bindingVersion: { type: "string" },
        msgVpn: { type: "string" }
      }
    };
    l.properties.solace = Ge;
    const Ue = {
      properties: {}
      // empty object
    };
    v.properties.solace = Ue;
    const Et = {
      properties: {
        destinationType: { type: "string", enum: ["queue", "topic"] },
        deliveryMode: { type: "string", enum: ["direct", "persistent"] },
        "queue.name": { type: "string" },
        "queue.topicSubscriptions": { type: "array", items: { type: "string" } },
        "queue.accessType": { type: "string", enum: ["exclusive", "nonexclusive"] },
        "queue.maxMsgSpoolSize": { type: "string" },
        "queue.maxTtl": { type: "string" },
        "topic.topicSubscriptions": { type: "array", items: { type: "string" } }
      }
    }, D = {
      properties: {
        bindingVersion: { type: "string" },
        destinations: (0, t.listOf)("SolaceDestination")
      }
    };
    g.properties.solace = D;
    const we = {
      properties: {}
      // empty object
    };
    o.properties.stomp = we;
    const Oe = {
      properties: {}
      // empty object
    };
    l.properties.stomp = Oe;
    const Ee = {
      properties: {}
      // empty object
    };
    v.properties.stomp = Ee;
    const Ce = {
      properties: {}
      // empty object
    };
    g.properties.stomp = Ce;
    const $e = {
      properties: {}
      // empty object
    };
    o.properties.redis = $e;
    const Fe = {
      properties: {}
      // empty object
    };
    l.properties.redis = Fe;
    const xe = {
      properties: {}
      // empty object
    };
    v.properties.redis = xe;
    const Le = {
      properties: {}
      // empty object
    };
    g.properties.redis = Le;
    const Ye = {
      properties: {}
      // empty object
    };
    o.properties.mercure = Ye;
    const mt = {
      properties: {}
      // empty object
    };
    l.properties.mercure = mt;
    const rt = {
      properties: {}
      // empty object
    };
    v.properties.mercure = rt;
    const ut = {
      properties: {}
      // empty object
    };
    g.properties.mercure = ut, e.AsyncApi2Bindings = {
      HttpServerBinding: B,
      HttpChannelBinding: I,
      HttpMessageBinding: L,
      HttpOperationBinding: Y,
      WsServerBinding: re,
      WsChannelBinding: Q,
      WsMessageBinding: oe,
      WsOperationBinding: ce,
      KafkaServerBinding: G,
      KafkaTopicConfiguration: pe,
      KafkaChannelBinding: fe,
      KafkaMessageBinding: Z,
      KafkaOperationBinding: K,
      AnypointmqServerBinding: te,
      AnypointmqChannelBinding: z,
      AnypointmqMessageBinding: q,
      AnypointmqOperationBinding: j,
      AmqpServerBinding: F,
      AmqpChannelBinding: H,
      AmqpMessageBinding: ue,
      AmqpOperationBinding: ge,
      Amqp1ServerBinding: C,
      Amqp1ChannelBinding: Ae,
      Amqp1MessageBinding: N,
      Amqp1OperationBinding: J,
      MqttServerBindingLastWill: ae,
      MqttServerBinding: U,
      MqttChannelBinding: X,
      MqttMessageBinding: W,
      MqttOperationBinding: ve,
      Mqtt5ServerBinding: Te,
      Mqtt5ChannelBinding: he,
      Mqtt5MessageBinding: Se,
      Mqtt5OperationBinding: O,
      NatsServerBinding: le,
      NatsChannelBinding: M,
      NatsMessageBinding: ye,
      NatsOperationBinding: be,
      JmsServerBinding: ke,
      JmsChannelBinding: Pe,
      JmsMessageBinding: Me,
      JmsOperationBinding: We,
      SolaceServerBinding: Ge,
      SolaceChannelBinding: Xe,
      SolaceMessageBinding: Ue,
      SolaceDestination: Et,
      SolaceOperationBinding: D,
      StompServerBinding: Oe,
      StompChannelBinding: we,
      StompMessageBinding: Ee,
      StompOperationBinding: Ce,
      RedisServerBinding: Fe,
      RedisChannelBinding: $e,
      RedisMessageBinding: xe,
      RedisOperationBinding: Le,
      MercureServerBinding: mt,
      MercureChannelBinding: Ye,
      MercureMessageBinding: rt,
      MercureOperationBinding: ut,
      ServerBindings: l,
      ChannelBindings: o,
      MessageBindings: v,
      OperationBindings: g
    }, e.AsyncApi2Types = {
      ...e.AsyncApi2Bindings,
      Root: n,
      Tag: e.Tag,
      TagList: (0, t.listOf)("Tag"),
      ServerMap: e.ServerMap,
      ExternalDocs: e.ExternalDocs,
      Server: p,
      ServerVariable: e.ServerVariable,
      ServerVariablesMap: (0, t.mapOf)("ServerVariable"),
      SecurityRequirement: a,
      SecurityRequirementList: (0, t.listOf)("SecurityRequirement"),
      Info: f,
      Contact: e.Contact,
      License: e.License,
      ChannelMap: s,
      Channel: i,
      Parameter: d,
      ParametersMap: (0, t.mapOf)("Parameter"),
      Operation: x,
      Schema: e.Schema,
      MessageExample: e.MessageExample,
      SchemaProperties: e.SchemaProperties,
      DiscriminatorMapping: e.DiscriminatorMapping,
      Discriminator: e.Discriminator,
      Components: y,
      NamedSchemas: (0, t.mapOf)("Schema"),
      NamedMessages: (0, t.mapOf)("Message"),
      NamedMessageTraits: (0, t.mapOf)("MessageTrait"),
      NamedOperationTraits: (0, t.mapOf)("OperationTrait"),
      NamedParameters: (0, t.mapOf)("Parameter"),
      NamedSecuritySchemes: (0, t.mapOf)("SecurityScheme"),
      NamedCorrelationIds: (0, t.mapOf)("CorrelationId"),
      ImplicitFlow: w,
      PasswordFlow: k,
      ClientCredentials: A,
      AuthorizationCode: T,
      SecuritySchemeFlows: e.SecuritySchemeFlows,
      SecurityScheme: R,
      Message: m,
      MessageBindings: v,
      OperationBindings: g,
      OperationTrait: S,
      OperationTraitList: (0, t.listOf)("OperationTrait"),
      MessageTrait: _,
      MessageTraitList: (0, t.listOf)("MessageTrait"),
      MessageExampleList: (0, t.listOf)("MessageExample"),
      CorrelationId: e.CorrelationId,
      Dependencies: e.Dependencies
    };
  }(Mv)), Mv;
}
var qu = {}, qk;
function SW() {
  if (qk) return qu;
  qk = 1, Object.defineProperty(qu, "__esModule", { value: !0 }), qu.AsyncApi3Types = void 0;
  const e = ai(), t = nN(), r = {
    properties: {
      asyncapi: { type: "string", enum: ["3.0.0"] },
      info: "Info",
      id: { type: "string" },
      servers: "ServerMap",
      channels: "NamedChannels",
      components: "Components",
      operations: "NamedOperations",
      defaultContentType: { type: "string" }
    },
    required: ["asyncapi", "info"]
  }, n = {
    properties: {
      address: { type: "string" },
      messages: "NamedMessages",
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      servers: "ServerList",
      parameters: "ParametersMap",
      bindings: "ChannelBindings",
      tags: "TagList",
      externalDocs: "ExternalDocs"
    }
  }, i = {
    properties: {
      host: { type: "string" },
      pathname: { type: "string" },
      protocol: { type: "string" },
      protocolVersion: { type: "string" },
      description: { type: "string" },
      variables: "ServerVariablesMap",
      security: "SecuritySchemeList",
      bindings: "ServerBindings",
      externalDocs: "ExternalDocs",
      tags: "TagList"
    },
    required: ["host", "protocol"]
  }, s = {
    properties: {
      title: { type: "string" },
      version: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      tags: "TagList",
      externalDocs: "ExternalDocs"
    },
    required: ["title", "version"]
  }, o = {
    properties: {
      description: { type: "string" },
      enum: { type: "array", items: { type: "string" } },
      default: { type: "string" },
      examples: { type: "array", items: { type: "string" } },
      location: { type: "string" }
    }
  }, a = {
    properties: {
      headers: "Schema",
      payload: (w) => w && (w != null && w.schemaFormat) ? {
        properties: {
          schema: "Schema",
          schemaFormat: { type: "string" }
        },
        required: ["schema", "schemaFormat"]
      } : "Schema",
      correlationId: "CorrelationId",
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings",
      examples: "MessageExampleList",
      traits: "MessageTraitList"
    },
    additionalProperties: {}
  }, l = {
    properties: {
      tags: "TagList",
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      security: "SecuritySchemeList",
      bindings: "OperationBindings"
    },
    required: []
  }, p = {
    properties: {
      headers: (w) => typeof w == "function" || typeof w == "object" && w ? {
        properties: {
          schema: "Schema",
          schemaFormat: { type: "string" }
        }
      } : "Schema",
      correlationId: "CorrelationId",
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings",
      examples: "MessageExampleList"
    },
    additionalProperties: {}
  }, f = {
    properties: {
      action: { type: "string", enum: ["send", "receive"] },
      channel: "Channel",
      title: { type: "string" },
      tags: "TagList",
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      security: "SecuritySchemeList",
      bindings: "OperationBindings",
      traits: "OperationTraitList",
      messages: "MessageList",
      reply: "OperationReply"
    },
    required: ["action", "channel"]
  }, d = {
    properties: {
      channel: "Channel",
      messages: "MessageList",
      address: "OperationReplyAddress"
    }
  }, m = {
    properties: {
      location: { type: "string" },
      description: { type: "string" }
    },
    required: ["location"]
  }, v = {
    properties: {
      messages: "NamedMessages",
      parameters: "NamedParameters",
      schemas: "NamedSchemas",
      replies: "NamedOperationReplies",
      replyAddresses: "NamedOperationRelyAddresses",
      correlationIds: "NamedCorrelationIds",
      messageTraits: "NamedMessageTraits",
      operationTraits: "NamedOperationTraits",
      tags: "NamedTags",
      externalDocs: "NamedExternalDocs",
      securitySchemes: "NamedSecuritySchemes",
      servers: "ServerMap",
      serverVariables: "ServerVariablesMap",
      channels: "NamedChannels",
      operations: "NamedOperations",
      serverBindings: "ServerBindings",
      channelBindings: "ChannelBindings",
      operationBindings: "OperationBindings",
      messageBindings: "MessageBindings"
    }
  }, g = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      authorizationUrl: { type: "string" }
    },
    required: ["authorizationUrl", "availableScopes"]
  }, S = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "availableScopes"]
  }, _ = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "availableScopes"]
  }, x = {
    properties: {
      refreshUrl: { type: "string" },
      authorizationUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["authorizationUrl", "tokenUrl", "availableScopes"]
  }, y = {
    properties: {
      type: {
        enum: [
          "userPassword",
          "apiKey",
          "X509",
          "symmetricEncryption",
          "asymmetricEncryption",
          "httpApiKey",
          "http",
          "oauth2",
          "openIdConnect",
          "plain",
          "scramSha256",
          "scramSha512",
          "gssapi"
        ]
      },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
      scheme: { type: "string" },
      bearerFormat: { type: "string" },
      flows: "SecuritySchemeFlows",
      openIdConnectUrl: { type: "string" },
      scopes: { type: "array", items: { type: "string" } }
    },
    required(w) {
      switch (w == null ? void 0 : w.type) {
        case "apiKey":
          return ["type", "in"];
        case "httpApiKey":
          return ["type", "name", "in"];
        case "http":
          return ["type", "scheme"];
        case "oauth2":
          return ["type", "flows"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl"];
        default:
          return ["type"];
      }
    },
    allowed(w) {
      switch (w == null ? void 0 : w.type) {
        case "apiKey":
          return ["type", "in", "description"];
        case "httpApiKey":
          return ["type", "name", "in", "description"];
        case "http":
          return ["type", "scheme", "bearerFormat", "description"];
        case "oauth2":
          return ["type", "flows", "description", "scopes"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl", "description", "scopes"];
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  };
  return qu.AsyncApi3Types = {
    // from asyncapi2
    ...t.AsyncApi2Bindings,
    CorrelationId: t.CorrelationId,
    SecuritySchemeFlows: t.SecuritySchemeFlows,
    ServerVariable: t.ServerVariable,
    Contact: t.Contact,
    License: t.License,
    MessageExample: t.MessageExample,
    Tag: t.Tag,
    Dependencies: t.Dependencies,
    Schema: t.Schema,
    Discriminator: t.Discriminator,
    DiscriminatorMapping: t.DiscriminatorMapping,
    SchemaProperties: t.SchemaProperties,
    ServerMap: t.ServerMap,
    ExternalDocs: t.ExternalDocs,
    Root: r,
    Channel: n,
    Parameter: o,
    Info: s,
    Server: i,
    MessageTrait: p,
    Operation: f,
    OperationReply: d,
    OperationReplyAddress: m,
    Components: v,
    ImplicitFlow: g,
    PasswordFlow: S,
    ClientCredentials: _,
    AuthorizationCode: x,
    SecurityScheme: y,
    Message: a,
    OperationTrait: l,
    ServerVariablesMap: (0, e.mapOf)("ServerVariable"),
    NamedTags: (0, e.mapOf)("Tag"),
    NamedExternalDocs: (0, e.mapOf)("ExternalDocs"),
    NamedChannels: (0, e.mapOf)("Channel"),
    ParametersMap: (0, e.mapOf)("Parameter"),
    NamedOperations: (0, e.mapOf)("Operation"),
    NamedOperationReplies: (0, e.mapOf)("OperationReply"),
    NamedOperationRelyAddresses: (0, e.mapOf)("OperationReplyAddress"),
    NamedSchemas: (0, e.mapOf)("Schema"),
    NamedMessages: (0, e.mapOf)("Message"),
    NamedMessageTraits: (0, e.mapOf)("MessageTrait"),
    NamedOperationTraits: (0, e.mapOf)("OperationTrait"),
    NamedParameters: (0, e.mapOf)("Parameter"),
    NamedSecuritySchemes: (0, e.mapOf)("SecurityScheme"),
    NamedCorrelationIds: (0, e.mapOf)("CorrelationId"),
    ServerList: (0, e.listOf)("Server"),
    SecuritySchemeList: (0, e.listOf)("SecurityScheme"),
    MessageList: (0, e.listOf)("Message"),
    OperationTraitList: (0, e.listOf)("OperationTrait"),
    MessageTraitList: (0, e.listOf)("MessageTrait"),
    MessageExampleList: (0, e.listOf)("MessageExample"),
    TagList: (0, e.listOf)("Tag")
  }, qu;
}
var Bu = {}, Bk;
function xW() {
  if (Bk) return Bu;
  Bk = 1, Object.defineProperty(Bu, "__esModule", { value: !0 }), Bu.ArazzoTypes = void 0;
  const e = ai(), t = rN(), r = kS(), n = {
    properties: {
      arazzo: { type: "string" },
      info: "Info",
      sourceDescriptions: "SourceDescriptions",
      "x-parameters": "Parameters",
      workflows: "Workflows",
      components: "Components"
    },
    required: ["arazzo", "info", "sourceDescriptions", "workflows"],
    extensionsPrefix: "x-"
  }, i = {
    properties: {},
    additionalProperties: "Parameter"
  }, s = {
    properties: {},
    additionalProperties: "SuccessActionObject"
  }, o = {
    properties: {},
    additionalProperties: "FailureActionObject"
  }, a = {
    properties: {
      inputs: "NamedInputs",
      parameters: "NamedParameters",
      successActions: "NamedSuccessActions",
      failureActions: "NamedFailureActions"
    },
    extensionsPrefix: "x-"
  }, l = (0, e.mapOf)("Schema"), p = {
    properties: {
      title: { type: "string" },
      description: { type: "string" },
      summary: { type: "string" },
      version: { type: "string" }
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, f = {
    properties: {},
    items: (fe) => (fe == null ? void 0 : fe.type) === "openapi" ? "OpenAPISourceDescription" : (fe == null ? void 0 : fe.type) === "arazzo" ? "ArazzoSourceDescription" : "NoneSourceDescription"
  }, d = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["openapi"] },
      url: { type: "string" },
      "x-serverUrl": { type: "string" }
    },
    required: ["name", "type", "url"],
    extensionsPrefix: "x-"
  }, m = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["none"] },
      "x-serverUrl": { type: "string" }
    },
    required: ["name", "type", "x-serverUrl"],
    extensionsPrefix: "x-"
  }, v = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["arazzo"] },
      url: { type: "string" }
    },
    required: ["name", "type", "url"],
    extensionsPrefix: "x-"
  }, g = {
    properties: {
      reference: { type: "string" },
      value: {}
      // any
    },
    required: ["reference"],
    extensionsPrefix: "x-"
  }, S = {
    properties: {
      in: { type: "string", enum: ["header", "query", "path", "cookie", "body"] },
      name: { type: "string" },
      value: {}
      // any
    },
    required: ["name", "value"],
    extensionsPrefix: "x-"
  }, _ = {
    properties: {},
    items: (fe) => fe != null && fe.reference ? "ReusableObject" : "Parameter"
  }, x = {
    properties: {
      workflowId: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      parameters: "Parameters",
      dependsOn: { type: "array", items: { type: "string" } },
      inputs: "Schema",
      outputs: "Outputs",
      steps: "Steps",
      successActions: "OnSuccessActionList",
      failureActions: "OnFailureActionList"
    },
    required: ["workflowId", "steps"],
    extensionsPrefix: "x-"
  }, y = (0, e.listOf)("Workflow"), w = (0, e.listOf)("Step"), k = {
    properties: {
      stepId: { type: "string" },
      description: { type: "string" },
      operationId: { type: "string" },
      operationPath: { type: "string" },
      workflowId: { type: "string" },
      parameters: "Parameters",
      successCriteria: (0, e.listOf)("CriterionObject"),
      onSuccess: "OnSuccessActionList",
      onFailure: "OnFailureActionList",
      outputs: "Outputs",
      "x-inherit": { enum: ["auto", "none"] },
      "x-expect": "ExpectSchema",
      "x-assert": { type: "string" },
      "x-operation": "ExtendedOperation",
      requestBody: "RequestBody"
    },
    required: ["stepId"],
    requiredOneOf: ["x-operation", "operationId", "operationPath", "workflowId"],
    extensionsPrefix: "x-"
  }, A = {
    properties: {},
    additionalProperties: {
      type: "string"
    }
  }, T = {
    properties: {
      contentType: { type: "string" },
      payload: {},
      replacements: (0, e.listOf)("Replacement")
    },
    required: ["payload"],
    extensionsPrefix: "x-"
  }, R = {
    properties: {
      target: { type: "string" },
      value: {}
    },
    required: ["target", "value"],
    extensionsPrefix: "x-"
  }, I = {
    properties: {
      path: { type: "string" },
      method: {
        enum: ["get", "post", "put", "delete", "patch"]
      },
      sourceDescriptionName: { type: "string" },
      serverUrl: { type: "string" }
    },
    required: ["path", "method"]
  }, B = {
    properties: {
      statusCode: { type: "number" },
      mimeType: { type: "string" },
      body: {},
      schema: "Schema"
    },
    requiredOneOf: ["statusCode", "mimeType", "body", "schema"]
  }, L = {
    properties: {
      condition: { type: "string" },
      context: { type: "string" },
      type: (fe) => {
        if (fe)
          return typeof fe == "string" ? { enum: ["regex", "jsonpath", "simple", "xpath"] } : (fe == null ? void 0 : fe.type) === "jsonpath" ? "JSONPathCriterion" : "XPathCriterion";
      }
    },
    required: ["condition"]
  }, Y = {
    properties: {
      type: { type: "string", enum: ["jsonpath"] },
      version: { type: "string", enum: ["draft-goessner-dispatch-jsonpath-00"] }
    }
  }, Q = {
    properties: {
      type: { type: "string", enum: ["xpath"] },
      version: { type: "string", enum: ["xpath-30", "xpath-20", "xpath-10"] }
    }
  }, re = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["goto", "end"] },
      stepId: { type: "string" },
      workflowId: { type: "string" },
      criteria: (0, e.listOf)("CriterionObject")
    },
    required: ["type", "name"]
  }, oe = {
    properties: {},
    items: (fe) => fe != null && fe.type && (fe != null && fe.name) ? "SuccessActionObject" : "ReusableObject"
  }, ce = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["goto", "retry", "end"] },
      workflowId: { type: "string" },
      stepId: { type: "string" },
      retryAfter: { type: "number" },
      retryLimit: { type: "number" },
      criteria: (0, e.listOf)("CriterionObject")
    },
    required: ["type", "name"]
  }, pe = {
    properties: {},
    items: (fe) => fe != null && fe.type && (fe != null && fe.name) ? "FailureActionObject" : "ReusableObject"
  };
  return Bu.ArazzoTypes = {
    Root: n,
    Info: p,
    SourceDescriptions: f,
    OpenAPISourceDescription: d,
    NoneSourceDescription: m,
    ArazzoSourceDescription: v,
    Parameters: _,
    Parameter: S,
    ReusableObject: g,
    Workflows: y,
    Workflow: x,
    Steps: w,
    Step: k,
    RequestBody: T,
    Replacement: R,
    ExtendedOperation: I,
    ExpectSchema: B,
    Outputs: A,
    CriterionObject: L,
    XPathCriterion: Q,
    JSONPathCriterion: Y,
    SuccessActionObject: re,
    OnSuccessActionList: oe,
    FailureActionObject: ce,
    OnFailureActionList: pe,
    Schema: t.Schema,
    NamedSchemas: (0, e.mapOf)("Schema"),
    ExternalDocs: r.ExternalDocs,
    DiscriminatorMapping: r.DiscriminatorMapping,
    Discriminator: r.Discriminator,
    DependentRequired: t.DependentRequired,
    SchemaProperties: t.SchemaProperties,
    PatternProperties: t.SchemaProperties,
    Components: a,
    NamedInputs: l,
    NamedParameters: i,
    NamedSuccessActions: s,
    NamedFailureActions: o,
    Xml: r.Xml
  }, Bu;
}
var Ts = {}, Uk;
function _W() {
  return Uk || (Uk = 1, Object.defineProperty(Ts, "__esModule", { value: !0 }), Ts.ARAZZO_VERSIONS_SUPPORTED_BY_SPOT = Ts.VERSION_PATTERN = void 0, Ts.VERSION_PATTERN = /^1\.0\.\d+(-.+)?$/, Ts.ARAZZO_VERSIONS_SUPPORTED_BY_SPOT = ["1.0.0"]), Ts;
}
var Vk;
function AS() {
  if (Vk) return vi;
  Vk = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.SpecMajorVersion = vi.SpecVersion = void 0, vi.detectSpec = d, vi.getMajorSpecVersion = m, vi.getTypes = v;
  const e = wW(), t = kS(), r = rN(), n = nN(), i = SW(), s = xW(), o = Sn(), a = _W();
  var l;
  (function(g) {
    g.OAS2 = "oas2", g.OAS3_0 = "oas3_0", g.OAS3_1 = "oas3_1", g.Async2 = "async2", g.Async3 = "async3", g.Arazzo = "arazzo";
  })(l || (vi.SpecVersion = l = {}));
  var p;
  (function(g) {
    g.OAS2 = "oas2", g.OAS3 = "oas3", g.Async2 = "async2", g.Async3 = "async3", g.Arazzo = "arazzo";
  })(p || (vi.SpecMajorVersion = p = {}));
  const f = {
    [l.OAS2]: e.Oas2Types,
    [l.OAS3_0]: t.Oas3Types,
    [l.OAS3_1]: r.Oas3_1Types,
    [l.Async2]: n.AsyncApi2Types,
    [l.Async3]: i.AsyncApi3Types,
    [l.Arazzo]: s.ArazzoTypes
  };
  function d(g) {
    if (!(0, o.isPlainObject)(g))
      throw new Error(`Document must be JSON object, got ${typeof g}`);
    if (g.openapi && typeof g.openapi != "string")
      throw new Error(`Invalid OpenAPI version: should be a string but got "${typeof g.openapi}"`);
    if (typeof g.openapi == "string" && g.openapi.startsWith("3.0"))
      return l.OAS3_0;
    if (typeof g.openapi == "string" && g.openapi.startsWith("3.1"))
      return l.OAS3_1;
    if (g.swagger && g.swagger === "2.0")
      return l.OAS2;
    if (g.openapi || g.swagger)
      throw new Error(`Unsupported OpenAPI version: ${g.openapi || g.swagger}`);
    if (typeof g.asyncapi == "string" && g.asyncapi.startsWith("2."))
      return l.Async2;
    if (typeof g.asyncapi == "string" && g.asyncapi.startsWith("3."))
      return l.Async3;
    if (g.asyncapi)
      throw new Error(`Unsupported AsyncAPI version: ${g.asyncapi}`);
    if (typeof g.arazzo == "string" && a.VERSION_PATTERN.test(g.arazzo))
      return l.Arazzo;
    throw new Error("Unsupported specification");
  }
  function m(g) {
    return g === l.OAS2 ? p.OAS2 : g === l.Async2 ? p.Async2 : g === l.Async3 ? p.Async3 : g === l.Arazzo ? p.Arazzo : p.OAS3;
  }
  function v(g) {
    return f[g];
  }
  return vi;
}
var nd = {}, Wk;
function EW() {
  if (Wk) return nd;
  Wk = 1, Object.defineProperty(nd, "__esModule", { value: !0 }), nd.initRules = t;
  const e = Sn();
  function t(r, n, i, s) {
    return r.flatMap((o) => Object.keys(o).map((a) => {
      const l = o[a], p = i === "rules" ? n.getRuleSettings(a, s) : i === "preprocessors" ? n.getPreprocessorSettings(a, s) : n.getDecoratorSettings(a, s);
      if (p.severity === "off")
        return;
      const f = p.severity, d = l(p);
      return Array.isArray(d) ? d.map((m) => ({
        severity: f,
        ruleId: a,
        visitor: m
      })) : {
        severity: f,
        ruleId: a,
        visitor: d
        // note: actually it is only one visitor object
      };
    })).flatMap((o) => o).filter(e.isDefined);
  }
  return nd;
}
var za = {}, Hk;
function OW() {
  if (Hk) return za;
  Hk = 1, Object.defineProperty(za, "__esModule", { value: !0 }), za.NoUnresolvedRefs = void 0, za.reportUnresolvedRef = r;
  const e = OS(), t = () => ({
    ref: {
      leave(n, { report: i, location: s }, o) {
        o.node === void 0 && r(o, i, s);
      }
    },
    DiscriminatorMapping(n, { report: i, resolve: s, location: o }) {
      for (const a of Object.keys(n)) {
        const l = s({ $ref: n[a] });
        if (l.node !== void 0)
          return;
        r(l, i, o.child(a));
      }
    }
  });
  za.NoUnresolvedRefs = t;
  function r(n, i, s) {
    var l;
    const o = n.error;
    o instanceof e.YamlParseError && i({
      message: "Failed to parse: " + o.message,
      location: {
        source: o.source,
        pointer: void 0,
        start: {
          col: o.col,
          line: o.line
        }
      }
    });
    const a = (l = n.error) == null ? void 0 : l.message;
    i({
      location: s,
      message: `Can't resolve $ref${a ? ": " + a : ""}`
    });
  }
  return za;
}
var Dv = {}, Qk;
function kW() {
  return Qk || (Qk = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AVAILABLE_REGIONS = e.DOMAINS = e.DEFAULT_REGION = void 0, e.getDomains = r, e.setRedoclyDomain = n, e.getRedoclyDomain = i, e.isRedoclyRegistryURL = s;
    let t = "redocly.com";
    e.DEFAULT_REGION = "us", e.DOMAINS = r(), e.AVAILABLE_REGIONS = Object.keys(e.DOMAINS);
    function r() {
      const o = {
        us: "redocly.com",
        eu: "eu.redocly.com"
      }, a = t;
      return a != null && a.endsWith(".redocly.host") && (o[a.split(".")[0]] = a), a === "redoc.online" && (o[a] = a), o;
    }
    function n(o) {
      t = o;
    }
    function i() {
      return t;
    }
    function s(o) {
      const a = i() || e.DOMAINS[e.DEFAULT_REGION], l = a === "redocly.com" ? "redoc.ly" : a;
      return !(!o.startsWith(`https://api.${a}/registry/`) && !o.startsWith(`https://api.${l}/registry/`));
    }
  }(Dv)), Dv;
}
var Uu = {}, Yk;
function AW() {
  if (Yk) return Uu;
  Yk = 1, Object.defineProperty(Uu, "__esModule", { value: !0 }), Uu.RemoveUnusedComponents = void 0;
  const e = Sn(), t = () => {
    const r = /* @__PURE__ */ new Map();
    function n(s, o, a) {
      var l;
      r.set(s.absolutePointer, {
        usedIn: ((l = r.get(s.absolutePointer)) == null ? void 0 : l.usedIn) ?? [],
        componentType: o,
        name: a
      });
    }
    function i(s, o) {
      const a = o.length;
      for (const [l, { usedIn: p, name: f, componentType: d }] of r)
        !p.some((v) => !o.some((g) => (
          // Check if the current location's absolute pointer starts with the 'removed' path
          // and either its length matches exactly with 'removed' or the character after the 'removed' path is a '/'
          v.absolutePointer.startsWith(g) && (v.absolutePointer.length === g.length || v.absolutePointer[g.length] === "/")
        ))) && d && (o.push(l), delete s[d][f], r.delete(l), (0, e.isEmptyObject)(s[d]) && delete s[d]);
      return o.length > a ? i(s, o) : o.length;
    }
    return {
      ref: {
        leave(s, { location: o, type: a, resolve: l, key: p }) {
          if (["Schema", "Parameter", "Response", "SecurityScheme"].includes(a.name)) {
            const f = l(s);
            if (!f.location)
              return;
            const [d, m] = f.location.absolutePointer.split("#", 2), v = m.split("/").slice(0, 3).join("/"), g = `${d}#${v}`, S = r.get(g);
            S ? S.usedIn.push(o) : r.set(g, {
              usedIn: [o],
              name: p.toString()
            });
          }
        }
      },
      Root: {
        leave(s, o) {
          const a = o.getVisitorData();
          a.removedCount = i(s, []);
        }
      },
      NamedSchemas: {
        Schema(s, { location: o, key: a }) {
          s.allOf || n(o, "definitions", a.toString());
        }
      },
      NamedParameters: {
        Parameter(s, { location: o, key: a }) {
          n(o, "parameters", a.toString());
        }
      },
      NamedResponses: {
        Response(s, { location: o, key: a }) {
          n(o, "responses", a.toString());
        }
      },
      NamedSecuritySchemes: {
        SecurityScheme(s, { location: o, key: a }) {
          n(o, "securityDefinitions", a.toString());
        }
      }
    };
  };
  return Uu.RemoveUnusedComponents = t, Uu;
}
var Vu = {}, Gk;
function PW() {
  if (Gk) return Vu;
  Gk = 1, Object.defineProperty(Vu, "__esModule", { value: !0 }), Vu.RemoveUnusedComponents = void 0;
  const e = Sn(), t = () => {
    const r = /* @__PURE__ */ new Map();
    function n(s, o, a) {
      var l;
      r.set(s.absolutePointer, {
        usedIn: ((l = r.get(s.absolutePointer)) == null ? void 0 : l.usedIn) ?? [],
        componentType: o,
        name: a
      });
    }
    function i(s, o) {
      const a = o.length;
      for (const [l, { usedIn: p, name: f, componentType: d }] of r)
        if (!p.some((v) => !o.some((g) => v.absolutePointer.startsWith(g) && (v.absolutePointer.length === g.length || v.absolutePointer[g.length] === "/"))) && d && s.components) {
          o.push(l);
          const v = s.components[d];
          delete v[f], r.delete(l), (0, e.isEmptyObject)(v) && delete s.components[d];
        }
      return o.length > a ? i(s, o) : o.length;
    }
    return {
      ref: {
        leave(s, { location: o, type: a, resolve: l, key: p }) {
          if (["Schema", "Header", "Parameter", "Response", "Example", "RequestBody"].includes(a.name)) {
            const f = l(s);
            if (!f.location)
              return;
            const [d, m] = f.location.absolutePointer.split("#", 2), v = m.split("/").slice(0, 4).join("/"), g = `${d}#${v}`, S = r.get(g);
            S ? S.usedIn.push(o) : r.set(g, {
              usedIn: [o],
              name: p.toString()
            });
          }
        }
      },
      Root: {
        leave(s, o) {
          const a = o.getVisitorData();
          a.removedCount = i(s, []), (0, e.isEmptyObject)(s.components) && delete s.components;
        }
      },
      NamedSchemas: {
        Schema(s, { location: o, key: a }) {
          s.allOf || n(o, "schemas", a.toString());
        }
      },
      NamedParameters: {
        Parameter(s, { location: o, key: a }) {
          n(o, "parameters", a.toString());
        }
      },
      NamedResponses: {
        Response(s, { location: o, key: a }) {
          n(o, "responses", a.toString());
        }
      },
      NamedExamples: {
        Example(s, { location: o, key: a }) {
          n(o, "examples", a.toString());
        }
      },
      NamedRequestBodies: {
        RequestBody(s, { location: o, key: a }) {
          n(o, "requestBodies", a.toString());
        }
      },
      NamedHeaders: {
        Header(s, { location: o, key: a }) {
          n(o, "headers", a.toString());
        }
      }
    };
  };
  return Vu.RemoveUnusedComponents = t, Vu;
}
var qa = {};
const mg = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: !1
    },
    type: {
      type: "string",
      enum: ["rating", "sentiment", "comment", "reasons", "mood", "scale"],
      default: "sentiment"
    },
    settings: {
      type: "object",
      properties: {
        label: { type: "string" },
        submitText: { type: "string" },
        buttonText: { type: "string" },
        component: {
          type: "string",
          enum: ["radio", "checkbox"],
          default: "checkbox"
        },
        items: { type: "array", items: { type: "string" }, minItems: 1 },
        leftScaleLabel: { type: "string" },
        rightScaleLabel: { type: "string" },
        reasons: {
          type: "object",
          properties: {
            hide: {
              type: "boolean",
              default: !1
            },
            component: {
              type: "string",
              enum: ["radio", "checkbox"],
              default: "checkbox"
            },
            label: { type: "string" },
            items: { type: "array", items: { type: "string" } }
          },
          additionalProperties: !1
        },
        comment: {
          type: "object",
          properties: {
            hide: {
              type: "boolean",
              default: !1
            },
            label: { type: "string" },
            likeLabel: { type: "string" },
            dislikeLabel: { type: "string" },
            satisfiedLabel: { type: "string" },
            neutralLabel: { type: "string" },
            dissatisfiedLabel: { type: "string" }
          },
          additionalProperties: !1
        }
      },
      additionalProperties: !1
    }
  },
  additionalProperties: !1
}, Ba = {
  type: "object",
  properties: {
    includeByName: {
      type: "array",
      items: {
        type: "string"
      }
    },
    excludeByName: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  additionalProperties: !1
}, CW = {
  type: "object",
  properties: {
    name: {
      type: "string"
    },
    items: Ba,
    queries: Ba,
    mutations: Ba,
    subscriptions: Ba,
    types: Ba,
    directives: Ba
  },
  required: ["name"],
  additionalProperties: !1
}, TW = {
  type: "object",
  properties: {
    requireExactGroups: {
      type: "boolean"
    },
    groups: {
      type: "array",
      items: CW
    },
    otherItemsGroupName: {
      type: "string"
    }
  },
  required: ["requireExactGroups", "groups", "otherItemsGroupName"],
  additionalProperties: !1
}, bm = {
  type: "object",
  properties: {
    pagination: {
      type: "string",
      enum: ["none", "section", "item"]
    },
    hidePaginationButtons: {
      type: "boolean"
    },
    menu: {
      type: "object",
      properties: Object.assign({}, TW.properties),
      additionalProperties: !1
    },
    sidebar: {
      type: "object",
      properties: {
        hide: {
          type: "boolean"
        }
      }
    },
    apiLogo: {
      type: "object",
      properties: {
        imageUrl: {
          type: "string"
        },
        href: {
          type: "string"
        },
        altText: {
          type: "string"
        },
        backgroundColor: {
          type: "string"
        }
      }
    },
    jsonSamplesDepth: {
      type: "number"
    },
    samplesMaxInlineArgs: {
      type: "number"
    },
    licenseKey: {
      type: "string"
    },
    fieldExpandLevel: {
      type: "number"
    },
    baseUrlPath: {
      type: "string"
    },
    feedback: mg
  },
  additionalProperties: !1
}, $W = {
  type: "object",
  properties: {
    languages: {
      type: "array",
      items: {
        type: "object",
        properties: {
          lang: {
            type: "string",
            enum: [
              "curl",
              "JavaScript",
              "Node.js",
              "Python",
              "Java8+Apache",
              "Java",
              "C#",
              "C#+Newtonsoft",
              "PHP",
              "Go",
              "Ruby",
              "R",
              "Payload"
            ]
          },
          label: { type: "string" },
          options: {
            type: "object",
            properties: {
              indent: { type: "string" },
              withImports: { type: "boolean" },
              withComments: { type: "boolean" },
              binary: { type: "boolean" },
              credentials: {
                type: "string",
                enum: ["omit", "same-origin", "include"]
              }
            },
            additionalProperties: !1
          }
        },
        required: ["lang"],
        additionalProperties: !1
      }
    },
    skipOptionalParameters: { type: "boolean" },
    withOAuth2Call: { type: "boolean" }
  },
  required: ["languages"],
  additionalProperties: !1
}, RW = {
  type: "array",
  items: {
    type: "object",
    properties: {
      title: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    additionalProperties: !1
  }
}, Nb = {
  type: "object",
  properties: {
    licenseKey: { type: "string" },
    hideLoading: { type: "boolean" },
    disableRouter: { type: "boolean" },
    hideSidebar: { type: "boolean" },
    feedback: mg,
    hideReplay: { type: "boolean" },
    oAuth2RedirectURI: { type: "string", nullable: !0 },
    corsProxyUrl: { type: "string" },
    sortRequiredPropsFirst: { type: "boolean" },
    sanitize: { type: "boolean" },
    hideDownloadButtons: { type: "boolean" },
    downloadUrls: RW,
    onlyRequiredInSamples: { type: "boolean" },
    generatedSamplesMaxDepth: { oneOf: [{ type: "number" }, { type: "string" }] },
    showExtensions: {
      oneOf: [
        { type: "boolean" },
        { type: "string" },
        { type: "array", items: { type: "string" } }
      ]
    },
    hideSchemaTitles: { type: "boolean" },
    jsonSamplesExpandLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    schemasExpansionLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    mockServer: {
      type: "object",
      properties: {
        url: { type: "string" },
        position: { type: "string", enum: ["first", "last", "replace", "off"] },
        description: { type: "string" }
      }
    },
    maxDisplayedEnumValues: { type: "number" },
    schemaDefinitionsTagName: { type: "string" },
    layout: { type: "string", enum: ["stacked", "three-panel"] },
    hideInfoMetadata: { type: "boolean" },
    events: { type: "object" },
    skipBundle: { type: "boolean" },
    routingBasePath: { type: "string" },
    codeSamples: $W,
    ignoreNamedSchemas: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    hidePropertiesPrefix: { type: "boolean" },
    excludeFromSearch: { type: "boolean" }
  },
  additionalProperties: !1
}, IW = {
  type: "object",
  properties: {
    label: { type: "string" },
    lang: {
      enum: [
        "curl",
        "C#",
        "Go",
        "Java",
        "Java8+Apache",
        "JavaScript",
        "Node.js",
        "PHP",
        "Python",
        "R",
        "Ruby"
      ]
    }
  },
  required: ["lang"]
}, jW = {
  type: "object",
  properties: {
    enum: { type: "string" },
    enumSingleValue: { type: "string" },
    enumArray: { type: "string" },
    default: { type: "string" },
    deprecated: { type: "string" },
    example: { type: "string" },
    examples: { type: "string" },
    nullable: { type: "string" },
    recursive: { type: "string" },
    arrayOf: { type: "string" },
    webhook: { type: "string" },
    authorizations: { type: "string" },
    tryItAuthBasicUsername: { type: "string" },
    tryItAuthBasicPassword: { type: "string" }
  }
}, Kk = {
  type: "object",
  properties: {
    label: { type: "string" },
    link: { type: "string" },
    target: { type: "string" }
  },
  required: ["label", "link"]
}, NW = {
  type: "object",
  properties: {
    beforeInfo: { type: "array", items: Kk },
    end: { type: "array", items: Kk }
  }
}, Fs = {
  type: "object",
  properties: {
    main: { type: "string" },
    light: { type: "string" },
    dark: { type: "string" },
    contrastText: { type: "string" }
  }
}, id = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderColor: { type: "string" },
    color: { type: "string" },
    tabTextColor: { type: "string" }
  }
}, LW = {
  type: "object",
  properties: gg(Fs.properties, ["light", "dark"])
}, MW = {
  type: "object",
  properties: {
    basic: { type: "string" },
    delete: { type: "string" },
    get: { type: "string" },
    head: { type: "string" },
    link: { type: "string" },
    options: { type: "string" },
    patch: { type: "string" },
    post: { type: "string" },
    put: { type: "string" }
  }
}, DW = {
  type: "object",
  properties: {
    error: id,
    info: id,
    redirect: id,
    success: id
  }
}, FW = {
  type: "object",
  properties: Kl(Fs.properties, ["dark"])
}, zW = {
  type: "object",
  properties: {
    primary: { type: "string" },
    secondary: { type: "string" },
    light: { type: "string" }
  }
}, qW = {
  type: "object",
  properties: {
    accent: Fs,
    border: LW,
    error: Fs,
    http: MW,
    primary: Fs,
    responses: DW,
    secondary: FW,
    success: Fs,
    text: zW,
    tonalOffset: { type: "number" },
    warning: Fs
  }
}, od = {
  type: "object",
  properties: {
    fontSize: { type: "string" },
    padding: { type: "string" },
    minWidth: { type: "string" }
  }
}, BW = {
  type: "object",
  properties: {
    small: od,
    medium: od,
    large: od,
    xlarge: od
  }
}, $i = {
  type: "object",
  properties: {
    fontFamily: { type: "string" },
    fontSize: { type: "string" },
    fontWeight: { type: "string" },
    lineHeight: { type: "string" }
  }
}, UW = {
  type: "object",
  properties: Object.assign(Object.assign({}, Kl($i.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, hoverStyle: { type: "string" }, boxShadow: { type: "string" }, hoverBoxShadow: { type: "string" }, sizes: BW })
}, Xk = {
  type: "object",
  properties: gg($i.properties, ["fontSize", "lineHeight"])
}, VW = {
  type: "object",
  properties: {
    medium: Xk,
    small: Xk
  }
}, WW = {
  type: "object",
  properties: Object.assign(Object.assign({}, Kl($i.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, color: { type: "string" }, sizes: VW })
}, HW = {
  type: "object",
  properties: {
    top: { type: "string" },
    width: { type: "string" },
    height: { type: "string" }
  }
}, QW = {
  type: "object",
  properties: {
    borderRadius: { type: "string" },
    backgroundColor: { type: "string" }
  }
}, Jk = {
  type: "object",
  properties: {
    fullWidth: { type: "boolean" }
  }
}, YW = {
  type: "object",
  properties: {
    buttons: UW,
    httpBadges: WW,
    layoutControls: HW,
    panels: QW,
    tryItButton: Jk,
    tryItSendButton: Jk
  }
}, wm = {
  type: "object",
  properties: {
    small: { type: "string" },
    medium: { type: "string" },
    large: { type: "string" }
  }
}, GW = {
  type: "object",
  properties: {
    maxWidth: wm
  }
}, KW = {
  type: "object",
  properties: {
    maxWidth: wm,
    middlePanelMaxWidth: wm
  }
}, XW = {
  type: "object",
  properties: {
    showDarkRightPanel: { type: "boolean" },
    stacked: GW,
    "three-panel": KW
  }
}, Zk = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    border: { type: "string" }
  }
}, JW = {
  type: "object",
  properties: {
    breakFieldNames: { type: "boolean" },
    caretColor: { type: "string" },
    caretSize: { type: "string" },
    constraints: Zk,
    defaultDetailsWidth: { type: "string" },
    examples: Zk,
    labelsTextSize: { type: "string" },
    linesColor: { type: "string" },
    nestedBackground: { type: "string" },
    nestingSpacing: { type: "string" },
    requireLabelColor: { type: "string" },
    typeNameColor: { type: "string" },
    typeTitleColor: { type: "string" }
  }
}, iN = {
  type: "object",
  properties: {
    subItemsColor: { type: "string" },
    textTransform: { type: "string" },
    fontWeight: { type: "string" }
  }
}, ZW = {
  type: "object",
  properties: gg(iN.properties, ["textTransform"])
}, e9 = {
  type: "object",
  properties: {
    unit: { type: "number" },
    paddingHorizontal: { type: "string" },
    paddingVertical: { type: "string" },
    offsetTop: { type: "string" },
    offsetLeft: { type: "string" },
    offsetNesting: { type: "string" }
  }
}, t9 = {
  type: "object",
  properties: Object.assign(Object.assign({}, Kl($i.properties, ["fontWeight", "lineHeight"])), { activeBgColor: { type: "string" }, activeTextColor: { type: "string" }, backgroundColor: { type: "string" }, borderRadius: { type: "string" }, breakPath: { type: "boolean" }, caretColor: { type: "string" }, caretSize: { type: "string" }, groupItems: iN, level1items: ZW, rightLineColor: { type: "string" }, separatorLabelColor: { type: "string" }, showAtBreakpoint: { type: "string" }, spacing: e9, textColor: { type: "string" }, width: { type: "string" } })
}, sd = {
  type: "object",
  properties: Object.assign(Object.assign({}, $i.properties), { color: { type: "string" }, transform: { type: "string" } })
}, r9 = {
  type: "object",
  properties: Object.assign(Object.assign({}, $i.properties), { backgroundColor: { type: "string" }, color: { type: "string" }, wordBreak: {
    type: "string",
    enum: [
      "break-all",
      "break-word",
      "keep-all",
      "normal",
      "revert",
      "unset",
      "inherit",
      "initial"
    ]
  }, wrap: { type: "boolean" } })
}, n9 = {
  type: "object",
  properties: Kl($i.properties, ["fontSize"])
}, i9 = {
  type: "object",
  properties: {
    color: { type: "string" },
    hover: { type: "string" },
    textDecoration: { type: "string" },
    hoverTextDecoration: { type: "string" },
    visited: { type: "string" }
  }
}, o9 = {
  type: "object",
  properties: Object.assign(Object.assign({ code: r9, fieldName: $i }, gg($i.properties, ["fontSize", "fontFamily"])), { fontWeightBold: { type: "string" }, fontWeightLight: { type: "string" }, fontWeightRegular: { type: "string" }, heading1: sd, heading2: sd, heading3: sd, headings: n9, lineHeight: { type: "string" }, links: i9, optimizeSpeed: { type: "boolean" }, rightPanelHeading: sd, smoothing: {
    type: "string",
    enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"]
  } })
}, s9 = {
  type: "object",
  properties: Object.assign({ color: { type: "string" } }, Kl($i.properties, ["fontWeight"]))
}, a9 = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderRadius: { type: "string" },
    tokens: s9
  }
}, l9 = {
  type: "object",
  properties: {
    gutter: { type: "string" },
    maxHeight: { type: "string" },
    maxWidth: { type: "string" }
  }
}, u9 = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    color: { type: "string" }
  }
}, eA = {
  type: "object",
  properties: {
    custom: { type: "string" }
  }
}, c9 = {
  type: "object",
  properties: {
    DownloadButton: eA,
    NextSectionButton: eA
  }
}, p9 = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    panelBackgroundColor: { type: "string" },
    panelControlsBackgroundColor: { type: "string" },
    showAtBreakpoint: { type: "string" },
    textColor: { type: "string" },
    width: { type: "string" }
  }
}, f9 = {
  type: "object",
  properties: { borderRadius: { type: "string" } }
}, d9 = {
  type: "object",
  properties: {
    sectionHorizontal: { type: "number" },
    sectionVertical: { type: "number" },
    unit: { type: "number" }
  }
}, h9 = {
  type: "object",
  properties: {
    breakpoints: wm,
    codeBlock: a9,
    colors: qW,
    components: YW,
    layout: XW,
    logo: l9,
    fab: u9,
    overrides: c9,
    rightPanel: p9,
    schema: JW,
    shape: f9,
    sidebar: t9,
    spacing: d9,
    typography: o9,
    links: { properties: { color: { type: "string" } } },
    codeSample: { properties: { backgroundColor: { type: "string" } } }
  }
}, m9 = {
  type: "object",
  properties: {
    skipOptionalParameters: { type: "boolean" },
    languages: { type: "array", items: IW }
  },
  required: ["languages"]
}, g9 = {
  type: "object",
  properties: {
    theme: h9,
    ctrlFHijack: { type: "boolean" },
    defaultSampleLanguage: { type: "string" },
    disableDeepLinks: { type: "boolean" },
    disableSearch: { type: "boolean" },
    disableSidebar: { type: "boolean" },
    downloadDefinitionUrl: { type: "string" },
    expandDefaultServerVariables: { type: "boolean" },
    enumSkipQuotes: { type: "boolean" },
    expandDefaultRequest: { type: "boolean" },
    expandDefaultResponse: { type: "boolean" },
    expandResponses: { type: "string" },
    expandSingleSchemaField: { type: "boolean" },
    generateCodeSamples: m9,
    generatedPayloadSamplesMaxDepth: { type: "number" },
    hideDownloadButton: { type: "boolean" },
    hideHostname: { type: "boolean" },
    hideInfoSection: { type: "boolean" },
    hideLogo: { type: "boolean" },
    hideRequestPayloadSample: { type: "boolean" },
    hideRightPanel: { type: "boolean" },
    hideSchemaPattern: { type: "boolean" },
    hideSingleRequestSampleTab: { type: "boolean" },
    hideSecuritySection: { type: "boolean" },
    hideTryItPanel: { type: "boolean" },
    hideFab: { type: "boolean" },
    hideOneOfDescription: { type: "boolean" },
    htmlTemplate: { type: "string" },
    jsonSampleExpandLevel: {
      oneOf: [{ type: "number", minimum: 1 }, { type: "string" }]
    },
    labels: jW,
    menuToggle: { type: "boolean" },
    nativeScrollbars: { type: "boolean" },
    noAutoAuth: { type: "boolean" },
    onDeepLinkClick: { type: "object" },
    pagination: { enum: ["none", "section", "item"] },
    pathInMiddlePanel: { type: "boolean" },
    payloadSampleIdx: { type: "number", minimum: 0 },
    requestInterceptor: { type: "object" },
    requiredPropsFirst: { type: "boolean" },
    routingStrategy: { type: "string" },
    samplesTabsMaxCount: { type: "number" },
    schemaExpansionLevel: {
      oneOf: [{ type: "number", minimum: 0 }, { type: "string" }]
    },
    minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
    maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
    scrollYOffset: {
      oneOf: [{ type: "number" }, { type: "string" }]
    },
    searchAutoExpand: { type: "boolean" },
    searchFieldLevelBoost: { type: "number", minimum: 0 },
    searchMaxDepth: { type: "number", minimum: 1 },
    searchMode: { type: "string", enum: ["default", "path-only"] },
    searchOperationTitleBoost: { type: "number" },
    searchTagTitleBoost: { type: "number" },
    sendXUserAgentInTryIt: { type: "boolean" },
    showChangeLayoutButton: { type: "boolean" },
    showConsole: { type: "boolean" },
    showNextButton: { type: "boolean" },
    showRightPanelToggle: { type: "boolean" },
    showSecuritySchemeType: { type: "boolean" },
    showWebhookVerb: { type: "boolean" },
    showObjectSchemaExamples: { type: "boolean" },
    disableTryItRequestUrlEncoding: { type: "boolean" },
    sidebarLinks: NW,
    sideNavStyle: { type: "string", enum: ["summary-only", "path-first", "id-only"] },
    simpleOneOfTypeLabel: { type: "boolean" },
    sortEnumValuesAlphabetically: { type: "boolean" },
    sortOperationsAlphabetically: { type: "boolean" },
    sortPropsAlphabetically: { type: "boolean" },
    sortTagsAlphabetically: { type: "boolean" },
    suppressWarnings: { type: "boolean" },
    unstable_externalDescription: { type: "boolean" },
    unstable_ignoreMimeParameters: { type: "boolean" },
    untrustedDefinition: { type: "boolean" },
    showAccessMode: { type: "boolean" },
    preserveOriginalExtensionsName: { type: "boolean" },
    markdownHeadingsAnchorLevel: { type: "number" }
  },
  additionalProperties: !1
};
function gg(e, t) {
  return Object.fromEntries(t.filter((r) => r in e).map((r) => [r, e[r]]));
}
function Kl(e, t) {
  return Object.fromEntries(Object.entries(e).filter(([r]) => !t.includes(r)));
}
const Rr = {
  type: "object",
  properties: {
    hide: { type: "boolean" }
  },
  additionalProperties: !1
}, tA = {
  type: "object",
  properties: {
    src: { type: "string" },
    async: { type: "boolean" },
    crossorigin: { type: "string" },
    defer: { type: "boolean" },
    fetchpriority: { type: "string" },
    integrity: { type: "string" },
    module: { type: "boolean" },
    nomodule: { type: "boolean" },
    nonce: { type: "string" },
    referrerpolicy: { type: "string" },
    type: { type: "string" }
  },
  required: ["src"],
  additionalProperties: !0
}, Fv = {
  type: "object",
  properties: {
    page: { type: "string" },
    directory: { type: "string" },
    disconnect: { type: "boolean", default: !1 },
    group: { type: "string" },
    label: { type: "string" },
    href: { type: "string" },
    external: { type: "boolean" },
    labelTranslationKey: { type: "string" },
    groupTranslationKey: { type: "string" },
    icon: {
      oneOf: [
        { type: "string" },
        { type: "object", properties: { srcSet: { type: "string" } }, required: ["srcSet"] }
      ]
    },
    separator: { type: "string" },
    separatorLine: { type: "boolean" },
    linePosition: {
      type: "string",
      enum: ["top", "bottom"],
      default: "top"
    },
    version: { type: "string" },
    menuStyle: { type: "string", enum: ["drilldown"] },
    expanded: { type: "string", const: "always" },
    selectFirstItemOnExpand: { type: "boolean" },
    flatten: { type: "boolean" },
    linkedSidebars: {
      type: "array",
      items: { type: "string" }
    },
    // Allow users to eject the navbar and implement additional levels of nesting
    items: { type: "array", items: { type: "object", additionalProperties: !0 } }
  }
}, PS = {
  type: "array",
  items: Object.assign(Object.assign({}, Fv), { properties: Object.assign(Object.assign({}, Fv.properties), { items: { type: "array", items: Fv } }) })
}, y9 = {
  type: "object",
  properties: {
    name: { type: "string" },
    icon: { type: "string" },
    folder: { type: "string" }
  },
  additionalProperties: !1,
  required: ["name", "folder"]
}, v9 = {
  type: "object",
  properties: {
    page: { type: "string" },
    label: { type: "string" },
    labelTranslationKey: { type: "string" }
  },
  required: ["page"]
}, oN = {
  type: "object",
  properties: {
    image: { type: "string" },
    srcSet: { type: "string" },
    altText: { type: "string" },
    link: { type: "string" },
    favicon: { type: "string" }
  },
  additionalProperties: !1
}, sN = {
  type: "object",
  properties: Object.assign({ items: PS }, Rr.properties),
  additionalProperties: !1
}, aN = {
  type: "object",
  additionalProperties: y9
}, lN = {
  type: "object",
  properties: Object.assign({ items: PS, copyrightText: { type: "string" }, logo: Rr }, Rr.properties),
  additionalProperties: !1
}, uN = {
  type: "object",
  properties: Object.assign({ separatorLine: { type: "boolean" }, linePosition: {
    type: "string",
    enum: ["top", "bottom"],
    default: "bottom"
  } }, Rr.properties),
  additionalProperties: !1
}, cN = {
  type: "object",
  properties: {
    head: { type: "array", items: tA },
    body: { type: "array", items: tA }
  },
  additionalProperties: !1
}, pN = {
  type: "array",
  items: {
    type: "object",
    properties: {
      href: { type: "string" },
      as: { type: "string" },
      crossorigin: { type: "string" },
      fetchpriority: { type: "string" },
      hreflang: { type: "string" },
      imagesizes: { type: "string" },
      imagesrcset: { type: "string" },
      integrity: { type: "string" },
      media: { type: "string" },
      prefetch: { type: "string" },
      referrerpolicy: { type: "string" },
      rel: { type: "string" },
      sizes: { type: "string" },
      title: { type: "string" },
      type: { type: "string" }
    },
    required: ["href"],
    additionalProperties: !0
  }
}, fN = {
  type: "object",
  properties: Object.assign({ placement: {
    type: "string",
    default: "navbar"
  }, shortcuts: {
    type: "array",
    items: { type: "string" },
    default: ["/"]
  }, suggestedPages: {
    type: "array",
    items: v9
  }, fuzzy: {
    type: "boolean",
    default: !1
  } }, Rr.properties),
  additionalProperties: !1
}, dN = {
  type: "object",
  properties: Object.assign({ ignoreDetection: { type: "boolean" }, modes: {
    type: "array",
    items: { type: "string" },
    default: ["light", "dark"]
  } }, Rr.properties),
  additionalProperties: !1
}, hN = {
  type: "object",
  properties: {
    nextButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Next page" } }, Rr.properties),
      additionalProperties: !1,
      default: {}
    },
    previousButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Previous page" } }, Rr.properties),
      additionalProperties: !1,
      default: {}
    }
  },
  additionalProperties: !1
}, mN = {
  type: "object",
  properties: {
    elementFormat: { type: "string", default: "icon" },
    copy: {
      type: "object",
      properties: Object.assign({}, Rr.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    report: {
      type: "object",
      properties: Object.assign({ tooltipText: { type: "string" }, buttonText: { type: "string" }, label: { type: "string" } }, Rr.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    expand: {
      type: "object",
      properties: Object.assign({}, Rr.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    collapse: {
      type: "object",
      properties: Object.assign({}, Rr.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    }
  },
  additionalProperties: !1
}, gN = {
  type: "object",
  properties: {
    frontMatterKeysToResolve: {
      type: "array",
      items: { type: "string" },
      default: ["image", "links"]
    },
    partialsFolders: {
      type: "array",
      items: { type: "string" },
      default: ["_partials"]
    },
    lastUpdatedBlock: {
      type: "object",
      properties: Object.assign({ format: {
        type: "string",
        enum: ["timeago", "iso", "long", "short"],
        default: "timeago"
      }, locale: { type: "string" } }, Rr.properties),
      additionalProperties: !1,
      default: {}
    },
    toc: {
      type: "object",
      properties: Object.assign({ header: { type: "string", default: "On this page" }, depth: { type: "integer", default: 3, minimum: 1 } }, Rr.properties),
      additionalProperties: !1,
      default: {}
    },
    editPage: {
      type: "object",
      properties: Object.assign({ baseUrl: { type: "string" } }, Rr.properties),
      additionalProperties: !1,
      default: {}
    }
  },
  additionalProperties: !1,
  default: {}
}, Sm = Object.assign(Object.assign({}, Nb), { properties: Object.assign(Object.assign({}, Nb.properties), g9.properties) }), b9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    scriptUrl: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: !1,
  required: ["scriptUrl"]
}, w9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    apiKey: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    outboundClickEventName: { type: "string" },
    pageViewEventName: { type: "string" },
    amplitudeConfig: { type: "object", additionalProperties: !0 }
  },
  additionalProperties: !1,
  required: ["apiKey"]
}, S9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    orgId: { type: "string" }
  },
  additionalProperties: !1,
  required: ["orgId"]
}, x9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    appId: { type: "string" }
  },
  additionalProperties: !1,
  required: ["appId"]
}, _9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    dataPlaneUrl: { type: "string" },
    controlPlaneUrl: { type: "string" },
    sdkUrl: { type: "string" },
    loadOptions: { type: "object", additionalProperties: !0 }
  },
  additionalProperties: !1,
  required: ["writeKey"]
}, E9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    includeTitleInPageCall: { type: "boolean" },
    host: { type: "string" }
  },
  additionalProperties: !1,
  required: ["writeKey"]
}, O9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    gtmAuth: { type: "string" },
    gtmPreview: { type: "string" },
    defaultDataLayer: {},
    dataLayerName: { type: "string" },
    enableWebVitalsTracking: { type: "boolean" },
    selfHostedOrigin: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, yN = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    optimizeId: { type: "string" },
    exclude: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, k9 = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    optimizeId: { type: "string" },
    anonymizeIp: { type: "boolean" },
    cookieExpires: { type: "number" },
    // All enabled tracking configs
    trackers: {
      type: "object",
      additionalProperties: yN
    }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, vN = {
  type: "object",
  properties: {
    adobe: b9,
    amplitude: w9,
    fullstory: S9,
    heap: x9,
    rudderstack: _9,
    segment: E9,
    gtm: O9,
    ga: k9
  }
}, bN = {
  type: "object",
  properties: Object.assign({ items: {
    type: "array",
    items: {
      type: "object",
      properties: {
        label: { type: "string" },
        external: { type: "boolean" },
        link: { type: "string" },
        separatorLine: { type: "boolean" }
      },
      additionalProperties: !0
    },
    default: []
  }, hideLoginButton: { type: "boolean" } }, Rr.properties),
  additionalProperties: !1
}, wN = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    showForUnversioned: {
      type: "boolean"
    }
  }
}, SN = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    prefixItems: {
      type: "array",
      items: {
        type: "object",
        properties: {
          label: { type: "string" },
          labelTranslationKey: { type: "string" },
          page: { type: "string" }
        },
        additionalProperties: !1,
        default: {}
      }
    }
  },
  additionalProperties: !1
}, A9 = {
  type: "object",
  additionalProperties: !1,
  required: ["title", "property"],
  properties: {
    type: {
      type: "string",
      enum: ["select", "checkboxes", "date-range"],
      default: "checkboxes"
    },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    property: { type: "string" },
    parentFilter: { type: "string" },
    valuesMapping: { type: "object", additionalProperties: { type: "string" } },
    missingCategoryName: { type: "string" },
    missingCategoryNameTranslationKey: { type: "string" },
    options: { type: "array", items: { type: "string" } }
  }
}, P9 = {
  type: "object",
  additionalProperties: !0,
  required: ["slug", "items"],
  properties: {
    slug: { type: "string" },
    filters: { type: "array", items: A9 },
    groupByFirstFilter: { type: "boolean" },
    filterValuesCasing: {
      type: "string",
      enum: ["sentence", "original", "lowercase", "uppercase"]
    },
    items: PS,
    requiredPermission: { type: "string" },
    separateVersions: { type: "boolean" },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    description: { type: "string" },
    descriptionTranslationKey: { type: "string" }
  }
}, xN = {
  type: "object",
  patternProperties: {
    ".*": P9
  }
}, _N = {
  type: "object",
  additionalProperties: !0,
  required: [],
  properties: {
    /**
     * @deprecated Should use `reunite.ignoreLint` instead
     */
    ignoreNonCompliant: { type: "boolean", default: !1 },
    teamMetadataProperty: {
      type: "object",
      properties: {
        property: { type: "string" },
        label: { type: "string" },
        default: { type: "string" }
      }
    },
    levels: {
      type: "array",
      items: {
        type: "object",
        required: ["name"],
        properties: {
          name: { type: "string" },
          color: { type: "string" },
          extends: { type: "array", items: { type: "string" } },
          rules: {
            type: "object",
            additionalProperties: {
              oneOf: [{ type: "string" }, { type: "object" }]
            }
          }
        },
        additionalProperties: !1
      }
    },
    targets: {
      type: "array",
      items: {
        type: "object",
        required: ["where"],
        properties: {
          minimumLevel: { type: "string" },
          where: {
            type: "object",
            required: ["metadata"],
            properties: {
              metadata: { type: "object", additionalProperties: { type: "string" } }
            },
            additionalProperties: !1
          }
        },
        additionalProperties: !1
      }
    }
  }
}, Wn = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    logo: oN,
    navbar: sN,
    products: aN,
    footer: lN,
    sidebar: uN,
    scripts: cN,
    links: pN,
    feedback: mg,
    search: fN,
    colorMode: dN,
    navigation: hN,
    codeSnippet: mN,
    markdown: gN,
    openapi: Sm,
    graphql: bm,
    analytics: vN,
    userMenu: bN,
    versionPicker: wN,
    breadcrumbs: SN,
    catalog: xN,
    scorecard: _N
  },
  additionalProperties: !0
};
Object.assign(Object.assign({}, Wn), { additionalProperties: !1 });
const EN = "https://redocly.com/sso/teams";
var ep;
(function(e) {
  e.OIDC = "OIDC", e.SAML2 = "SAML2";
})(ep || (ep = {}));
var tp;
(function(e) {
  e.SERVICE_ACCOUNT = "SERVICE_ACCOUNT", e.OAUTH2 = "OAUTH2";
})(tp || (tp = {}));
const C9 = "redocly::teams-rbac", T9 = "redocly::route-rbac";
var Lb;
(function(e) {
  e.STACKED = "stacked", e.THREE_PANEL = "three-panel";
})(Lb || (Lb = {}));
function Mb(e, t) {
  return Object.fromEntries(Object.entries(e).map(([r, n]) => {
    if (r !== t)
      return typeof n != "object" || !n ? [r, n] : Array.isArray(n) ? [
        r,
        n.map((i) => typeof i == "object" ? Mb(i, t) : i)
      ] : [r, Mb(n, t)];
  }).filter(Boolean));
}
const $9 = {
  type: "object",
  properties: {
    ignoreLint: { type: "boolean", default: !1 },
    ignoreLinkChecker: { type: "boolean" },
    ignoreMarkdocErrors: { type: "boolean" }
  },
  additionalProperties: !1
}, R9 = {
  type: "object",
  properties: {
    end_session_endpoint: { type: "string" },
    token_endpoint: { type: "string" },
    authorization_endpoint: { type: "string" },
    jwks_uri: { type: "string" }
  },
  required: ["token_endpoint", "authorization_endpoint"],
  additionalProperties: !0
}, I9 = {
  type: "object",
  properties: {
    type: { type: "string", const: ep.OIDC },
    title: { type: "string" },
    pkce: { type: "boolean", default: !1 },
    configurationUrl: { type: "string", minLength: 1 },
    configuration: R9,
    clientId: { type: "string", minLength: 1 },
    clientSecret: { type: "string", minLength: 0 },
    teamsClaimName: { type: "string" },
    teamsClaimMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } },
    scopes: { type: "array", items: { type: "string" } },
    tokenExpirationTime: { type: "number" },
    authorizationRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    tokenRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    audience: { type: "array", items: { type: "string" } }
  },
  required: ["type", "clientId"],
  oneOf: [{ required: ["configurationUrl"] }, { required: ["configuration"] }],
  additionalProperties: !1
}, j9 = {
  type: "object",
  properties: {
    type: { type: "string", const: ep.SAML2 },
    title: { type: "string" },
    issuerId: { type: "string" },
    entityId: { type: "string" },
    ssoUrl: { type: "string" },
    x509PublicCert: { type: "string" },
    teamsAttributeName: { type: "string", default: EN },
    teamsAttributeMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1,
  required: ["type", "issuerId", "ssoUrl", "x509PublicCert"]
}, N9 = {
  oneOf: [I9, j9],
  discriminator: { propertyName: "type" }
}, L9 = {
  type: "object",
  additionalProperties: N9
}, M9 = {
  oneOf: [
    {
      type: "array",
      items: {
        type: "string",
        enum: ["REDOCLY", "CORPORATE", "GUEST"]
      },
      uniqueItems: !0
    },
    {
      type: "string",
      enum: ["REDOCLY", "CORPORATE", "GUEST"]
    }
  ]
}, D9 = {
  type: "object",
  properties: {
    to: { type: "string" },
    type: { type: "number", default: 301 }
  },
  additionalProperties: !1
}, F9 = {
  type: "object",
  additionalProperties: D9,
  default: {}
}, ON = {
  type: "object",
  additionalProperties: {
    oneOf: [{ type: "string" }, { type: "object" }]
  }
}, kN = {
  type: "object",
  properties: {
    root: { type: "string" },
    output: { type: "string", pattern: "(.ya?ml|.json)$" },
    rbac: { type: "object", additionalProperties: !0 },
    openapi: Sm,
    graphql: bm,
    /**
     * @deprecated left for backwards compatibility
     */
    theme: {
      type: "object",
      properties: {
        openapi: Sm,
        graphql: bm
      },
      additionalProperties: !1
    },
    title: { type: "string" },
    metadata: { type: "object", additionalProperties: !0 },
    rules: ON,
    decorators: { type: "object", additionalProperties: !0 },
    preprocessors: { type: "object", additionalProperties: !0 }
  },
  required: ["root"]
}, z9 = {
  type: "object",
  additionalProperties: !0
}, q9 = {
  type: "object",
  properties: {
    title: { type: "string" },
    description: { type: "string" },
    siteUrl: { type: "string" },
    image: { type: "string" },
    keywords: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    lang: { type: "string" },
    jsonLd: { type: "object" },
    meta: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: { type: "string" },
          content: { type: "string" }
        },
        required: ["name", "content"],
        additionalProperties: !1
      }
    }
  },
  additionalProperties: !1
}, Ua = {
  type: "object",
  additionalProperties: { type: "string" }
}, AN = {
  type: "object",
  properties: {
    teamNamePatterns: { type: "array", items: { type: "string" } },
    teamFolders: { type: "array", items: { type: "string" } },
    teamFoldersBaseRoles: Ua,
    cms: Ua,
    reunite: Ua,
    content: {
      type: "object",
      properties: {
        "**": Ua
      },
      additionalProperties: Ua
    }
  },
  additionalProperties: Ua
}, B9 = {
  type: "object",
  properties: { static: { type: "string" } },
  additionalProperties: !1,
  required: ["static"]
}, U9 = {
  type: "object",
  properties: { idp: { type: "string" } },
  additionalProperties: !1,
  required: ["idp"]
}, V9 = {
  type: "object",
  properties: {
    type: { type: "string", const: "GRAVITEE" },
    apiBaseUrl: { type: "string" },
    env: { type: "string" },
    allowApiProductsOutsideCatalog: { type: "boolean", default: !1 },
    stage: { type: "string", default: "non-production" },
    auth: {
      oneOf: [B9, U9]
    }
  },
  additionalProperties: !1,
  required: ["type", "apiBaseUrl"]
}, W9 = {
  type: "object",
  properties: {
    type: { type: "string", const: tp.OAUTH2 },
    tokenEndpoint: { type: "string" },
    clientId: { type: "string" },
    clientSecret: { type: "string" }
  },
  additionalProperties: !1,
  required: ["type", "tokenEndpoint", "clientId", "clientSecret"]
}, H9 = {
  type: "object",
  properties: {
    type: { type: "string", const: tp.SERVICE_ACCOUNT },
    serviceAccountEmail: { type: "string" },
    serviceAccountPrivateKey: { type: "string" }
  },
  additionalProperties: !1,
  required: ["type", "serviceAccountEmail", "serviceAccountPrivateKey"]
}, Db = {
  type: "object",
  properties: {
    type: { type: "string", const: "APIGEE_X" },
    apiUrl: { type: "string" },
    stage: { type: "string", default: "non-production" },
    organizationName: { type: "string" },
    ignoreApiProducts: { type: "array", items: { type: "string" } },
    allowApiProductsOutsideCatalog: { type: "boolean", default: !1 },
    auth: {
      type: "object",
      oneOf: [W9, H9],
      discriminator: { propertyName: "type" }
    }
  },
  additionalProperties: !1,
  required: ["type", "organizationName", "auth"]
}, Q9 = Object.assign(Object.assign({}, Db), { properties: Object.assign(Object.assign({}, Db.properties), { type: { type: "string", const: "APIGEE_EDGE" } }) }), Y9 = {
  type: "object",
  oneOf: [Db, Q9, V9],
  discriminator: { propertyName: "type" }
}, G9 = {
  type: "object",
  required: ["adapters"],
  additionalProperties: !1,
  properties: {
    adapters: {
      type: "array",
      items: Y9
    }
  }
}, rA = {
  type: "object",
  properties: {
    defaultLocale: {
      type: "string"
    },
    locales: {
      type: "array",
      items: {
        type: "object",
        properties: {
          code: {
            type: "string"
          },
          name: {
            type: "string"
          }
        },
        required: ["code"]
      }
    }
  },
  additionalProperties: !1,
  required: ["defaultLocale"]
}, K9 = {
  type: "object",
  properties: {
    name: { type: "string" },
    value: { type: "string" }
  },
  additionalProperties: !1,
  required: ["name", "value"]
}, Fb = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    licenseKey: { type: "string" },
    redirects: F9,
    seo: q9,
    rbac: AN,
    requiresLogin: { type: "boolean" },
    responseHeaders: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: K9
      }
    },
    mockServer: {
      type: "object",
      properties: {
        off: { type: "boolean", default: !1 },
        position: { type: "string", enum: ["first", "last", "replace", "off"], default: "first" },
        strictExamples: { type: "boolean", default: !1 },
        errorIfForcedExampleNotFound: { type: "boolean", default: !1 },
        description: { type: "string" }
      }
    },
    apis: {
      type: "object",
      additionalProperties: kN
    },
    rules: ON,
    decorators: { type: "object", additionalProperties: !0 },
    preprocessors: { type: "object", additionalProperties: !0 },
    ssoOnPrem: L9,
    sso: M9,
    residency: { type: "string" },
    developerOnboarding: G9,
    removeAttribution: { type: "boolean" },
    i18n: rA,
    l10n: rA,
    metadata: z9,
    ignore: {
      type: "array",
      items: {
        type: "string"
      }
    },
    /**
     * @deprecated properties moved to the root of the config
     */
    theme: Wn,
    reunite: $9,
    // Ex theme properties
    logo: oN,
    navbar: sN,
    products: aN,
    footer: lN,
    sidebar: uN,
    scripts: cN,
    links: pN,
    feedback: mg,
    search: fN,
    colorMode: dN,
    navigation: hN,
    codeSnippet: mN,
    markdown: gN,
    openapi: Sm,
    graphql: bm,
    analytics: vN,
    userMenu: bN,
    versionPicker: wN,
    breadcrumbs: SN,
    catalog: xN,
    scorecard: _N
  },
  default: { redirects: {} },
  additionalProperties: !0
}, X9 = Object.assign(Object.assign({}, Mb(Fb, "default")), { additionalProperties: !1 }), J9 = Object.assign(Object.assign({ $id: "root-redocly-config" }, Fb), { properties: Object.assign(Object.assign({ plugins: {
  type: "array",
  items: { type: "string" }
} }, Fb.properties), { env: {
  type: "object",
  additionalProperties: X9
  // TODO: if we want full validation we need to override apis, theme and the root
} }), default: {}, additionalProperties: !1 }), zb = {
  type: "object",
  properties: {
    logo: Wn.properties.logo,
    navbar: Wn.properties.navbar,
    footer: Wn.properties.footer,
    sidebar: Wn.properties.sidebar,
    search: Wn.properties.search,
    codeSnippet: Wn.properties.codeSnippet,
    breadcrumbs: Wn.properties.breadcrumbs,
    openapi: Wn.properties.openapi,
    feedback: Wn.properties.feedback,
    analytics: {
      type: "object",
      properties: {
        ga: yN
      }
    }
  },
  additionalProperties: !0,
  default: {}
}, Z9 = {
  $id: "product-config-override",
  type: "object",
  properties: Object.assign(Object.assign({}, zb.properties), {
    apis: {
      type: "object",
      additionalProperties: kN
    },
    /**
     * @deprecated left for backwards compatibility
     */
    theme: zb
  }),
  additionalProperties: !1
}, eH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ApigeeDevOnboardingIntegrationAuthType() {
    return tp;
  },
  get AuthProviderType() {
    return ep;
  },
  DEFAULT_TEAM_CLAIM_NAME: EN,
  get LayoutVariant() {
    return Lb;
  },
  REDOCLY_ROUTE_RBAC: T9,
  REDOCLY_TEAMS_RBAC: C9,
  productConfigOverrideSchema: Z9,
  productThemeOverrideSchema: zb,
  rbacConfigSchema: AN,
  redocConfigSchema: Nb,
  rootRedoclyConfigSchema: J9
}, Symbol.toStringTag, { value: "Module" })), tH = /* @__PURE__ */ Ri(eH);
var ad = {}, ld = { exports: {} }, zv = {}, $s = {}, Wu = {}, qv = {}, Bv = {}, Uv = {}, nA;
function xm() {
  return nA || (nA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0, e._ = i, e.str = o, e.addCodeArg = a, e.strConcat = f, e.stringify = m, e.safeStringify = v, e.getProperty = g, e.getEsmExportName = S, e.regexpCode = _;
    class t {
    }
    e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends t {
      constructor(y) {
        if (super(), !e.IDENTIFIER.test(y))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = y;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = r;
    class n extends t {
      constructor(y) {
        super(), this._items = typeof y == "string" ? [y] : y;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const y = this._items[0];
        return y === "" || y === '""';
      }
      get str() {
        var y;
        return (y = this._str) !== null && y !== void 0 ? y : this._str = this._items.reduce((w, k) => `${w}${k}`, "");
      }
      get names() {
        var y;
        return (y = this._names) !== null && y !== void 0 ? y : this._names = this._items.reduce((w, k) => (k instanceof r && (w[k.str] = (w[k.str] || 0) + 1), w), {});
      }
    }
    e._Code = n, e.nil = new n("");
    function i(x, ...y) {
      const w = [x[0]];
      let k = 0;
      for (; k < y.length; )
        a(w, y[k]), w.push(x[++k]);
      return new n(w);
    }
    const s = new n("+");
    function o(x, ...y) {
      const w = [v(x[0])];
      let k = 0;
      for (; k < y.length; )
        w.push(s), a(w, y[k]), w.push(s, v(x[++k]));
      return l(w), new n(w);
    }
    function a(x, y) {
      y instanceof n ? x.push(...y._items) : y instanceof r ? x.push(y) : x.push(d(y));
    }
    function l(x) {
      let y = 1;
      for (; y < x.length - 1; ) {
        if (x[y] === s) {
          const w = p(x[y - 1], x[y + 1]);
          if (w !== void 0) {
            x.splice(y - 1, 3, w);
            continue;
          }
          x[y++] = "+";
        }
        y++;
      }
    }
    function p(x, y) {
      if (y === '""')
        return x;
      if (x === '""')
        return y;
      if (typeof x == "string")
        return y instanceof r || x[x.length - 1] !== '"' ? void 0 : typeof y != "string" ? `${x.slice(0, -1)}${y}"` : y[0] === '"' ? x.slice(0, -1) + y.slice(1) : void 0;
      if (typeof y == "string" && y[0] === '"' && !(x instanceof r))
        return `"${x}${y.slice(1)}`;
    }
    function f(x, y) {
      return y.emptyStr() ? x : x.emptyStr() ? y : o`${x}${y}`;
    }
    function d(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : v(Array.isArray(x) ? x.join(",") : x);
    }
    function m(x) {
      return new n(v(x));
    }
    function v(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function g(x) {
      return typeof x == "string" && e.IDENTIFIER.test(x) ? new n(`.${x}`) : i`[${x}]`;
    }
    function S(x) {
      if (typeof x == "string" && e.IDENTIFIER.test(x))
        return new n(`${x}`);
      throw new Error(`CodeGen: invalid export name: ${x}, use explicit $id name mapping`);
    }
    function _(x) {
      return new n(x.toString());
    }
  }(Uv)), Uv;
}
var Vv = {}, iA;
function oA() {
  return iA || (iA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const t = xm();
    class r extends Error {
      constructor(p) {
        super(`CodeGen: "code" for ${p} not defined`), this.value = p.value;
      }
    }
    var n;
    (function(l) {
      l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
    })(n || (e.UsedValueState = n = {})), e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var")
    };
    class i {
      constructor({ prefixes: p, parent: f } = {}) {
        this._names = {}, this._prefixes = p, this._parent = f;
      }
      toName(p) {
        return p instanceof t.Name ? p : this.name(p);
      }
      name(p) {
        return new t.Name(this._newName(p));
      }
      _newName(p) {
        const f = this._names[p] || this._nameGroup(p);
        return `${p}${f.index++}`;
      }
      _nameGroup(p) {
        var f, d;
        if (!((d = (f = this._parent) === null || f === void 0 ? void 0 : f._prefixes) === null || d === void 0) && d.has(p) || this._prefixes && !this._prefixes.has(p))
          throw new Error(`CodeGen: prefix "${p}" is not allowed in this scope`);
        return this._names[p] = { prefix: p, index: 0 };
      }
    }
    e.Scope = i;
    class s extends t.Name {
      constructor(p, f) {
        super(f), this.prefix = p;
      }
      setValue(p, { property: f, itemIndex: d }) {
        this.value = p, this.scopePath = (0, t._)`.${new t.Name(f)}[${d}]`;
      }
    }
    e.ValueScopeName = s;
    const o = (0, t._)`\n`;
    class a extends i {
      constructor(p) {
        super(p), this._values = {}, this._scope = p.scope, this.opts = { ...p, _n: p.lines ? o : t.nil };
      }
      get() {
        return this._scope;
      }
      name(p) {
        return new s(p, this._newName(p));
      }
      value(p, f) {
        var d;
        if (f.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const m = this.toName(p), { prefix: v } = m, g = (d = f.key) !== null && d !== void 0 ? d : f.ref;
        let S = this._values[v];
        if (S) {
          const y = S.get(g);
          if (y)
            return y;
        } else
          S = this._values[v] = /* @__PURE__ */ new Map();
        S.set(g, m);
        const _ = this._scope[v] || (this._scope[v] = []), x = _.length;
        return _[x] = f.ref, m.setValue(f, { property: v, itemIndex: x }), m;
      }
      getValue(p, f) {
        const d = this._values[p];
        if (d)
          return d.get(f);
      }
      scopeRefs(p, f = this._values) {
        return this._reduceValues(f, (d) => {
          if (d.scopePath === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return (0, t._)`${p}${d.scopePath}`;
        });
      }
      scopeCode(p = this._values, f, d) {
        return this._reduceValues(p, (m) => {
          if (m.value === void 0)
            throw new Error(`CodeGen: name "${m}" has no value`);
          return m.value.code;
        }, f, d);
      }
      _reduceValues(p, f, d = {}, m) {
        let v = t.nil;
        for (const g in p) {
          const S = p[g];
          if (!S)
            continue;
          const _ = d[g] = d[g] || /* @__PURE__ */ new Map();
          S.forEach((x) => {
            if (_.has(x))
              return;
            _.set(x, n.Started);
            let y = f(x);
            if (y) {
              const w = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              v = (0, t._)`${v}${w} ${x} = ${y};${this.opts._n}`;
            } else if (y = m == null ? void 0 : m(x))
              v = (0, t._)`${v}${y}${this.opts._n}`;
            else
              throw new r(x);
            _.set(x, n.Completed);
          });
        }
        return v;
      }
    }
    e.ValueScope = a;
  }(Vv)), Vv;
}
var sA;
function ot() {
  return sA || (sA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0, e.not = pe, e.and = G, e.or = K;
    const t = xm(), r = oA();
    var n = xm();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var i = oA();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return i.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return i.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return i.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return i.varKinds;
    } }), e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+")
    };
    class s {
      optimizeNodes() {
        return this;
      }
      optimizeNames(j, H) {
        return this;
      }
    }
    class o extends s {
      constructor(j, H, F) {
        super(), this.varKind = j, this.name = H, this.rhs = F;
      }
      render({ es5: j, _n: H }) {
        const F = j ? r.varKinds.var : this.varKind, ue = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${F} ${this.name}${ue};` + H;
      }
      optimizeNames(j, H) {
        if (j[this.name.str])
          return this.rhs && (this.rhs = oe(this.rhs, j, H)), this;
      }
      get names() {
        return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
      }
    }
    class a extends s {
      constructor(j, H, F) {
        super(), this.lhs = j, this.rhs = H, this.sideEffects = F;
      }
      render({ _n: j }) {
        return `${this.lhs} = ${this.rhs};` + j;
      }
      optimizeNames(j, H) {
        if (!(this.lhs instanceof t.Name && !j[this.lhs.str] && !this.sideEffects))
          return this.rhs = oe(this.rhs, j, H), this;
      }
      get names() {
        const j = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
        return re(j, this.rhs);
      }
    }
    class l extends a {
      constructor(j, H, F, ue) {
        super(j, F, ue), this.op = H;
      }
      render({ _n: j }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + j;
      }
    }
    class p extends s {
      constructor(j) {
        super(), this.label = j, this.names = {};
      }
      render({ _n: j }) {
        return `${this.label}:` + j;
      }
    }
    class f extends s {
      constructor(j) {
        super(), this.label = j, this.names = {};
      }
      render({ _n: j }) {
        return `break${this.label ? ` ${this.label}` : ""};` + j;
      }
    }
    class d extends s {
      constructor(j) {
        super(), this.error = j;
      }
      render({ _n: j }) {
        return `throw ${this.error};` + j;
      }
      get names() {
        return this.error.names;
      }
    }
    class m extends s {
      constructor(j) {
        super(), this.code = j;
      }
      render({ _n: j }) {
        return `${this.code};` + j;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(j, H) {
        return this.code = oe(this.code, j, H), this;
      }
      get names() {
        return this.code instanceof t._CodeOrName ? this.code.names : {};
      }
    }
    class v extends s {
      constructor(j = []) {
        super(), this.nodes = j;
      }
      render(j) {
        return this.nodes.reduce((H, F) => H + F.render(j), "");
      }
      optimizeNodes() {
        const { nodes: j } = this;
        let H = j.length;
        for (; H--; ) {
          const F = j[H].optimizeNodes();
          Array.isArray(F) ? j.splice(H, 1, ...F) : F ? j[H] = F : j.splice(H, 1);
        }
        return j.length > 0 ? this : void 0;
      }
      optimizeNames(j, H) {
        const { nodes: F } = this;
        let ue = F.length;
        for (; ue--; ) {
          const ge = F[ue];
          ge.optimizeNames(j, H) || (ce(j, ge.names), F.splice(ue, 1));
        }
        return F.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((j, H) => Q(j, H.names), {});
      }
    }
    class g extends v {
      render(j) {
        return "{" + j._n + super.render(j) + "}" + j._n;
      }
    }
    class S extends v {
    }
    class _ extends g {
    }
    _.kind = "else";
    class x extends g {
      constructor(j, H) {
        super(H), this.condition = j;
      }
      render(j) {
        let H = `if(${this.condition})` + super.render(j);
        return this.else && (H += "else " + this.else.render(j)), H;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const j = this.condition;
        if (j === !0)
          return this.nodes;
        let H = this.else;
        if (H) {
          const F = H.optimizeNodes();
          H = this.else = Array.isArray(F) ? new _(F) : F;
        }
        if (H)
          return j === !1 ? H instanceof x ? H : H.nodes : this.nodes.length ? this : new x(pe(j), H instanceof x ? [H] : H.nodes);
        if (!(j === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(j, H) {
        var F;
        if (this.else = (F = this.else) === null || F === void 0 ? void 0 : F.optimizeNames(j, H), !!(super.optimizeNames(j, H) || this.else))
          return this.condition = oe(this.condition, j, H), this;
      }
      get names() {
        const j = super.names;
        return re(j, this.condition), this.else && Q(j, this.else.names), j;
      }
    }
    x.kind = "if";
    class y extends g {
    }
    y.kind = "for";
    class w extends y {
      constructor(j) {
        super(), this.iteration = j;
      }
      render(j) {
        return `for(${this.iteration})` + super.render(j);
      }
      optimizeNames(j, H) {
        if (super.optimizeNames(j, H))
          return this.iteration = oe(this.iteration, j, H), this;
      }
      get names() {
        return Q(super.names, this.iteration.names);
      }
    }
    class k extends y {
      constructor(j, H, F, ue) {
        super(), this.varKind = j, this.name = H, this.from = F, this.to = ue;
      }
      render(j) {
        const H = j.es5 ? r.varKinds.var : this.varKind, { name: F, from: ue, to: ge } = this;
        return `for(${H} ${F}=${ue}; ${F}<${ge}; ${F}++)` + super.render(j);
      }
      get names() {
        const j = re(super.names, this.from);
        return re(j, this.to);
      }
    }
    class A extends y {
      constructor(j, H, F, ue) {
        super(), this.loop = j, this.varKind = H, this.name = F, this.iterable = ue;
      }
      render(j) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(j);
      }
      optimizeNames(j, H) {
        if (super.optimizeNames(j, H))
          return this.iterable = oe(this.iterable, j, H), this;
      }
      get names() {
        return Q(super.names, this.iterable.names);
      }
    }
    class T extends g {
      constructor(j, H, F) {
        super(), this.name = j, this.args = H, this.async = F;
      }
      render(j) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(j);
      }
    }
    T.kind = "func";
    class R extends v {
      render(j) {
        return "return " + super.render(j);
      }
    }
    R.kind = "return";
    class I extends g {
      render(j) {
        let H = "try" + super.render(j);
        return this.catch && (H += this.catch.render(j)), this.finally && (H += this.finally.render(j)), H;
      }
      optimizeNodes() {
        var j, H;
        return super.optimizeNodes(), (j = this.catch) === null || j === void 0 || j.optimizeNodes(), (H = this.finally) === null || H === void 0 || H.optimizeNodes(), this;
      }
      optimizeNames(j, H) {
        var F, ue;
        return super.optimizeNames(j, H), (F = this.catch) === null || F === void 0 || F.optimizeNames(j, H), (ue = this.finally) === null || ue === void 0 || ue.optimizeNames(j, H), this;
      }
      get names() {
        const j = super.names;
        return this.catch && Q(j, this.catch.names), this.finally && Q(j, this.finally.names), j;
      }
    }
    class B extends g {
      constructor(j) {
        super(), this.error = j;
      }
      render(j) {
        return `catch(${this.error})` + super.render(j);
      }
    }
    B.kind = "catch";
    class L extends g {
      render(j) {
        return "finally" + super.render(j);
      }
    }
    L.kind = "finally";
    class Y {
      constructor(j, H = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...H, _n: H.lines ? `
` : "" }, this._extScope = j, this._scope = new r.Scope({ parent: j }), this._nodes = [new S()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(j) {
        return this._scope.name(j);
      }
      // reserves unique name in the external scope
      scopeName(j) {
        return this._extScope.name(j);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(j, H) {
        const F = this._extScope.value(j, H);
        return (this._values[F.prefix] || (this._values[F.prefix] = /* @__PURE__ */ new Set())).add(F), F;
      }
      getScopeValue(j, H) {
        return this._extScope.getValue(j, H);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(j) {
        return this._extScope.scopeRefs(j, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(j, H, F, ue) {
        const ge = this._scope.toName(H);
        return F !== void 0 && ue && (this._constants[ge.str] = F), this._leafNode(new o(j, ge, F)), ge;
      }
      // `const` declaration (`var` in es5 mode)
      const(j, H, F) {
        return this._def(r.varKinds.const, j, H, F);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(j, H, F) {
        return this._def(r.varKinds.let, j, H, F);
      }
      // `var` declaration with optional assignment
      var(j, H, F) {
        return this._def(r.varKinds.var, j, H, F);
      }
      // assignment code
      assign(j, H, F) {
        return this._leafNode(new a(j, H, F));
      }
      // `+=` code
      add(j, H) {
        return this._leafNode(new l(j, e.operators.ADD, H));
      }
      // appends passed SafeExpr to code or executes Block
      code(j) {
        return typeof j == "function" ? j() : j !== t.nil && this._leafNode(new m(j)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...j) {
        const H = ["{"];
        for (const [F, ue] of j)
          H.length > 1 && H.push(","), H.push(F), (F !== ue || this.opts.es5) && (H.push(":"), (0, t.addCodeArg)(H, ue));
        return H.push("}"), new t._Code(H);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(j, H, F) {
        if (this._blockNode(new x(j)), H && F)
          this.code(H).else().code(F).endIf();
        else if (H)
          this.code(H).endIf();
        else if (F)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(j) {
        return this._elseNode(new x(j));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new _());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(x, _);
      }
      _for(j, H) {
        return this._blockNode(j), H && this.code(H).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(j, H) {
        return this._for(new w(j), H);
      }
      // `for` statement for a range of values
      forRange(j, H, F, ue, ge = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const Ae = this._scope.toName(j);
        return this._for(new k(ge, Ae, H, F), () => ue(Ae));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(j, H, F, ue = r.varKinds.const) {
        const ge = this._scope.toName(j);
        if (this.opts.es5) {
          const Ae = H instanceof t.Name ? H : this.var("_arr", H);
          return this.forRange("_i", 0, (0, t._)`${Ae}.length`, (C) => {
            this.var(ge, (0, t._)`${Ae}[${C}]`), F(ge);
          });
        }
        return this._for(new A("of", ue, ge, H), () => F(ge));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(j, H, F, ue = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(j, (0, t._)`Object.keys(${H})`, F);
        const ge = this._scope.toName(j);
        return this._for(new A("in", ue, ge, H), () => F(ge));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(y);
      }
      // `label` statement
      label(j) {
        return this._leafNode(new p(j));
      }
      // `break` statement
      break(j) {
        return this._leafNode(new f(j));
      }
      // `return` statement
      return(j) {
        const H = new R();
        if (this._blockNode(H), this.code(j), H.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(R);
      }
      // `try` statement
      try(j, H, F) {
        if (!H && !F)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const ue = new I();
        if (this._blockNode(ue), this.code(j), H) {
          const ge = this.name("e");
          this._currNode = ue.catch = new B(ge), H(ge);
        }
        return F && (this._currNode = ue.finally = new L(), this.code(F)), this._endBlockNode(B, L);
      }
      // `throw` statement
      throw(j) {
        return this._leafNode(new d(j));
      }
      // start self-balancing block
      block(j, H) {
        return this._blockStarts.push(this._nodes.length), j && this.code(j).endBlock(H), this;
      }
      // end the current self-balancing block
      endBlock(j) {
        const H = this._blockStarts.pop();
        if (H === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const F = this._nodes.length - H;
        if (F < 0 || j !== void 0 && F !== j)
          throw new Error(`CodeGen: wrong number of nodes: ${F} vs ${j} expected`);
        return this._nodes.length = H, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(j, H = t.nil, F, ue) {
        return this._blockNode(new T(j, H, F)), ue && this.code(ue).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(T);
      }
      optimize(j = 1) {
        for (; j-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(j) {
        return this._currNode.nodes.push(j), this;
      }
      _blockNode(j) {
        this._currNode.nodes.push(j), this._nodes.push(j);
      }
      _endBlockNode(j, H) {
        const F = this._currNode;
        if (F instanceof j || H && F instanceof H)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${H ? `${j.kind}/${H.kind}` : j.kind}"`);
      }
      _elseNode(j) {
        const H = this._currNode;
        if (!(H instanceof x))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = H.else = j, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const j = this._nodes;
        return j[j.length - 1];
      }
      set _currNode(j) {
        const H = this._nodes;
        H[H.length - 1] = j;
      }
    }
    e.CodeGen = Y;
    function Q(q, j) {
      for (const H in j)
        q[H] = (q[H] || 0) + (j[H] || 0);
      return q;
    }
    function re(q, j) {
      return j instanceof t._CodeOrName ? Q(q, j.names) : q;
    }
    function oe(q, j, H) {
      if (q instanceof t.Name)
        return F(q);
      if (!ue(q))
        return q;
      return new t._Code(q._items.reduce((ge, Ae) => (Ae instanceof t.Name && (Ae = F(Ae)), Ae instanceof t._Code ? ge.push(...Ae._items) : ge.push(Ae), ge), []));
      function F(ge) {
        const Ae = H[ge.str];
        return Ae === void 0 || j[ge.str] !== 1 ? ge : (delete j[ge.str], Ae);
      }
      function ue(ge) {
        return ge instanceof t._Code && ge._items.some((Ae) => Ae instanceof t.Name && j[Ae.str] === 1 && H[Ae.str] !== void 0);
      }
    }
    function ce(q, j) {
      for (const H in j)
        q[H] = (q[H] || 0) - (j[H] || 0);
    }
    function pe(q) {
      return typeof q == "boolean" || typeof q == "number" || q === null ? !q : (0, t._)`!${te(q)}`;
    }
    const fe = z(e.operators.AND);
    function G(...q) {
      return q.reduce(fe);
    }
    const Z = z(e.operators.OR);
    function K(...q) {
      return q.reduce(Z);
    }
    function z(q) {
      return (j, H) => j === t.nil ? H : H === t.nil ? j : (0, t._)`${te(j)} ${q} ${te(H)}`;
    }
    function te(q) {
      return q instanceof t.Name ? q : (0, t._)`(${q})`;
    }
  }(Bv)), Bv;
}
var Ft = {}, aA;
function ct() {
  if (aA) return Ft;
  aA = 1, Object.defineProperty(Ft, "__esModule", { value: !0 }), Ft.Type = Ft.mergeEvaluated = void 0, Ft.toHash = r, Ft.alwaysValidSchema = n, Ft.checkUnknownRules = i, Ft.schemaHasRules = s, Ft.schemaHasRulesButRef = o, Ft.schemaRefOrVal = a, Ft.unescapeFragment = l, Ft.escapeFragment = p, Ft.escapeJsonPointer = f, Ft.unescapeJsonPointer = d, Ft.eachItem = m, Ft.evaluatedPropsToName = g, Ft.setEvaluated = S, Ft.useFunc = x, Ft.getErrorPath = w, Ft.checkStrictMode = k;
  const e = ot(), t = xm();
  function r(A) {
    const T = {};
    for (const R of A)
      T[R] = !0;
    return T;
  }
  function n(A, T) {
    return typeof T == "boolean" ? T : Object.keys(T).length === 0 ? !0 : (i(A, T), !s(T, A.self.RULES.all));
  }
  function i(A, T = A.schema) {
    const { opts: R, self: I } = A;
    if (!R.strictSchema || typeof T == "boolean")
      return;
    const B = I.RULES.keywords;
    for (const L in T)
      B[L] || k(A, `unknown keyword: "${L}"`);
  }
  function s(A, T) {
    if (typeof A == "boolean")
      return !A;
    for (const R in A)
      if (T[R])
        return !0;
    return !1;
  }
  function o(A, T) {
    if (typeof A == "boolean")
      return !A;
    for (const R in A)
      if (R !== "$ref" && T.all[R])
        return !0;
    return !1;
  }
  function a({ topSchemaRef: A, schemaPath: T }, R, I, B) {
    if (!B) {
      if (typeof R == "number" || typeof R == "boolean")
        return R;
      if (typeof R == "string")
        return (0, e._)`${R}`;
    }
    return (0, e._)`${A}${T}${(0, e.getProperty)(I)}`;
  }
  function l(A) {
    return d(decodeURIComponent(A));
  }
  function p(A) {
    return encodeURIComponent(f(A));
  }
  function f(A) {
    return typeof A == "number" ? `${A}` : A.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function d(A) {
    return A.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function m(A, T) {
    if (Array.isArray(A))
      for (const R of A)
        T(R);
    else
      T(A);
  }
  function v({ mergeNames: A, mergeToName: T, mergeValues: R, resultToName: I }) {
    return (B, L, Y, Q) => {
      const re = Y === void 0 ? L : Y instanceof e.Name ? (L instanceof e.Name ? A(B, L, Y) : T(B, L, Y), Y) : L instanceof e.Name ? (T(B, Y, L), L) : R(L, Y);
      return Q === e.Name && !(re instanceof e.Name) ? I(B, re) : re;
    };
  }
  Ft.mergeEvaluated = {
    props: v({
      mergeNames: (A, T, R) => A.if((0, e._)`${R} !== true && ${T} !== undefined`, () => {
        A.if((0, e._)`${T} === true`, () => A.assign(R, !0), () => A.assign(R, (0, e._)`${R} || {}`).code((0, e._)`Object.assign(${R}, ${T})`));
      }),
      mergeToName: (A, T, R) => A.if((0, e._)`${R} !== true`, () => {
        T === !0 ? A.assign(R, !0) : (A.assign(R, (0, e._)`${R} || {}`), S(A, R, T));
      }),
      mergeValues: (A, T) => A === !0 ? !0 : { ...A, ...T },
      resultToName: g
    }),
    items: v({
      mergeNames: (A, T, R) => A.if((0, e._)`${R} !== true && ${T} !== undefined`, () => A.assign(R, (0, e._)`${T} === true ? true : ${R} > ${T} ? ${R} : ${T}`)),
      mergeToName: (A, T, R) => A.if((0, e._)`${R} !== true`, () => A.assign(R, T === !0 ? !0 : (0, e._)`${R} > ${T} ? ${R} : ${T}`)),
      mergeValues: (A, T) => A === !0 ? !0 : Math.max(A, T),
      resultToName: (A, T) => A.var("items", T)
    })
  };
  function g(A, T) {
    if (T === !0)
      return A.var("props", !0);
    const R = A.var("props", (0, e._)`{}`);
    return T !== void 0 && S(A, R, T), R;
  }
  function S(A, T, R) {
    Object.keys(R).forEach((I) => A.assign((0, e._)`${T}${(0, e.getProperty)(I)}`, !0));
  }
  const _ = {};
  function x(A, T) {
    return A.scopeValue("func", {
      ref: T,
      code: _[T.code] || (_[T.code] = new t._Code(T.code))
    });
  }
  var y;
  (function(A) {
    A[A.Num = 0] = "Num", A[A.Str = 1] = "Str";
  })(y || (Ft.Type = y = {}));
  function w(A, T, R) {
    if (A instanceof e.Name) {
      const I = T === y.Num;
      return R ? I ? (0, e._)`"[" + ${A} + "]"` : (0, e._)`"['" + ${A} + "']"` : I ? (0, e._)`"/" + ${A}` : (0, e._)`"/" + ${A}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return R ? (0, e.getProperty)(A).toString() : "/" + f(A);
  }
  function k(A, T, R = A.opts.strictSchema) {
    if (R) {
      if (T = `strict mode: ${T}`, R === !0)
        throw new Error(T);
      A.self.logger.warn(T);
    }
  }
  return Ft;
}
var ud = {}, lA;
function li() {
  if (lA) return ud;
  lA = 1, Object.defineProperty(ud, "__esModule", { value: !0 });
  const e = ot(), t = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    isAllOfVariant: new e.Name("isAllOfVariant"),
    // used to check in runtime if the current function (ref) is called from allOf
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return ud.default = t, ud;
}
var uA;
function yg() {
  return uA || (uA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.keyword$DataError = e.keywordError = void 0, e.reportError = i, e.reportExtraError = s, e.resetErrorsCount = o, e.extendErrors = a;
    const t = ot(), r = ct(), n = li();
    e.keywordError = {
      message: ({ keyword: _ }) => (0, t.str)`must pass "${_}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: _, schemaType: x }) => x ? (0, t.str)`"${_}" keyword must be ${x} ($data)` : (0, t.str)`"${_}" keyword is invalid ($data)`
    };
    function i(_, x = e.keywordError, y, w) {
      const { it: k } = _, { gen: A, compositeRule: T, allErrors: R } = k, I = d(_, x, y);
      w ?? (T || R) ? l(A, I) : p(k, (0, t._)`[${I}]`);
    }
    function s(_, x = e.keywordError, y) {
      const { it: w } = _, { gen: k, compositeRule: A, allErrors: T } = w, R = d(_, x, y);
      l(k, R), A || T || p(w, n.default.vErrors);
    }
    function o(_, x) {
      _.assign(n.default.errors, x), _.if((0, t._)`${n.default.vErrors} !== null`, () => _.if(x, () => _.assign((0, t._)`${n.default.vErrors}.length`, x), () => _.assign(n.default.vErrors, null)));
    }
    function a({ gen: _, keyword: x, schemaValue: y, data: w, errsCount: k, it: A }) {
      if (k === void 0)
        throw new Error("ajv implementation error");
      const T = _.name("err");
      _.forRange("i", k, n.default.errors, (R) => {
        _.const(T, (0, t._)`${n.default.vErrors}[${R}]`), _.if((0, t._)`${T}.instancePath === undefined`, () => _.assign((0, t._)`${T}.instancePath`, (0, t.strConcat)(n.default.instancePath, A.errorPath))), _.assign((0, t._)`${T}.schemaPath`, (0, t.str)`${A.errSchemaPath}/${x}`), A.opts.verbose && (_.assign((0, t._)`${T}.schema`, y), _.assign((0, t._)`${T}.data`, w));
      });
    }
    function l(_, x) {
      const y = _.const("err", x);
      _.if((0, t._)`${n.default.vErrors} === null`, () => _.assign(n.default.vErrors, (0, t._)`[${y}]`), (0, t._)`${n.default.vErrors}.push(${y})`), _.code((0, t._)`${n.default.errors}++`);
    }
    function p(_, x) {
      const { gen: y, validateName: w, schemaEnv: k } = _;
      k.$async ? y.throw((0, t._)`new ${_.ValidationError}(${x})`) : (y.assign((0, t._)`${w}.errors`, x), y.return(!1));
    }
    const f = {
      keyword: new t.Name("keyword"),
      schemaPath: new t.Name("schemaPath"),
      // also used in JTD errors
      params: new t.Name("params"),
      propertyName: new t.Name("propertyName"),
      message: new t.Name("message"),
      schema: new t.Name("schema"),
      parentSchema: new t.Name("parentSchema")
    };
    function d(_, x, y) {
      const { createErrors: w } = _.it;
      return w === !1 ? (0, t._)`{}` : m(_, x, y);
    }
    function m(_, x, y = {}) {
      const { gen: w, it: k } = _, A = [
        v(k, y),
        g(_, y)
      ];
      return S(_, x, A), w.object(...A);
    }
    function v({ errorPath: _ }, { instancePath: x }) {
      const y = x ? (0, t.str)`${_}${(0, r.getErrorPath)(x, r.Type.Str)}` : _;
      return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, y)];
    }
    function g({ keyword: _, it: { errSchemaPath: x } }, { schemaPath: y, parentSchema: w }) {
      let k = w ? x : (0, t.str)`${x}/${_}`;
      return y && (k = (0, t.str)`${k}${(0, r.getErrorPath)(y, r.Type.Str)}`), [f.schemaPath, k];
    }
    function S(_, { params: x, message: y }, w) {
      const { keyword: k, data: A, schemaValue: T, it: R } = _, { opts: I, propertyName: B, topSchemaRef: L, schemaPath: Y } = R;
      w.push([f.keyword, k], [f.params, typeof x == "function" ? x(_) : x || (0, t._)`{}`]), I.messages && w.push([f.message, typeof y == "function" ? y(_) : y]), I.verbose && w.push([f.schema, T], [f.parentSchema, (0, t._)`${L}${Y}`], [n.default.data, A]), B && w.push([f.propertyName, B]);
    }
  }(qv)), qv;
}
var cA;
function rH() {
  if (cA) return Wu;
  cA = 1, Object.defineProperty(Wu, "__esModule", { value: !0 }), Wu.topBoolOrEmptySchema = i, Wu.boolOrEmptySchema = s;
  const e = yg(), t = ot(), r = li(), n = {
    message: "boolean schema is false"
  };
  function i(a) {
    const { gen: l, schema: p, validateName: f } = a;
    p === !1 ? o(a, !1) : typeof p == "object" && p.$async === !0 ? l.return(r.default.data) : (l.assign((0, t._)`${f}.errors`, null), l.return(!0));
  }
  function s(a, l) {
    const { gen: p, schema: f } = a;
    f === !1 ? (p.var(l, !1), o(a)) : p.var(l, !0);
  }
  function o(a, l) {
    const { gen: p, data: f } = a, d = {
      gen: p,
      keyword: "false schema",
      data: f,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: a
    };
    (0, e.reportError)(d, n, void 0, l);
  }
  return Wu;
}
var Un = {}, Hu = {}, pA;
function PN() {
  if (pA) return Hu;
  pA = 1, Object.defineProperty(Hu, "__esModule", { value: !0 }), Hu.isJSONType = r, Hu.getRules = n;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
  function r(i) {
    return typeof i == "string" && t.has(i);
  }
  function n() {
    const i = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...i, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, i.number, i.string, i.array, i.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return Hu;
}
var Va = {}, fA;
function CN() {
  if (fA) return Va;
  fA = 1, Object.defineProperty(Va, "__esModule", { value: !0 }), Va.schemaHasRulesForType = e, Va.shouldUseGroup = t, Va.shouldUseRule = r;
  function e({ schema: n, self: i }, s) {
    const o = i.RULES.types[s];
    return o && o !== !0 && t(n, o);
  }
  function t(n, i) {
    return i.rules.some((s) => r(n, s));
  }
  function r(n, i) {
    var s;
    return n[i.keyword] !== void 0 || ((s = i.definition.implements) === null || s === void 0 ? void 0 : s.some((o) => n[o] !== void 0));
  }
  return Va;
}
var dA;
function _m() {
  if (dA) return Un;
  dA = 1, Object.defineProperty(Un, "__esModule", { value: !0 }), Un.DataType = void 0, Un.getSchemaTypes = o, Un.getJSONTypes = a, Un.coerceAndCheckDataType = l, Un.checkDataType = v, Un.checkDataTypes = g, Un.reportTypeError = _;
  const e = PN(), t = CN(), r = yg(), n = ot(), i = ct();
  var s;
  (function(y) {
    y[y.Correct = 0] = "Correct", y[y.Wrong = 1] = "Wrong";
  })(s || (Un.DataType = s = {}));
  function o(y) {
    const w = a(y.type);
    if (w.includes("null")) {
      if (y.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!w.length && y.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      y.nullable === !0 && w.push("null");
    }
    return w;
  }
  function a(y) {
    const w = Array.isArray(y) ? y : y ? [y] : [];
    if (w.every(e.isJSONType))
      return w;
    throw new Error("type must be JSONType or JSONType[]: " + w.join(","));
  }
  function l(y, w) {
    const { gen: k, data: A, opts: T } = y, R = f(w, T.coerceTypes), I = w.length > 0 && !(R.length === 0 && w.length === 1 && (0, t.schemaHasRulesForType)(y, w[0]));
    if (I) {
      const B = g(w, A, T.strictNumbers, s.Wrong);
      k.if(B, () => {
        R.length ? d(y, w, R) : _(y);
      });
    }
    return I;
  }
  const p = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function f(y, w) {
    return w ? y.filter((k) => p.has(k) || w === "array" && k === "array") : [];
  }
  function d(y, w, k) {
    const { gen: A, data: T, opts: R } = y, I = A.let("dataType", (0, n._)`typeof ${T}`), B = A.let("coerced", (0, n._)`undefined`);
    R.coerceTypes === "array" && A.if((0, n._)`${I} == 'object' && Array.isArray(${T}) && ${T}.length == 1`, () => A.assign(T, (0, n._)`${T}[0]`).assign(I, (0, n._)`typeof ${T}`).if(g(w, T, R.strictNumbers), () => A.assign(B, T))), A.if((0, n._)`${B} !== undefined`);
    for (const Y of k)
      (p.has(Y) || Y === "array" && R.coerceTypes === "array") && L(Y);
    A.else(), _(y), A.endIf(), A.if((0, n._)`${B} !== undefined`, () => {
      A.assign(T, B), m(y, B);
    });
    function L(Y) {
      switch (Y) {
        case "string":
          A.elseIf((0, n._)`${I} == "number" || ${I} == "boolean"`).assign(B, (0, n._)`"" + ${T}`).elseIf((0, n._)`${T} === null`).assign(B, (0, n._)`""`);
          return;
        case "number":
          A.elseIf((0, n._)`${I} == "boolean" || ${T} === null
              || (${I} == "string" && ${T} && ${T} == +${T})`).assign(B, (0, n._)`+${T}`);
          return;
        case "integer":
          A.elseIf((0, n._)`${I} === "boolean" || ${T} === null
              || (${I} === "string" && ${T} && ${T} == +${T} && !(${T} % 1))`).assign(B, (0, n._)`+${T}`);
          return;
        case "boolean":
          A.elseIf((0, n._)`${T} === "false" || ${T} === 0 || ${T} === null`).assign(B, !1).elseIf((0, n._)`${T} === "true" || ${T} === 1`).assign(B, !0);
          return;
        case "null":
          A.elseIf((0, n._)`${T} === "" || ${T} === 0 || ${T} === false`), A.assign(B, null);
          return;
        case "array":
          A.elseIf((0, n._)`${I} === "string" || ${I} === "number"
              || ${I} === "boolean" || ${T} === null`).assign(B, (0, n._)`[${T}]`);
      }
    }
  }
  function m({ gen: y, parentData: w, parentDataProperty: k }, A) {
    y.if((0, n._)`${w} !== undefined`, () => y.assign((0, n._)`${w}[${k}]`, A));
  }
  function v(y, w, k, A = s.Correct) {
    const T = A === s.Correct ? n.operators.EQ : n.operators.NEQ;
    let R;
    switch (y) {
      case "null":
        return (0, n._)`${w} ${T} null`;
      case "array":
        R = (0, n._)`Array.isArray(${w})`;
        break;
      case "object":
        R = (0, n._)`${w} && typeof ${w} == "object" && !Array.isArray(${w})`;
        break;
      case "integer":
        R = I((0, n._)`!(${w} % 1) && !isNaN(${w})`);
        break;
      case "number":
        R = I();
        break;
      default:
        return (0, n._)`typeof ${w} ${T} ${y}`;
    }
    return A === s.Correct ? R : (0, n.not)(R);
    function I(B = n.nil) {
      return (0, n.and)((0, n._)`typeof ${w} == "number"`, B, k ? (0, n._)`isFinite(${w})` : n.nil);
    }
  }
  function g(y, w, k, A) {
    if (y.length === 1)
      return v(y[0], w, k, A);
    let T;
    const R = (0, i.toHash)(y);
    if (R.array && R.object) {
      const I = (0, n._)`typeof ${w} != "object"`;
      T = R.null ? I : (0, n._)`!${w} || ${I}`, delete R.null, delete R.array, delete R.object;
    } else
      T = n.nil;
    R.number && delete R.integer;
    for (const I in R)
      T = (0, n.and)(T, v(I, w, k, A));
    return T;
  }
  const S = {
    message: ({ schema: y }) => `must be ${y}`,
    params: ({ schema: y, schemaValue: w }) => typeof y == "string" ? (0, n._)`{type: ${y}}` : (0, n._)`{type: ${w}}`
  };
  function _(y) {
    const w = x(y);
    (0, r.reportError)(w, S);
  }
  function x(y) {
    const { gen: w, data: k, schema: A } = y, T = (0, i.schemaRefOrVal)(y, A, "type");
    return {
      gen: w,
      keyword: "type",
      data: k,
      schema: A.type,
      schemaCode: T,
      schemaValue: T,
      parentSchema: A,
      params: {},
      it: y
    };
  }
  return Un;
}
var cd = {}, hA;
function nH() {
  if (hA) return cd;
  hA = 1, Object.defineProperty(cd, "__esModule", { value: !0 }), cd.assignDefaults = r;
  const e = ot(), t = ct();
  function r(i, s) {
    const { properties: o, items: a } = i.schema;
    if (s === "object" && o)
      for (const l in o)
        n(i, l, o[l].default);
    else s === "array" && Array.isArray(a) && a.forEach((l, p) => n(i, p, l.default));
  }
  function n(i, s, o) {
    const { gen: a, compositeRule: l, data: p, opts: f } = i;
    if (o === void 0)
      return;
    const d = (0, e._)`${p}${(0, e.getProperty)(s)}`;
    if (l) {
      (0, t.checkStrictMode)(i, `default is ignored for: ${d}`);
      return;
    }
    let m = (0, e._)`${d} === undefined`;
    f.useDefaults === "empty" && (m = (0, e._)`${m} || ${d} === null || ${d} === ""`), a.if(m, (0, e._)`${d} = ${(0, e.stringify)(o)}`);
  }
  return cd;
}
var Rs = {}, Cr = {}, mA;
function ui() {
  if (mA) return Cr;
  mA = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.checkReportMissingProp = i, Cr.checkMissingProp = s, Cr.reportMissingProp = o, Cr.hasPropFunc = a, Cr.isOwnProperty = l, Cr.propertyInData = p, Cr.noPropertyInData = f, Cr.allSchemaProperties = d, Cr.schemaProperties = m, Cr.callValidateCode = v, Cr.usePattern = S, Cr.validateArray = _, Cr.validateUnion = x;
  const e = ot(), t = ct(), r = li(), n = ct();
  function i(y, w) {
    const { gen: k, data: A, it: T } = y;
    k.if(f(k, A, w, T.opts.ownProperties), () => {
      y.setParams({ missingProperty: (0, e._)`${w}` }, !0), y.error();
    });
  }
  function s({ gen: y, data: w, it: { opts: k } }, A, T) {
    return (0, e.or)(...A.map((R) => (0, e.and)(f(y, w, R, k.ownProperties), (0, e._)`${T} = ${R}`)));
  }
  function o(y, w) {
    y.setParams({ missingProperty: w }, !0), y.error();
  }
  function a(y) {
    return y.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  function l(y, w, k) {
    return (0, e._)`${a(y)}.call(${w}, ${k})`;
  }
  function p(y, w, k, A) {
    const T = (0, e._)`${w}${(0, e.getProperty)(k)} !== undefined`;
    return A ? (0, e._)`${T} && ${l(y, w, k)}` : T;
  }
  function f(y, w, k, A) {
    const T = (0, e._)`${w}${(0, e.getProperty)(k)} === undefined`;
    return A ? (0, e.or)(T, (0, e.not)(l(y, w, k))) : T;
  }
  function d(y) {
    return y ? Object.keys(y).filter((w) => w !== "__proto__") : [];
  }
  function m(y, w) {
    return d(w).filter((k) => !(0, t.alwaysValidSchema)(y, w[k]));
  }
  function v({ schemaCode: y, data: w, it: { gen: k, topSchemaRef: A, schemaPath: T, errorPath: R }, it: I }, B, L, Y) {
    const Q = Y ? (0, e._)`${y}, ${w}, ${A}${T}` : w, re = [
      [r.default.instancePath, (0, e.strConcat)(r.default.instancePath, R)],
      [r.default.parentData, I.parentData],
      [r.default.parentDataProperty, I.parentDataProperty],
      [r.default.rootData, r.default.rootData],
      [r.default.isAllOfVariant, I.isAllOfVariant ? 1 : 0]
    ];
    I.opts.dynamicRef && re.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const oe = (0, e._)`${Q}, ${k.object(...re)}`;
    return L !== e.nil ? (0, e._)`${B}.call(${L}, ${oe})` : (0, e._)`${B}(${oe})`;
  }
  const g = (0, e._)`new RegExp`;
  function S({ gen: y, it: { opts: w } }, k) {
    const A = w.unicodeRegExp ? "u" : "", { regExp: T } = w.code, R = T(k, A);
    return y.scopeValue("pattern", {
      key: R.toString(),
      ref: R,
      code: (0, e._)`${T.code === "new RegExp" ? g : (0, n.useFunc)(y, T)}(${k}, ${A})`
    });
  }
  function _(y) {
    const { gen: w, data: k, keyword: A, it: T } = y, R = w.name("valid");
    if (T.allErrors) {
      const B = w.let("valid", !0);
      return I(() => w.assign(B, !1)), B;
    }
    return w.var(R, !0), I(() => w.break()), R;
    function I(B) {
      const L = w.const("len", (0, e._)`${k}.length`);
      w.forRange("i", 0, L, (Y) => {
        y.subschema({
          keyword: A,
          dataProp: Y,
          dataPropType: t.Type.Num
        }, R), w.if((0, e.not)(R), B);
      });
    }
  }
  function x(y) {
    const { gen: w, schema: k, keyword: A, parentSchema: T, it: R } = y;
    if (!Array.isArray(k))
      throw new Error("ajv implementation error");
    if (R.opts.discriminator && T.discriminator || k.some((Y) => (0, t.alwaysValidSchema)(R, Y)) && !R.opts.unevaluated)
      return;
    const B = w.let("valid", !1), L = w.name("_valid");
    w.block(() => k.forEach((Y, Q) => {
      const re = y.subschema({
        keyword: A,
        schemaProp: Q,
        compositeRule: !0
      }, L);
      w.assign(B, (0, e._)`${B} || ${L}`), y.mergeValidEvaluated(re, L) || w.if((0, e.not)(B));
    })), y.result(B, () => y.reset(), () => y.error(!0));
  }
  return Cr;
}
var gA;
function iH() {
  if (gA) return Rs;
  gA = 1, Object.defineProperty(Rs, "__esModule", { value: !0 }), Rs.macroKeywordCode = i, Rs.funcKeywordCode = s, Rs.validSchemaType = f, Rs.validateKeywordUsage = d;
  const e = ot(), t = li(), r = ui(), n = yg();
  function i(m, v) {
    const { gen: g, keyword: S, schema: _, parentSchema: x, it: y } = m, w = v.macro.call(y.self, _, x, y), k = p(g, S, w);
    y.opts.validateSchema !== !1 && y.self.validateSchema(w, !0);
    const A = g.name("valid");
    m.subschema({
      schema: w,
      schemaPath: e.nil,
      errSchemaPath: `${y.errSchemaPath}/${S}`,
      topSchemaRef: k,
      compositeRule: !0
    }, A), m.pass(A, () => m.error(!0));
  }
  function s(m, v) {
    var g;
    const { gen: S, keyword: _, schema: x, parentSchema: y, $data: w, it: k } = m;
    l(k, v);
    const A = !w && v.compile ? v.compile.call(k.self, x, y, k) : v.validate, T = p(S, _, A), R = S.let("valid");
    m.block$data(R, I), m.ok((g = v.valid) !== null && g !== void 0 ? g : R);
    function I() {
      if (v.errors === !1)
        Y(), v.modifying && o(m), Q(() => m.error());
      else {
        const re = v.async ? B() : L();
        v.modifying && o(m), Q(() => a(m, re));
      }
    }
    function B() {
      const re = S.let("ruleErrs", null);
      return S.try(() => Y((0, e._)`await `), (oe) => S.assign(R, !1).if((0, e._)`${oe} instanceof ${k.ValidationError}`, () => S.assign(re, (0, e._)`${oe}.errors`), () => S.throw(oe))), re;
    }
    function L() {
      const re = (0, e._)`${T}.errors`;
      return S.assign(re, null), Y(e.nil), re;
    }
    function Y(re = v.async ? (0, e._)`await ` : e.nil) {
      const oe = k.opts.passContext ? t.default.this : t.default.self, ce = !("compile" in v && !w || v.schema === !1);
      S.assign(R, (0, e._)`${re}${(0, r.callValidateCode)(m, T, oe, ce)}`, v.modifying);
    }
    function Q(re) {
      var oe;
      S.if((0, e.not)((oe = v.valid) !== null && oe !== void 0 ? oe : R), re);
    }
  }
  function o(m) {
    const { gen: v, data: g, it: S } = m;
    v.if(S.parentData, () => v.assign(g, (0, e._)`${S.parentData}[${S.parentDataProperty}]`));
  }
  function a(m, v) {
    const { gen: g } = m;
    g.if((0, e._)`Array.isArray(${v})`, () => {
      g.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${v} : ${t.default.vErrors}.concat(${v})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, n.extendErrors)(m);
    }, () => m.error());
  }
  function l({ schemaEnv: m }, v) {
    if (v.async && !m.$async)
      throw new Error("async keyword in sync schema");
  }
  function p(m, v, g) {
    if (g === void 0)
      throw new Error(`keyword "${v}" failed to compile`);
    return m.scopeValue("keyword", typeof g == "function" ? { ref: g } : { ref: g, code: (0, e.stringify)(g) });
  }
  function f(m, v, g = !1) {
    return !v.length || v.some((S) => S === "array" ? Array.isArray(m) : S === "object" ? m && typeof m == "object" && !Array.isArray(m) : typeof m == S || g && typeof m > "u");
  }
  function d({ schema: m, opts: v, self: g, errSchemaPath: S }, _, x) {
    if (Array.isArray(_.keyword) ? !_.keyword.includes(x) : _.keyword !== x)
      throw new Error("ajv implementation error");
    const y = _.dependencies;
    if (y != null && y.some((w) => !Object.prototype.hasOwnProperty.call(m, w)))
      throw new Error(`parent schema must have dependencies of ${x}: ${y.join(",")}`);
    if (_.validateSchema && !_.validateSchema(m[x])) {
      const k = `keyword "${x}" value is invalid at path "${S}": ` + g.errorsText(_.validateSchema.errors);
      if (v.validateSchema === "log")
        g.logger.error(k);
      else
        throw new Error(k);
    }
  }
  return Rs;
}
var Wa = {}, yA;
function oH() {
  if (yA) return Wa;
  yA = 1, Object.defineProperty(Wa, "__esModule", { value: !0 }), Wa.getSubschema = r, Wa.extendSubschemaData = n, Wa.extendSubschemaMode = i;
  const e = ot(), t = ct();
  function r(s, { keyword: o, schemaProp: a, schema: l, schemaPath: p, errSchemaPath: f, topSchemaRef: d }) {
    if (o !== void 0 && l !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (o !== void 0) {
      const m = s.schema[o];
      return a === void 0 ? {
        schema: m,
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(o)}`,
        errSchemaPath: `${s.errSchemaPath}/${o}`
      } : {
        schema: m[a],
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(o)}${(0, e.getProperty)(a)}`,
        errSchemaPath: `${s.errSchemaPath}/${o}/${(0, t.escapeFragment)(a)}`
      };
    }
    if (l !== void 0) {
      if (p === void 0 || f === void 0 || d === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: l,
        schemaPath: p,
        topSchemaRef: d,
        errSchemaPath: f
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  function n(s, o, { dataProp: a, dataPropType: l, data: p, dataTypes: f, propertyName: d }) {
    if (p !== void 0 && a !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: m } = o;
    if (a !== void 0) {
      const { errorPath: g, dataPathArr: S, opts: _ } = o, x = m.let("data", (0, e._)`${o.data}${(0, e.getProperty)(a)}`, !0);
      v(x), s.errorPath = (0, e.str)`${g}${(0, t.getErrorPath)(a, l, _.jsPropertySyntax)}`, s.parentDataProperty = (0, e._)`${a}`, s.dataPathArr = [...S, s.parentDataProperty];
    }
    if (p !== void 0) {
      const g = p instanceof e.Name ? p : m.let("data", p, !0);
      v(g), d !== void 0 && (s.propertyName = d);
    }
    f && (s.dataTypes = f);
    function v(g) {
      s.data = g, s.dataLevel = o.dataLevel + 1, s.dataTypes = [], o.definedProperties = /* @__PURE__ */ new Set(), s.parentData = o.data, s.dataNames = [...o.dataNames, g];
    }
  }
  function i(s, { jtdDiscriminator: o, jtdMetadata: a, compositeRule: l, createErrors: p, allErrors: f }) {
    l !== void 0 && (s.compositeRule = l), p !== void 0 && (s.createErrors = p), f !== void 0 && (s.allErrors = f), s.jtdDiscriminator = o, s.jtdMetadata = a;
  }
  return Wa;
}
var Qi = {}, Wv, vA;
function TN() {
  return vA || (vA = 1, Wv = function e(t, r) {
    if (t === r) return !0;
    if (t && r && typeof t == "object" && typeof r == "object") {
      if (t.constructor !== r.constructor) return !1;
      var n, i, s;
      if (Array.isArray(t)) {
        if (n = t.length, n != r.length) return !1;
        for (i = n; i-- !== 0; )
          if (!e(t[i], r[i])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
      if (s = Object.keys(t), n = s.length, n !== Object.keys(r).length) return !1;
      for (i = n; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, s[i])) return !1;
      for (i = n; i-- !== 0; ) {
        var o = s[i];
        if (!e(t[o], r[o])) return !1;
      }
      return !0;
    }
    return t !== t && r !== r;
  }), Wv;
}
var Hv = { exports: {} }, bA;
function sH() {
  if (bA) return Hv.exports;
  bA = 1;
  var e = Hv.exports = function(n, i, s) {
    typeof i == "function" && (s = i, i = {}), s = i.cb || s;
    var o = typeof s == "function" ? s : s.pre || function() {
    }, a = s.post || function() {
    };
    t(i, o, a, n, "", n);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(n, i, s, o, a, l, p, f, d, m) {
    if (o && typeof o == "object" && !Array.isArray(o)) {
      i(o, a, l, p, f, d, m);
      for (var v in o) {
        var g = o[v];
        if (Array.isArray(g)) {
          if (v in e.arrayKeywords)
            for (var S = 0; S < g.length; S++)
              t(n, i, s, g[S], a + "/" + v + "/" + S, l, a, v, o, S);
        } else if (v in e.propsKeywords) {
          if (g && typeof g == "object")
            for (var _ in g)
              t(n, i, s, g[_], a + "/" + v + "/" + r(_), l, a, v, o, _);
        } else (v in e.keywords || n.allKeys && !(v in e.skipKeywords)) && t(n, i, s, g, a + "/" + v, l, a, v, o);
      }
      s(o, a, l, p, f, d, m);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return Hv.exports;
}
var wA;
function vg() {
  if (wA) return Qi;
  wA = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.inlineRef = i, Qi.getFullPath = l, Qi._getFullPath = p, Qi.normalizeId = d, Qi.resolveUrl = m, Qi.getSchemaRefs = g;
  const e = ct(), t = TN(), r = sH(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function i(S, _ = !0) {
    return typeof S == "boolean" ? !0 : _ === !0 ? !o(S) : _ ? a(S) <= _ : !1;
  }
  const s = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function o(S) {
    for (const _ in S) {
      if (s.has(_))
        return !0;
      const x = S[_];
      if (Array.isArray(x) && x.some(o) || typeof x == "object" && o(x))
        return !0;
    }
    return !1;
  }
  function a(S) {
    let _ = 0;
    for (const x in S) {
      if (x === "$ref")
        return 1 / 0;
      if (_++, !n.has(x) && (typeof S[x] == "object" && (0, e.eachItem)(S[x], (y) => _ += a(y)), _ === 1 / 0))
        return 1 / 0;
    }
    return _;
  }
  function l(S, _ = "", x) {
    x !== !1 && (_ = d(_));
    const y = S.parse(_);
    return p(S, y);
  }
  function p(S, _) {
    return S.serialize(_).split("#")[0] + "#";
  }
  const f = /#\/?$/;
  function d(S) {
    return S ? S.replace(f, "") : "";
  }
  function m(S, _, x) {
    return x = d(x), S.resolve(_, x);
  }
  const v = /^[a-z_][-a-z0-9._]*$/i;
  function g(S, _) {
    if (typeof S == "boolean")
      return {};
    const { schemaId: x, uriResolver: y } = this.opts, w = d(S[x] || _), k = { "": w }, A = l(y, w, !1), T = {}, R = /* @__PURE__ */ new Set();
    return r(S, { allKeys: !0 }, (L, Y, Q, re) => {
      if (re === void 0)
        return;
      const oe = A + Y;
      let ce = k[re];
      typeof L[x] == "string" && (ce = pe.call(this, L[x])), fe.call(this, L.$anchor), fe.call(this, L.$dynamicAnchor), k[Y] = ce;
      function pe(G) {
        const Z = this.opts.uriResolver.resolve;
        if (G = d(ce ? Z(ce, G) : G), R.has(G))
          throw B(G);
        R.add(G);
        let K = this.refs[G];
        return typeof K == "string" && (K = this.refs[K]), typeof K == "object" ? I(L, K.schema, G) : G !== d(oe) && (G[0] === "#" ? (I(L, T[G], G), T[G] = L) : this.refs[G] = oe), G;
      }
      function fe(G) {
        if (typeof G == "string") {
          if (!v.test(G))
            throw new Error(`invalid anchor "${G}"`);
          pe.call(this, `#${G}`);
        }
      }
    }), T;
    function I(L, Y, Q) {
      if (Y !== void 0 && !t(L, Y))
        throw B(Q);
    }
    function B(L) {
      return new Error(`reference "${L}" resolves to more than one schema`);
    }
  }
  return Qi;
}
var SA;
function bg() {
  if (SA) return $s;
  SA = 1, Object.defineProperty($s, "__esModule", { value: !0 }), $s.KeywordCxt = void 0, $s.validateFunctionCode = m, $s.getData = Ae;
  const e = rH(), t = _m(), r = CN(), n = _m(), i = nH(), s = iH(), o = oH(), a = ot(), l = li(), p = vg(), f = ct(), d = yg();
  function m(C) {
    if (A(C) && (R(C), k(C))) {
      _(C);
      return;
    }
    v(C, () => (0, e.topBoolOrEmptySchema)(C));
  }
  function v({ gen: C, validateName: N, schema: J, schemaEnv: X, opts: ae }, U) {
    ae.code.es5 ? C.func(N, (0, a._)`${l.default.data}, ${l.default.valCxt}`, X.$async, () => {
      C.code((0, a._)`"use strict"; ${y(J, ae)}`), S(C, ae), C.code(U);
    }) : C.func(N, (0, a._)`${l.default.data}, ${g(ae)}`, X.$async, () => C.code(y(J, ae)).code(U));
  }
  function g(C) {
    return (0, a._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${C.dynamicRef ? (0, a._)`, ${l.default.dynamicAnchors}={}` : a.nil}, ${l.default.isAllOfVariant} = 0}={}`;
  }
  function S(C, N) {
    C.if(l.default.valCxt, () => {
      C.var(l.default.instancePath, (0, a._)`${l.default.valCxt}.${l.default.instancePath}`), C.var(l.default.parentData, (0, a._)`${l.default.valCxt}.${l.default.parentData}`), C.var(l.default.parentDataProperty, (0, a._)`${l.default.valCxt}.${l.default.parentDataProperty}`), C.var(l.default.rootData, (0, a._)`${l.default.valCxt}.${l.default.rootData}`), C.var(l.default.isAllOfVariant, (0, a._)`${l.default.valCxt}.${l.default.isAllOfVariant}`), N.dynamicRef && C.var(l.default.dynamicAnchors, (0, a._)`${l.default.valCxt}.${l.default.dynamicAnchors}`);
    }, () => {
      C.var(l.default.instancePath, (0, a._)`""`), C.var(l.default.parentData, (0, a._)`undefined`), C.var(l.default.parentDataProperty, (0, a._)`undefined`), C.var(l.default.rootData, l.default.data), C.var(l.default.isAllOfVariant, (0, a._)`0`), N.dynamicRef && C.var(l.default.dynamicAnchors, (0, a._)`{}`);
    });
  }
  function _(C) {
    const { schema: N, opts: J, gen: X } = C;
    v(C, () => {
      J.$comment && N.$comment && re(C), L(C), X.let(l.default.vErrors, null), X.let(l.default.errors, 0), J.unevaluated && x(C), I(C), oe(C);
    });
  }
  function x(C) {
    const { gen: N, validateName: J } = C;
    C.evaluated = N.const("evaluated", (0, a._)`${J}.evaluated`), N.if((0, a._)`${C.evaluated}.dynamicProps`, () => N.assign((0, a._)`${C.evaluated}.props`, (0, a._)`undefined`)), N.if((0, a._)`${C.evaluated}.dynamicItems`, () => N.assign((0, a._)`${C.evaluated}.items`, (0, a._)`undefined`));
  }
  function y(C, N) {
    const J = typeof C == "object" && C[N.schemaId];
    return J && (N.code.source || N.code.process) ? (0, a._)`/*# sourceURL=${J} */` : a.nil;
  }
  function w(C, N) {
    if (A(C) && (R(C), k(C))) {
      T(C, N);
      return;
    }
    (0, e.boolOrEmptySchema)(C, N);
  }
  function k({ schema: C, self: N }) {
    if (typeof C == "boolean")
      return !C;
    for (const J in C)
      if (N.RULES.all[J])
        return !0;
    return !1;
  }
  function A(C) {
    return typeof C.schema != "boolean";
  }
  function T(C, N) {
    const { schema: J, gen: X, opts: ae } = C;
    ae.$comment && J.$comment && re(C), Y(C), Q(C);
    const U = X.const("_errs", l.default.errors);
    I(C, U), X.var(N, (0, a._)`${U} === ${l.default.errors}`);
  }
  function R(C) {
    (0, f.checkUnknownRules)(C), B(C);
  }
  function I(C, N) {
    if (C.opts.jtd)
      return pe(C, [], !1, N);
    const J = (0, t.getSchemaTypes)(C.schema), X = (0, t.coerceAndCheckDataType)(C, J);
    pe(C, J, !X, N);
  }
  function B(C) {
    const { schema: N, errSchemaPath: J, opts: X, self: ae } = C;
    N.$ref && X.ignoreKeywordsWithRef && (0, f.schemaHasRulesButRef)(N, ae.RULES) && ae.logger.warn(`$ref: keywords ignored in schema at path "${J}"`);
  }
  function L(C) {
    const { schema: N, opts: J } = C;
    N.default !== void 0 && J.useDefaults && J.strictSchema && (0, f.checkStrictMode)(C, "default is ignored in the schema root");
  }
  function Y(C) {
    const N = C.schema[C.opts.schemaId];
    N && (C.baseId = (0, p.resolveUrl)(C.opts.uriResolver, C.baseId, N));
  }
  function Q(C) {
    if (C.schema.$async && !C.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function re({ gen: C, schemaEnv: N, schema: J, errSchemaPath: X, opts: ae }) {
    const U = J.$comment;
    if (ae.$comment === !0)
      C.code((0, a._)`${l.default.self}.logger.log(${U})`);
    else if (typeof ae.$comment == "function") {
      const W = (0, a.str)`${X}/$comment`, ve = C.scopeValue("root", { ref: N.root });
      C.code((0, a._)`${l.default.self}.opts.$comment(${U}, ${W}, ${ve}.schema)`);
    }
  }
  function oe(C) {
    const { gen: N, schemaEnv: J, validateName: X, ValidationError: ae, opts: U } = C;
    J.$async ? N.if((0, a._)`${l.default.errors} === 0`, () => N.return(l.default.data), () => N.throw((0, a._)`new ${ae}(${l.default.vErrors})`)) : (N.assign((0, a._)`${X}.errors`, l.default.vErrors), U.unevaluated && ce(C), N.return((0, a._)`${l.default.errors} === 0`));
  }
  function ce({ gen: C, evaluated: N, props: J, items: X }) {
    J instanceof a.Name && C.assign((0, a._)`${N}.props`, J), X instanceof a.Name && C.assign((0, a._)`${N}.items`, X);
  }
  function pe(C, N, J, X) {
    const { gen: ae, schema: U, data: W, allErrors: ve, opts: he, self: Te } = C, { RULES: Se } = Te;
    if (U.$ref && (he.ignoreKeywordsWithRef || !(0, f.schemaHasRulesButRef)(U, Se))) {
      ae.block(() => F(C, "$ref", Se.all.$ref.definition));
      return;
    }
    he.jtd || G(C, N), ae.block(() => {
      for (const M of Se.rules)
        O(M);
      O(Se.post);
    });
    function O(M) {
      (0, r.shouldUseGroup)(U, M) && (M.type ? (ae.if((0, n.checkDataType)(M.type, W, he.strictNumbers)), fe(C, M), N.length === 1 && N[0] === M.type && J && (ae.else(), (0, n.reportTypeError)(C)), ae.endIf()) : fe(C, M), ve || ae.if((0, a._)`${l.default.errors} === ${X || 0}`));
    }
  }
  function fe(C, N) {
    const { gen: J, schema: X, opts: { useDefaults: ae } } = C;
    ae && (0, i.assignDefaults)(C, N.type), J.block(() => {
      for (const W of N.rules)
        ((0, r.shouldUseRule)(X, W) || U(X, W)) && F(C, W.keyword, W.definition, N.type);
    });
    function U(W, ve) {
      return !!(ve.keyword === "unevaluatedProperties" && (W.properties || W.patternProperties) && !C.isAllOfVariant && C.opts.defaultUnevaluatedProperties === !1);
    }
  }
  function G(C, N) {
    C.schemaEnv.meta || !C.opts.strictTypes || (Z(C, N), C.opts.allowUnionTypes || K(C, N), z(C, C.dataTypes));
  }
  function Z(C, N) {
    if (N.length) {
      if (!C.dataTypes.length) {
        C.dataTypes = N;
        return;
      }
      N.forEach((J) => {
        q(C.dataTypes, J) || j(C, `type "${J}" not allowed by context "${C.dataTypes.join(",")}"`);
      }), C.dataTypes = C.dataTypes.filter((J) => q(N, J));
    }
  }
  function K(C, N) {
    N.length > 1 && !(N.length === 2 && N.includes("null")) && j(C, "use allowUnionTypes to allow union type keyword");
  }
  function z(C, N) {
    const J = C.self.RULES.all;
    for (const X in J) {
      const ae = J[X];
      if (typeof ae == "object" && (0, r.shouldUseRule)(C.schema, ae)) {
        const { type: U } = ae.definition;
        U.length && !U.some((W) => te(N, W)) && j(C, `missing type "${U.join(",")}" for keyword "${X}"`);
      }
    }
  }
  function te(C, N) {
    return C.includes(N) || N === "number" && C.includes("integer");
  }
  function q(C, N) {
    return C.includes(N) || N === "integer" && C.includes("number");
  }
  function j(C, N) {
    const J = C.schemaEnv.baseId + C.errSchemaPath;
    N += ` at "${J}" (strictTypes)`, (0, f.checkStrictMode)(C, N, C.opts.strictTypes);
  }
  class H {
    constructor(N, J, X) {
      if ((0, s.validateKeywordUsage)(N, J, X), this.gen = N.gen, this.allErrors = N.allErrors, this.keyword = X, this.data = N.data, this.schema = N.schema[X], this.$data = J.$data && N.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, f.schemaRefOrVal)(N, this.schema, X, this.$data), this.schemaType = J.schemaType, this.parentSchema = N.schema, this.params = {}, this.it = N, this.def = J, this.$data)
        this.schemaCode = N.gen.const("vSchema", Ae(this.$data, N));
      else if (this.schemaCode = this.schemaValue, !(0, s.validSchemaType)(this.schema, J.schemaType, J.allowUndefined))
        throw new Error(`${X} value must be ${JSON.stringify(J.schemaType)}`);
      ("code" in J ? J.trackErrors : J.errors !== !1) && (this.errsCount = N.gen.const("_errs", l.default.errors));
    }
    result(N, J, X) {
      this.failResult((0, a.not)(N), J, X);
    }
    failResult(N, J, X) {
      this.gen.if(N), X ? X() : this.error(), J ? (this.gen.else(), J(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(N, J) {
      this.failResult((0, a.not)(N), void 0, J);
    }
    fail(N) {
      if (N === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(N), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(N) {
      if (!this.$data)
        return this.fail(N);
      const { schemaCode: J } = this;
      this.fail((0, a._)`${J} !== undefined && (${(0, a.or)(this.invalid$data(), N)})`);
    }
    error(N, J, X) {
      if (J) {
        this.setParams(J), this._error(N, X), this.setParams({});
        return;
      }
      this._error(N, X);
    }
    _error(N, J) {
      (N ? d.reportExtraError : d.reportError)(this, this.def.error, J);
    }
    $dataError() {
      (0, d.reportError)(this, this.def.$dataError || d.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, d.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(N) {
      this.allErrors || this.gen.if(N);
    }
    setParams(N, J) {
      J ? Object.assign(this.params, N) : this.params = N;
    }
    block$data(N, J, X = a.nil) {
      this.gen.block(() => {
        this.check$data(N, X), J();
      });
    }
    check$data(N = a.nil, J = a.nil) {
      if (!this.$data)
        return;
      const { gen: X, schemaCode: ae, schemaType: U, def: W } = this;
      X.if((0, a.or)((0, a._)`${ae} === undefined`, J)), N !== a.nil && X.assign(N, !0), (U.length || W.validateSchema) && (X.elseIf(this.invalid$data()), this.$dataError(), N !== a.nil && X.assign(N, !1)), X.else();
    }
    invalid$data() {
      const { gen: N, schemaCode: J, schemaType: X, def: ae, it: U } = this;
      return (0, a.or)(W(), ve());
      function W() {
        if (X.length) {
          if (!(J instanceof a.Name))
            throw new Error("ajv implementation error");
          const he = Array.isArray(X) ? X : [X];
          return (0, a._)`${(0, n.checkDataTypes)(he, J, U.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return a.nil;
      }
      function ve() {
        if (ae.validateSchema) {
          const he = N.scopeValue("validate$data", { ref: ae.validateSchema });
          return (0, a._)`!${he}(${J})`;
        }
        return a.nil;
      }
    }
    subschema(N, J, X) {
      const ae = (0, o.getSubschema)(this.it, N);
      (0, o.extendSubschemaData)(ae, this.it, N), (0, o.extendSubschemaMode)(ae, N);
      const U = {
        ...this.it,
        ...ae,
        items: void 0,
        props: void 0,
        isAllOfVariant: X
      };
      return w(U, J), U;
    }
    mergeEvaluated(N, J) {
      const { it: X, gen: ae } = this;
      X.opts.unevaluated && (X.props !== !0 && N.props !== void 0 && (X.props = f.mergeEvaluated.props(ae, N.props, X.props, J)), X.items !== !0 && N.items !== void 0 && (X.items = f.mergeEvaluated.items(ae, N.items, X.items, J)));
    }
    mergeValidEvaluated(N, J) {
      const { it: X, gen: ae } = this;
      if (X.opts.unevaluated && (X.props !== !0 || X.items !== !0))
        return ae.if(J, () => this.mergeEvaluated(N, a.Name)), !0;
    }
  }
  $s.KeywordCxt = H;
  function F(C, N, J, X) {
    const ae = new H(C, J, N);
    "code" in J ? J.code(ae, X) : ae.$data && J.validate ? (0, s.funcKeywordCode)(ae, J) : "macro" in J ? (0, s.macroKeywordCode)(ae, J) : (J.compile || J.validate) && (0, s.funcKeywordCode)(ae, J);
  }
  const ue = /^\/(?:[^~]|~0|~1)*$/, ge = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function Ae(C, { dataLevel: N, dataNames: J, dataPathArr: X }) {
    let ae, U;
    if (C === "")
      return l.default.rootData;
    if (C[0] === "/") {
      if (!ue.test(C))
        throw new Error(`Invalid JSON-pointer: ${C}`);
      ae = C, U = l.default.rootData;
    } else {
      const Te = ge.exec(C);
      if (!Te)
        throw new Error(`Invalid JSON-pointer: ${C}`);
      const Se = +Te[1];
      if (ae = Te[2], ae === "#") {
        if (Se >= N)
          throw new Error(he("property/index", Se));
        return X[N - Se];
      }
      if (Se > N)
        throw new Error(he("data", Se));
      if (U = J[N - Se], !ae)
        return U;
    }
    let W = U;
    const ve = ae.split("/");
    for (const Te of ve)
      Te && (U = (0, a._)`${U}${(0, a.getProperty)((0, f.unescapeJsonPointer)(Te))}`, W = (0, a._)`${W} && ${U}`);
    return W;
    function he(Te, Se) {
      return `Cannot access ${Te} ${Se} levels up, current level is ${N}`;
    }
  }
  return $s;
}
var pd = {}, xA;
function $N() {
  if (xA) return pd;
  xA = 1, Object.defineProperty(pd, "__esModule", { value: !0 });
  class e extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return pd.default = e, pd;
}
var fd = {}, _A;
function RN() {
  if (_A) return fd;
  _A = 1, Object.defineProperty(fd, "__esModule", { value: !0 });
  const e = vg();
  class t extends Error {
    constructor(n, i, s, o) {
      super(o || `can't resolve reference ${s} from id ${i}`), this.missingRef = (0, e.resolveUrl)(n, i, s), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(n, this.missingRef));
    }
  }
  return fd.default = t, fd;
}
var Yi = {}, EA;
function wg() {
  if (EA) return Yi;
  EA = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.SchemaEnv = void 0, Yi.compileSchema = a, Yi.resolveRef = l, Yi.getCompilingSchema = f, Yi.resolveSchema = v;
  const e = ot(), t = $N(), r = li(), n = vg(), i = ct(), s = bg();
  class o {
    constructor(x) {
      var y;
      this.refs = {}, this.dynamicAnchors = {};
      let w;
      typeof x.schema == "object" && (w = x.schema), this.schema = x.schema, this.schemaId = x.schemaId, this.root = x.root || this, this.baseId = (y = x.baseId) !== null && y !== void 0 ? y : (0, n.normalizeId)(w == null ? void 0 : w[x.schemaId || "$id"]), this.schemaPath = x.schemaPath, this.localRefs = x.localRefs, this.meta = x.meta, this.$async = w == null ? void 0 : w.$async, this.refs = {};
    }
  }
  Yi.SchemaEnv = o;
  function a(_) {
    const x = f.call(this, _);
    if (x)
      return x;
    const y = (0, n.getFullPath)(this.opts.uriResolver, _.root.baseId), { es5: w, lines: k } = this.opts.code, { ownProperties: A } = this.opts, T = new e.CodeGen(this.scope, { es5: w, lines: k, ownProperties: A });
    let R;
    _.$async && (R = T.scopeValue("Error", {
      ref: t.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const I = T.scopeName("validate");
    _.validateName = I;
    const B = {
      gen: T,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: T.scopeValue("schema", this.opts.code.source === !0 ? { ref: _.schema, code: (0, e.stringify)(_.schema) } : { ref: _.schema }),
      validateName: I,
      ValidationError: R,
      schema: _.schema,
      schemaEnv: _,
      rootId: y,
      baseId: _.baseId || y,
      schemaPath: e.nil,
      errSchemaPath: _.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let L;
    try {
      this._compilations.add(_), (0, s.validateFunctionCode)(B), T.optimize(this.opts.code.optimize);
      const Y = T.toString();
      L = `const visitedNodesForRef = new WeakMap(); ${T.scopeRefs(r.default.scope)}return ${Y}`, this.opts.code.process && (L = this.opts.code.process(L, _));
      const re = new Function(`${r.default.self}`, `${r.default.scope}`, L)(this, this.scope.get());
      if (this.scope.value(I, { ref: re }), re.errors = null, re.schema = _.schema, re.schemaEnv = _, _.$async && (re.$async = !0), this.opts.code.source === !0 && (re.source = { validateName: I, validateCode: Y, scopeValues: T._values }), this.opts.unevaluated) {
        const { props: oe, items: ce } = B;
        re.evaluated = {
          props: oe instanceof e.Name ? void 0 : oe,
          items: ce instanceof e.Name ? void 0 : ce,
          dynamicProps: oe instanceof e.Name,
          dynamicItems: ce instanceof e.Name
        }, re.source && (re.source.evaluated = (0, e.stringify)(re.evaluated));
      }
      return _.validate = re, _;
    } catch (Y) {
      throw delete _.validate, delete _.validateName, L && this.logger.error("Error compiling schema, function code:", L), Y;
    } finally {
      this._compilations.delete(_);
    }
  }
  function l(_, x, y) {
    var w;
    const k = (0, n.resolveUrl)(this.opts.uriResolver, x, y), A = _.refs[k];
    if (A)
      return A;
    let T = m.call(this, _, k);
    if (T === void 0) {
      const R = (w = _.localRefs) === null || w === void 0 ? void 0 : w[k], { schemaId: I } = this.opts;
      R && (T = new o({ schema: R, schemaId: I, root: _, baseId: x }));
    }
    if (T === void 0 && this.opts.loadSchemaSync) {
      const R = this.opts.loadSchemaSync(x, y, k);
      R && !(this.refs[k] || this.schemas[k]) && (this.addSchema(R, k, void 0), T = m.call(this, _, k));
    }
    if (T !== void 0)
      return _.refs[k] = p.call(this, T);
  }
  function p(_) {
    return (0, n.inlineRef)(_.schema, this.opts.inlineRefs) ? _.schema : _.validate ? _ : a.call(this, _);
  }
  function f(_) {
    for (const x of this._compilations)
      if (d(x, _))
        return x;
  }
  function d(_, x) {
    return _.schema === x.schema && _.root === x.root && _.baseId === x.baseId;
  }
  function m(_, x) {
    let y;
    for (; typeof (y = this.refs[x]) == "string"; )
      x = y;
    return y || this.schemas[x] || v.call(this, _, x);
  }
  function v(_, x) {
    const y = this.opts.uriResolver.parse(x), w = (0, n._getFullPath)(this.opts.uriResolver, y);
    let k = (0, n.getFullPath)(this.opts.uriResolver, _.baseId, void 0);
    if (Object.keys(_.schema).length > 0 && w === k)
      return S.call(this, y, _);
    const A = (0, n.normalizeId)(w), T = this.refs[A] || this.schemas[A];
    if (typeof T == "string") {
      const R = v.call(this, _, T);
      return typeof (R == null ? void 0 : R.schema) != "object" ? void 0 : S.call(this, y, R);
    }
    if (typeof (T == null ? void 0 : T.schema) == "object") {
      if (T.validate || a.call(this, T), A === (0, n.normalizeId)(x)) {
        const { schema: R } = T, { schemaId: I } = this.opts, B = R[I];
        return B && (k = (0, n.resolveUrl)(this.opts.uriResolver, k, B)), new o({ schema: R, schemaId: I, root: _, baseId: k });
      }
      return S.call(this, y, T);
    }
  }
  const g = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function S(_, { baseId: x, schema: y, root: w }) {
    var k;
    if (((k = _.fragment) === null || k === void 0 ? void 0 : k[0]) !== "/")
      return;
    for (const R of _.fragment.slice(1).split("/")) {
      if (typeof y == "boolean")
        return;
      const I = y[(0, i.unescapeFragment)(R)];
      if (I === void 0)
        return;
      y = I;
      const B = typeof y == "object" && y[this.opts.schemaId];
      !g.has(R) && B && (x = (0, n.resolveUrl)(this.opts.uriResolver, x, B));
    }
    let A;
    if (typeof y != "boolean" && y.$ref && !(0, i.schemaHasRulesButRef)(y, this.RULES)) {
      const R = (0, n.resolveUrl)(this.opts.uriResolver, x, y.$ref);
      A = v.call(this, w, R);
    }
    const { schemaId: T } = this.opts;
    if (A = A || new o({ schema: y, schemaId: T, root: w, baseId: x }), A.schema !== A.root.schema)
      return A;
  }
  return Yi;
}
const aH = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", lH = "Meta-schema for $data reference (JSON AnySchema extension proposal)", uH = "object", cH = [
  "$data"
], pH = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, fH = !1, dH = {
  $id: aH,
  description: lH,
  type: uH,
  required: cH,
  properties: pH,
  additionalProperties: fH
};
var dd = {}, Qv = {}, Qu = {}, OA;
function qb() {
  if (OA) return Qu;
  OA = 1, Object.defineProperty(Qu, "__esModule", { value: !0 }), Qu.serialize = void 0;
  function e(s) {
    let o = i(s), a;
    try {
      a = new URL(o.startUrl);
    } catch (p) {
      return p.message && console.error(p.message + " " + o.startUrl), "";
    }
    if (s.scheme !== void 0 && !o.temporarySchemeAndHostUsed && !o.temporarySchemeUsed ? a.protocol = s.scheme.toLowerCase() : a.protocol = "", s.host !== void 0 && !o.temporarySchemeAndHostUsed && !o.temporaryHostUsed ? a.host = s.host : a.host = "", s.port && (a.port = String(s.port)), s.path && (a.pathname = s.path), s.userinfo) {
      let p = s.userinfo.split(":");
      p[0] && (a.username = p[0]), p[1] && (a.password = p[1]);
    }
    s.query && (a.search = s.query), s.fragment && (a.hash = s.fragment);
    let l = a.toString();
    return !s.path && l.endsWith("/") && (l = l.slice(0, -1)), o.temporarySchemeAndHostUsed && (l = l.replace(n, ""), l.startsWith("/") && (l = l.slice(1))), o.temporaryHostUsed && (l = l.replace(r, "")), o.temporarySchemeUsed && (l = l.replace(t, "")), l;
  }
  Qu.serialize = e;
  const t = "https:", r = "_remove_me_host_", n = t + "//" + r;
  function i(s) {
    let o = {
      startUrl: "",
      temporaryHostUsed: !1,
      temporarySchemeUsed: !1,
      temporarySchemeAndHostUsed: !1
    };
    return s.scheme && s.host ? (o.startUrl = s.scheme + "://" + s.host, o) : s.host ? (o.temporarySchemeUsed = !0, o.startUrl = t + s.host, o) : s.scheme ? s.path ? (o.startUrl = s.scheme + ":" + s.path, o) : (o.temporaryHostUsed = !0, o.startUrl = s.scheme + ":" + r, o) : (o.temporarySchemeAndHostUsed = !0, o.startUrl = n, o);
  }
  return Qu;
}
var Yu = {}, kA;
function Bb() {
  if (kA) return Yu;
  kA = 1, Object.defineProperty(Yu, "__esModule", { value: !0 }), Yu.parse = void 0;
  function e(n) {
    let i = {
      path: "",
      fragment: void 0,
      host: void 0,
      port: void 0,
      query: void 0,
      reference: void 0,
      scheme: void 0,
      userinfo: void 0
    };
    n.includes("#") && (i.fragment = "");
    let { parsed: s, addedDefaultScheme: o, addedTemporaryHost: a, error: l } = r(n);
    if (l || s === void 0)
      return i.error = l, i;
    if (typeof s.protocol !== void 0 && s.protocol !== "" && !o && (i.scheme = String(s.protocol).replace(":", "")), typeof s.username !== void 0 && s.username !== "") {
      let p = s.username;
      s.password && (p += ":" + s.password), i.userinfo = p;
    }
    return typeof s.hostname !== void 0 && s.hostname !== "" && !a && (i.host = s.hostname, i.host.startsWith("[") && (i.host = i.host.substring(1), i.host = i.host.slice(0, -1))), typeof s.port !== void 0 && s.port !== "" && (i.port = Number(s.port)), typeof s.pathname !== void 0 && s.pathname !== "/" && (i.path = s.pathname, a && i.path.startsWith("/") && (i.path = i.path.substring(1))), typeof s.search !== void 0 && s.search !== "" && (i.query = s.search.replace("?", "")), typeof s.hash !== void 0 && s.hash !== "" && (i.fragment = s.hash.replace("#", "")), i.scheme === void 0 && i.userinfo === void 0 && i.host === void 0 && i.port === void 0 && !i.path && i.query === void 0 ? i.reference = "same-document" : i.scheme === void 0 ? i.reference = "relative" : i.fragment === void 0 ? i.reference = "absolute" : i.reference = "uri", i;
  }
  Yu.parse = e;
  const t = "_remove_me_host/";
  function r(n) {
    let i = {
      parsed: void 0,
      addedDefaultScheme: !1,
      addedTemporaryHost: !1,
      error: void 0
    }, s;
    try {
      return i.parsed = new URL(n), i;
    } catch (o) {
      s = o;
    }
    if (n.startsWith("//"))
      try {
        return i.parsed = new URL("https:" + n), i.addedDefaultScheme = !0, i;
      } catch {
        return i.error = s.message, i;
      }
    try {
      return i.parsed = new URL("https://" + t + n), i.addedDefaultScheme = !0, i.addedTemporaryHost = !0, i;
    } catch {
    }
    return i.error = s.message, i;
  }
  return Yu;
}
var Is = {}, AA;
function hH() {
  if (AA) return Is;
  AA = 1, Object.defineProperty(Is, "__esModule", { value: !0 }), Is.resolveComponents = Is.resolve = void 0;
  const e = Bb(), t = qb();
  function r(s, o, a) {
    const l = Object.assign({ scheme: "null" }, a), p = n((0, e.parse)(s), (0, e.parse)(o), l, !0);
    return (0, t.serialize)(p);
  }
  Is.resolve = r;
  function n(s, o, a, l) {
    const p = {};
    return l || (s = (0, e.parse)((0, t.serialize)(s)), o = (0, e.parse)((0, t.serialize)(o))), a = a || {}, !a.tolerant && o.scheme ? (p.scheme = o.scheme, p.userinfo = o.userinfo, p.host = o.host, p.port = o.port, p.path = i(o.path || ""), p.query = o.query) : (o.userinfo !== void 0 || o.host !== void 0 || o.port !== void 0 ? (p.userinfo = o.userinfo, p.host = o.host, p.port = o.port, p.path = i(o.path || ""), p.query = o.query) : (o.path ? (o.path.charAt(0) === "/" ? p.path = i(o.path) : ((s.userinfo !== void 0 || s.host !== void 0 || s.port !== void 0) && !s.path ? p.path = "/" + o.path : s.path ? p.path = s.path.slice(0, s.path.lastIndexOf("/") + 1) + o.path : p.path = o.path, p.path = i(p.path)), p.query = o.query) : (p.path = s.path, o.query !== void 0 ? p.query = o.query : p.query = s.query), p.userinfo = s.userinfo, p.host = s.host, p.port = s.port), p.scheme = s.scheme), p.fragment = o.fragment, p;
  }
  Is.resolveComponents = n;
  function i(s) {
    const o = /^\.\.?\//u, a = /^\/\.(?:\/|$)/u, l = /^\/\.\.(?:\/|$)/u, p = /^\/?(?:.|\n)*?(?=\/|$)/u, f = [];
    for (; s.length; )
      if (s.match(o))
        s = s.replace(o, "");
      else if (s.match(a))
        s = s.replace(a, "/");
      else if (s.match(l))
        s = s.replace(l, "/"), f.pop();
      else if (s === "." || s === "..")
        s = "";
      else {
        const d = s.match(p);
        if (d) {
          const m = d[0];
          s = s.slice(m.length), f.push(m);
        } else
          throw new Error("Unexpected dot segment condition");
      }
    return f.join("");
  }
  return Is;
}
var PA;
function mH() {
  return PA || (PA = 1, function(e) {
    var t = pn && pn.__createBinding || (Object.create ? function(a, l, p, f) {
      f === void 0 && (f = p);
      var d = Object.getOwnPropertyDescriptor(l, p);
      (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return l[p];
      } }), Object.defineProperty(a, f, d);
    } : function(a, l, p, f) {
      f === void 0 && (f = p), a[f] = l[p];
    }), r = pn && pn.__exportStar || function(a, l) {
      for (var p in a) p !== "default" && !Object.prototype.hasOwnProperty.call(l, p) && t(l, a, p);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.normalize = e.equal = void 0;
    const n = qb(), i = Bb();
    r(hH(), e), r(qb(), e), r(Bb(), e);
    function s(a, l) {
      let p, f;
      return typeof a == "string" ? p = (0, n.serialize)((0, i.parse)(a)) : p = (0, n.serialize)(a), typeof l == "string" ? f = (0, n.serialize)((0, i.parse)(l)) : f = (0, n.serialize)(l), p.toLowerCase() === f.toLowerCase();
    }
    e.equal = s;
    function o(a) {
      return typeof a == "string" ? (0, n.serialize)((0, i.parse)(a)) : (0, i.parse)((0, n.serialize)(a));
    }
    e.normalize = o;
  }(Qv)), Qv;
}
var CA;
function gH() {
  if (CA) return dd;
  CA = 1, Object.defineProperty(dd, "__esModule", { value: !0 });
  const e = mH();
  return e.code = 'require("ajv/dist/runtime/uri").default', dd.default = e, dd;
}
var TA;
function yH() {
  return TA || (TA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var t = bg();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return t.KeywordCxt;
    } });
    var r = ot();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = $N(), i = RN(), s = PN(), o = wg(), a = ot(), l = vg(), p = _m(), f = ct(), d = dH, m = gH(), v = (K, z) => new RegExp(K, z);
    v.code = "new RegExp";
    const g = [
      "removeAdditional",
      "useDefaults",
      "coerceTypes",
      "defaultUnevaluatedProperties",
      "defaultAdditionalProperties"
    ], S = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), _ = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, x = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, y = 200;
    function w(K) {
      var z, te, q, j, H, F, ue, ge, Ae, C, N, J, X, ae, U, W, ve, he, Te, Se, O, M, le, ye, be;
      const Pe = K.strict, ke = (z = K.code) === null || z === void 0 ? void 0 : z.optimize, Me = ke === !0 || ke === void 0 ? 1 : ke || 0, We = (q = (te = K.code) === null || te === void 0 ? void 0 : te.regExp) !== null && q !== void 0 ? q : v, Xe = (j = K.uriResolver) !== null && j !== void 0 ? j : m.default;
      return {
        strictSchema: (F = (H = K.strictSchema) !== null && H !== void 0 ? H : Pe) !== null && F !== void 0 ? F : !0,
        strictNumbers: (ge = (ue = K.strictNumbers) !== null && ue !== void 0 ? ue : Pe) !== null && ge !== void 0 ? ge : !0,
        strictTypes: (C = (Ae = K.strictTypes) !== null && Ae !== void 0 ? Ae : Pe) !== null && C !== void 0 ? C : "log",
        strictTuples: (J = (N = K.strictTuples) !== null && N !== void 0 ? N : Pe) !== null && J !== void 0 ? J : "log",
        strictRequired: (ae = (X = K.strictRequired) !== null && X !== void 0 ? X : Pe) !== null && ae !== void 0 ? ae : !1,
        code: K.code ? { ...K.code, optimize: Me, regExp: We } : { optimize: Me, regExp: We },
        loopRequired: (U = K.loopRequired) !== null && U !== void 0 ? U : y,
        loopEnum: (W = K.loopEnum) !== null && W !== void 0 ? W : y,
        meta: (ve = K.meta) !== null && ve !== void 0 ? ve : !0,
        messages: (he = K.messages) !== null && he !== void 0 ? he : !0,
        inlineRefs: (Te = K.inlineRefs) !== null && Te !== void 0 ? Te : !0,
        schemaId: (Se = K.schemaId) !== null && Se !== void 0 ? Se : "$id",
        addUsedSchema: (O = K.addUsedSchema) !== null && O !== void 0 ? O : !0,
        validateSchema: (M = K.validateSchema) !== null && M !== void 0 ? M : !0,
        validateFormats: (le = K.validateFormats) !== null && le !== void 0 ? le : !0,
        unicodeRegExp: (ye = K.unicodeRegExp) !== null && ye !== void 0 ? ye : !0,
        int32range: (be = K.int32range) !== null && be !== void 0 ? be : !0,
        uriResolver: Xe
      };
    }
    class k {
      constructor(z = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), z = this.opts = { ...z, ...w(z) };
        const { es5: te, lines: q } = this.opts.code;
        this.scope = new a.ValueScope({ scope: {}, prefixes: S, es5: te, lines: q }), this.logger = Q(z.logger);
        const j = z.validateFormats;
        z.validateFormats = !1, this.RULES = (0, s.getRules)(), A.call(this, _, z, "NOT SUPPORTED"), A.call(this, x, z, "DEPRECATED", "warn"), this._metaOpts = L.call(this), z.formats && I.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), z.keywords && B.call(this, z.keywords), typeof z.meta == "object" && this.addMetaSchema(z.meta), R.call(this), z.validateFormats = j;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: z, meta: te, schemaId: q } = this.opts;
        let j = d;
        q === "id" && (j = { ...d }, j.id = j.$id, delete j.$id), te && z && this.addMetaSchema(j, j[q], !1);
      }
      defaultMeta() {
        const { meta: z, schemaId: te } = this.opts;
        return this.opts.defaultMeta = typeof z == "object" ? z[te] || z : void 0;
      }
      validate(z, te) {
        let q;
        if (typeof z == "string") {
          if (q = this.getSchema(z), !q)
            throw new Error(`no schema with key or ref "${z}"`);
        } else
          q = this.compile(z);
        const j = q(te);
        return "$async" in q || (this.errors = q.errors), j;
      }
      compile(z, te) {
        const q = this._addSchema(z, te);
        return q.validate || this._compileSchemaEnv(q);
      }
      compileAsync(z, te) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: q } = this.opts;
        return j.call(this, z, te);
        async function j(C, N) {
          await H.call(this, C.$schema);
          const J = this._addSchema(C, N);
          return J.validate || F.call(this, J);
        }
        async function H(C) {
          C && !this.getSchema(C) && await j.call(this, { $ref: C }, !0);
        }
        async function F(C) {
          try {
            return this._compileSchemaEnv(C);
          } catch (N) {
            if (!(N instanceof i.default))
              throw N;
            return ue.call(this, N), await ge.call(this, N.missingSchema), F.call(this, C);
          }
        }
        function ue({ missingSchema: C, missingRef: N }) {
          if (this.refs[C])
            throw new Error(`AnySchema ${C} is loaded but ${N} cannot be resolved`);
        }
        async function ge(C) {
          const N = await Ae.call(this, C);
          this.refs[C] || await H.call(this, N.$schema), this.refs[C] || this.addSchema(N, C, te);
        }
        async function Ae(C) {
          const N = this._loading[C];
          if (N)
            return N;
          try {
            return await (this._loading[C] = q(C));
          } finally {
            delete this._loading[C];
          }
        }
      }
      // Adds schema to the instance
      addSchema(z, te, q, j = this.opts.validateSchema) {
        if (Array.isArray(z)) {
          for (const F of z)
            this.addSchema(F, void 0, q, j);
          return this;
        }
        let H;
        if (typeof z == "object") {
          const { schemaId: F } = this.opts;
          if (H = z[F], H !== void 0 && typeof H != "string")
            throw new Error(`schema ${F} must be string`);
        }
        return te = (0, l.normalizeId)(te || H), this._checkUnique(te), this.schemas[te] = this._addSchema(z, q, te, j, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(z, te, q = this.opts.validateSchema) {
        return this.addSchema(z, te, !0, q), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(z, te) {
        if (typeof z == "boolean")
          return !0;
        let q;
        if (q = z.$schema, q !== void 0 && typeof q != "string")
          throw new Error("$schema must be a string");
        if (q = q || this.opts.defaultMeta || this.defaultMeta(), !q)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const j = this.validate(q, z);
        if (!j && te) {
          const H = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(H);
          else
            throw new Error(H);
        }
        return j;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(z) {
        let te;
        for (; typeof (te = T.call(this, z)) == "string"; )
          z = te;
        if (te === void 0) {
          const { schemaId: q } = this.opts, j = new o.SchemaEnv({ schema: {}, schemaId: q });
          if (te = o.resolveSchema.call(this, j, z), !te)
            return;
          this.refs[z] = te;
        }
        return te.validate || this._compileSchemaEnv(te);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(z) {
        if (z instanceof RegExp)
          return this._removeAllSchemas(this.schemas, z), this._removeAllSchemas(this.refs, z), this;
        switch (typeof z) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const te = T.call(this, z);
            return typeof te == "object" && this._cache.delete(te.schema), delete this.schemas[z], delete this.refs[z], this;
          }
          case "object": {
            const te = z;
            this._cache.delete(te);
            let q = z[this.opts.schemaId];
            return q && (q = (0, l.normalizeId)(q), delete this.schemas[q], delete this.refs[q]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(z) {
        for (const te of z)
          this.addKeyword(te);
        return this;
      }
      addKeyword(z, te) {
        let q;
        if (typeof z == "string")
          q = z, typeof te == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), te.keyword = q);
        else if (typeof z == "object" && te === void 0) {
          if (te = z, q = te.keyword, Array.isArray(q) && !q.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (oe.call(this, q, te), !te)
          return (0, f.eachItem)(q, (H) => ce.call(this, H)), this;
        fe.call(this, te);
        const j = {
          ...te,
          type: (0, p.getJSONTypes)(te.type),
          schemaType: (0, p.getJSONTypes)(te.schemaType)
        };
        return (0, f.eachItem)(q, j.type.length === 0 ? (H) => ce.call(this, H, j) : (H) => j.type.forEach((F) => ce.call(this, H, j, F))), this;
      }
      getKeyword(z) {
        const te = this.RULES.all[z];
        return typeof te == "object" ? te.definition : !!te;
      }
      // Remove keyword
      removeKeyword(z) {
        const { RULES: te } = this;
        delete te.keywords[z], delete te.all[z];
        for (const q of te.rules) {
          const j = q.rules.findIndex((H) => H.keyword === z);
          j >= 0 && q.rules.splice(j, 1);
        }
        return this;
      }
      // Add format
      addFormat(z, te) {
        return typeof te == "string" && (te = new RegExp(te)), this.formats[z] = te, this;
      }
      errorsText(z = this.errors, { separator: te = ", ", dataVar: q = "data" } = {}) {
        return !z || z.length === 0 ? "No errors" : z.map((j) => `${q}${j.instancePath} ${j.message}`).reduce((j, H) => j + te + H);
      }
      $dataMetaSchema(z, te) {
        const q = this.RULES.all;
        z = JSON.parse(JSON.stringify(z));
        for (const j of te) {
          const H = j.split("/").slice(1);
          let F = z;
          for (const ue of H)
            F = F[ue];
          for (const ue in q) {
            const ge = q[ue];
            if (typeof ge != "object")
              continue;
            const { $data: Ae } = ge.definition, C = F[ue];
            Ae && C && (F[ue] = Z(C));
          }
        }
        return z;
      }
      _removeAllSchemas(z, te) {
        for (const q in z) {
          const j = z[q];
          (!te || te.test(q)) && (typeof j == "string" ? delete z[q] : j && !j.meta && (this._cache.delete(j.schema), delete z[q]));
        }
      }
      _addSchema(z, te, q, j = this.opts.validateSchema, H = this.opts.addUsedSchema) {
        let F;
        const { schemaId: ue } = this.opts;
        if (typeof z == "object")
          F = z[ue];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof z != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let ge = this._cache.get(z);
        if (ge !== void 0)
          return ge;
        q = (0, l.normalizeId)(F || q);
        const Ae = l.getSchemaRefs.call(this, z, q);
        return ge = new o.SchemaEnv({ schema: z, schemaId: ue, meta: te, baseId: q, localRefs: Ae }), this._cache.set(ge.schema, ge), H && !q.startsWith("#") && (q && this._checkUnique(q), this.refs[q] = ge), j && this.validateSchema(z, !0), ge;
      }
      _checkUnique(z) {
        if (this.schemas[z] || this.refs[z])
          throw new Error(`schema with key or id "${z}" already exists`);
      }
      _compileSchemaEnv(z) {
        if (z.meta ? this._compileMetaSchema(z) : o.compileSchema.call(this, z), !z.validate)
          throw new Error("ajv implementation error");
        return z.validate;
      }
      _compileMetaSchema(z) {
        const te = this.opts;
        this.opts = this._metaOpts;
        try {
          o.compileSchema.call(this, z);
        } finally {
          this.opts = te;
        }
      }
    }
    k.ValidationError = n.default, k.MissingRefError = i.default, e.default = k;
    function A(K, z, te, q = "error") {
      for (const j in K) {
        const H = j;
        H in z && this.logger[q](`${te}: option ${j}. ${K[H]}`);
      }
    }
    function T(K) {
      return K = (0, l.normalizeId)(K), this.schemas[K] || this.refs[K];
    }
    function R() {
      const K = this.opts.schemas;
      if (K)
        if (Array.isArray(K))
          this.addSchema(K);
        else
          for (const z in K)
            this.addSchema(K[z], z);
    }
    function I() {
      for (const K in this.opts.formats) {
        const z = this.opts.formats[K];
        z && this.addFormat(K, z);
      }
    }
    function B(K) {
      if (Array.isArray(K)) {
        this.addVocabulary(K);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const z in K) {
        const te = K[z];
        te.keyword || (te.keyword = z), this.addKeyword(te);
      }
    }
    function L() {
      const K = { ...this.opts };
      for (const z of g)
        delete K[z];
      return K;
    }
    const Y = { log() {
    }, warn() {
    }, error() {
    } };
    function Q(K) {
      if (K === !1)
        return Y;
      if (K === void 0)
        return console;
      if (K.log && K.warn && K.error)
        return K;
      throw new Error("logger must implement log, warn and error methods");
    }
    const re = /^[a-z_$][a-z0-9_$:-]*$/i;
    function oe(K, z) {
      const { RULES: te } = this;
      if ((0, f.eachItem)(K, (q) => {
        if (te.keywords[q])
          throw new Error(`Keyword ${q} is already defined`);
        if (!re.test(q))
          throw new Error(`Keyword ${q} has invalid name`);
      }), !!z && z.$data && !("code" in z || "validate" in z))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function ce(K, z, te) {
      var q;
      const j = z == null ? void 0 : z.post;
      if (te && j)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: H } = this;
      let F = j ? H.post : H.rules.find(({ type: ge }) => ge === te);
      if (F || (F = { type: te, rules: [] }, H.rules.push(F)), H.keywords[K] = !0, !z)
        return;
      const ue = {
        keyword: K,
        definition: {
          ...z,
          type: (0, p.getJSONTypes)(z.type),
          schemaType: (0, p.getJSONTypes)(z.schemaType)
        }
      };
      z.before ? pe.call(this, F, ue, z.before) : F.rules.push(ue), H.all[K] = ue, (q = z.implements) === null || q === void 0 || q.forEach((ge) => this.addKeyword(ge));
    }
    function pe(K, z, te) {
      const q = K.rules.findIndex((j) => j.keyword === te);
      q >= 0 ? K.rules.splice(q, 0, z) : (K.rules.push(z), this.logger.warn(`rule ${te} is not defined`));
    }
    function fe(K) {
      let { metaSchema: z } = K;
      z !== void 0 && (K.$data && this.opts.$data && (z = Z(z)), K.validateSchema = this.compile(z, !0));
    }
    const G = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function Z(K) {
      return { anyOf: [K, G] };
    }
  }(zv)), zv;
}
var hd = {}, md = {}, gd = {}, $A;
function vH() {
  if ($A) return gd;
  $A = 1, Object.defineProperty(gd, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return gd.default = e, gd;
}
var Ha = {}, RA;
function CS() {
  if (RA) return Ha;
  RA = 1, Object.defineProperty(Ha, "__esModule", { value: !0 }), Ha.getValidate = a, Ha.callRef = l;
  const e = RN(), t = ui(), r = ot(), n = li(), i = wg(), s = ct(), o = {
    keyword: "$ref",
    schemaType: "string",
    code(p) {
      const { gen: f, schema: d, it: m } = p, { baseId: v, schemaEnv: g, validateName: S, opts: _, self: x } = m, { root: y } = g;
      if ((d === "#" || d === "#/") && v === y.baseId)
        return k();
      const w = i.resolveRef.call(x, y, v, d);
      if (w === void 0)
        throw new e.default(m.opts.uriResolver, v, d);
      if (w instanceof i.SchemaEnv)
        return A(w);
      return T(w);
      function k() {
        if (g === y)
          return l(p, S, g, g.$async);
        const R = f.scopeValue("root", { ref: y });
        return l(p, (0, r._)`${R}.validate`, y, y.$async);
      }
      function A(R) {
        const I = a(p, R);
        l(p, I, R, R.$async);
      }
      function T(R) {
        const I = f.scopeValue("schema", _.code.source === !0 ? { ref: R, code: (0, r.stringify)(R) } : { ref: R }), B = f.name("valid"), L = p.subschema(
          {
            schema: R,
            dataTypes: [],
            schemaPath: r.nil,
            topSchemaRef: I,
            errSchemaPath: d
          },
          B,
          m.isAllOfVariant
          // pass isAllOfVariant into inlined $ref
        );
        p.mergeEvaluated(L), p.ok(B);
      }
    }
  };
  function a(p, f) {
    const { gen: d } = p;
    return f.validate ? d.scopeValue("validate", { ref: f.validate }) : (0, r._)`${d.scopeValue("wrapper", { ref: f })}.validate`;
  }
  function l(p, f, d, m) {
    const { gen: v, it: g } = p, { allErrors: S, schemaEnv: _, opts: x } = g, y = x.passContext ? n.default.this : r.nil;
    m ? w() : k();
    function w() {
      if (!_.$async)
        throw new Error("async schema referenced by sync schema");
      const R = v.let("valid");
      v.try(() => {
        v.code((0, r._)`await ${(0, t.callValidateCode)(p, f, y)}`), T(f), S || v.assign(R, !0);
      }, (I) => {
        v.if((0, r._)`!(${I} instanceof ${g.ValidationError})`, () => v.throw(I)), A(I), S || v.assign(R, !1);
      }), p.ok(R);
    }
    function k() {
      const R = v.name("visitedNodes");
      v.code((0, r._)`const ${R} = (typeof visitedNodesForRef !== 'undefined') && visitedNodesForRef.get(${f}) || new Set()`), v.if((0, r._)`!${R}.has(${p.data})`, () => {
        v.code((0, r._)`if (typeof visitedNodesForRef !== 'undefined') visitedNodesForRef.set(${f}, ${R})`), v.code((0, r._)`const dataNode = ${p.data}`), v.code((0, r._)`if (typeof dataNode === "object" && dataNode !== null) ${R}.add(dataNode)`);
        const I = p.result((0, t.callValidateCode)(p, f, y), () => T(f), () => A(f));
        return v.code((0, r._)`${R}.delete(dataNode)`), I;
      });
    }
    function A(R) {
      const I = (0, r._)`${R}.errors`;
      v.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${I} : ${n.default.vErrors}.concat(${I})`), v.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function T(R) {
      var I;
      if (!g.opts.unevaluated)
        return;
      const B = (I = d == null ? void 0 : d.validate) === null || I === void 0 ? void 0 : I.evaluated;
      if (g.props !== !0)
        if (B && !B.dynamicProps)
          B.props !== void 0 && (g.props = s.mergeEvaluated.props(v, B.props, g.props));
        else {
          const L = v.var("props", (0, r._)`${R}.evaluated.props`);
          g.props = s.mergeEvaluated.props(v, L, g.props, r.Name);
        }
      if (g.items !== !0)
        if (B && !B.dynamicItems)
          B.items !== void 0 && (g.items = s.mergeEvaluated.items(v, B.items, g.items));
        else {
          const L = v.var("items", (0, r._)`${R}.evaluated.items`);
          g.items = s.mergeEvaluated.items(v, L, g.items, r.Name);
        }
    }
  }
  return Ha.default = o, Ha;
}
var IA;
function bH() {
  if (IA) return md;
  IA = 1, Object.defineProperty(md, "__esModule", { value: !0 });
  const e = vH(), t = CS(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    t.default
  ];
  return md.default = r, md;
}
var yd = {}, vd = {}, jA;
function wH() {
  if (jA) return vd;
  jA = 1, Object.defineProperty(vd, "__esModule", { value: !0 });
  const e = ot(), t = e.operators, r = {
    maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
    minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
    exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
    exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
  }, n = {
    message: ({ keyword: s, schemaCode: o }) => (0, e.str)`must be ${r[s].okStr} ${o}`,
    params: ({ keyword: s, schemaCode: o }) => (0, e._)`{comparison: ${r[s].okStr}, limit: ${o}}`
  }, i = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(s) {
      const { keyword: o, data: a, schemaCode: l } = s;
      s.fail$data((0, e._)`${a} ${r[o].fail} ${l} || isNaN(${a})`);
    }
  };
  return vd.default = i, vd;
}
var bd = {}, NA;
function SH() {
  if (NA) return bd;
  NA = 1, Object.defineProperty(bd, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: i, data: s, schemaCode: o, it: a } = n, l = a.opts.multipleOfPrecision, p = i.let("res"), f = l ? (0, e._)`Math.abs(Math.round(${p}) - ${p}) > 1e-${l}` : (0, e._)`${p} !== parseInt(${p})`;
      n.fail$data((0, e._)`(${o} === 0 || (${p} = ${s}/${o}, ${f}))`);
    }
  };
  return bd.default = r, bd;
}
var wd = {}, Sd = {}, LA;
function xH() {
  if (LA) return Sd;
  LA = 1, Object.defineProperty(Sd, "__esModule", { value: !0 }), Sd.default = e;
  function e(t) {
    const r = t.length;
    let n = 0, i = 0, s;
    for (; i < r; )
      n++, s = t.charCodeAt(i++), s >= 55296 && s <= 56319 && i < r && (s = t.charCodeAt(i), (s & 64512) === 56320 && i++);
    return n;
  }
  return e.code = 'require("ajv/dist/runtime/ucs2length").default', Sd;
}
var MA;
function _H() {
  if (MA) return wd;
  MA = 1, Object.defineProperty(wd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = xH(), i = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: s, schemaCode: o }) {
        const a = s === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${o} characters`;
      },
      params: ({ schemaCode: s }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { keyword: o, data: a, schemaCode: l, it: p } = s, f = o === "maxLength" ? e.operators.GT : e.operators.LT, d = p.opts.unicode === !1 ? (0, e._)`${a}.length` : (0, e._)`${(0, t.useFunc)(s.gen, r.default)}(${a})`;
      s.fail$data((0, e._)`${d} ${f} ${l}`);
    }
  };
  return wd.default = i, wd;
}
var xd = {}, DA;
function EH() {
  if (DA) return xd;
  DA = 1, Object.defineProperty(xd, "__esModule", { value: !0 });
  const e = ui(), t = ot(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: i }) => (0, t.str)`must match pattern "${i}"`,
      params: ({ schemaCode: i }) => (0, t._)`{pattern: ${i}}`
    },
    code(i) {
      const { data: s, $data: o, schema: a, schemaCode: l, it: p } = i, f = p.opts.unicodeRegExp ? "u" : "", d = o ? (0, t._)`(new RegExp(${l}, ${f}))` : (0, e.usePattern)(i, a);
      i.fail$data((0, t._)`!${d}.test(${s})`);
    }
  };
  return xd.default = n, xd;
}
var _d = {}, FA;
function OH() {
  if (FA) return _d;
  FA = 1, Object.defineProperty(_d, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const s = n === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${s} than ${i} properties`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: s, schemaCode: o } = n, a = i === "maxProperties" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`Object.keys(${s}).length ${a} ${o}`);
    }
  };
  return _d.default = r, _d;
}
var Ed = {}, zA;
function kH() {
  if (zA) return Ed;
  zA = 1, Object.defineProperty(Ed, "__esModule", { value: !0 });
  const e = ui(), t = ot(), r = ct(), i = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: s } }) => (0, t.str)`must have required property '${s}'`,
      params: ({ params: { missingProperty: s } }) => (0, t._)`{missingProperty: ${s}}`
    },
    code(s) {
      const { gen: o, schema: a, schemaCode: l, data: p, $data: f, it: d } = s, { opts: m } = d;
      if (!f && a.length === 0)
        return;
      const v = a.length >= m.loopRequired;
      if (d.allErrors ? g() : S(), m.strictRequired) {
        const y = s.parentSchema.properties, { definedProperties: w } = s.it;
        for (const k of a)
          if ((y == null ? void 0 : y[k]) === void 0 && !w.has(k)) {
            const A = d.schemaEnv.baseId + d.errSchemaPath, T = `required property "${k}" is not defined at "${A}" (strictRequired)`;
            (0, r.checkStrictMode)(d, T, d.opts.strictRequired);
          }
      }
      function g() {
        if (v || f)
          s.block$data(t.nil, _);
        else
          for (const y of a)
            (0, e.checkReportMissingProp)(s, y);
      }
      function S() {
        const y = o.let("missing");
        if (v || f) {
          const w = o.let("valid", !0);
          s.block$data(w, () => x(y, w)), s.ok(w);
        } else
          o.if((0, e.checkMissingProp)(s, a, y)), (0, e.reportMissingProp)(s, y), o.else();
      }
      function _() {
        o.forOf("prop", l, (y) => {
          s.setParams({ missingProperty: y }), o.if((0, e.noPropertyInData)(o, p, y, m.ownProperties), () => s.error());
        });
      }
      function x(y, w) {
        s.setParams({ missingProperty: y }), o.forOf(y, l, () => {
          o.assign(w, (0, e.propertyInData)(o, p, y, m.ownProperties)), o.if((0, t.not)(w), () => {
            s.error(), o.break();
          });
        }, t.nil);
      }
    }
  };
  return Ed.default = i, Ed;
}
var Od = {}, qA;
function AH() {
  if (qA) return Od;
  qA = 1, Object.defineProperty(Od, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const s = n === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${s} than ${i} items`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: s, schemaCode: o } = n, a = i === "maxItems" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`${s}.length ${a} ${o}`);
    }
  };
  return Od.default = r, Od;
}
var kd = {}, Ad = {}, BA;
function TS() {
  if (BA) return Ad;
  BA = 1, Object.defineProperty(Ad, "__esModule", { value: !0 });
  const e = TN();
  return e.code = 'require("ajv/dist/runtime/equal").default', Ad.default = e, Ad;
}
var UA;
function PH() {
  if (UA) return kd;
  UA = 1, Object.defineProperty(kd, "__esModule", { value: !0 });
  const e = _m(), t = ot(), r = ct(), n = TS(), s = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: o, j: a } }) => (0, t.str)`must NOT have duplicate items (items ## ${a} and ${o} are identical)`,
      params: ({ params: { i: o, j: a } }) => (0, t._)`{i: ${o}, j: ${a}}`
    },
    code(o) {
      const { gen: a, data: l, $data: p, schema: f, parentSchema: d, schemaCode: m, it: v } = o;
      if (!p && !f)
        return;
      const g = a.let("valid"), S = d.items ? (0, e.getSchemaTypes)(d.items) : [];
      o.block$data(g, _, (0, t._)`${m} === false`), o.ok(g);
      function _() {
        const k = a.let("i", (0, t._)`${l}.length`), A = a.let("j");
        o.setParams({ i: k, j: A }), a.assign(g, !0), a.if((0, t._)`${k} > 1`, () => (x() ? y : w)(k, A));
      }
      function x() {
        return S.length > 0 && !S.some((k) => k === "object" || k === "array");
      }
      function y(k, A) {
        const T = a.name("item"), R = (0, e.checkDataTypes)(S, T, v.opts.strictNumbers, e.DataType.Wrong), I = a.const("indices", (0, t._)`{}`);
        a.for((0, t._)`;${k}--;`, () => {
          a.let(T, (0, t._)`${l}[${k}]`), a.if(R, (0, t._)`continue`), S.length > 1 && a.if((0, t._)`typeof ${T} == "string"`, (0, t._)`${T} += "_"`), a.if((0, t._)`typeof ${I}[${T}] == "number"`, () => {
            a.assign(A, (0, t._)`${I}[${T}]`), o.error(), a.assign(g, !1).break();
          }).code((0, t._)`${I}[${T}] = ${k}`);
        });
      }
      function w(k, A) {
        const T = (0, r.useFunc)(a, n.default), R = a.name("outer");
        a.label(R).for((0, t._)`;${k}--;`, () => a.for((0, t._)`${A} = ${k}; ${A}--;`, () => a.if((0, t._)`${T}(${l}[${k}], ${l}[${A}])`, () => {
          o.error(), a.assign(g, !1).break(R);
        })));
      }
    }
  };
  return kd.default = s, kd;
}
var Pd = {}, VA;
function CH() {
  if (VA) return Pd;
  VA = 1, Object.defineProperty(Pd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = TS(), i = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: s }) => (0, e._)`{allowedValue: ${s}}`
    },
    code(s) {
      const { gen: o, data: a, $data: l, schemaCode: p, schema: f } = s;
      l || f && typeof f == "object" ? s.fail$data((0, e._)`!${(0, t.useFunc)(o, r.default)}(${a}, ${p})`) : s.fail((0, e._)`${f} !== ${a}`);
    }
  };
  return Pd.default = i, Pd;
}
var Cd = {}, WA;
function TH() {
  if (WA) return Cd;
  WA = 1, Object.defineProperty(Cd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = TS(), i = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: s }) => (0, e._)`{allowedValues: ${s}}`
    },
    code(s) {
      const { gen: o, data: a, $data: l, schema: p, schemaCode: f, it: d } = s;
      if (!l && p.length === 0)
        throw new Error("enum must have non-empty array");
      const m = p.length >= d.opts.loopEnum;
      let v;
      const g = () => v ?? (v = (0, t.useFunc)(o, r.default));
      let S;
      if (m || l)
        S = o.let("valid"), s.block$data(S, _);
      else {
        if (!Array.isArray(p))
          throw new Error("ajv implementation error");
        const y = o.const("vSchema", f);
        S = (0, e.or)(...p.map((w, k) => x(y, k)));
      }
      s.pass(S);
      function _() {
        o.assign(S, !1), o.forOf("v", f, (y) => o.if((0, e._)`${g()}(${a}, ${y})`, () => o.assign(S, !0).break()));
      }
      function x(y, w) {
        const k = p[w];
        return typeof k == "object" && k !== null ? (0, e._)`${g()}(${a}, ${y}[${w}])` : (0, e._)`${a} === ${k}`;
      }
    }
  };
  return Cd.default = i, Cd;
}
var HA;
function $H() {
  if (HA) return yd;
  HA = 1, Object.defineProperty(yd, "__esModule", { value: !0 });
  const e = wH(), t = SH(), r = _H(), n = EH(), i = OH(), s = kH(), o = AH(), a = PH(), l = CH(), p = TH(), f = [
    // number
    e.default,
    t.default,
    // string
    r.default,
    n.default,
    // object
    i.default,
    s.default,
    // array
    o.default,
    a.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    l.default,
    p.default
  ];
  return yd.default = f, yd;
}
var Td = {}, Gu = {}, QA;
function IN() {
  if (QA) return Gu;
  QA = 1, Object.defineProperty(Gu, "__esModule", { value: !0 }), Gu.validateAdditionalItems = i;
  const e = ot(), t = ct(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, e.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { parentSchema: o, it: a } = s, { items: l } = o;
      if (!Array.isArray(l)) {
        (0, t.checkStrictMode)(a, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      i(s, l);
    }
  };
  function i(s, o) {
    const { gen: a, schema: l, data: p, keyword: f, it: d } = s;
    d.items = !0;
    const m = a.const("len", (0, e._)`${p}.length`);
    if (l === !1)
      s.setParams({ len: o.length }), s.pass((0, e._)`${m} <= ${o.length}`);
    else if (typeof l == "object" && !(0, t.alwaysValidSchema)(d, l)) {
      const g = a.var("valid", (0, e._)`${m} <= ${o.length}`);
      a.if((0, e.not)(g), () => v(g)), s.ok(g);
    }
    function v(g) {
      a.forRange("i", o.length, m, (S) => {
        s.subschema({ keyword: f, dataProp: S, dataPropType: t.Type.Num }, g), d.allErrors || a.if((0, e.not)(g), () => a.break());
      });
    }
  }
  return Gu.default = n, Gu;
}
var $d = {}, Ku = {}, YA;
function jN() {
  if (YA) return Ku;
  YA = 1, Object.defineProperty(Ku, "__esModule", { value: !0 }), Ku.validateTuple = i;
  const e = ot(), t = ct(), r = ui(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(s) {
      const { schema: o, it: a } = s;
      if (Array.isArray(o))
        return i(s, "additionalItems", o);
      a.items = !0, !(0, t.alwaysValidSchema)(a, o) && s.ok((0, r.validateArray)(s));
    }
  };
  function i(s, o, a = s.schema) {
    const { gen: l, parentSchema: p, data: f, keyword: d, it: m } = s;
    S(p), m.opts.unevaluated && a.length && m.items !== !0 && (m.items = t.mergeEvaluated.items(l, a.length, m.items));
    const v = l.name("valid"), g = l.const("len", (0, e._)`${f}.length`);
    a.forEach((_, x) => {
      (0, t.alwaysValidSchema)(m, _) || (l.if((0, e._)`${g} > ${x}`, () => s.subschema({
        keyword: d,
        schemaProp: x,
        dataProp: x
      }, v)), s.ok(v));
    });
    function S(_) {
      const { opts: x, errSchemaPath: y } = m, w = a.length, k = w === _.minItems && (w === _.maxItems || _[o] === !1);
      if (x.strictTuples && !k) {
        const A = `"${d}" is ${w}-tuple, but minItems or maxItems/${o} are not specified or different at path "${y}"`;
        (0, t.checkStrictMode)(m, A, x.strictTuples);
      }
    }
  }
  return Ku.default = n, Ku;
}
var GA;
function RH() {
  if (GA) return $d;
  GA = 1, Object.defineProperty($d, "__esModule", { value: !0 });
  const e = jN(), t = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, e.validateTuple)(r, "items")
  };
  return $d.default = t, $d;
}
var Rd = {}, KA;
function IH() {
  if (KA) return Rd;
  KA = 1, Object.defineProperty(Rd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = ui(), n = IN(), s = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: o } }) => (0, e.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, e._)`{limit: ${o}}`
    },
    code(o) {
      const { schema: a, parentSchema: l, it: p } = o, { prefixItems: f } = l;
      p.items = !0, !(0, t.alwaysValidSchema)(p, a) && (f ? (0, n.validateAdditionalItems)(o, f) : o.ok((0, r.validateArray)(o)));
    }
  };
  return Rd.default = s, Rd;
}
var Id = {}, XA;
function jH() {
  if (XA) return Id;
  XA = 1, Object.defineProperty(Id, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: i, max: s } }) => s === void 0 ? (0, e.str)`must contain at least ${i} valid item(s)` : (0, e.str)`must contain at least ${i} and no more than ${s} valid item(s)`,
      params: ({ params: { min: i, max: s } }) => s === void 0 ? (0, e._)`{minContains: ${i}}` : (0, e._)`{minContains: ${i}, maxContains: ${s}}`
    },
    code(i) {
      const { gen: s, schema: o, parentSchema: a, data: l, it: p } = i;
      let f, d;
      const { minContains: m, maxContains: v } = a;
      p.opts.next ? (f = m === void 0 ? 1 : m, d = v) : f = 1;
      const g = s.const("len", (0, e._)`${l}.length`);
      if (i.setParams({ min: f, max: d }), d === void 0 && f === 0) {
        (0, t.checkStrictMode)(p, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (d !== void 0 && f > d) {
        (0, t.checkStrictMode)(p, '"minContains" > "maxContains" is always invalid'), i.fail();
        return;
      }
      if ((0, t.alwaysValidSchema)(p, o)) {
        let w = (0, e._)`${g} >= ${f}`;
        d !== void 0 && (w = (0, e._)`${w} && ${g} <= ${d}`), i.pass(w);
        return;
      }
      p.items = !0;
      const S = s.name("valid");
      d === void 0 && f === 1 ? x(S, () => s.if(S, () => s.break())) : f === 0 ? (s.let(S, !0), d !== void 0 && s.if((0, e._)`${l}.length > 0`, _)) : (s.let(S, !1), _()), i.result(S, () => i.reset());
      function _() {
        const w = s.name("_valid"), k = s.let("count", 0);
        x(w, () => s.if(w, () => y(k)));
      }
      function x(w, k) {
        s.forRange("i", 0, g, (A) => {
          i.subschema({
            keyword: "contains",
            dataProp: A,
            dataPropType: t.Type.Num,
            compositeRule: !0
          }, w), k();
        });
      }
      function y(w) {
        s.code((0, e._)`${w}++`), d === void 0 ? s.if((0, e._)`${w} >= ${f}`, () => s.assign(S, !0).break()) : (s.if((0, e._)`${w} > ${d}`, () => s.assign(S, !1).break()), f === 1 ? s.assign(S, !0) : s.if((0, e._)`${w} >= ${f}`, () => s.assign(S, !0)));
      }
    }
  };
  return Id.default = n, Id;
}
var Yv = {}, JA;
function $S() {
  return JA || (JA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.error = void 0, e.validatePropertyDeps = o, e.validateSchemaDeps = a;
    const t = ot(), r = ct(), n = ui();
    e.error = {
      message: ({ params: { property: l, depsCount: p, deps: f } }) => {
        const d = p === 1 ? "property" : "properties";
        return (0, t.str)`must have ${d} ${f} when property ${l} is present`;
      },
      params: ({ params: { property: l, depsCount: p, deps: f, missingProperty: d } }) => (0, t._)`{property: ${l},
    missingProperty: ${d},
    depsCount: ${p},
    deps: ${f}}`
      // TODO change to reference
    };
    const i = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(l) {
        const [p, f] = s(l);
        o(l, p), a(l, f);
      }
    };
    function s({ schema: l }) {
      const p = {}, f = {};
      for (const d in l) {
        if (d === "__proto__")
          continue;
        const m = Array.isArray(l[d]) ? p : f;
        m[d] = l[d];
      }
      return [p, f];
    }
    function o(l, p = l.schema) {
      const { gen: f, data: d, it: m } = l;
      if (Object.keys(p).length === 0)
        return;
      const v = f.let("missing");
      for (const g in p) {
        const S = p[g];
        if (S.length === 0)
          continue;
        const _ = (0, n.propertyInData)(f, d, g, m.opts.ownProperties);
        l.setParams({
          property: g,
          depsCount: S.length,
          deps: S.join(", ")
        }), m.allErrors ? f.if(_, () => {
          for (const x of S)
            (0, n.checkReportMissingProp)(l, x);
        }) : (f.if((0, t._)`${_} && (${(0, n.checkMissingProp)(l, S, v)})`), (0, n.reportMissingProp)(l, v), f.else());
      }
    }
    function a(l, p = l.schema) {
      const { gen: f, data: d, keyword: m, it: v } = l, g = f.name("valid");
      for (const S in p)
        (0, r.alwaysValidSchema)(v, p[S]) || (f.if(
          (0, n.propertyInData)(f, d, S, v.opts.ownProperties),
          () => {
            const _ = l.subschema({ keyword: m, schemaProp: S }, g);
            l.mergeValidEvaluated(_, g);
          },
          () => f.var(g, !0)
          // TODO var
        ), l.ok(g));
    }
    e.default = i;
  }(Yv)), Yv;
}
var jd = {}, ZA;
function NH() {
  if (ZA) return jd;
  ZA = 1, Object.defineProperty(jd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: i }) => (0, e._)`{propertyName: ${i.propertyName}}`
    },
    code(i) {
      const { gen: s, schema: o, data: a, it: l } = i;
      if ((0, t.alwaysValidSchema)(l, o))
        return;
      const p = s.name("valid");
      s.forIn("key", a, (f) => {
        i.setParams({ propertyName: f }), i.subschema({
          keyword: "propertyNames",
          data: f,
          dataTypes: ["string"],
          propertyName: f,
          compositeRule: !0
        }, p), s.if((0, e.not)(p), () => {
          i.error(!0), l.allErrors || s.break();
        });
      }), i.ok(p);
    }
  };
  return jd.default = n, jd;
}
var Nd = {}, eP;
function NN() {
  if (eP) return Nd;
  eP = 1, Object.defineProperty(Nd, "__esModule", { value: !0 });
  const e = ui(), t = ot(), r = li(), n = ct(), s = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: o }) => (0, t._)`{additionalProperty: ${o.additionalProperty}}`
    },
    code(o) {
      const { gen: a, parentSchema: l, data: p, errsCount: f, it: d } = o, { schema: m = d.opts.defaultAdditionalProperties } = o;
      if (!f)
        throw new Error("ajv implementation error");
      const { allErrors: v, opts: g } = d;
      if (d.props = !0, g.removeAdditional !== "all" && (0, n.alwaysValidSchema)(d, m))
        return;
      const S = (0, e.allSchemaProperties)(l.properties), _ = (0, e.allSchemaProperties)(l.patternProperties);
      x(), o.ok((0, t._)`${f} === ${r.default.errors}`);
      function x() {
        a.forIn("key", p, (T) => {
          !S.length && !_.length ? k(T) : a.if(y(T), () => k(T));
        });
      }
      function y(T) {
        let R;
        if (S.length > 8) {
          const I = (0, n.schemaRefOrVal)(d, l.properties, "properties");
          R = (0, e.isOwnProperty)(a, I, T);
        } else S.length ? R = (0, t.or)(...S.map((I) => (0, t._)`${T} === ${I}`)) : R = t.nil;
        return _.length && (R = (0, t.or)(R, ..._.map((I) => (0, t._)`${(0, e.usePattern)(o, I)}.test(${T})`))), (0, t.not)(R);
      }
      function w(T) {
        a.code((0, t._)`delete ${p}[${T}]`);
      }
      function k(T) {
        if (g.removeAdditional === "all" || g.removeAdditional && m === !1) {
          w(T);
          return;
        }
        if (m === !1) {
          o.setParams({ additionalProperty: T }), o.error(), v || a.break();
          return;
        }
        if (typeof m == "object" && !(0, n.alwaysValidSchema)(d, m)) {
          const R = a.name("valid");
          g.removeAdditional === "failing" ? (A(T, R, !1), a.if((0, t.not)(R), () => {
            o.reset(), w(T);
          })) : (A(T, R), v || a.if((0, t.not)(R), () => a.break()));
        }
      }
      function A(T, R, I) {
        const B = {
          keyword: "additionalProperties",
          dataProp: T,
          dataPropType: n.Type.Str
        };
        I === !1 && Object.assign(B, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), o.subschema(B, R);
      }
    }
  };
  return Nd.default = s, Nd;
}
var Ld = {}, tP;
function LH() {
  if (tP) return Ld;
  tP = 1, Object.defineProperty(Ld, "__esModule", { value: !0 });
  const e = bg(), t = ui(), r = ct(), n = NN(), i = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: o, schema: a, parentSchema: l, data: p, it: f } = s;
      (f.opts.removeAdditional === "all" && l.additionalProperties === void 0 || f.opts.defaultAdditionalProperties === !1) && n.default.code(new e.KeywordCxt(f, n.default, "additionalProperties"));
      const d = (0, t.allSchemaProperties)(a);
      for (const _ of d)
        f.definedProperties.add(_);
      f.opts.unevaluated && d.length && f.props !== !0 && (f.props = r.mergeEvaluated.props(o, (0, r.toHash)(d), f.props));
      const m = d.filter((_) => !(0, r.alwaysValidSchema)(f, a[_]));
      if (m.length === 0)
        return;
      const v = o.name("valid");
      for (const _ of m)
        g(_) ? S(_) : (o.if((0, t.propertyInData)(o, p, _, f.opts.ownProperties)), S(_), f.allErrors || o.else().var(v, !0), o.endIf()), s.it.definedProperties.add(_), s.ok(v);
      function g(_) {
        return f.opts.useDefaults && !f.compositeRule && a[_].default !== void 0;
      }
      function S(_) {
        s.subschema({
          keyword: "properties",
          schemaProp: _,
          dataProp: _
        }, v);
      }
    }
  };
  return Ld.default = i, Ld;
}
var Md = {}, rP;
function MH() {
  if (rP) return Md;
  rP = 1, Object.defineProperty(Md, "__esModule", { value: !0 });
  const e = ui(), t = ot(), r = ct(), n = ct(), i = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: o, schema: a, data: l, parentSchema: p, it: f } = s, { opts: d } = f, m = (0, e.allSchemaProperties)(a), v = m.filter((k) => (0, r.alwaysValidSchema)(f, a[k]));
      if (m.length === 0 || v.length === m.length && (!f.opts.unevaluated || f.props === !0))
        return;
      const g = d.strictSchema && !d.allowMatchingProperties && p.properties, S = o.name("valid");
      f.props !== !0 && !(f.props instanceof t.Name) && (f.props = (0, n.evaluatedPropsToName)(o, f.props));
      const { props: _ } = f;
      x();
      function x() {
        for (const k of m)
          g && y(k), f.allErrors ? w(k) : (o.var(S, !0), w(k), o.if(S));
      }
      function y(k) {
        for (const A in g)
          new RegExp(k).test(A) && (0, r.checkStrictMode)(f, `property ${A} matches pattern ${k} (use allowMatchingProperties)`);
      }
      function w(k) {
        o.forIn("key", l, (A) => {
          o.if((0, t._)`${(0, e.usePattern)(s, k)}.test(${A})`, () => {
            const T = v.includes(k);
            T || s.subschema({
              keyword: "patternProperties",
              schemaProp: k,
              dataProp: A,
              dataPropType: n.Type.Str
            }, S), f.opts.unevaluated && _ !== !0 ? o.assign((0, t._)`${_}[${A}]`, !0) : !T && !f.allErrors && o.if((0, t.not)(S), () => o.break());
          });
        });
      }
    }
  };
  return Md.default = i, Md;
}
var Dd = {}, nP;
function DH() {
  if (nP) return Dd;
  nP = 1, Object.defineProperty(Dd, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: i, it: s } = r;
      if ((0, e.alwaysValidSchema)(s, i)) {
        r.fail();
        return;
      }
      const o = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, o), r.failResult(o, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return Dd.default = t, Dd;
}
var Fd = {}, iP;
function FH() {
  if (iP) return Fd;
  iP = 1, Object.defineProperty(Fd, "__esModule", { value: !0 });
  const t = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: ui().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return Fd.default = t, Fd;
}
var zd = {}, oP;
function zH() {
  if (oP) return zd;
  oP = 1, Object.defineProperty(zd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: i }) => (0, e._)`{passingSchemas: ${i.passing}}`
    },
    code(i) {
      const { gen: s, schema: o, parentSchema: a, it: l } = i;
      if (!Array.isArray(o))
        throw new Error("ajv implementation error");
      if (l.opts.discriminator && a.discriminator)
        return;
      const p = o, f = s.let("valid", !1), d = s.let("passing", null), m = s.name("_valid");
      i.setParams({ passing: d }), s.block(v), i.result(f, () => i.reset(), () => i.error(!0));
      function v() {
        p.forEach((g, S) => {
          let _;
          (0, t.alwaysValidSchema)(l, g) ? s.var(m, !0) : _ = i.subschema({
            keyword: "oneOf",
            schemaProp: S,
            compositeRule: !0
          }, m), S > 0 && s.if((0, e._)`${m} && ${f}`).assign(f, !1).assign(d, (0, e._)`[${d}, ${S}]`).else(), s.if(m, () => {
            s.assign(f, !0), s.assign(d, S), _ && i.mergeEvaluated(_, e.Name);
          });
        });
      }
    }
  };
  return zd.default = n, zd;
}
var qd = {}, sP;
function qH() {
  if (sP) return qd;
  sP = 1, Object.defineProperty(qd, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: i, it: s } = r;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const o = n.name("valid");
      i.forEach((a, l) => {
        if ((0, e.alwaysValidSchema)(s, a))
          return;
        const p = r.subschema({ keyword: "allOf", schemaProp: l }, o, !0);
        r.ok(o), r.mergeEvaluated(p);
      });
    }
  };
  return qd.default = t, qd;
}
var Bd = {}, aP;
function BH() {
  if (aP) return Bd;
  aP = 1, Object.defineProperty(Bd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: s }) => (0, e.str)`must match "${s.ifClause}" schema`,
      params: ({ params: s }) => (0, e._)`{failingKeyword: ${s.ifClause}}`
    },
    code(s) {
      const { gen: o, parentSchema: a, it: l } = s;
      a.then === void 0 && a.else === void 0 && (0, t.checkStrictMode)(l, '"if" without "then" and "else" is ignored');
      const p = i(l, "then"), f = i(l, "else");
      if (!p && !f)
        return;
      const d = o.let("valid", !0), m = o.name("_valid");
      if (v(), s.reset(), p && f) {
        const S = o.let("ifClause");
        s.setParams({ ifClause: S }), o.if(m, g("then", S), g("else", S));
      } else p ? o.if(m, g("then")) : o.if((0, e.not)(m), g("else"));
      s.pass(d, () => s.error(!0));
      function v() {
        const S = s.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, m);
        s.mergeEvaluated(S);
      }
      function g(S, _) {
        return () => {
          const x = s.subschema({ keyword: S }, m);
          o.assign(d, m), s.mergeValidEvaluated(x, d), _ ? o.assign(_, (0, e._)`${S}`) : s.setParams({ ifClause: S });
        };
      }
    }
  };
  function i(s, o) {
    const a = s.schema[o];
    return a !== void 0 && !(0, t.alwaysValidSchema)(s, a);
  }
  return Bd.default = n, Bd;
}
var Ud = {}, lP;
function UH() {
  if (lP) return Ud;
  lP = 1, Object.defineProperty(Ud, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: i }) {
      n.if === void 0 && (0, e.checkStrictMode)(i, `"${r}" without "if" is ignored`);
    }
  };
  return Ud.default = t, Ud;
}
var uP;
function VH() {
  if (uP) return Td;
  uP = 1, Object.defineProperty(Td, "__esModule", { value: !0 }), Td.default = _;
  const e = IN(), t = RH(), r = jN(), n = IH(), i = jH(), s = $S(), o = NH(), a = NN(), l = LH(), p = MH(), f = DH(), d = FH(), m = zH(), v = qH(), g = BH(), S = UH();
  function _(x = !1) {
    const y = [
      // any
      f.default,
      d.default,
      m.default,
      v.default,
      g.default,
      S.default,
      // object
      o.default,
      a.default,
      s.default,
      l.default,
      p.default
    ];
    return x ? y.push(t.default, n.default) : y.push(e.default, r.default), y.push(i.default), y;
  }
  return Td;
}
var Vd = {}, Xu = {}, cP;
function LN() {
  if (cP) return Xu;
  cP = 1, Object.defineProperty(Xu, "__esModule", { value: !0 }), Xu.dynamicAnchor = s;
  const e = ot(), t = li(), r = wg(), n = CS(), i = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (a) => s(a, a.schema)
  };
  function s(a, l) {
    const { gen: p, it: f } = a;
    f.schemaEnv.root.dynamicAnchors[l] = !0;
    const d = (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(l)}`, m = f.errSchemaPath === "#" ? f.validateName : o(a);
    p.if((0, e._)`!${d}`, () => p.assign(d, m));
  }
  function o(a) {
    const { schemaEnv: l, schema: p, self: f } = a.it, { root: d, baseId: m, localRefs: v, meta: g } = l.root, { schemaId: S } = f.opts, _ = new r.SchemaEnv({ schema: p, schemaId: S, root: d, baseId: m, localRefs: v, meta: g });
    return r.compileSchema.call(f, _), (0, n.getValidate)(a, _);
  }
  return Xu.default = i, Xu;
}
var Ju = {}, pP;
function MN() {
  if (pP) return Ju;
  pP = 1, Object.defineProperty(Ju, "__esModule", { value: !0 }), Ju.dynamicRef = i;
  const e = ot(), t = li(), r = CS(), n = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (s) => i(s, s.schema)
  };
  function i(s, o) {
    const { gen: a, keyword: l, it: p } = s;
    if (o[0] !== "#")
      throw new Error(`"${l}" only supports hash fragment reference`);
    const f = o.slice(1);
    if (p.allErrors)
      d();
    else {
      const v = a.let("valid", !1);
      d(v), s.ok(v);
    }
    function d(v) {
      if (p.schemaEnv.root.dynamicAnchors[f]) {
        const g = a.let("_v", (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(f)}`);
        a.if(g, m(g, v), m(p.validateName, v));
      } else
        m(p.validateName, v)();
    }
    function m(v, g) {
      return g ? () => a.block(() => {
        (0, r.callRef)(s, v), a.let(g, !0);
      }) : () => (0, r.callRef)(s, v);
    }
  }
  return Ju.default = n, Ju;
}
var Wd = {}, fP;
function WH() {
  if (fP) return Wd;
  fP = 1, Object.defineProperty(Wd, "__esModule", { value: !0 });
  const e = LN(), t = ct(), r = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(n) {
      n.schema ? (0, e.dynamicAnchor)(n, "") : (0, t.checkStrictMode)(n.it, "$recursiveAnchor: false is ignored");
    }
  };
  return Wd.default = r, Wd;
}
var Hd = {}, dP;
function HH() {
  if (dP) return Hd;
  dP = 1, Object.defineProperty(Hd, "__esModule", { value: !0 });
  const e = MN(), t = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (r) => (0, e.dynamicRef)(r, r.schema)
  };
  return Hd.default = t, Hd;
}
var hP;
function QH() {
  if (hP) return Vd;
  hP = 1, Object.defineProperty(Vd, "__esModule", { value: !0 });
  const e = LN(), t = MN(), r = WH(), n = HH(), i = [e.default, t.default, r.default, n.default];
  return Vd.default = i, Vd;
}
var Qd = {}, Yd = {}, mP;
function YH() {
  if (mP) return Yd;
  mP = 1, Object.defineProperty(Yd, "__esModule", { value: !0 });
  const e = $S(), t = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: e.error,
    code: (r) => (0, e.validatePropertyDeps)(r)
  };
  return Yd.default = t, Yd;
}
var Gd = {}, gP;
function GH() {
  if (gP) return Gd;
  gP = 1, Object.defineProperty(Gd, "__esModule", { value: !0 });
  const e = $S(), t = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (r) => (0, e.validateSchemaDeps)(r)
  };
  return Gd.default = t, Gd;
}
var Kd = {}, yP;
function KH() {
  if (yP) return Kd;
  yP = 1, Object.defineProperty(Kd, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: r, parentSchema: n, it: i }) {
      n.contains === void 0 && (0, e.checkStrictMode)(i, `"${r}" without "contains" is ignored`);
    }
  };
  return Kd.default = t, Kd;
}
var vP;
function XH() {
  if (vP) return Qd;
  vP = 1, Object.defineProperty(Qd, "__esModule", { value: !0 });
  const e = YH(), t = GH(), r = KH(), n = [e.default, t.default, r.default];
  return Qd.default = n, Qd;
}
var Xd = {}, Jd = {}, bP;
function JH() {
  if (bP) return Jd;
  bP = 1, Object.defineProperty(Jd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = li(), i = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: s }) => (0, e._)`{unevaluatedProperty: ${s.unevaluatedProperty}}`
    },
    code(s) {
      const { gen: o, schema: a = s.it.opts.defaultUnevaluatedProperties, data: l, errsCount: p, it: f } = s, d = s.schema === void 0 && s.it.opts.defaultUnevaluatedProperties === !1;
      if (!p)
        throw new Error("ajv implementation error");
      const { allErrors: m, props: v } = f;
      if (v instanceof e.Name)
        o.if((0, e._)`${v} !== true`, () => o.forIn("key", l, (x) => o.if(S(v, x), () => g(x))));
      else if (v !== !0) {
        const x = () => o.forIn("key", l, (y) => v === void 0 ? g(y) : o.if(_(v, y), () => g(y)));
        d && f.errorPath.emptyStr() ? o.if((0, e._)`${r.default.isAllOfVariant} === 0`, x) : x();
      }
      d || (f.props = !0), s.ok((0, e._)`${p} === ${r.default.errors}`);
      function g(x) {
        if (a === !1) {
          s.setParams({ unevaluatedProperty: x }), s.error(), m || o.break();
          return;
        }
        if (!(0, t.alwaysValidSchema)(f, a)) {
          const y = o.name("valid");
          s.subschema({
            keyword: "unevaluatedProperties",
            dataProp: x,
            dataPropType: t.Type.Str
          }, y), m || o.if((0, e.not)(y), () => o.break());
        }
      }
      function S(x, y) {
        return (0, e._)`!${x} || !${x}[${y}]`;
      }
      function _(x, y) {
        const w = [];
        for (const k in x)
          x[k] === !0 && w.push((0, e._)`${y} !== ${k}`);
        return (0, e.and)(...w);
      }
    }
  };
  return Jd.default = i, Jd;
}
var Zd = {}, wP;
function ZH() {
  if (wP) return Zd;
  wP = 1, Object.defineProperty(Zd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: i } }) => (0, e.str)`must NOT have more than ${i} items`,
      params: ({ params: { len: i } }) => (0, e._)`{limit: ${i}}`
    },
    code(i) {
      const { gen: s, schema: o, data: a, it: l } = i, p = l.items || 0;
      if (p === !0)
        return;
      const f = s.const("len", (0, e._)`${a}.length`);
      if (o === !1)
        i.setParams({ len: p }), i.fail((0, e._)`${f} > ${p}`);
      else if (typeof o == "object" && !(0, t.alwaysValidSchema)(l, o)) {
        const m = s.var("valid", (0, e._)`${f} <= ${p}`);
        s.if((0, e.not)(m), () => d(m, p)), i.ok(m);
      }
      l.items = !0;
      function d(m, v) {
        s.forRange("i", v, f, (g) => {
          i.subschema({ keyword: "unevaluatedItems", dataProp: g, dataPropType: t.Type.Num }, m), l.allErrors || s.if((0, e.not)(m), () => s.break());
        });
      }
    }
  };
  return Zd.default = n, Zd;
}
var SP;
function e7() {
  if (SP) return Xd;
  SP = 1, Object.defineProperty(Xd, "__esModule", { value: !0 });
  const e = JH(), t = ZH(), r = [e.default, t.default];
  return Xd.default = r, Xd;
}
var eh = {}, th = {}, xP;
function t7() {
  if (xP) return th;
  xP = 1, Object.defineProperty(th, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
    },
    code(n, i) {
      const { gen: s, data: o, $data: a, schema: l, schemaCode: p, it: f } = n, { opts: d, errSchemaPath: m, schemaEnv: v, self: g } = f;
      if (!d.validateFormats)
        return;
      a ? S() : _();
      function S() {
        const x = s.scopeValue("formats", {
          ref: g.formats,
          code: d.code.formats
        }), y = s.const("fDef", (0, e._)`${x}[${p}]`), w = s.let("fType"), k = s.let("format");
        s.if((0, e._)`typeof ${y} == "object" && !(${y} instanceof RegExp)`, () => s.assign(w, (0, e._)`${y}.type || "string"`).assign(k, (0, e._)`${y}.validate`), () => s.assign(w, (0, e._)`"string"`).assign(k, y)), n.fail$data((0, e.or)(A(), T()));
        function A() {
          return d.strictSchema === !1 ? e.nil : (0, e._)`${p} && !${k}`;
        }
        function T() {
          const R = v.$async ? (0, e._)`(${y}.async ? await ${k}(${o}) : ${k}(${o}))` : (0, e._)`${k}(${o})`, I = (0, e._)`(typeof ${k} == "function" ? ${R} : ${k}.test(${o}))`;
          return (0, e._)`${k} && ${k} !== true && ${w} === ${i} && !${I}`;
        }
      }
      function _() {
        const x = g.formats[l];
        if (!x) {
          A();
          return;
        }
        if (x === !0)
          return;
        const [y, w, k] = T(x);
        y === i && n.pass(R());
        function A() {
          if (d.strictSchema === !1) {
            g.logger.warn(I());
            return;
          }
          throw new Error(I());
          function I() {
            return `unknown format "${l}" ignored in schema at path "${m}"`;
          }
        }
        function T(I) {
          const B = I instanceof RegExp ? (0, e.regexpCode)(I) : d.code.formats ? (0, e._)`${d.code.formats}${(0, e.getProperty)(l)}` : void 0, L = s.scopeValue("formats", { key: l, ref: I, code: B });
          return typeof I == "object" && !(I instanceof RegExp) ? [I.type || "string", I.validate, (0, e._)`${L}.validate`] : ["string", I, L];
        }
        function R() {
          if (typeof x == "object" && !(x instanceof RegExp) && x.async) {
            if (!v.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${k}(${o})`;
          }
          return typeof w == "function" ? (0, e._)`${k}(${o})` : (0, e._)`${k}.test(${o})`;
        }
      }
    }
  };
  return th.default = r, th;
}
var _P;
function r7() {
  if (_P) return eh;
  _P = 1, Object.defineProperty(eh, "__esModule", { value: !0 });
  const t = [t7().default];
  return eh.default = t, eh;
}
var js = {}, EP;
function n7() {
  return EP || (EP = 1, Object.defineProperty(js, "__esModule", { value: !0 }), js.contentVocabulary = js.metadataVocabulary = void 0, js.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], js.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), js;
}
var OP;
function i7() {
  if (OP) return hd;
  OP = 1, Object.defineProperty(hd, "__esModule", { value: !0 });
  const e = bH(), t = $H(), r = VH(), n = QH(), i = XH(), s = e7(), o = r7(), a = n7(), l = [
    n.default,
    e.default,
    t.default,
    (0, r.default)(!0),
    o.default,
    a.metadataVocabulary,
    a.contentVocabulary,
    i.default,
    s.default
  ];
  return hd.default = l, hd;
}
var rh = {}, Zu = {}, kP;
function o7() {
  if (kP) return Zu;
  kP = 1, Object.defineProperty(Zu, "__esModule", { value: !0 }), Zu.DiscrError = void 0;
  var e;
  return function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e || (Zu.DiscrError = e = {})), Zu;
}
var AP;
function s7() {
  if (AP) return rh;
  AP = 1, Object.defineProperty(rh, "__esModule", { value: !0 });
  const e = ot(), t = o7(), r = wg(), n = ct(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: o, tagName: a } }) => o === t.DiscrError.Tag ? `tag "${a}" must be string` : `value of tag "${a}" must be in oneOf or anyOf`,
      params: ({ params: { discrError: o, tag: a, tagName: l } }) => (0, e._)`{error: ${o}, tag: ${l}, tagValue: ${a}}`
    },
    code(o) {
      const { gen: a, data: l, schema: p, parentSchema: f, it: d } = o, m = f.oneOf ? "oneOf" : f.anyOf ? "anyOf" : void 0;
      if (!d.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const v = p.propertyName;
      if (typeof v != "string")
        throw new Error("discriminator: requires propertyName");
      if (!m)
        throw new Error("discriminator: requires oneOf or anyOf composite keyword");
      const g = f[m], S = a.let("valid", !1), _ = a.const("tag", (0, e._)`${l}${(0, e.getProperty)(v)}`);
      a.if((0, e._)`typeof ${_} == "string"`, () => x(), () => o.error(!1, { discrError: t.DiscrError.Tag, tag: _, tagName: v })), o.ok(S);
      function x() {
        const k = w();
        a.if(!1);
        for (const A in k)
          a.elseIf((0, e._)`${_} === ${A}`), a.assign(S, y(k[A]));
        a.else(), o.error(!1, { discrError: t.DiscrError.Mapping, tag: _, tagName: v }), a.endIf();
      }
      function y(k) {
        const A = a.name("valid"), T = o.subschema({ keyword: m, schemaProp: k }, A);
        return o.mergeEvaluated(T, e.Name), A;
      }
      function w() {
        var k;
        const A = {}, T = I(f);
        let R = !0;
        for (let Y = 0; Y < g.length; Y++) {
          let Q = g[Y];
          const re = Q == null ? void 0 : Q.$ref;
          if (re && p.mapping) {
            const { mapping: ce } = p, pe = Object.keys(ce).filter((fe) => ce[fe] === Q.$ref);
            if (pe.length) {
              for (const fe of pe)
                L(fe, Y);
              continue;
            }
          }
          re && !(0, n.schemaHasRulesButRef)(Q, d.self.RULES) && (Q = r.resolveRef.call(d.self, d.schemaEnv.root, d.baseId, re), Q instanceof r.SchemaEnv && (Q = Q.schema));
          const oe = (k = Q == null ? void 0 : Q.properties) === null || k === void 0 ? void 0 : k[v];
          if (typeof oe != "object")
            throw new Error(`discriminator: ${m} subschemas (or referenced schemas) must have "properties/${v}" or match mapping`);
          R = R && (T || I(Q)), B(oe, Y);
        }
        if (!R)
          throw new Error(`discriminator: "${v}" must be required`);
        return A;
        function I({ required: Y }) {
          return Array.isArray(Y) && Y.includes(v);
        }
        function B(Y, Q) {
          if (Y.const)
            L(Y.const, Q);
          else if (Y.enum)
            for (const re of Y.enum)
              L(re, Q);
          else
            throw new Error(`discriminator: "properties/${v}" must have "const" or "enum"`);
        }
        function L(Y, Q) {
          if (typeof Y != "string" || Y in A)
            throw new Error(`discriminator: "${v}" values must be unique strings`);
          A[Y] = Q;
        }
      }
    }
  };
  return rh.default = s, rh;
}
var nh = {};
const a7 = "https://json-schema.org/draft/2020-12/schema", l7 = "https://json-schema.org/draft/2020-12/schema", u7 = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, c7 = "meta", p7 = "Core and Validation specifications meta-schema", f7 = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], d7 = [
  "object",
  "boolean"
], h7 = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", m7 = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, g7 = {
  $schema: a7,
  $id: l7,
  $vocabulary: u7,
  $dynamicAnchor: c7,
  title: p7,
  allOf: f7,
  type: d7,
  $comment: h7,
  properties: m7
}, y7 = "https://json-schema.org/draft/2020-12/schema", v7 = "https://json-schema.org/draft/2020-12/meta/applicator", b7 = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, w7 = "meta", S7 = "Applicator vocabulary meta-schema", x7 = [
  "object",
  "boolean"
], _7 = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, E7 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, O7 = {
  $schema: y7,
  $id: v7,
  $vocabulary: b7,
  $dynamicAnchor: w7,
  title: S7,
  type: x7,
  properties: _7,
  $defs: E7
}, k7 = "https://json-schema.org/draft/2020-12/schema", A7 = "https://json-schema.org/draft/2020-12/meta/unevaluated", P7 = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, C7 = "meta", T7 = "Unevaluated applicator vocabulary meta-schema", $7 = [
  "object",
  "boolean"
], R7 = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, I7 = {
  $schema: k7,
  $id: A7,
  $vocabulary: P7,
  $dynamicAnchor: C7,
  title: T7,
  type: $7,
  properties: R7
}, j7 = "https://json-schema.org/draft/2020-12/schema", N7 = "https://json-schema.org/draft/2020-12/meta/content", L7 = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, M7 = "meta", D7 = "Content vocabulary meta-schema", F7 = [
  "object",
  "boolean"
], z7 = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, q7 = {
  $schema: j7,
  $id: N7,
  $vocabulary: L7,
  $dynamicAnchor: M7,
  title: D7,
  type: F7,
  properties: z7
}, B7 = "https://json-schema.org/draft/2020-12/schema", U7 = "https://json-schema.org/draft/2020-12/meta/core", V7 = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, W7 = "meta", H7 = "Core vocabulary meta-schema", Q7 = [
  "object",
  "boolean"
], Y7 = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, G7 = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, K7 = {
  $schema: B7,
  $id: U7,
  $vocabulary: V7,
  $dynamicAnchor: W7,
  title: H7,
  type: Q7,
  properties: Y7,
  $defs: G7
}, X7 = "https://json-schema.org/draft/2020-12/schema", J7 = "https://json-schema.org/draft/2020-12/meta/format-annotation", Z7 = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, eQ = "meta", tQ = "Format vocabulary meta-schema for annotation results", rQ = [
  "object",
  "boolean"
], nQ = {
  format: {
    type: "string"
  }
}, iQ = {
  $schema: X7,
  $id: J7,
  $vocabulary: Z7,
  $dynamicAnchor: eQ,
  title: tQ,
  type: rQ,
  properties: nQ
}, oQ = "https://json-schema.org/draft/2020-12/schema", sQ = "https://json-schema.org/draft/2020-12/meta/meta-data", aQ = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, lQ = "meta", uQ = "Meta-data vocabulary meta-schema", cQ = [
  "object",
  "boolean"
], pQ = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, fQ = {
  $schema: oQ,
  $id: sQ,
  $vocabulary: aQ,
  $dynamicAnchor: lQ,
  title: uQ,
  type: cQ,
  properties: pQ
}, dQ = "https://json-schema.org/draft/2020-12/schema", hQ = "https://json-schema.org/draft/2020-12/meta/validation", mQ = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, gQ = "meta", yQ = "Validation vocabulary meta-schema", vQ = [
  "object",
  "boolean"
], bQ = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, wQ = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, SQ = {
  $schema: dQ,
  $id: hQ,
  $vocabulary: mQ,
  $dynamicAnchor: gQ,
  title: yQ,
  type: vQ,
  properties: bQ,
  $defs: wQ
};
var PP;
function xQ() {
  if (PP) return nh;
  PP = 1, Object.defineProperty(nh, "__esModule", { value: !0 }), nh.default = p;
  const e = g7, t = O7, r = I7, n = q7, i = K7, s = iQ, o = fQ, a = SQ, l = ["/properties"];
  function p(f) {
    return [
      e,
      t,
      r,
      n,
      i,
      d(this, s),
      o,
      d(this, a)
    ].forEach((m) => this.addMetaSchema(m, void 0, !1)), this;
    function d(m, v) {
      return f ? m.$dataMetaSchema(v, l) : v;
    }
  }
  return nh;
}
var CP;
function _Q() {
  return CP || (CP = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
    const r = yH(), n = i7(), i = s7(), s = xQ(), o = "https://json-schema.org/draft/2020-12/schema";
    class a extends r.default {
      constructor(d = {}) {
        super({
          ...d,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((d) => this.addVocabulary(d)), this.opts.discriminator && this.addKeyword(i.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: d, meta: m } = this.opts;
        m && (s.default.call(this, d), this.refs["http://json-schema.org/schema"] = o);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
      }
    }
    e.exports = t = a, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;
    var l = bg();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return l.KeywordCxt;
    } });
    var p = ot();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return p._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return p.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return p.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return p.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return p.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return p.CodeGen;
    } });
  }(ld, ld.exports)), ld.exports;
}
var TP;
function EQ() {
  if (TP) return ad;
  TP = 1, Object.defineProperty(ad, "__esModule", { value: !0 }), ad.getNodeTypesFromJSONSchema = o;
  const e = _Q(), t = Sn(), r = new e.default({
    strictSchema: !1,
    allowUnionTypes: !0,
    useDefaults: !0,
    allErrors: !0,
    discriminator: !0,
    strictTypes: !1,
    verbose: !0
  });
  function n(a, l) {
    if (l.some((p) => typeof p == "function"))
      throw new Error("Unexpected oneOf inside oneOf.");
    return (p) => {
      let f = a.findIndex((d) => r.validate(d, p));
      return f === -1 && (f = 0), l[f];
    };
  }
  function i(a, l, p) {
    var f;
    if (!l || typeof l == "boolean")
      throw new Error(`Unexpected schema in ${a}.`);
    if (l instanceof Array)
      throw new Error(`Unexpected array schema in ${a}. Try using oneOf instead.`);
    if (l.type === "null")
      throw new Error(`Unexpected null schema type in ${a} schema.`);
    if (l.type instanceof Array)
      throw new Error(`Unexpected array schema type in ${a} schema. Try using oneOf instead.`);
    if (l.type === "string" || l.type === "number" || l.type === "integer" || l.type === "boolean") {
      const { default: d, format: m, ...v } = l;
      return v;
    }
    if (l.type === "object" && !l.properties && !l.oneOf) {
      if (l.additionalProperties === void 0 || l.additionalProperties === !0)
        return { type: "object" };
      if (l.additionalProperties === !1)
        return { type: "object", properties: {} };
    }
    if (l.allOf)
      throw new Error(`Unexpected allOf in ${a}.`);
    if (l.anyOf)
      throw new Error(`Unexpected anyOf in ${a}.`);
    if ((0, t.isPlainObject)(l.properties) || (0, t.isPlainObject)(l.additionalProperties) || (0, t.isPlainObject)(l.items) && ((0, t.isPlainObject)(l.items.properties) || (0, t.isPlainObject)(l.items.additionalProperties) || l.items.oneOf))
      return s(a, l, p);
    if (l.oneOf)
      if (l.discriminator) {
        const d = (f = l.discriminator) == null ? void 0 : f.propertyName;
        if (!d)
          throw new Error(`Unexpected discriminator without a propertyName in ${a}.`);
        const m = l.oneOf.map((v, g) => {
          var x;
          if (typeof v == "boolean")
            throw new Error(`Unexpected boolean schema in ${a} at position ${g} in oneOf.`);
          const S = (x = v == null ? void 0 : v.properties) == null ? void 0 : x[d];
          if (!S || typeof S == "boolean")
            throw new Error(`Unexpected property '${S}' schema in ${a} at position ${g} in oneOf.`);
          const _ = S.const;
          return i(_, v, p);
        });
        return (v, g) => {
          if ((0, t.isPlainObject)(v)) {
            const S = v[d];
            if (typeof S == "string" && p[S])
              return S;
          }
          return n(l.oneOf, m)(v, g);
        };
      } else {
        const d = l.oneOf.map((m, v) => i(a + "_" + v, m, p));
        return n(l.oneOf, d);
      }
    return l;
  }
  function s(a, l, p) {
    if (!l || typeof l == "boolean")
      throw new Error(`Unexpected schema in ${a}.`);
    if (l instanceof Array)
      throw new Error(`Unexpected array schema in ${a}. Try using oneOf instead.`);
    if (l.type === "null")
      throw new Error(`Unexpected null schema type in ${a} schema.`);
    if (l.type instanceof Array)
      throw new Error(`Unexpected array schema type in ${a} schema. Try using oneOf instead.`);
    const f = {};
    for (const [g, S] of Object.entries(l.properties || {}))
      f[g] = i(a + "." + g, S, p);
    let d;
    (0, t.isPlainObject)(l.additionalProperties) && (d = i(a + "_additionalProperties", l.additionalProperties, p)), l.additionalProperties === !0 && (d = {});
    let m;
    (0, t.isPlainObject)(l.items) && ((0, t.isPlainObject)(l.items.properties) || (0, t.isPlainObject)(l.items.additionalProperties) || l.items.oneOf) && (m = i(a + "_items", l.items, p));
    let v = l.required;
    return l.oneOf && l.oneOf.every((g) => !!g.required) && (v = (g) => {
      const S = l.oneOf.map((x) => [
        ...l.required || [],
        ...x.required
      ]);
      let _ = S.findIndex((x) => x.every((y) => g[y] !== void 0));
      return _ === -1 && (_ = 0), S[_];
    }), p[a] = { properties: f, additionalProperties: d, items: m, required: v }, a;
  }
  function o(a, l) {
    const p = {};
    return i(a, l, p), p;
  }
  return ad;
}
var $P;
function OQ() {
  if ($P) return qa;
  $P = 1, Object.defineProperty(qa, "__esModule", { value: !0 }), qa.ConfigTypes = void 0, qa.createConfigTypes = $e;
  const e = tH, t = ai(), r = Sn(), n = EQ(), i = AS(), s = [
    "spec",
    "info-contact",
    "operation-operationId",
    "tag-description",
    "tags-alphabetical",
    "info-license-url",
    "info-license-strict",
    "info-license",
    "no-ambiguous-paths",
    "no-enum-type-mismatch",
    "no-http-verbs-in-paths",
    "no-identical-paths",
    "no-invalid-parameter-examples",
    "no-invalid-schema-examples",
    "no-path-trailing-slash",
    "operation-2xx-response",
    "operation-4xx-response",
    "operation-description",
    "operation-operationId-unique",
    "operation-operationId-url-safe",
    "operation-parameters-unique",
    "operation-singular-tag",
    "operation-summary",
    "operation-tag-defined",
    "parameter-description",
    "path-declaration-must-exist",
    "path-excludes-patterns",
    "path-http-verbs-order",
    "path-not-include-query",
    "path-params-defined",
    "path-parameters-defined",
    "path-segment-plural",
    "paths-kebab-case",
    "required-string-property-missing-min-length",
    "response-contains-header",
    "scalar-property-missing-example",
    "security-defined",
    "spec-strict-refs",
    "no-unresolved-refs",
    "no-required-schema-properties-undefined"
  ], o = [
    "boolean-parameter-prefixes",
    "request-mime-type",
    "response-contains-property",
    "response-mime-type"
  ], a = [
    "boolean-parameter-prefixes",
    "component-name-unique",
    "no-empty-servers",
    "no-example-value-and-externalValue",
    "no-invalid-media-type-examples",
    "no-server-example.com",
    "no-server-trailing-slash",
    "no-server-variables-empty-enum",
    "no-undefined-server-variable",
    "no-unused-components",
    "operation-4xx-problem-details-rfc7807",
    "request-mime-type",
    "response-contains-property",
    "response-mime-type",
    "spec-components-invalid-map-name",
    "array-parameter-serialization"
  ], l = [
    "spec",
    "info-contact",
    "info-license-strict",
    "operation-operationId",
    "tag-description",
    "tags-alphabetical",
    "channels-kebab-case",
    "no-channel-trailing-slash"
  ], p = [
    "spec",
    "info-contact",
    "info-license-strict",
    "operation-operationId",
    "tag-description",
    "tags-alphabetical",
    "channels-kebab-case",
    "no-channel-trailing-slash"
  ], f = [
    "spec",
    "parameters-not-in-body",
    "sourceDescription-type",
    "version-enum",
    "workflowId-unique",
    "stepId-unique",
    "sourceDescription-name-unique",
    "workflow-dependsOn",
    "parameters-unique",
    "step-onSuccess-unique",
    "step-onFailure-unique",
    "requestBody-replacements-unique",
    "no-criteria-xpath",
    "no-actions-type-end",
    "criteria-unique"
  ], d = [
    ...s,
    ...o,
    ...a,
    ...l,
    ...p,
    ...f
  ], m = {
    properties: {
      extends: {
        type: "array",
        items: {
          type: "string"
        }
      },
      rules: "Rules",
      oas2Rules: "Rules",
      oas3_0Rules: "Rules",
      oas3_1Rules: "Rules",
      async2Rules: "Rules",
      arazzoRules: "Rules",
      preprocessors: { type: "object" },
      oas2Preprocessors: { type: "object" },
      oas3_0Preprocessors: { type: "object" },
      oas3_1Preprocessors: { type: "object" },
      async2Preprocessors: { type: "object" },
      arazzoPreprocessors: { type: "object" },
      decorators: { type: "object" },
      oas2Decorators: { type: "object" },
      oas3_0Decorators: { type: "object" },
      oas3_1Decorators: { type: "object" },
      async2Decorators: { type: "object" },
      arazzoDecorators: { type: "object" }
    }
  }, v = (xe) => ({
    ...xe.rootRedoclyConfigSchema,
    properties: {
      ...xe.rootRedoclyConfigSchema.properties,
      ...m.properties,
      apis: "ConfigApis",
      // Override apis with internal format
      "features.openapi": "ConfigReferenceDocs",
      // deprecated
      "features.mockServer": "ConfigMockServer",
      // deprecated
      organization: { type: "string" },
      region: { enum: ["us", "eu"] },
      telemetry: { enum: ["on", "off"] },
      resolve: {
        properties: {
          http: "ConfigHTTP",
          doNotResolveExamples: { type: "boolean" }
        }
      },
      files: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }
  }), g = {
    properties: {},
    additionalProperties: "ConfigApisProperties"
  }, S = (xe) => {
    var Le;
    return {
      ...xe["rootRedoclyConfigSchema.apis_additionalProperties"],
      properties: {
        ...(Le = xe["rootRedoclyConfigSchema.apis_additionalProperties"]) == null ? void 0 : Le.properties,
        labels: {
          type: "array",
          items: {
            type: "string"
          }
        },
        ...m.properties,
        "features.openapi": "ConfigReferenceDocs",
        // deprecated
        "features.mockServer": "ConfigMockServer",
        // deprecated
        files: {
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    };
  }, _ = {
    properties: {
      headers: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }
  }, x = {
    properties: {},
    additionalProperties: (xe, Le) => {
      if (Le.startsWith("rule/"))
        return "Assert";
      if (Le.startsWith("assert/"))
        return "Assert";
      if (d.includes(Le) || (0, r.isCustomRuleId)(Le))
        return typeof xe == "string" ? { enum: ["error", "warn", "off"] } : "ObjectRule";
      if (Le === "metadata-schema" || Le === "custom-fields-schema")
        return "Schema";
    }
  }, y = {
    properties: {
      severity: { enum: ["error", "warn", "off"] }
    },
    additionalProperties: {},
    required: ["severity"]
  }, w = {
    properties: {},
    additionalProperties: {}
  };
  function k(xe) {
    return {
      properties: {
        type: {
          enum: [.../* @__PURE__ */ new Set(["any", ...xe, "SpecExtension"])]
        },
        property: (Le) => Array.isArray(Le) ? { type: "array", items: { type: "string" } } : Le === null ? null : { type: "string" },
        filterInParentKeys: { type: "array", items: { type: "string" } },
        filterOutParentKeys: { type: "array", items: { type: "string" } },
        matchParentKeys: { type: "string" }
      },
      required: ["type"]
    };
  }
  const A = {
    properties: {
      enum: { type: "array", items: { type: "string" } },
      pattern: { type: "string" },
      notPattern: { type: "string" },
      casing: {
        enum: [
          "camelCase",
          "kebab-case",
          "snake_case",
          "PascalCase",
          "MACRO_CASE",
          "COBOL-CASE",
          "flatcase"
        ]
      },
      mutuallyExclusive: { type: "array", items: { type: "string" } },
      mutuallyRequired: { type: "array", items: { type: "string" } },
      required: { type: "array", items: { type: "string" } },
      requireAny: { type: "array", items: { type: "string" } },
      disallowed: { type: "array", items: { type: "string" } },
      defined: { type: "boolean" },
      // undefined: { type: 'boolean' }, // TODO: Remove `undefined` assertion from codebase overall
      nonEmpty: { type: "boolean" },
      minLength: { type: "integer" },
      maxLength: { type: "integer" },
      ref: (xe) => typeof xe == "string" ? { type: "string" } : { type: "boolean" },
      const: (xe) => {
        if (typeof xe == "string")
          return { type: "string" };
        if (typeof xe == "number")
          return { type: "number" };
        if (typeof xe == "boolean")
          return { type: "boolean" };
      }
    },
    additionalProperties: (xe, Le) => {
      if (/^\w+\/\w+$/.test(Le))
        return { type: "object" };
    }
  }, T = {
    properties: {
      subject: "AssertionDefinitionSubject",
      assertions: "AssertionDefinitionAssertions"
    },
    required: ["subject", "assertions"]
  }, R = {
    properties: {
      subject: "AssertionDefinitionSubject",
      assertions: "AssertionDefinitionAssertions",
      where: (0, t.listOf)("AssertDefinition"),
      message: { type: "string" },
      suggest: { type: "array", items: { type: "string" } },
      severity: { enum: ["error", "warn", "off"] }
    },
    required: ["subject", "assertions"]
  }, I = {
    properties: {
      label: { type: "string" },
      lang: {
        enum: [
          "curl",
          "C#",
          "Go",
          "Java",
          "Java8+Apache",
          "JavaScript",
          "Node.js",
          "PHP",
          "Python",
          "R",
          "Ruby"
        ]
      }
    },
    required: ["lang"]
  }, B = {
    properties: {
      enum: { type: "string" },
      enumSingleValue: { type: "string" },
      enumArray: { type: "string" },
      default: { type: "string" },
      deprecated: { type: "string" },
      example: { type: "string" },
      examples: { type: "string" },
      nullable: { type: "string" },
      recursive: { type: "string" },
      arrayOf: { type: "string" },
      webhook: { type: "string" },
      authorizations: { type: "string" },
      tryItAuthBasicUsername: { type: "string" },
      tryItAuthBasicPassword: { type: "string" }
    }
  }, L = {
    properties: {
      beforeInfo: (0, t.listOf)("CommonConfigSidebarLinks"),
      end: (0, t.listOf)("CommonConfigSidebarLinks")
    }
  }, Y = {
    properties: {
      label: { type: "string" },
      link: { type: "string" },
      target: { type: "string" }
    },
    required: ["label", "link"]
  }, Q = {
    properties: {
      main: { type: "string" },
      light: { type: "string" },
      dark: { type: "string" },
      contrastText: { type: "string" }
    }
  }, re = {
    properties: {
      backgroundColor: { type: "string" },
      borderColor: { type: "string" },
      color: { type: "string" },
      tabTextColor: { type: "string" }
    }
  }, oe = {
    properties: (0, r.pickObjectProps)(Q.properties, ["light", "dark"])
  }, ce = {
    properties: {
      basic: { type: "string" },
      delete: { type: "string" },
      get: { type: "string" },
      head: { type: "string" },
      link: { type: "string" },
      options: { type: "string" },
      patch: { type: "string" },
      post: { type: "string" },
      put: { type: "string" }
    }
  }, pe = {
    properties: {
      error: "CommonColorProps",
      info: "CommonColorProps",
      redirect: "CommonColorProps",
      success: "CommonColorProps"
    }
  }, fe = {
    properties: (0, r.omitObjectProps)(Q.properties, ["dark"])
  }, G = {
    properties: {
      primary: { type: "string" },
      secondary: { type: "string" },
      light: { type: "string" }
    }
  }, Z = {
    properties: {
      accent: "CommonThemeColors",
      border: "BorderThemeColors",
      error: "CommonThemeColors",
      http: "HttpColors",
      primary: "CommonThemeColors",
      responses: "ResponseColors",
      secondary: "SecondaryColors",
      success: "CommonThemeColors",
      text: "TextThemeColors",
      tonalOffset: { type: "number" },
      warning: "CommonThemeColors"
    }
  }, K = {
    properties: {
      fontSize: { type: "string" },
      padding: { type: "string" },
      minWidth: { type: "string" }
    }
  }, z = {
    properties: {
      small: "SizeProps",
      medium: "SizeProps",
      large: "SizeProps",
      xlarge: "SizeProps"
    }
  }, te = {
    properties: {
      fontFamily: { type: "string" },
      fontSize: { type: "string" },
      fontWeight: { type: "string" },
      lineHeight: { type: "string" }
    }
  }, q = {
    properties: {
      ...(0, r.omitObjectProps)(te.properties, ["fontSize", "lineHeight"]),
      borderRadius: { type: "string" },
      hoverStyle: { type: "string" },
      boxShadow: { type: "string" },
      hoverBoxShadow: { type: "string" },
      sizes: "Sizes"
    }
  }, j = {
    properties: (0, r.pickObjectProps)(te.properties, ["fontSize", "lineHeight"])
  }, H = {
    properties: {
      medium: "BadgeFontConfig",
      small: "BadgeFontConfig"
    }
  }, F = {
    properties: {
      ...(0, r.omitObjectProps)(te.properties, ["fontSize", "lineHeight"]),
      borderRadius: { type: "string" },
      color: { type: "string" },
      sizes: "BadgeSizes"
    }
  }, ue = {
    properties: {
      top: { type: "string" },
      width: { type: "string" },
      height: { type: "string" }
    }
  }, ge = {
    properties: {
      borderRadius: { type: "string" },
      backgroundColor: { type: "string" }
    }
  }, Ae = {
    properties: {
      fullWidth: { type: "boolean" }
    }
  }, C = {
    properties: {
      buttons: "ButtonsConfig",
      httpBadges: "HttpBadgesConfig",
      layoutControls: "LabelControls",
      panels: "Panels",
      tryItButton: "TryItButton",
      tryItSendButton: "TryItButton"
    }
  }, N = {
    properties: {
      small: { type: "string" },
      medium: { type: "string" },
      large: { type: "string" }
    }
  }, J = {
    properties: {
      maxWidth: "Breakpoints"
    }
  }, X = {
    properties: {
      maxWidth: "Breakpoints",
      middlePanelMaxWidth: "Breakpoints"
    }
  }, ae = {
    properties: {
      showDarkRightPanel: { type: "boolean" },
      stacked: "StackedConfig",
      "three-panel": "ThreePanelConfig"
    }
  }, U = {
    properties: {
      backgroundColor: { type: "string" },
      border: { type: "string" }
    }
  }, W = {
    properties: {
      breakFieldNames: { type: "boolean" },
      caretColor: { type: "string" },
      caretSize: { type: "string" },
      constraints: "SchemaColorsConfig",
      defaultDetailsWidth: { type: "string" },
      examples: "SchemaColorsConfig",
      labelsTextSize: { type: "string" },
      linesColor: { type: "string" },
      nestedBackground: { type: "string" },
      nestingSpacing: { type: "string" },
      requireLabelColor: { type: "string" },
      typeNameColor: { type: "string" },
      typeTitleColor: { type: "string" }
    }
  }, ve = {
    properties: {
      subItemsColor: { type: "string" },
      textTransform: { type: "string" },
      fontWeight: { type: "string" }
    }
  }, he = {
    properties: (0, r.pickObjectProps)(ve.properties, ["textTransform"])
  }, Te = {
    properties: {
      unit: { type: "number" },
      paddingHorizontal: { type: "string" },
      paddingVertical: { type: "string" },
      offsetTop: { type: "string" },
      offsetLeft: { type: "string" },
      offsetNesting: { type: "string" }
    }
  }, Se = {
    properties: {
      ...(0, r.omitObjectProps)(te.properties, ["fontWeight", "lineHeight"]),
      activeBgColor: { type: "string" },
      activeTextColor: { type: "string" },
      backgroundColor: { type: "string" },
      borderRadius: { type: "string" },
      breakPath: { type: "boolean" },
      caretColor: { type: "string" },
      caretSize: { type: "string" },
      groupItems: "GroupItemsConfig",
      level1items: "Level1Items",
      rightLineColor: { type: "string" },
      separatorLabelColor: { type: "string" },
      showAtBreakpoint: { type: "string" },
      spacing: "SpacingConfig",
      textColor: { type: "string" },
      width: { type: "string" }
    }
  }, O = {
    properties: {
      ...te.properties,
      color: { type: "string" },
      transform: { type: "string" }
    }
  }, M = {
    properties: {
      ...te.properties,
      backgroundColor: { type: "string" },
      color: { type: "string" },
      wordBreak: {
        enum: [
          "break-all",
          "break-word",
          "keep-all",
          "normal",
          "revert",
          "unset",
          "inherit",
          "initial"
        ]
      },
      wrap: { type: "boolean" }
    }
  }, le = {
    properties: (0, r.omitObjectProps)(te.properties, ["fontSize"])
  }, ye = {
    properties: {
      color: { type: "string" },
      hover: { type: "string" },
      textDecoration: { type: "string" },
      hoverTextDecoration: { type: "string" },
      visited: { type: "string" }
    }
  }, be = {
    properties: {
      code: "CodeConfig",
      fieldName: "FontConfig",
      ...(0, r.pickObjectProps)(te.properties, ["fontSize", "fontFamily"]),
      fontWeightBold: { type: "string" },
      fontWeightLight: { type: "string" },
      fontWeightRegular: { type: "string" },
      heading1: "Heading",
      heading2: "Heading",
      heading3: "Heading",
      headings: "HeadingsConfig",
      lineHeight: { type: "string" },
      links: "LinksConfig",
      optimizeSpeed: { type: "boolean" },
      rightPanelHeading: "Heading",
      smoothing: { enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"] }
    }
  }, Pe = {
    properties: {
      color: { type: "string" },
      ...(0, r.omitObjectProps)(te.properties, ["fontWeight"])
    }
  }, ke = {
    properties: {
      backgroundColor: { type: "string" },
      borderRadius: { type: "string" },
      tokens: "TokenProps"
    }
  }, Me = {
    properties: {
      gutter: { type: "string" },
      maxHeight: { type: "string" },
      maxWidth: { type: "string" }
    }
  }, We = {
    properties: {
      backgroundColor: { type: "string" },
      color: { type: "string" }
    }
  }, Xe = {
    properties: {
      custom: { type: "string" }
    }
  }, Ge = {
    properties: {
      DownloadButton: "ButtonOverrides",
      NextSectionButton: "ButtonOverrides"
    }
  }, Ue = {
    properties: {
      backgroundColor: { type: "string" },
      panelBackgroundColor: { type: "string" },
      panelControlsBackgroundColor: { type: "string" },
      showAtBreakpoint: { type: "string" },
      textColor: { type: "string" },
      width: { type: "string" }
    }
  }, Et = {
    properties: { borderRadius: { type: "string" } }
  }, D = {
    properties: {
      sectionHorizontal: { type: "number" },
      sectionVertical: { type: "number" },
      unit: { type: "number" }
    }
  }, we = {
    properties: {
      breakpoints: "Breakpoints",
      codeBlock: "CodeBlock",
      colors: "ThemeColors",
      components: "ConfigThemeComponents",
      layout: "Layout",
      logo: "ConfigThemeLogo",
      fab: "Fab",
      overrides: "Overrides",
      rightPanel: "RightPanel",
      schema: "ConfigThemeSchema",
      shape: "Shape",
      sidebar: "Sidebar",
      spacing: "ThemeSpacing",
      typography: "Typography",
      links: { properties: { color: { type: "string" } } },
      // deprecated
      codeSample: { properties: { backgroundColor: { type: "string" } } }
      // deprecated
    }
  }, Oe = {
    properties: {
      skipOptionalParameters: { type: "boolean" },
      languages: (0, t.listOf)("ConfigLanguage")
    },
    required: ["languages"]
  }, Ee = {
    properties: {
      theme: "ConfigTheme",
      corsProxyUrl: { type: "string" },
      ctrlFHijack: { type: "boolean" },
      defaultSampleLanguage: { type: "string" },
      disableDeepLinks: { type: "boolean" },
      disableSearch: { type: "boolean" },
      disableSidebar: { type: "boolean" },
      downloadDefinitionUrl: { type: "string" },
      expandDefaultServerVariables: { type: "boolean" },
      enumSkipQuotes: { type: "boolean" },
      expandDefaultRequest: { type: "boolean" },
      expandDefaultResponse: { type: "boolean" },
      expandResponses: { type: "string" },
      expandSingleSchemaField: { type: "boolean" },
      generateCodeSamples: "GenerateCodeSamples",
      generatedPayloadSamplesMaxDepth: { type: "number" },
      hideDownloadButton: { type: "boolean" },
      hideHostname: { type: "boolean" },
      hideInfoSection: { type: "boolean" },
      hideLoading: { type: "boolean" },
      hideLogo: { type: "boolean" },
      hideRequestPayloadSample: { type: "boolean" },
      hideRightPanel: { type: "boolean" },
      hideSchemaPattern: { type: "boolean" },
      hideSchemaTitles: { type: "boolean" },
      hideSingleRequestSampleTab: { type: "boolean" },
      hideSecuritySection: { type: "boolean" },
      hideTryItPanel: { type: "boolean" },
      hideFab: { type: "boolean" },
      hideOneOfDescription: { type: "boolean" },
      htmlTemplate: { type: "string" },
      jsonSampleExpandLevel: (xe) => typeof xe == "number" ? { type: "number", minimum: 1 } : { type: "string" },
      labels: "ConfigLabels",
      layout: { enum: ["stacked", "three-panel"] },
      maxDisplayedEnumValues: { type: "number" },
      menuToggle: { type: "boolean" },
      nativeScrollbars: { type: "boolean" },
      noAutoAuth: { type: "boolean" },
      // deprecated
      oAuth2RedirectURI: { type: "string" },
      onDeepLinkClick: { type: "object" },
      onlyRequiredInSamples: { type: "boolean" },
      pagination: { enum: ["none", "section", "item"] },
      pathInMiddlePanel: { type: "boolean" },
      payloadSampleIdx: { type: "number", minimum: 0 },
      requestInterceptor: { type: "object" },
      requiredPropsFirst: { type: "boolean" },
      routingBasePath: { type: "string" },
      routingStrategy: { type: "string" },
      // deprecated
      samplesTabsMaxCount: { type: "number" },
      schemaExpansionLevel: (xe) => typeof xe == "number" ? { type: "number", minimum: 0 } : { type: "string" },
      schemaDefinitionsTagName: { type: "string" },
      minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
      maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
      scrollYOffset: (xe) => typeof xe == "number" ? { type: "number" } : { type: "string" },
      searchAutoExpand: { type: "boolean" },
      searchFieldLevelBoost: { type: "number", minimum: 0 },
      searchMaxDepth: { type: "number", minimum: 1 },
      searchMode: { enum: ["default", "path-only"] },
      searchOperationTitleBoost: { type: "number" },
      searchTagTitleBoost: { type: "number" },
      sendXUserAgentInTryIt: { type: "boolean" },
      showChangeLayoutButton: { type: "boolean" },
      showConsole: { type: "boolean" },
      // deprecated
      showExtensions: (xe) => typeof xe == "boolean" ? { type: "boolean" } : {
        type: "array",
        items: {
          type: "string"
        }
      },
      showNextButton: { type: "boolean" },
      showRightPanelToggle: { type: "boolean" },
      showSecuritySchemeType: { type: "boolean" },
      showWebhookVerb: { type: "boolean" },
      showObjectSchemaExamples: { type: "boolean" },
      disableTryItRequestUrlEncoding: { type: "boolean" },
      sidebarLinks: "ConfigSidebarLinks",
      sideNavStyle: { enum: ["summary-only", "path-first", "id-only"] },
      simpleOneOfTypeLabel: { type: "boolean" },
      sortEnumValuesAlphabetically: { type: "boolean" },
      sortOperationsAlphabetically: { type: "boolean" },
      sortPropsAlphabetically: { type: "boolean" },
      sortTagsAlphabetically: { type: "boolean" },
      suppressWarnings: { type: "boolean" },
      // deprecated
      unstable_externalDescription: { type: "boolean" },
      // deprecated
      unstable_ignoreMimeParameters: { type: "boolean" },
      untrustedDefinition: { type: "boolean" },
      mockServer: {
        properties: {
          url: { type: "string" },
          position: { enum: ["first", "last", "replace", "off"] },
          description: { type: "string" }
        }
      },
      showAccessMode: { type: "boolean" },
      preserveOriginalExtensionsName: { type: "boolean" },
      markdownHeadingsAnchorLevel: { type: "number" }
    },
    additionalProperties: {}
  }, Ce = {
    properties: {
      strictExamples: { type: "boolean" },
      errorIfForcedExampleNotFound: { type: "boolean" }
    }
  };
  function $e(xe, Le) {
    const Ye = Object.values(i.SpecVersion).flatMap((rt) => {
      const ut = Le != null && Le.styleguide ? Le.styleguide.extendTypes((0, i.getTypes)(rt), rt) : (0, i.getTypes)(rt);
      return Object.keys(ut);
    }), mt = (0, n.getNodeTypesFromJSONSchema)("rootRedoclyConfigSchema", xe);
    return {
      ...Fe,
      ConfigRoot: v(mt),
      // This is the REAL config root type
      ConfigApisProperties: S(mt),
      AssertionDefinitionSubject: k(Ye),
      ...mt
    };
  }
  const Fe = {
    Assert: R,
    ConfigApis: g,
    ConfigStyleguide: m,
    ConfigReferenceDocs: Ee,
    ConfigMockServer: Ce,
    ConfigHTTP: _,
    ConfigLanguage: I,
    ConfigLabels: B,
    ConfigSidebarLinks: L,
    CommonConfigSidebarLinks: Y,
    ConfigTheme: we,
    AssertDefinition: T,
    ThemeColors: Z,
    CommonThemeColors: Q,
    BorderThemeColors: oe,
    HttpColors: ce,
    ResponseColors: pe,
    SecondaryColors: fe,
    TextThemeColors: G,
    Sizes: z,
    ButtonsConfig: q,
    CommonColorProps: re,
    BadgeFontConfig: j,
    BadgeSizes: H,
    HttpBadgesConfig: F,
    LabelControls: ue,
    Panels: ge,
    TryItButton: Ae,
    Breakpoints: N,
    StackedConfig: J,
    ThreePanelConfig: X,
    SchemaColorsConfig: U,
    SizeProps: K,
    Level1Items: he,
    SpacingConfig: Te,
    FontConfig: te,
    CodeConfig: M,
    HeadingsConfig: le,
    LinksConfig: ye,
    TokenProps: Pe,
    CodeBlock: ke,
    ConfigThemeLogo: Me,
    Fab: We,
    ButtonOverrides: Xe,
    Overrides: Ge,
    ObjectRule: y,
    Schema: w,
    RightPanel: Ue,
    Rules: x,
    Shape: Et,
    ThemeSpacing: D,
    GenerateCodeSamples: Oe,
    GroupItemsConfig: ve,
    ConfigThemeComponents: C,
    Layout: ae,
    ConfigThemeSchema: W,
    Sidebar: Se,
    Heading: O,
    Typography: be,
    AssertionDefinitionAssertions: A
  };
  return qa.ConfigTypes = $e(e.rootRedoclyConfigSchema), qa;
}
var RP;
function kQ() {
  if (RP) return yi;
  RP = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.OasVersion = void 0, yi.bundleConfig = g, yi.bundle = S, yi.bundleFromString = _, yi.bundleDocument = x, yi.mapTypeToComponent = y;
  const e = OS(), t = vW(), r = ai(), n = bW(), i = AS(), s = Gl(), o = EW(), a = OW(), l = Sn(), p = kW(), f = AW(), d = PW(), m = OQ();
  var v;
  (function(A) {
    A.Version2 = "oas2", A.Version3_0 = "oas3_0", A.Version3_1 = "oas3_1";
  })(v || (yi.OasVersion = v = {}));
  async function g(A, T) {
    const R = (0, r.normalizeTypes)(m.ConfigTypes), I = {
      problems: [],
      oasVersion: i.SpecVersion.OAS3_0,
      refTypes: /* @__PURE__ */ new Map(),
      visitorsData: {}
    }, B = (0, t.normalizeVisitors)([
      {
        severity: "error",
        ruleId: "configBundler",
        visitor: {
          ref: {
            leave(L, Y, Q) {
              w(L, Q, Y);
            }
          }
        }
      }
    ], R);
    return (0, n.walkDocument)({
      document: A,
      rootType: R.ConfigRoot,
      normalizedVisitors: B,
      resolvedRefMap: T,
      ctx: I
    }), A.parsed ?? {};
  }
  async function S(A) {
    var Y;
    const { ref: T, doc: R, externalRefResolver: I = new e.BaseResolver(A.config.resolve), base: B = null } = A;
    if (!(T || R))
      throw new Error(`Document or reference is required.
`);
    const L = R === void 0 ? await I.resolveDocument(B, T, !0) : R;
    if (L instanceof Error)
      throw L;
    return (Y = A.collectSpecData) == null || Y.call(A, L.parsed), x({
      document: L,
      ...A,
      config: A.config.styleguide,
      externalRefResolver: I
    });
  }
  async function _(A) {
    const { source: T, absoluteRef: R, externalRefResolver: I = new e.BaseResolver(A.config.resolve) } = A, B = (0, e.makeDocumentFromString)(T, R || "/");
    return x({
      document: B,
      ...A,
      externalRefResolver: I,
      config: A.config.styleguide
    });
  }
  async function x(A) {
    const { document: T, config: R, customTypes: I, externalRefResolver: B, dereference: L = !1, skipRedoclyRegistryRefs: Y = !1, removeUnusedComponents: Q = !1, keepUrlRefs: re = !1 } = A, oe = (0, i.detectSpec)(T.parsed), ce = (0, i.getMajorSpecVersion)(oe), pe = R.getRulesForOasVersion(ce), fe = (0, r.normalizeTypes)(R.extendTypes(I ?? (0, i.getTypes)(oe), oe), R), G = (0, o.initRules)(pe, R, "preprocessors", oe), Z = (0, o.initRules)(pe, R, "decorators", oe), K = {
      problems: [],
      oasVersion: oe,
      refTypes: /* @__PURE__ */ new Map(),
      visitorsData: {}
    };
    Q && Z.push({
      severity: "error",
      ruleId: "remove-unused-components",
      visitor: ce === i.SpecMajorVersion.OAS2 ? (0, f.RemoveUnusedComponents)({}) : (0, d.RemoveUnusedComponents)({})
    });
    let z = await (0, e.resolveDocument)({
      rootDocument: T,
      rootType: fe.Root,
      externalRefResolver: B
    });
    G.length > 0 && ((0, n.walkDocument)({
      document: T,
      rootType: fe.Root,
      normalizedVisitors: (0, t.normalizeVisitors)(G, fe),
      resolvedRefMap: z,
      ctx: K
    }), z = await (0, e.resolveDocument)({
      rootDocument: T,
      rootType: fe.Root,
      externalRefResolver: B
    }));
    const te = (0, t.normalizeVisitors)([
      {
        severity: "error",
        ruleId: "bundler",
        visitor: k(ce, L, Y, T, z, re)
      },
      ...Z
    ], fe);
    return (0, n.walkDocument)({
      document: T,
      rootType: fe.Root,
      normalizedVisitors: te,
      resolvedRefMap: z,
      ctx: K
    }), {
      bundle: T,
      problems: K.problems.map((q) => R.addProblemToIgnore(q)),
      fileDependencies: B.getFiles(),
      rootType: fe.Root,
      refTypes: K.refTypes,
      visitorsData: K.visitorsData
    };
  }
  function y(A, T) {
    switch (T) {
      case i.SpecMajorVersion.OAS3:
        switch (A) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          case "Response":
            return "responses";
          case "Example":
            return "examples";
          case "RequestBody":
            return "requestBodies";
          case "Header":
            return "headers";
          case "SecuritySchema":
            return "securitySchemes";
          case "Link":
            return "links";
          case "Callback":
            return "callbacks";
          default:
            return null;
        }
      case i.SpecMajorVersion.OAS2:
        switch (A) {
          case "Schema":
            return "definitions";
          case "Parameter":
            return "parameters";
          case "Response":
            return "responses";
          default:
            return null;
        }
      case i.SpecMajorVersion.Async2:
        switch (A) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          default:
            return null;
        }
      case i.SpecMajorVersion.Async3:
        switch (A) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          default:
            return null;
        }
      case i.SpecMajorVersion.Arazzo:
        switch (A) {
          case "Root.x-parameters_items":
          case "Root.workflows_items.parameters_items":
          case "Root.workflows_items.steps_items.parameters_items":
            return "parameters";
          default:
            return null;
        }
    }
  }
  function w(A, T, R) {
    if (!(0, l.isPlainObject)(T.node))
      R.parent[R.key] = T.node;
    else {
      delete A.$ref;
      const I = Object.assign({}, T.node, A);
      Object.assign(A, I);
    }
  }
  function k(A, T, R, I, B, L) {
    let Y, Q;
    const re = {
      ref: {
        leave(G, Z, K) {
          if (!K.location || K.node === void 0) {
            (0, a.reportUnresolvedRef)(K, Z.report, Z.location);
            return;
          }
          if (K.location.source === I.source && K.location.source === Z.location.source && Z.type.name !== "scalar" && !T || R && (0, p.isRedoclyRegistryURL)(G.$ref) || L && (0, s.isAbsoluteUrl)(G.$ref))
            return;
          const z = y(Z.type.name, A);
          z ? T ? (ce(z, K, Z), w(G, K, Z)) : (G.$ref = ce(z, K, Z), oe(G, K, Z)) : w(G, K, Z);
        }
      },
      Root: {
        enter(G, Z) {
          Q = Z.location, A === i.SpecMajorVersion.OAS3 ? Y = G.components = G.components || {} : A === i.SpecMajorVersion.OAS2 ? Y = G : A === i.SpecMajorVersion.Async2 ? Y = G.components = G.components || {} : A === i.SpecMajorVersion.Async3 ? Y = G.components = G.components || {} : A === i.SpecMajorVersion.Arazzo && (Y = G.components = G.components || {});
        }
      }
    };
    A === i.SpecMajorVersion.OAS3 && (re.DiscriminatorMapping = {
      leave(G, Z) {
        for (const K of Object.keys(G)) {
          const z = G[K], te = Z.resolve({ $ref: z });
          if (!te.location || te.node === void 0) {
            (0, a.reportUnresolvedRef)(te, Z.report, Z.location.child(K));
            return;
          }
          const q = y("Schema", A);
          T ? ce(q, te, Z) : G[K] = ce(q, te, Z);
        }
      }
    });
    function oe(G, Z, K) {
      const z = (0, e.makeRefId)(K.location.source.absoluteRef, G.$ref);
      B.set(z, {
        document: I,
        isRemote: !1,
        node: Z.node,
        nodePointer: G.$ref,
        resolved: !0
      });
    }
    function ce(G, Z, K) {
      Y[G] = Y[G] || {};
      const z = fe(Z, G, K);
      return Y[G][z] = Z.node, A === i.SpecMajorVersion.OAS3 ? `#/components/${G}/${z}` : A === i.SpecMajorVersion.Async2 || A === i.SpecMajorVersion.Async3 ? `#/components/${G}/${z}` : `#/${G}/${z}`;
    }
    function pe(G, Z, K) {
      var z;
      return (0, s.isRef)(G) && ((z = K.resolve(G, Q.absolutePointer).location) == null ? void 0 : z.absolutePointer) === Z.location.absolutePointer ? !0 : (0, l.dequal)(G, Z.node);
    }
    function fe(G, Z, K) {
      const [z, te] = [G.location.source.absoluteRef, G.location.pointer], q = Y[Z];
      let j = "";
      const H = te.slice(2).split("/").filter(l.isTruthy);
      for (; H.length > 0; )
        if (j = H.pop() + (j ? `-${j}` : ""), !q || !q[j] || pe(q[j], G, K))
          return j;
      if (j = (0, s.refBaseName)(z) + (j ? `_${j}` : ""), !q[j] || pe(q[j], G, K))
        return j;
      const F = j;
      let ue = 2;
      for (; q[j] && !pe(q[j], G, K); )
        j = `${F}-${ue}`, ue++;
      return q[j] || K.report({
        message: `Two schemas are referenced with the same name but different content. Renamed ${F} to ${j}.`,
        location: K.location,
        forceSeverity: "warn"
      }), j;
    }
    return re;
  }
  return yi;
}
var Gv = {}, yr = {}, IP;
function AQ() {
  if (IP) return yr;
  IP = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.ConfigValidationError = void 0, yr.parsePresetName = n, yr.transformApiDefinitionsToApis = i, yr.prefixRules = a, yr.mergeExtends = l, yr.getMergedConfig = p, yr.checkForDeprecatedFields = f, yr.transformConfig = d, yr.getResolveConfig = v, yr.getUniquePlugins = g, yr.deepCloneMapWithJSON = _, yr.isDeprecatedPluginFormat = x, yr.isCommonJsPlugin = y;
  const e = Sn(), t = DN(), r = tN();
  function n(w) {
    if (w.indexOf("/") > -1) {
      const [k, A] = w.split("/");
      return { pluginId: k, configName: A };
    } else
      return { pluginId: "", configName: w };
  }
  function i(w) {
    if (!w)
      return;
    const k = {};
    for (const [A, T] of Object.entries(w))
      k[A] = { root: T };
    return k;
  }
  function s({ plugins: w, extends: k, rules: A, oas2Rules: T, oas3_0Rules: R, oas3_1Rules: I, async2Rules: B, async3Rules: L, arazzoRules: Y, preprocessors: Q, oas2Preprocessors: re, oas3_0Preprocessors: oe, oas3_1Preprocessors: ce, async2Preprocessors: pe, async3Preprocessors: fe, arazzoPreprocessors: G, decorators: Z, oas2Decorators: K, oas3_0Decorators: z, oas3_1Decorators: te, async2Decorators: q, async3Decorators: j, arazzoDecorators: H, ...F }) {
    var ge;
    const ue = {
      plugins: w,
      extends: k,
      rules: A,
      oas2Rules: T,
      oas3_0Rules: R,
      oas3_1Rules: I,
      async2Rules: B,
      async3Rules: L,
      arazzoRules: Y,
      preprocessors: Q,
      oas2Preprocessors: re,
      oas3_0Preprocessors: oe,
      oas3_1Preprocessors: ce,
      async2Preprocessors: pe,
      async3Preprocessors: fe,
      arazzoPreprocessors: G,
      decorators: Z,
      oas2Decorators: K,
      oas3_0Decorators: z,
      oas3_1Decorators: te,
      async2Decorators: q,
      async3Decorators: j,
      arazzoDecorators: H,
      doNotResolveExamples: (ge = F.resolve) == null ? void 0 : ge.doNotResolveExamples
    };
    if (F.lint && F.styleguide || Object.values(ue).some(e.isDefined) && (F.lint || F.styleguide))
      throw new Error(`Do not use 'lint', 'styleguide' and flat syntax together. 
See more about the configuration in the docs: https://redocly.com/docs/cli/configuration/ 
`);
    return {
      styleguideConfig: Object.values(ue).some(e.isDefined) ? ue : void 0,
      rawConfigRest: F
    };
  }
  function o(w) {
    if (!w)
      return;
    const k = {};
    for (const [A, { lint: T, ...R }] of Object.entries(w)) {
      const { styleguideConfig: I, rawConfigRest: B } = s(R);
      k[A] = {
        styleguide: I || T,
        ...B
      };
    }
    return k;
  }
  function a(w, k) {
    if (!k)
      return w;
    const A = {};
    for (const T of Object.keys(w))
      A[`${k}/${T}`] = w[T];
    return A;
  }
  function l(w) {
    const k = {
      rules: {},
      oas2Rules: {},
      oas3_0Rules: {},
      oas3_1Rules: {},
      async2Rules: {},
      async3Rules: {},
      arazzoRules: {},
      preprocessors: {},
      oas2Preprocessors: {},
      oas3_0Preprocessors: {},
      oas3_1Preprocessors: {},
      async2Preprocessors: {},
      async3Preprocessors: {},
      arazzoPreprocessors: {},
      decorators: {},
      oas2Decorators: {},
      oas3_0Decorators: {},
      oas3_1Decorators: {},
      async2Decorators: {},
      async3Decorators: {},
      arazzoDecorators: {},
      plugins: [],
      pluginPaths: [],
      extendPaths: []
    };
    for (const A of w) {
      if (A.extends)
        throw new Error(`'extends' is not supported in shared configs yet:
${JSON.stringify(A, null, 2)}`);
      Object.assign(k.rules, A.rules), Object.assign(k.oas2Rules, A.oas2Rules), (0, e.assignExisting)(k.oas2Rules, A.rules || {}), Object.assign(k.oas3_0Rules, A.oas3_0Rules), (0, e.assignExisting)(k.oas3_0Rules, A.rules || {}), Object.assign(k.oas3_1Rules, A.oas3_1Rules), (0, e.assignExisting)(k.oas3_1Rules, A.rules || {}), Object.assign(k.async2Rules, A.async2Rules), (0, e.assignExisting)(k.async2Rules, A.rules || {}), Object.assign(k.async3Rules, A.async3Rules), (0, e.assignExisting)(k.async3Rules, A.rules || {}), Object.assign(k.arazzoRules, A.arazzoRules), (0, e.assignExisting)(k.arazzoRules, A.rules || {}), Object.assign(k.preprocessors, A.preprocessors), Object.assign(k.oas2Preprocessors, A.oas2Preprocessors), (0, e.assignExisting)(k.oas2Preprocessors, A.preprocessors || {}), Object.assign(k.oas3_0Preprocessors, A.oas3_0Preprocessors), (0, e.assignExisting)(k.oas3_0Preprocessors, A.preprocessors || {}), Object.assign(k.oas3_1Preprocessors, A.oas3_1Preprocessors), (0, e.assignExisting)(k.oas3_1Preprocessors, A.preprocessors || {}), Object.assign(k.async2Preprocessors, A.async2Preprocessors), (0, e.assignExisting)(k.async2Preprocessors, A.preprocessors || {}), Object.assign(k.async3Preprocessors, A.async3Preprocessors), (0, e.assignExisting)(k.async3Preprocessors, A.preprocessors || {}), Object.assign(k.arazzoPreprocessors, A.arazzoPreprocessors), (0, e.assignExisting)(k.arazzoPreprocessors, A.preprocessors || {}), Object.assign(k.decorators, A.decorators), Object.assign(k.oas2Decorators, A.oas2Decorators), (0, e.assignExisting)(k.oas2Decorators, A.decorators || {}), Object.assign(k.oas3_0Decorators, A.oas3_0Decorators), (0, e.assignExisting)(k.oas3_0Decorators, A.decorators || {}), Object.assign(k.oas3_1Decorators, A.oas3_1Decorators), (0, e.assignExisting)(k.oas3_1Decorators, A.decorators || {}), Object.assign(k.async2Decorators, A.async2Decorators), (0, e.assignExisting)(k.async2Decorators, A.decorators || {}), Object.assign(k.async3Decorators, A.async3Decorators), (0, e.assignExisting)(k.async3Decorators, A.decorators || {}), Object.assign(k.arazzoDecorators, A.arazzoDecorators), (0, e.assignExisting)(k.arazzoDecorators, A.decorators || {}), k.plugins.push(...A.plugins || []), k.pluginPaths.push(...A.pluginPaths || []), k.extendPaths.push(...new Set(A.extendPaths));
    }
    return k;
  }
  function p(w, k) {
    var R, I, B, L, Y, Q, re;
    const A = [
      ...Object.values(w.apis).map((oe) => {
        var ce;
        return (ce = oe == null ? void 0 : oe.styleguide) == null ? void 0 : ce.extendPaths;
      }),
      (I = (R = w.rawConfig) == null ? void 0 : R.styleguide) == null ? void 0 : I.extendPaths
    ].flat().filter(e.isTruthy), T = [
      ...Object.values(w.apis).map((oe) => {
        var ce;
        return (ce = oe == null ? void 0 : oe.styleguide) == null ? void 0 : ce.pluginPaths;
      }),
      (L = (B = w.rawConfig) == null ? void 0 : B.styleguide) == null ? void 0 : L.pluginPaths
    ].flat().filter(e.isTruthy);
    return k ? new t.Config({
      ...w.rawConfig,
      styleguide: {
        ...w.apis[k] ? w.apis[k].styleguide : w.rawConfig.styleguide,
        extendPaths: A,
        pluginPaths: T
      },
      theme: {
        ...w.rawConfig.theme,
        ...(Y = w.apis[k]) == null ? void 0 : Y.theme
      },
      files: [...w.files, ...((re = (Q = w.apis) == null ? void 0 : Q[k]) == null ? void 0 : re.files) ?? []]
      // TODO: merge everything else here
    }, w.configFile) : w;
  }
  function f(w, k, A, T) {
    const R = A.apis && Object.values(A.apis).some((I) => I[w]);
    A[w] && k === null && (0, e.showWarningForDeprecatedField)(w), A[w] && k && A[k] && (0, e.showErrorForDeprecatedField)(w, k), A[w] && T && A[T] && (0, e.showErrorForDeprecatedField)(w, k, T), (A[w] || R) && (0, e.showWarningForDeprecatedField)(w, k, T);
  }
  function d(w) {
    var re, oe;
    const k = [
      ["apiDefinitions", "apis", void 0],
      ["referenceDocs", "openapi", "theme"],
      ["lint", void 0, void 0],
      ["styleguide", void 0, void 0],
      ["features.openapi", "openapi", "theme"]
    ];
    for (const [ce, pe, fe] of k)
      f(ce, pe, w, fe);
    const { apis: A, apiDefinitions: T, referenceDocs: R, lint: I, ...B } = w, { styleguideConfig: L, rawConfigRest: Y } = s(B), Q = {
      theme: {
        openapi: {
          ...R,
          ...w["features.openapi"],
          ...(re = w.theme) == null ? void 0 : re.openapi
        },
        mockServer: {
          ...w["features.mockServer"],
          ...(oe = w.theme) == null ? void 0 : oe.mockServer
        }
      },
      apis: o(A) || i(T),
      styleguide: L || I,
      ...Y
    };
    return m(Q), Q;
  }
  function m(w) {
    var A, T;
    let k = { ...(A = w.styleguide) == null ? void 0 : A.rules };
    for (const R of Object.values(w.apis || {}))
      k = { ...k, ...(T = R == null ? void 0 : R.styleguide) == null ? void 0 : T.rules };
    for (const R of Object.keys(k))
      R.startsWith("assert/") && r.logger.warn(`
The 'assert/' syntax in ${R} is deprecated. Update your configuration to use 'rule/' instead. Examples and more information: https://redocly.com/docs/cli/rules/configurable-rules/
`);
  }
  function v(w) {
    var k;
    return {
      http: {
        headers: ((k = w == null ? void 0 : w.http) == null ? void 0 : k.headers) ?? [],
        customFetch: void 0
      }
    };
  }
  function g(w) {
    const k = /* @__PURE__ */ new Set(), A = [];
    for (const T of w)
      k.has(T.id) ? T.id && r.logger.warn(`Duplicate plugin id "${r.colorize.red(T.id)}".
`) : (A.push(T), k.add(T.id));
    return A;
  }
  class S extends Error {
  }
  yr.ConfigValidationError = S;
  function _(w) {
    return new Map(JSON.parse(JSON.stringify([...w])));
  }
  function x(w) {
    return w !== void 0 && typeof w == "object" && "id" in w;
  }
  function y(w) {
    return typeof w == "function";
  }
  return yr;
}
var jP;
function DN() {
  return jP || (jP = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Config = e.StyleguideConfig = e.IGNORE_FILE = void 0;
    const t = Gs, r = xS(), n = jb(), i = Sn(), s = AS(), o = ES(), a = AQ(), l = Gl();
    e.IGNORE_FILE = ".redocly.lint-ignore.yaml";
    const p = `# This file instructs Redocly's linter to ignore the rules contained for specific parts of your API.
# See https://redoc.ly/docs/cli/ for more information.
`;
    function f(v) {
      return v ? (0, i.doesYamlFileExist)(v) ? r.join(r.dirname(v), e.IGNORE_FILE) : r.join(v, e.IGNORE_FILE) : o.isBrowser ? void 0 : r.join(process.cwd(), e.IGNORE_FILE);
    }
    class d {
      constructor(g, S) {
        var _;
        this.rawConfig = g, this.configFile = S, this.ignore = {}, this._usedRules = /* @__PURE__ */ new Set(), this._usedVersions = /* @__PURE__ */ new Set(), this.plugins = g.plugins || [], this.doNotResolveExamples = !!g.doNotResolveExamples, this.recommendedFallback = g.recommendedFallback || !1, this.rules = {
          [s.SpecVersion.OAS2]: { ...g.rules, ...g.oas2Rules },
          [s.SpecVersion.OAS3_0]: { ...g.rules, ...g.oas3_0Rules },
          [s.SpecVersion.OAS3_1]: { ...g.rules, ...g.oas3_1Rules },
          [s.SpecVersion.Async2]: { ...g.rules, ...g.async2Rules },
          [s.SpecVersion.Async3]: { ...g.rules, ...g.async3Rules },
          [s.SpecVersion.Arazzo]: {
            ...g.arazzoRules || {},
            ...(_ = g.rules) != null && _.assertions ? { assertions: g.rules.assertions } : {}
          }
        }, this.preprocessors = {
          [s.SpecVersion.OAS2]: { ...g.preprocessors, ...g.oas2Preprocessors },
          [s.SpecVersion.OAS3_0]: { ...g.preprocessors, ...g.oas3_0Preprocessors },
          [s.SpecVersion.OAS3_1]: { ...g.preprocessors, ...g.oas3_1Preprocessors },
          [s.SpecVersion.Async2]: { ...g.preprocessors, ...g.async2Preprocessors },
          [s.SpecVersion.Async3]: { ...g.preprocessors, ...g.async3Preprocessors },
          [s.SpecVersion.Arazzo]: { ...g.arazzoPreprocessors }
        }, this.decorators = {
          [s.SpecVersion.OAS2]: { ...g.decorators, ...g.oas2Decorators },
          [s.SpecVersion.OAS3_0]: { ...g.decorators, ...g.oas3_0Decorators },
          [s.SpecVersion.OAS3_1]: { ...g.decorators, ...g.oas3_1Decorators },
          [s.SpecVersion.Async2]: { ...g.decorators, ...g.async2Decorators },
          [s.SpecVersion.Async3]: { ...g.decorators, ...g.async3Decorators },
          [s.SpecVersion.Arazzo]: { ...g.arazzoDecorators }
        }, this.extendPaths = g.extendPaths || [], this.pluginPaths = g.pluginPaths || [], this.resolveIgnore(f(S));
      }
      resolveIgnore(g) {
        if (!(!g || !(0, i.doesYamlFileExist)(g))) {
          this.ignore = (0, n.parseYaml)(t.readFileSync(g, "utf-8")) || {};
          for (const S of Object.keys(this.ignore)) {
            this.ignore[(0, l.isAbsoluteUrl)(S) ? S : r.resolve(r.dirname(g), S)] = this.ignore[S];
            for (const _ of Object.keys(this.ignore[S]))
              this.ignore[S][_] = new Set(this.ignore[S][_]);
            (0, l.isAbsoluteUrl)(S) || delete this.ignore[S];
          }
        }
      }
      saveIgnore() {
        const g = this.configFile ? r.dirname(this.configFile) : process.cwd(), S = r.join(g, e.IGNORE_FILE), _ = {};
        for (const x of Object.keys(this.ignore)) {
          const y = (0, l.isAbsoluteUrl)(x) ? x : (0, i.slash)(r.relative(g, x)), w = _[y] = this.ignore[x];
          for (const k of Object.keys(w))
            w[k] = Array.from(w[k]);
        }
        t.writeFileSync(S, p + (0, n.stringifyYaml)(_));
      }
      addIgnore(g) {
        const S = this.ignore, _ = g.location[0];
        if (_.pointer === void 0)
          return;
        const x = S[_.source.absoluteRef] = S[_.source.absoluteRef] || {};
        (x[g.ruleId] = x[g.ruleId] || /* @__PURE__ */ new Set()).add(_.pointer);
      }
      addProblemToIgnore(g) {
        const S = g.location[0];
        if (S.pointer === void 0)
          return g;
        const x = (this.ignore[S.source.absoluteRef] || {})[g.ruleId], y = x && x.has(S.pointer);
        return y ? {
          ...g,
          ignored: y
        } : g;
      }
      extendTypes(g, S) {
        let _ = g;
        for (const x of this.plugins)
          if (x.typeExtension !== void 0)
            switch (S) {
              case s.SpecVersion.OAS3_0:
              case s.SpecVersion.OAS3_1:
                if (!x.typeExtension.oas3)
                  continue;
                _ = x.typeExtension.oas3(_, S);
                break;
              case s.SpecVersion.OAS2:
                if (!x.typeExtension.oas2)
                  continue;
                _ = x.typeExtension.oas2(_, S);
                break;
              case s.SpecVersion.Async2:
                if (!x.typeExtension.async2)
                  continue;
                _ = x.typeExtension.async2(_, S);
                break;
              case s.SpecVersion.Async3:
                if (!x.typeExtension.async3)
                  continue;
                _ = x.typeExtension.async3(_, S);
                break;
              case s.SpecVersion.Arazzo:
                if (!x.typeExtension.arazzo)
                  continue;
                _ = x.typeExtension.arazzo(_, S);
                break;
              default:
                throw new Error("Not implemented");
            }
        return _;
      }
      getRuleSettings(g, S) {
        this._usedRules.add(g), this._usedVersions.add(S);
        const _ = this.rules[S][g] || "off";
        return typeof _ == "string" ? {
          severity: _
        } : { severity: "error", ..._ };
      }
      getPreprocessorSettings(g, S) {
        this._usedRules.add(g), this._usedVersions.add(S);
        const _ = this.preprocessors[S][g] || "off";
        return typeof _ == "string" ? {
          severity: _ === "on" ? "error" : _
        } : { severity: "error", ..._ };
      }
      getDecoratorSettings(g, S) {
        this._usedRules.add(g), this._usedVersions.add(S);
        const _ = this.decorators[S][g] || "off";
        return typeof _ == "string" ? {
          severity: _ === "on" ? "error" : _
        } : { severity: "error", ..._ };
      }
      getUnusedRules() {
        const g = [], S = [], _ = [];
        for (const x of Array.from(this._usedVersions))
          g.push(...Object.keys(this.rules[x]).filter((y) => !this._usedRules.has(y))), S.push(...Object.keys(this.decorators[x]).filter((y) => !this._usedRules.has(y))), _.push(...Object.keys(this.preprocessors[x]).filter((y) => !this._usedRules.has(y)));
        return {
          rules: g,
          preprocessors: _,
          decorators: S
        };
      }
      getRulesForOasVersion(g) {
        switch (g) {
          case s.SpecMajorVersion.OAS3:
            const S = [];
            return this.plugins.forEach((k) => {
              var A;
              return ((A = k.preprocessors) == null ? void 0 : A.oas3) && S.push(k.preprocessors.oas3);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.rules) == null ? void 0 : A.oas3) && S.push(k.rules.oas3);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.decorators) == null ? void 0 : A.oas3) && S.push(k.decorators.oas3);
            }), S;
          case s.SpecMajorVersion.OAS2:
            const _ = [];
            return this.plugins.forEach((k) => {
              var A;
              return ((A = k.preprocessors) == null ? void 0 : A.oas2) && _.push(k.preprocessors.oas2);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.rules) == null ? void 0 : A.oas2) && _.push(k.rules.oas2);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.decorators) == null ? void 0 : A.oas2) && _.push(k.decorators.oas2);
            }), _;
          case s.SpecMajorVersion.Async2:
            const x = [];
            return this.plugins.forEach((k) => {
              var A;
              return ((A = k.preprocessors) == null ? void 0 : A.async2) && x.push(k.preprocessors.async2);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.rules) == null ? void 0 : A.async2) && x.push(k.rules.async2);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.decorators) == null ? void 0 : A.async2) && x.push(k.decorators.async2);
            }), x;
          case s.SpecMajorVersion.Async3:
            const y = [];
            return this.plugins.forEach((k) => {
              var A;
              return ((A = k.preprocessors) == null ? void 0 : A.async3) && y.push(k.preprocessors.async3);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.rules) == null ? void 0 : A.async3) && y.push(k.rules.async3);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.decorators) == null ? void 0 : A.async3) && y.push(k.decorators.async3);
            }), y;
          case s.SpecMajorVersion.Arazzo:
            const w = [];
            return this.plugins.forEach((k) => {
              var A;
              return ((A = k.preprocessors) == null ? void 0 : A.arazzo) && w.push(k.preprocessors.arazzo);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.rules) == null ? void 0 : A.arazzo) && w.push(k.rules.arazzo);
            }), this.plugins.forEach((k) => {
              var A;
              return ((A = k.decorators) == null ? void 0 : A.arazzo) && w.push(k.decorators.arazzo);
            }), w;
        }
      }
      skipRules(g) {
        for (const S of g || [])
          for (const _ of Object.values(s.SpecVersion))
            this.rules[_][S] && (this.rules[_][S] = "off");
      }
      skipPreprocessors(g) {
        for (const S of g || [])
          for (const _ of Object.values(s.SpecVersion))
            this.preprocessors[_][S] && (this.preprocessors[_][S] = "off");
      }
      skipDecorators(g) {
        for (const S of g || [])
          for (const _ of Object.values(s.SpecVersion))
            this.decorators[_][S] && (this.decorators[_][S] = "off");
      }
    }
    e.StyleguideConfig = d;
    class m {
      constructor(g, S) {
        this.rawConfig = g, this.configFile = S, this.apis = g.apis || {}, this.styleguide = new d(g.styleguide || {}, S), this.theme = g.theme || {}, this.resolve = (0, a.getResolveConfig)(g == null ? void 0 : g.resolve), this.region = g.region, this.organization = g.organization, this.files = g.files || [], this.telemetry = g.telemetry;
      }
    }
    e.Config = m;
  }(Gv)), Gv;
}
var Kv = {}, NP;
function PQ() {
  return NP || (NP = 1, function(e) {
    (function(t, r) {
      r(e);
    })(pn, function(t) {
      t.__esModule = !0;
      var r = {}, n = Object.prototype.hasOwnProperty, i = { memoize: function(d) {
        var m = arguments.length <= 1 || arguments[1] === void 0 ? r : arguments[1], v = m.cache || {};
        return function() {
          for (var g = arguments.length, S = Array(g), _ = 0; _ < g; _++)
            S[_] = arguments[_];
          var x = String(S[0]);
          return m.caseSensitive === !1 && (x = x.toLowerCase()), n.call(v, x) ? v[x] : v[x] = d.apply(this, S);
        };
      }, debounce: function(d, m) {
        if (typeof m == "function") {
          var v = d;
          d = m, m = v;
        }
        var g = m && m.delay || m || 0, S = void 0, _ = void 0, x = void 0;
        return function() {
          for (var y = arguments.length, w = Array(y), k = 0; k < y; k++)
            w[k] = arguments[k];
          S = w, _ = this, x || (x = setTimeout(function() {
            d.apply(_, S), S = _ = x = null;
          }, g));
        };
      }, bind: function(d, m, v) {
        var g = v.value;
        return { configurable: !0, get: function() {
          var _ = g.bind(this);
          return Object.defineProperty(this, m, { value: _, configurable: !0, writable: !0 }), _;
        } };
      } }, s = l(i.memoize), o = l(i.debounce), a = l(function(f, d) {
        return f.bind(d);
      }, function() {
        return i.bind;
      });
      t.memoize = s, t.debounce = o, t.bind = a, t.default = { memoize: s, debounce: o, bind: a };
      function l(f, d) {
        d = d || f.decorate || p(f);
        var m = d();
        return function() {
          for (var v = arguments.length, g = Array(v), S = 0; S < v; S++)
            g[S] = arguments[S];
          var _ = g.length;
          return (_ < 2 ? d : _ > 2 ? m : f).apply(void 0, g);
        };
      }
      function p(f) {
        return function(d) {
          return typeof d == "function" ? f(d) : function(m, v, g) {
            g.value = f(g.value, d, m, v, g);
          };
        };
      }
    });
  }(Kv)), Kv;
}
var Xv = { exports: {} }, LP;
function CQ() {
  return LP || (LP = 1, function(e) {
    var t = Object.prototype.hasOwnProperty, r = "~";
    function n() {
    }
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
    function i(l, p, f) {
      this.fn = l, this.context = p, this.once = f || !1;
    }
    function s(l, p, f, d, m) {
      if (typeof f != "function")
        throw new TypeError("The listener must be a function");
      var v = new i(f, d || l, m), g = r ? r + p : p;
      return l._events[g] ? l._events[g].fn ? l._events[g] = [l._events[g], v] : l._events[g].push(v) : (l._events[g] = v, l._eventsCount++), l;
    }
    function o(l, p) {
      --l._eventsCount === 0 ? l._events = new n() : delete l._events[p];
    }
    function a() {
      this._events = new n(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
      var p = [], f, d;
      if (this._eventsCount === 0) return p;
      for (d in f = this._events)
        t.call(f, d) && p.push(r ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? p.concat(Object.getOwnPropertySymbols(f)) : p;
    }, a.prototype.listeners = function(p) {
      var f = r ? r + p : p, d = this._events[f];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var m = 0, v = d.length, g = new Array(v); m < v; m++)
        g[m] = d[m].fn;
      return g;
    }, a.prototype.listenerCount = function(p) {
      var f = r ? r + p : p, d = this._events[f];
      return d ? d.fn ? 1 : d.length : 0;
    }, a.prototype.emit = function(p, f, d, m, v, g) {
      var S = r ? r + p : p;
      if (!this._events[S]) return !1;
      var _ = this._events[S], x = arguments.length, y, w;
      if (_.fn) {
        switch (_.once && this.removeListener(p, _.fn, void 0, !0), x) {
          case 1:
            return _.fn.call(_.context), !0;
          case 2:
            return _.fn.call(_.context, f), !0;
          case 3:
            return _.fn.call(_.context, f, d), !0;
          case 4:
            return _.fn.call(_.context, f, d, m), !0;
          case 5:
            return _.fn.call(_.context, f, d, m, v), !0;
          case 6:
            return _.fn.call(_.context, f, d, m, v, g), !0;
        }
        for (w = 1, y = new Array(x - 1); w < x; w++)
          y[w - 1] = arguments[w];
        _.fn.apply(_.context, y);
      } else {
        var k = _.length, A;
        for (w = 0; w < k; w++)
          switch (_[w].once && this.removeListener(p, _[w].fn, void 0, !0), x) {
            case 1:
              _[w].fn.call(_[w].context);
              break;
            case 2:
              _[w].fn.call(_[w].context, f);
              break;
            case 3:
              _[w].fn.call(_[w].context, f, d);
              break;
            case 4:
              _[w].fn.call(_[w].context, f, d, m);
              break;
            default:
              if (!y) for (A = 1, y = new Array(x - 1); A < x; A++)
                y[A - 1] = arguments[A];
              _[w].fn.apply(_[w].context, y);
          }
      }
      return !0;
    }, a.prototype.on = function(p, f, d) {
      return s(this, p, f, d, !1);
    }, a.prototype.once = function(p, f, d) {
      return s(this, p, f, d, !0);
    }, a.prototype.removeListener = function(p, f, d, m) {
      var v = r ? r + p : p;
      if (!this._events[v]) return this;
      if (!f)
        return o(this, v), this;
      var g = this._events[v];
      if (g.fn)
        g.fn === f && (!m || g.once) && (!d || g.context === d) && o(this, v);
      else {
        for (var S = 0, _ = [], x = g.length; S < x; S++)
          (g[S].fn !== f || m && !g[S].once || d && g[S].context !== d) && _.push(g[S]);
        _.length ? this._events[v] = _.length === 1 ? _[0] : _ : o(this, v);
      }
      return this;
    }, a.prototype.removeAllListeners = function(p) {
      var f;
      return p ? (f = r ? r + p : p, this._events[f] && o(this, f)) : (this._events = new n(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, e.exports = a;
  }(Xv)), Xv.exports;
}
var Jv, MP;
function TQ() {
  if (MP) return Jv;
  MP = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString;
  return Jv = function(n, i, s) {
    if (t.call(i) !== "[object Function]")
      throw new TypeError("iterator must be a function");
    var o = n.length;
    if (o === +o)
      for (var a = 0; a < o; a++)
        i.call(s, n[a], a, n);
    else
      for (var l in n)
        e.call(n, l) && i.call(s, n[l], l, n);
  }, Jv;
}
var Zv, DP;
function FN() {
  if (DP) return Zv;
  DP = 1;
  var e = TQ();
  Zv = t;
  function t(r, n, i) {
    if (arguments.length === 3)
      return t.set(r, n, i);
    if (arguments.length === 2)
      return t.get(r, n);
    var s = t.bind(t, r);
    for (var o in t)
      t.hasOwnProperty(o) && (s[o] = t[o].bind(s, r));
    return s;
  }
  return t.get = function(n, i) {
    for (var s = Array.isArray(i) ? i : t.parse(i), o = 0; o < s.length; ++o) {
      var a = s[o];
      if (!(typeof n == "object" && a in n))
        throw new Error("Invalid reference token: " + a);
      n = n[a];
    }
    return n;
  }, t.set = function(n, i, s) {
    var o = Array.isArray(i) ? i : t.parse(i), a = o[0];
    if (o.length === 0)
      throw Error("Can not set the root object");
    for (var l = 0; l < o.length - 1; ++l) {
      var p = o[l];
      typeof p != "string" && typeof p != "number" && (p = String(p)), !(p === "__proto__" || p === "constructor" || p === "prototype") && (p === "-" && Array.isArray(n) && (p = n.length), a = o[l + 1], p in n || (a.match(/^(\d+|-)$/) ? n[p] = [] : n[p] = {}), n = n[p]);
    }
    return a === "-" && Array.isArray(n) && (a = n.length), n[a] = s, this;
  }, t.remove = function(r, n) {
    var i = Array.isArray(n) ? n : t.parse(n), s = i[i.length - 1];
    if (s === void 0)
      throw new Error('Invalid JSON pointer for remove: "' + n + '"');
    var o = t.get(r, i.slice(0, -1));
    if (Array.isArray(o)) {
      var a = +s;
      if (s === "" && isNaN(a))
        throw new Error('Invalid array index: "' + s + '"');
      Array.prototype.splice.call(o, a, 1);
    } else
      delete o[s];
  }, t.dict = function(n, i) {
    var s = {};
    return t.walk(n, function(o, a) {
      s[a] = o;
    }, i), s;
  }, t.walk = function(n, i, s) {
    var o = [];
    s = s || function(a) {
      var l = Object.prototype.toString.call(a);
      return l === "[object Object]" || l === "[object Array]";
    }, function a(l) {
      e(l, function(p, f) {
        o.push(String(f)), s(p) ? a(p) : i(p, t.compile(o)), o.pop();
      });
    }(n);
  }, t.has = function(n, i) {
    try {
      t.get(n, i);
    } catch {
      return !1;
    }
    return !0;
  }, t.escape = function(n) {
    return n.toString().replace(/~/g, "~0").replace(/\//g, "~1");
  }, t.unescape = function(n) {
    return n.replace(/~1/g, "/").replace(/~0/g, "~");
  }, t.parse = function(n) {
    if (n === "")
      return [];
    if (n.charAt(0) !== "/")
      throw new Error("Invalid JSON pointer: " + n);
    return n.substring(1).split(/\//).map(t.unescape);
  }, t.compile = function(n) {
    return n.length === 0 ? "" : "/" + n.map(t.escape).join("/");
  }, Zv;
}
var e0 = { exports: {} }, FP;
function $Q() {
  return FP || (FP = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(pn, function() {
      function r() {
      }
      return r.prototype.encodeReserved = function(n) {
        return n.split(/(%[0-9A-Fa-f]{2})/g).map(function(i) {
          return /%[0-9A-Fa-f]/.test(i) || (i = encodeURI(i).replace(/%5B/g, "[").replace(/%5D/g, "]")), i;
        }).join("");
      }, r.prototype.encodeUnreserved = function(n) {
        return encodeURIComponent(n).replace(/[!'()*]/g, function(i) {
          return "%" + i.charCodeAt(0).toString(16).toUpperCase();
        });
      }, r.prototype.encodeValue = function(n, i, s) {
        return i = n === "+" || n === "#" ? this.encodeReserved(i) : this.encodeUnreserved(i), s ? this.encodeUnreserved(s) + "=" + i : i;
      }, r.prototype.isDefined = function(n) {
        return n != null;
      }, r.prototype.isKeyOperator = function(n) {
        return n === ";" || n === "&" || n === "?";
      }, r.prototype.getValues = function(n, i, s, o) {
        var a = n[s], l = [];
        if (this.isDefined(a) && a !== "")
          if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
            a = a.toString(), o && o !== "*" && (a = a.substring(0, parseInt(o, 10))), l.push(this.encodeValue(i, a, this.isKeyOperator(i) ? s : null));
          else if (o === "*")
            Array.isArray(a) ? a.filter(this.isDefined).forEach(function(f) {
              l.push(this.encodeValue(i, f, this.isKeyOperator(i) ? s : null));
            }, this) : Object.keys(a).forEach(function(f) {
              this.isDefined(a[f]) && l.push(this.encodeValue(i, a[f], f));
            }, this);
          else {
            var p = [];
            Array.isArray(a) ? a.filter(this.isDefined).forEach(function(f) {
              p.push(this.encodeValue(i, f));
            }, this) : Object.keys(a).forEach(function(f) {
              this.isDefined(a[f]) && (p.push(this.encodeUnreserved(f)), p.push(this.encodeValue(i, a[f].toString())));
            }, this), this.isKeyOperator(i) ? l.push(this.encodeUnreserved(s) + "=" + p.join(",")) : p.length !== 0 && l.push(p.join(","));
          }
        else
          i === ";" ? this.isDefined(a) && l.push(this.encodeUnreserved(s)) : a === "" && (i === "&" || i === "?") ? l.push(this.encodeUnreserved(s) + "=") : a === "" && l.push("");
        return l;
      }, r.prototype.parse = function(n) {
        var i = this, s = ["+", "#", ".", "/", ";", "?", "&"];
        return {
          expand: function(o) {
            return n.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(a, l, p) {
              if (l) {
                var f = null, d = [];
                if (s.indexOf(l.charAt(0)) !== -1 && (f = l.charAt(0), l = l.substr(1)), l.split(/,/g).forEach(function(v) {
                  var g = /([^:\*]*)(?::(\d+)|(\*))?/.exec(v);
                  d.push.apply(d, i.getValues(o, f, g[1], g[2] || g[3]));
                }), f && f !== "+") {
                  var m = ",";
                  return f === "?" ? m = "&" : f !== "#" && (m = f), (d.length !== 0 ? f : "") + d.join(m);
                } else
                  return d.join(",");
              } else
                return i.encodeReserved(p);
            });
          }
        };
      }, new r();
    });
  }(e0)), e0.exports;
}
var t0 = { exports: {} }, zP;
function RQ() {
  return zP || (zP = 1, function(e) {
    var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var r = function(n) {
      var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, s = 0, o = {}, a = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: n.Prism && n.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function y(w) {
            return w instanceof l ? new l(w.type, y(w.content), w.alias) : Array.isArray(w) ? w.map(y) : w.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(y) {
            return Object.prototype.toString.call(y).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(y) {
            return y.__id || Object.defineProperty(y, "__id", { value: ++s }), y.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function y(w, k) {
            k = k || {};
            var A, T;
            switch (a.util.type(w)) {
              case "Object":
                if (T = a.util.objId(w), k[T])
                  return k[T];
                A = /** @type {Record<string, any>} */
                {}, k[T] = A;
                for (var R in w)
                  w.hasOwnProperty(R) && (A[R] = y(w[R], k));
                return (
                  /** @type {any} */
                  A
                );
              case "Array":
                return T = a.util.objId(w), k[T] ? k[T] : (A = [], k[T] = A, /** @type {Array} */
                /** @type {any} */
                w.forEach(function(I, B) {
                  A[B] = y(I, k);
                }), /** @type {any} */
                A);
              default:
                return w;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(y) {
            for (; y; ) {
              var w = i.exec(y.className);
              if (w)
                return w[1].toLowerCase();
              y = y.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(y, w) {
            y.className = y.className.replace(RegExp(i, "gi"), ""), y.classList.add("language-" + w);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (A) {
              var y = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(A.stack) || [])[1];
              if (y) {
                var w = document.getElementsByTagName("script");
                for (var k in w)
                  if (w[k].src == y)
                    return w[k];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(y, w, k) {
            for (var A = "no-" + w; y; ) {
              var T = y.classList;
              if (T.contains(w))
                return !0;
              if (T.contains(A))
                return !1;
              y = y.parentElement;
            }
            return !!k;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: o,
          plaintext: o,
          text: o,
          txt: o,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(y, w) {
            var k = a.util.clone(a.languages[y]);
            for (var A in w)
              k[A] = w[A];
            return k;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(y, w, k, A) {
            A = A || /** @type {any} */
            a.languages;
            var T = A[y], R = {};
            for (var I in T)
              if (T.hasOwnProperty(I)) {
                if (I == w)
                  for (var B in k)
                    k.hasOwnProperty(B) && (R[B] = k[B]);
                k.hasOwnProperty(I) || (R[I] = T[I]);
              }
            var L = A[y];
            return A[y] = R, a.languages.DFS(a.languages, function(Y, Q) {
              Q === L && Y != y && (this[Y] = R);
            }), R;
          },
          // Traverse a language definition with Depth First Search
          DFS: function y(w, k, A, T) {
            T = T || {};
            var R = a.util.objId;
            for (var I in w)
              if (w.hasOwnProperty(I)) {
                k.call(w, I, w[I], A || I);
                var B = w[I], L = a.util.type(B);
                L === "Object" && !T[R(B)] ? (T[R(B)] = !0, y(B, k, null, T)) : L === "Array" && !T[R(B)] && (T[R(B)] = !0, y(B, k, I, T));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(y, w) {
          a.highlightAllUnder(document, y, w);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(y, w, k) {
          var A = {
            callback: k,
            container: y,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          a.hooks.run("before-highlightall", A), A.elements = Array.prototype.slice.apply(A.container.querySelectorAll(A.selector)), a.hooks.run("before-all-elements-highlight", A);
          for (var T = 0, R; R = A.elements[T++]; )
            a.highlightElement(R, w === !0, A.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(y, w, k) {
          var A = a.util.getLanguage(y), T = a.languages[A];
          a.util.setLanguage(y, A);
          var R = y.parentElement;
          R && R.nodeName.toLowerCase() === "pre" && a.util.setLanguage(R, A);
          var I = y.textContent, B = {
            element: y,
            language: A,
            grammar: T,
            code: I
          };
          function L(Q) {
            B.highlightedCode = Q, a.hooks.run("before-insert", B), B.element.innerHTML = B.highlightedCode, a.hooks.run("after-highlight", B), a.hooks.run("complete", B), k && k.call(B.element);
          }
          if (a.hooks.run("before-sanity-check", B), R = B.element.parentElement, R && R.nodeName.toLowerCase() === "pre" && !R.hasAttribute("tabindex") && R.setAttribute("tabindex", "0"), !B.code) {
            a.hooks.run("complete", B), k && k.call(B.element);
            return;
          }
          if (a.hooks.run("before-highlight", B), !B.grammar) {
            L(a.util.encode(B.code));
            return;
          }
          if (w && n.Worker) {
            var Y = new Worker(a.filename);
            Y.onmessage = function(Q) {
              L(Q.data);
            }, Y.postMessage(JSON.stringify({
              language: B.language,
              code: B.code,
              immediateClose: !0
            }));
          } else
            L(a.highlight(B.code, B.grammar, B.language));
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(y, w, k) {
          var A = {
            code: y,
            grammar: w,
            language: k
          };
          if (a.hooks.run("before-tokenize", A), !A.grammar)
            throw new Error('The language "' + A.language + '" has no grammar.');
          return A.tokens = a.tokenize(A.code, A.grammar), a.hooks.run("after-tokenize", A), l.stringify(a.util.encode(A.tokens), A.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(y, w) {
          var k = w.rest;
          if (k) {
            for (var A in k)
              w[A] = k[A];
            delete w.rest;
          }
          var T = new d();
          return m(T, T.head, y), f(y, T, w, T.head, 0), g(T);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(y, w) {
            var k = a.hooks.all;
            k[y] = k[y] || [], k[y].push(w);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(y, w) {
            var k = a.hooks.all[y];
            if (!(!k || !k.length))
              for (var A = 0, T; T = k[A++]; )
                T(w);
          }
        },
        Token: l
      };
      n.Prism = a;
      function l(y, w, k, A) {
        this.type = y, this.content = w, this.alias = k, this.length = (A || "").length | 0;
      }
      l.stringify = function y(w, k) {
        if (typeof w == "string")
          return w;
        if (Array.isArray(w)) {
          var A = "";
          return w.forEach(function(L) {
            A += y(L, k);
          }), A;
        }
        var T = {
          type: w.type,
          content: y(w.content, k),
          tag: "span",
          classes: ["token", w.type],
          attributes: {},
          language: k
        }, R = w.alias;
        R && (Array.isArray(R) ? Array.prototype.push.apply(T.classes, R) : T.classes.push(R)), a.hooks.run("wrap", T);
        var I = "";
        for (var B in T.attributes)
          I += " " + B + '="' + (T.attributes[B] || "").replace(/"/g, "&quot;") + '"';
        return "<" + T.tag + ' class="' + T.classes.join(" ") + '"' + I + ">" + T.content + "</" + T.tag + ">";
      };
      function p(y, w, k, A) {
        y.lastIndex = w;
        var T = y.exec(k);
        if (T && A && T[1]) {
          var R = T[1].length;
          T.index += R, T[0] = T[0].slice(R);
        }
        return T;
      }
      function f(y, w, k, A, T, R) {
        for (var I in k)
          if (!(!k.hasOwnProperty(I) || !k[I])) {
            var B = k[I];
            B = Array.isArray(B) ? B : [B];
            for (var L = 0; L < B.length; ++L) {
              if (R && R.cause == I + "," + L)
                return;
              var Y = B[L], Q = Y.inside, re = !!Y.lookbehind, oe = !!Y.greedy, ce = Y.alias;
              if (oe && !Y.pattern.global) {
                var pe = Y.pattern.toString().match(/[imsuy]*$/)[0];
                Y.pattern = RegExp(Y.pattern.source, pe + "g");
              }
              for (var fe = Y.pattern || Y, G = A.next, Z = T; G !== w.tail && !(R && Z >= R.reach); Z += G.value.length, G = G.next) {
                var K = G.value;
                if (w.length > y.length)
                  return;
                if (!(K instanceof l)) {
                  var z = 1, te;
                  if (oe) {
                    if (te = p(fe, Z, y, re), !te || te.index >= y.length)
                      break;
                    var F = te.index, q = te.index + te[0].length, j = Z;
                    for (j += G.value.length; F >= j; )
                      G = G.next, j += G.value.length;
                    if (j -= G.value.length, Z = j, G.value instanceof l)
                      continue;
                    for (var H = G; H !== w.tail && (j < q || typeof H.value == "string"); H = H.next)
                      z++, j += H.value.length;
                    z--, K = y.slice(Z, j), te.index -= Z;
                  } else if (te = p(fe, 0, K, re), !te)
                    continue;
                  var F = te.index, ue = te[0], ge = K.slice(0, F), Ae = K.slice(F + ue.length), C = Z + K.length;
                  R && C > R.reach && (R.reach = C);
                  var N = G.prev;
                  ge && (N = m(w, N, ge), Z += ge.length), v(w, N, z);
                  var J = new l(I, Q ? a.tokenize(ue, Q) : ue, ce, ue);
                  if (G = m(w, N, J), Ae && m(w, G, Ae), z > 1) {
                    var X = {
                      cause: I + "," + L,
                      reach: C
                    };
                    f(y, w, k, G.prev, Z, X), R && X.reach > R.reach && (R.reach = X.reach);
                  }
                }
              }
            }
          }
      }
      function d() {
        var y = { value: null, prev: null, next: null }, w = { value: null, prev: y, next: null };
        y.next = w, this.head = y, this.tail = w, this.length = 0;
      }
      function m(y, w, k) {
        var A = w.next, T = { value: k, prev: w, next: A };
        return w.next = T, A.prev = T, y.length++, T;
      }
      function v(y, w, k) {
        for (var A = w.next, T = 0; T < k && A !== y.tail; T++)
          A = A.next;
        w.next = A, A.prev = w, y.length -= T;
      }
      function g(y) {
        for (var w = [], k = y.head.next; k !== y.tail; )
          w.push(k.value), k = k.next;
        return w;
      }
      if (!n.document)
        return n.addEventListener && (a.disableWorkerMessageHandler || n.addEventListener("message", function(y) {
          var w = JSON.parse(y.data), k = w.language, A = w.code, T = w.immediateClose;
          n.postMessage(a.highlight(A, a.languages[k], k)), T && n.close();
        }, !1)), a;
      var S = a.util.currentScript();
      S && (a.filename = S.src, S.hasAttribute("data-manual") && (a.manual = !0));
      function _() {
        a.manual || a.highlightAll();
      }
      if (!a.manual) {
        var x = document.readyState;
        x === "loading" || x === "interactive" && S && S.defer ? document.addEventListener("DOMContentLoaded", _) : window.requestAnimationFrame ? window.requestAnimationFrame(_) : window.setTimeout(_, 16);
      }
      return a;
    }(t);
    e.exports && (e.exports = r), typeof pn < "u" && (pn.Prism = r), r.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, r.languages.markup.tag.inside["attr-value"].inside.entity = r.languages.markup.entity, r.languages.markup.doctype.inside["internal-subset"].inside = r.languages.markup, r.hooks.add("wrap", function(n) {
      n.type === "entity" && (n.attributes.title = n.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(r.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(i, s) {
        var o = {};
        o["language-" + s] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: r.languages[s]
        }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var a = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: o
          }
        };
        a["language-" + s] = {
          pattern: /[\s\S]+/,
          inside: r.languages[s]
        };
        var l = {};
        l[i] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return i;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: a
        }, r.languages.insertBefore("markup", "cdata", l);
      }
    }), Object.defineProperty(r.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(n, i) {
        r.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + n + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [i, "language-" + i],
                  inside: r.languages[i]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), r.languages.html = r.languages.markup, r.languages.mathml = r.languages.markup, r.languages.svg = r.languages.markup, r.languages.xml = r.languages.extend("markup", {}), r.languages.ssml = r.languages.xml, r.languages.atom = r.languages.xml, r.languages.rss = r.languages.xml, function(n) {
      var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      n.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + i.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: i,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, n.languages.css.atrule.inside.rest = n.languages.css;
      var s = n.languages.markup;
      s && (s.tag.addInlined("style", "css"), s.tag.addAttribute("style", "css"));
    }(r), r.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, r.languages.javascript = r.languages.extend("clike", {
      "class-name": [
        r.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), r.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, r.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: r.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: r.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), r.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: r.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), r.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), r.languages.markup && (r.languages.markup.tag.addInlined("script", "javascript"), r.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), r.languages.js = r.languages.javascript, function() {
      if (typeof r > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var n = "Loading…", i = function(S, _) {
        return "✖ Error " + S + " while fetching file: " + _;
      }, s = "✖ Error: File does not exist or is empty", o = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, a = "data-src-status", l = "loading", p = "loaded", f = "failed", d = "pre[data-src]:not([" + a + '="' + p + '"]):not([' + a + '="' + l + '"])';
      function m(S, _, x) {
        var y = new XMLHttpRequest();
        y.open("GET", S, !0), y.onreadystatechange = function() {
          y.readyState == 4 && (y.status < 400 && y.responseText ? _(y.responseText) : y.status >= 400 ? x(i(y.status, y.statusText)) : x(s));
        }, y.send(null);
      }
      function v(S) {
        var _ = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(S || "");
        if (_) {
          var x = Number(_[1]), y = _[2], w = _[3];
          return y ? w ? [x, Number(w)] : [x, void 0] : [x, x];
        }
      }
      r.hooks.add("before-highlightall", function(S) {
        S.selector += ", " + d;
      }), r.hooks.add("before-sanity-check", function(S) {
        var _ = (
          /** @type {HTMLPreElement} */
          S.element
        );
        if (_.matches(d)) {
          S.code = "", _.setAttribute(a, l);
          var x = _.appendChild(document.createElement("CODE"));
          x.textContent = n;
          var y = _.getAttribute("data-src"), w = S.language;
          if (w === "none") {
            var k = (/\.(\w+)$/.exec(y) || [, "none"])[1];
            w = o[k] || k;
          }
          r.util.setLanguage(x, w), r.util.setLanguage(_, w);
          var A = r.plugins.autoloader;
          A && A.loadLanguages(w), m(
            y,
            function(T) {
              _.setAttribute(a, p);
              var R = v(_.getAttribute("data-range"));
              if (R) {
                var I = T.split(/\r\n?|\n/g), B = R[0], L = R[1] == null ? I.length : R[1];
                B < 0 && (B += I.length), B = Math.max(0, Math.min(B - 1, I.length)), L < 0 && (L += I.length), L = Math.max(0, Math.min(L, I.length)), T = I.slice(B, L).join(`
`), _.hasAttribute("data-start") || _.setAttribute("data-start", String(B + 1));
              }
              x.textContent = T, r.highlightElement(x);
            },
            function(T) {
              _.setAttribute(a, f), x.textContent = T;
            }
          );
        }
      }), r.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(_) {
          for (var x = (_ || document).querySelectorAll(d), y = 0, w; w = x[y++]; )
            r.highlightElement(w);
        }
      };
      var g = !1;
      r.fileHighlight = function() {
        g || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), g = !0), r.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(t0)), t0.exports;
}
var qP = {}, BP;
function IQ() {
  return BP || (BP = 1, function(e) {
    var t = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", r = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: !0,
      alias: "punctuation",
      // this looks reasonably well in all themes
      inside: null
      // see below
    }, n = {
      bash: r,
      environment: {
        pattern: RegExp("\\$" + t),
        alias: "constant"
      },
      variable: [
        // [0]: Arithmetic Environment
        {
          pattern: /\$?\(\([\s\S]+?\)\)/,
          greedy: !0,
          inside: {
            // If there is a $ sign at the beginning highlight $(( and )) as variable
            variable: [
              {
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: !0
              },
              /^\$\(\(/
            ],
            number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
            operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
            // If there is no $ sign at the beginning highlight (( and )) as punctuation
            punctuation: /\(\(?|\)\)?|,|;/
          }
        },
        // [1]: Command Substitution
        {
          pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
          greedy: !0,
          inside: {
            variable: /^\$\(|^`|\)$|`$/
          }
        },
        // [2]: Brace expansion
        {
          pattern: /\$\{[^}]+\}/,
          greedy: !0,
          inside: {
            operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
            punctuation: /[\[\]]/,
            environment: {
              pattern: RegExp("(\\{)" + t),
              lookbehind: !0,
              alias: "constant"
            }
          }
        },
        /\$(?:\w+|[#?*!@$])/
      ],
      // Escape sequences from echo and printf's manuals, and escaped quotes.
      entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    e.languages.bash = {
      shebang: {
        pattern: /^#!\s*\/.*/,
        alias: "important"
      },
      comment: {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: !0
      },
      "function-name": [
        // a) function foo {
        // b) foo() {
        // c) function foo() {
        // but not “foo {”
        {
          // a) and c)
          pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
          lookbehind: !0,
          alias: "function"
        },
        {
          // b)
          pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
          alias: "function"
        }
      ],
      // Highlight variable names as variables in for and select beginnings.
      "for-or-select": {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: "variable",
        lookbehind: !0
      },
      // Highlight variable names as variables in the left-hand part
      // of assignments (“=” and “+=”).
      "assign-left": {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
        inside: {
          environment: {
            pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t),
            lookbehind: !0,
            alias: "constant"
          }
        },
        alias: "variable",
        lookbehind: !0
      },
      // Highlight parameter names as variables
      parameter: {
        pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
        alias: "variable",
        lookbehind: !0
      },
      string: [
        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
        {
          pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
          lookbehind: !0,
          greedy: !0,
          inside: n
        },
        // Here-document with quotes around the tag
        // → No expansion (so no “inside”).
        {
          pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            bash: r
          }
        },
        // “Normal” string
        {
          // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
          pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
          lookbehind: !0,
          greedy: !0,
          inside: n
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
          pattern: /(^|[^$\\])'[^']*'/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
          pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
          greedy: !0,
          inside: {
            entity: n.entity
          }
        }
      ],
      environment: {
        pattern: RegExp("\\$?" + t),
        alias: "constant"
      },
      variable: n.variable,
      function: {
        pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      keyword: {
        pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      builtin: {
        pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
        lookbehind: !0,
        // Alias added to make those easier to distinguish from strings.
        alias: "class-name"
      },
      boolean: {
        pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      "file-descriptor": {
        pattern: /\B&\d\b/,
        alias: "important"
      },
      operator: {
        // Lots of redirections here, but not just that.
        pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          "file-descriptor": {
            pattern: /^\d/,
            alias: "important"
          }
        }
      },
      punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      number: {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: !0
      }
    }, r.inside = e.languages.bash;
    for (var i = [
      "comment",
      "function-name",
      "for-or-select",
      "assign-left",
      "parameter",
      "string",
      "environment",
      "function",
      "keyword",
      "builtin",
      "boolean",
      "file-descriptor",
      "operator",
      "punctuation",
      "number"
    ], s = n.variable[1].inside, o = 0; o < i.length; o++)
      s[i[o]] = e.languages.bash[i[o]];
    e.languages.sh = e.languages.bash, e.languages.shell = e.languages.bash;
  }(Prism)), qP;
}
var UP = {}, VP;
function jQ() {
  return VP || (VP = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), UP;
}
var WP = {}, HP;
function NQ() {
  return HP || (HP = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), WP;
}
var QP = {}, YP;
function LQ() {
  return YP || (YP = 1, function(e) {
    var t = /#(?!\{).+/, r = {
      pattern: /#\{[^}]+\}/,
      alias: "variable"
    };
    e.languages.coffeescript = e.languages.extend("javascript", {
      comment: t,
      string: [
        // Strings are multiline
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          greedy: !0
        },
        {
          // Strings are multiline
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          greedy: !0,
          inside: {
            interpolation: r
          }
        }
      ],
      keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
      "class-member": {
        pattern: /@(?!\d)\w+/,
        alias: "variable"
      }
    }), e.languages.insertBefore("coffeescript", "comment", {
      "multiline-comment": {
        pattern: /###[\s\S]+?###/,
        alias: "comment"
      },
      // Block regexp can contain comments and interpolation
      "block-regex": {
        pattern: /\/{3}[\s\S]*?\/{3}/,
        alias: "regex",
        inside: {
          comment: t,
          interpolation: r
        }
      }
    }), e.languages.insertBefore("coffeescript", "string", {
      "inline-javascript": {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        inside: {
          delimiter: {
            pattern: /^`|`$/,
            alias: "punctuation"
          },
          script: {
            pattern: /[\s\S]+/,
            alias: "language-javascript",
            inside: e.languages.javascript
          }
        }
      },
      // Block strings
      "multiline-string": [
        {
          pattern: /'''[\s\S]*?'''/,
          greedy: !0,
          alias: "string"
        },
        {
          pattern: /"""[\s\S]*?"""/,
          greedy: !0,
          alias: "string",
          inside: {
            interpolation: r
          }
        }
      ]
    }), e.languages.insertBefore("coffeescript", "keyword", {
      // Object property
      property: /(?!\d)\w+(?=\s*:(?!:))/
    }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
  }(Prism)), QP;
}
var GP = {}, KP;
function MQ() {
  return KP || (KP = 1, function(e) {
    var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, r = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return t.source;
    });
    e.languages.cpp = e.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return t.source;
          })),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: t,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), e.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return r;
          }) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), e.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: e.languages.cpp
          }
        }
      }
    }), e.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: e.languages.extend("cpp", {})
      }
    }), e.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, e.languages.cpp["base-clause"]);
  }(Prism)), GP;
}
var XP = {}, JP;
function DQ() {
  return JP || (JP = 1, function(e) {
    function t(Z, K) {
      return Z.replace(/<<(\d+)>>/g, function(z, te) {
        return "(?:" + K[+te] + ")";
      });
    }
    function r(Z, K, z) {
      return RegExp(t(Z, K), "");
    }
    function n(Z, K) {
      for (var z = 0; z < K; z++)
        Z = Z.replace(/<<self>>/g, function() {
          return "(?:" + Z + ")";
        });
      return Z.replace(/<<self>>/g, "[^\\s\\S]");
    }
    var i = {
      // keywords which represent a return or variable type
      type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
      // keywords which are used to declare a type
      typeDeclaration: "class enum interface record struct",
      // contextual keywords
      // ("var" and "dynamic" are missing because they are used like types)
      contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
      // all other keywords
      other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
    };
    function s(Z) {
      return "\\b(?:" + Z.trim().replace(/ /g, "|") + ")\\b";
    }
    var o = s(i.typeDeclaration), a = RegExp(s(i.type + " " + i.typeDeclaration + " " + i.contextual + " " + i.other)), l = s(i.typeDeclaration + " " + i.contextual + " " + i.other), p = s(i.type + " " + i.typeDeclaration + " " + i.other), f = n(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), d = n(/\((?:[^()]|<<self>>)*\)/.source, 2), m = /@?\b[A-Za-z_]\w*\b/.source, v = t(/<<0>>(?:\s*<<1>>)?/.source, [m, f]), g = t(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [l, v]), S = /\[\s*(?:,\s*)*\]/.source, _ = t(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [g, S]), x = t(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [f, d, S]), y = t(/\(<<0>>+(?:,<<0>>+)+\)/.source, [x]), w = t(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [y, g, S]), k = {
      keyword: a,
      punctuation: /[<>()?,.:[\]]/
    }, A = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, T = /"(?:\\.|[^\\"\r\n])*"/.source, R = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    e.languages.csharp = e.languages.extend("clike", {
      string: [
        {
          pattern: r(/(^|[^$\\])<<0>>/.source, [R]),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: r(/(^|[^@$\\])<<0>>/.source, [T]),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "class-name": [
        {
          // Using static
          // using static System.Math;
          pattern: r(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [g]),
          lookbehind: !0,
          inside: k
        },
        {
          // Using alias (type)
          // using Project = PC.MyCompany.Project;
          pattern: r(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [m, w]),
          lookbehind: !0,
          inside: k
        },
        {
          // Using alias (alias)
          // using Project = PC.MyCompany.Project;
          pattern: r(/(\busing\s+)<<0>>(?=\s*=)/.source, [m]),
          lookbehind: !0
        },
        {
          // Type declarations
          // class Foo<A, B>
          // interface Foo<out A, B>
          pattern: r(/(\b<<0>>\s+)<<1>>/.source, [o, v]),
          lookbehind: !0,
          inside: k
        },
        {
          // Single catch exception declaration
          // catch(Foo)
          // (things like catch(Foo e) is covered by variable declaration)
          pattern: r(/(\bcatch\s*\(\s*)<<0>>/.source, [g]),
          lookbehind: !0,
          inside: k
        },
        {
          // Name of the type parameter of generic constraints
          // where Foo : class
          pattern: r(/(\bwhere\s+)<<0>>/.source, [m]),
          lookbehind: !0
        },
        {
          // Casts and checks via as and is.
          // as Foo<A>, is Bar<B>
          // (things like if(a is Foo b) is covered by variable declaration)
          pattern: r(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [_]),
          lookbehind: !0,
          inside: k
        },
        {
          // Variable, field and parameter declaration
          // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
          pattern: r(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [w, p, m]),
          inside: k
        }
      ],
      keyword: a,
      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
      number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
      operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
      punctuation: /\?\.?|::|[{}[\];(),.:]/
    }), e.languages.insertBefore("csharp", "number", {
      range: {
        pattern: /\.\./,
        alias: "operator"
      }
    }), e.languages.insertBefore("csharp", "punctuation", {
      "named-parameter": {
        pattern: r(/([(,]\s*)<<0>>(?=\s*:)/.source, [m]),
        lookbehind: !0,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("csharp", "class-name", {
      namespace: {
        // namespace Foo.Bar {}
        // using Foo.Bar;
        pattern: r(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [m]),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      "type-expression": {
        // default(Foo), typeof(Foo<Bar>), sizeof(int)
        pattern: r(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [d]),
        lookbehind: !0,
        alias: "class-name",
        inside: k
      },
      "return-type": {
        // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
        // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
        // int Foo => 0; int Foo { get; set } = 0;
        pattern: r(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [w, g]),
        inside: k,
        alias: "class-name"
      },
      "constructor-invocation": {
        // new List<Foo<Bar[]>> { }
        pattern: r(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [w]),
        lookbehind: !0,
        inside: k,
        alias: "class-name"
      },
      /*'explicit-implementation': {
      	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
      	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
      	inside: classNameInside,
      	alias: 'class-name'
      },*/
      "generic-method": {
        // foo<Bar>()
        pattern: r(/<<0>>\s*<<1>>(?=\s*\()/.source, [m, f]),
        inside: {
          function: r(/^<<0>>/.source, [m]),
          generic: {
            pattern: RegExp(f),
            alias: "class-name",
            inside: k
          }
        }
      },
      "type-list": {
        // The list of types inherited or of generic constraints
        // class Foo<F> : Bar, IList<FooBar>
        // where F : Bar, IList<int>
        pattern: r(
          /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
          [o, v, m, w, a.source, d, /\bnew\s*\(\s*\)/.source]
        ),
        lookbehind: !0,
        inside: {
          "record-arguments": {
            pattern: r(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [v, d]),
            lookbehind: !0,
            greedy: !0,
            inside: e.languages.csharp
          },
          keyword: a,
          "class-name": {
            pattern: RegExp(w),
            greedy: !0,
            inside: k
          },
          punctuation: /[,()]/
        }
      },
      preprocessor: {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: !0,
        alias: "property",
        inside: {
          // highlight preprocessor directives as keywords
          directive: {
            pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
            lookbehind: !0,
            alias: "keyword"
          }
        }
      }
    });
    var I = T + "|" + A, B = t(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [I]), L = n(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [B]), 2), Y = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, Q = t(/<<0>>(?:\s*\(<<1>>*\))?/.source, [g, L]);
    e.languages.insertBefore("csharp", "class-name", {
      attribute: {
        // Attributes
        // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
        pattern: r(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [Y, Q]),
        lookbehind: !0,
        greedy: !0,
        inside: {
          target: {
            pattern: r(/^<<0>>(?=\s*:)/.source, [Y]),
            alias: "keyword"
          },
          "attribute-arguments": {
            pattern: r(/\(<<0>>*\)/.source, [L]),
            inside: e.languages.csharp
          },
          "class-name": {
            pattern: RegExp(g),
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[:,]/
        }
      }
    });
    var re = /:[^}\r\n]+/.source, oe = n(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [B]), 2), ce = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [oe, re]), pe = n(t(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [I]), 2), fe = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [pe, re]);
    function G(Z, K) {
      return {
        interpolation: {
          pattern: r(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [Z]),
          lookbehind: !0,
          inside: {
            "format-string": {
              pattern: r(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [K, re]),
              lookbehind: !0,
              inside: {
                punctuation: /^:/
              }
            },
            punctuation: /^\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              alias: "language-csharp",
              inside: e.languages.csharp
            }
          }
        },
        string: /[\s\S]+/
      };
    }
    e.languages.insertBefore("csharp", "string", {
      "interpolation-string": [
        {
          pattern: r(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [ce]),
          lookbehind: !0,
          greedy: !0,
          inside: G(ce, oe)
        },
        {
          pattern: r(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [fe]),
          lookbehind: !0,
          greedy: !0,
          inside: G(fe, pe)
        }
      ],
      char: {
        pattern: RegExp(A),
        greedy: !0
      }
    }), e.languages.dotnet = e.languages.cs = e.languages.csharp;
  }(Prism)), XP;
}
var ZP = {}, eC;
function FQ() {
  return eC || (eC = 1, Prism.languages.go = Prism.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    boolean: /\b(?:_|false|iota|nil|true)\b/,
    number: [
      // binary and octal integers
      /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
      // hexadecimal integers and floats
      /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
      // decimal integers and floats
      /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
    ],
    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
  }), Prism.languages.insertBefore("go", "string", {
    char: {
      pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
      greedy: !0
    }
  }), delete Prism.languages.go["class-name"]), ZP;
}
var tC = {}, rC;
function zQ() {
  return rC || (rC = 1, function(e) {
    function t(p) {
      return RegExp("(^(?:" + p + "):[ 	]*(?![ 	]))[^]+", "i");
    }
    e.languages.http = {
      "request-line": {
        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
        inside: {
          // HTTP Method
          method: {
            pattern: /^[A-Z]+\b/,
            alias: "property"
          },
          // Request Target e.g. http://example.com, /path/to/file
          "request-target": {
            pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
            lookbehind: !0,
            alias: "url",
            inside: e.languages.uri
          },
          // HTTP Version
          "http-version": {
            pattern: /^(\s)HTTP\/[\d.]+/,
            lookbehind: !0,
            alias: "property"
          }
        }
      },
      "response-status": {
        pattern: /^HTTP\/[\d.]+ \d+ .+/m,
        inside: {
          // HTTP Version
          "http-version": {
            pattern: /^HTTP\/[\d.]+/,
            alias: "property"
          },
          // Status Code
          "status-code": {
            pattern: /^(\s)\d+(?=\s)/,
            lookbehind: !0,
            alias: "number"
          },
          // Reason Phrase
          "reason-phrase": {
            pattern: /^(\s).+/,
            lookbehind: !0,
            alias: "string"
          }
        }
      },
      header: {
        pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
        inside: {
          "header-value": [
            {
              pattern: t(/Content-Security-Policy/.source),
              lookbehind: !0,
              alias: ["csp", "languages-csp"],
              inside: e.languages.csp
            },
            {
              pattern: t(/Public-Key-Pins(?:-Report-Only)?/.source),
              lookbehind: !0,
              alias: ["hpkp", "languages-hpkp"],
              inside: e.languages.hpkp
            },
            {
              pattern: t(/Strict-Transport-Security/.source),
              lookbehind: !0,
              alias: ["hsts", "languages-hsts"],
              inside: e.languages.hsts
            },
            {
              pattern: t(/[^:]+/.source),
              lookbehind: !0
            }
          ],
          "header-name": {
            pattern: /^[^:]+/,
            alias: "keyword"
          },
          punctuation: /^:/
        }
      }
    };
    var r = e.languages, n = {
      "application/javascript": r.javascript,
      "application/json": r.json || r.javascript,
      "application/xml": r.xml,
      "text/xml": r.xml,
      "text/html": r.html,
      "text/css": r.css,
      "text/plain": r.plain
    }, i = {
      "application/json": !0,
      "application/xml": !0
    };
    function s(p) {
      var f = p.replace(/^[a-z]+\//, ""), d = "\\w+/(?:[\\w.-]+\\+)+" + f + "(?![+\\w.-])";
      return "(?:" + p + "|" + d + ")";
    }
    var o;
    for (var a in n)
      if (n[a]) {
        o = o || {};
        var l = i[a] ? s(a) : a;
        o[a.replace(/\//g, "-")] = {
          pattern: RegExp(
            "(" + /content-type:\s*/.source + l + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
            // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
            // However, when writing code by hand (e.g. to display on a website) people can forget about this,
            // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
            // the body does not start with a [\w-] character (as headers do).
            /[^ \t\w-][\s\S]*/.source,
            "i"
          ),
          lookbehind: !0,
          inside: n[a]
        };
      }
    o && e.languages.insertBefore("http", "header", o);
  }(Prism)), tC;
}
var nC = {}, iC;
function qQ() {
  return iC || (iC = 1, function(e) {
    var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, r = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, n = {
      pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    e.languages.java = e.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        n,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: !0,
          inside: n.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + r + /[A-Z]\w*\b/.source),
          lookbehind: !0,
          inside: n.inside
        }
      ],
      keyword: t,
      function: [
        e.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), e.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), e.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": n,
          keyword: t,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + r + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: {
            namespace: n.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + r + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: n.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return t.source;
          })
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), nC;
}
var oC = {}, sC;
function BQ() {
  return sC || (sC = 1, Prism.languages.lua = {
    comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
    // \z may be used to skip the following space
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
      greedy: !0
    },
    number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
    keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
    function: /(?!\d)\w+(?=\s*(?:[({]))/,
    operator: [
      /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
      {
        // Match ".." but don't break "..."
        pattern: /(^|[^.])\.\.(?!\.)/,
        lookbehind: !0
      }
    ],
    punctuation: /[\[\](){},;]|\.+|:+/
  }), oC;
}
var aC = {}, lC;
function UQ() {
  return lC || (lC = 1, function(e) {
    function t(r, n) {
      return "___" + r.toUpperCase() + n + "___";
    }
    Object.defineProperties(e.languages["markup-templating"] = {}, {
      buildPlaceholders: {
        /**
         * Tokenize all inline templating expressions matching `placeholderPattern`.
         *
         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
         * `true` will be replaced.
         *
         * @param {object} env The environment of the `before-tokenize` hook.
         * @param {string} language The language id.
         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
         * @param {(match: string) => boolean} [replaceFilter]
         */
        value: function(r, n, i, s) {
          if (r.language === n) {
            var o = r.tokenStack = [];
            r.code = r.code.replace(i, function(a) {
              if (typeof s == "function" && !s(a))
                return a;
              for (var l = o.length, p; r.code.indexOf(p = t(n, l)) !== -1; )
                ++l;
              return o[l] = a, p;
            }), r.grammar = e.languages.markup;
          }
        }
      },
      tokenizePlaceholders: {
        /**
         * Replace placeholders with proper tokens after tokenizing.
         *
         * @param {object} env The environment of the `after-tokenize` hook.
         * @param {string} language The language id.
         */
        value: function(r, n) {
          if (r.language !== n || !r.tokenStack)
            return;
          r.grammar = e.languages[n];
          var i = 0, s = Object.keys(r.tokenStack);
          function o(a) {
            for (var l = 0; l < a.length && !(i >= s.length); l++) {
              var p = a[l];
              if (typeof p == "string" || p.content && typeof p.content == "string") {
                var f = s[i], d = r.tokenStack[f], m = typeof p == "string" ? p : p.content, v = t(n, f), g = m.indexOf(v);
                if (g > -1) {
                  ++i;
                  var S = m.substring(0, g), _ = new e.Token(n, e.tokenize(d, r.grammar), "language-" + n, d), x = m.substring(g + v.length), y = [];
                  S && y.push.apply(y, o([S])), y.push(_), x && y.push.apply(y, o([x])), typeof p == "string" ? a.splice.apply(a, [l, 1].concat(y)) : p.content = y;
                }
              } else p.content && o(p.content);
            }
            return a;
          }
          o(r.tokens);
        }
      }
    });
  }(Prism)), aC;
}
var uC = {}, cC;
function VQ() {
  return cC || (cC = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
    e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(t, r) {
      var n = {};
      n["language-" + r] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[r]
      }, n.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var i = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: n
        }
      };
      i["language-" + r] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[r]
      };
      var s = {};
      s[t] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return t;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: i
      }, Prism.languages.insertBefore("markup", "cdata", s);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(e, t) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [t, "language-" + t],
                inside: Prism.languages[t]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), uC;
}
var pC = {}, fC;
function WQ() {
  return fC || (fC = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), pC;
}
var dC = {}, hC;
function HQ() {
  return hC || (hC = 1, function(e) {
    var t = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
    e.languages.perl = {
      comment: [
        {
          // POD
          pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\$])#.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      // TODO Could be nice to handle Heredoc too.
      string: [
        {
          pattern: RegExp(
            /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // q/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // q a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // q(...)
              // q{...}
              // q[...]
              // q<...>
              t
            ].join("|") + ")"
          ),
          greedy: !0
        },
        // "...", `...`
        {
          pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
          greedy: !0
        },
        // '...'
        // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
        {
          pattern: /'(?:[^'\\\r\n]|\\.)*'/,
          greedy: !0
        }
      ],
      regex: [
        {
          pattern: RegExp(
            /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // m/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // m a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // m(...)
              // m{...}
              // m[...]
              // m<...>
              t
            ].join("|") + ")" + /[msixpodualngc]*/.source
          ),
          greedy: !0
        },
        // The lookbehinds prevent -s from breaking
        {
          pattern: RegExp(
            /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // s/.../.../
              // eslint-disable-next-line regexp/strict
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // s a...a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
              // s(...)(...)
              // s{...}{...}
              // s[...][...]
              // s<...><...>
              // s(...)[...]
              t + /\s*/.source + t
            ].join("|") + ")" + /[msixpodualngcer]*/.source
          ),
          lookbehind: !0,
          greedy: !0
        },
        // /.../
        // The look-ahead tries to prevent two divisions on
        // the same line from being highlighted as regex.
        // This does not support multi-line regex.
        {
          pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
          greedy: !0
        }
      ],
      // FIXME Not sure about the handling of ::, ', and #
      variable: [
        // ${^POSTMATCH}
        /[&*$@%]\{\^[A-Z]+\}/,
        // $^V
        /[&*$@%]\^[A-Z_]/,
        // ${...}
        /[&*$@%]#?(?=\{)/,
        // $foo
        /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
        // $1
        /[&*$@%]\d+/,
        // $_, @_, %!
        // The negative lookahead prevents from breaking the %= operator
        /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
      ],
      filehandle: {
        // <>, <FOO>, _
        pattern: /<(?![<=])\S*?>|\b_\b/,
        alias: "symbol"
      },
      "v-string": {
        // v1.2, 1.2.3
        pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
        alias: "string"
      },
      function: {
        pattern: /(\bsub[ \t]+)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
      operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
      punctuation: /[{}[\];(),:]/
    };
  }(Prism)), dC;
}
var mC = {}, gC;
function QQ() {
  return gC || (gC = 1, function(e) {
    var t = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, r = [
      {
        pattern: /\b(?:false|true)\b/i,
        alias: "boolean"
      },
      {
        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
        greedy: !0,
        lookbehind: !0
      },
      {
        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
        greedy: !0,
        lookbehind: !0
      },
      /\b(?:null)\b/i,
      /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
    ], n = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, i = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, s = /[{}\[\](),:;]/;
    e.languages.php = {
      delimiter: {
        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
        alias: "important"
      },
      comment: t,
      variable: /\$+(?:\w+\b|(?=\{))/,
      package: {
        pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      "class-name-definition": {
        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
        lookbehind: !0,
        alias: "class-name"
      },
      "function-definition": {
        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
        lookbehind: !0,
        alias: "function"
      },
      keyword: [
        {
          pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
          alias: "type-casting",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
          alias: "type-declaration",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:parent|self|static)(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          // yield from
          pattern: /(\byield\s+)from\b/i,
          lookbehind: !0
        },
        // `class` is always a keyword unlike other keywords
        /\bclass\b/i,
        {
          // https://www.php.net/manual/en/reserved.keywords.php
          //
          // keywords cannot be preceded by "->"
          // the complex lookbehind means `(?<!(?:->|::)\s*)`
          pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
          lookbehind: !0
        }
      ],
      "argument-name": {
        pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
        lookbehind: !0
      },
      "class-name": [
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-declaration"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
          alias: ["class-name-fully-qualified", "static-context"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-hint"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: ["class-name-fully-qualified", "return-type"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }
      ],
      constant: r,
      function: {
        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      property: {
        pattern: /(->\s*)\w+/,
        lookbehind: !0
      },
      number: n,
      operator: i,
      punctuation: s
    };
    var o = {
      pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
      lookbehind: !0,
      inside: e.languages.php
    }, a = [
      {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        alias: "nowdoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<'?|[';]$/
            }
          }
        }
      },
      {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        alias: "heredoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<"?|[";]$/
            }
          },
          interpolation: o
        }
      },
      {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        alias: "backtick-quoted-string",
        greedy: !0
      },
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        alias: "single-quoted-string",
        greedy: !0
      },
      {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        alias: "double-quoted-string",
        greedy: !0,
        inside: {
          interpolation: o
        }
      }
    ];
    e.languages.insertBefore("php", "variable", {
      string: a,
      attribute: {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: !0,
        inside: {
          "attribute-content": {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: !0,
            // inside can appear subset of php
            inside: {
              comment: t,
              string: a,
              "attribute-class-name": [
                {
                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                  alias: "class-name",
                  greedy: !0,
                  lookbehind: !0
                },
                {
                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                  alias: [
                    "class-name",
                    "class-name-fully-qualified"
                  ],
                  greedy: !0,
                  lookbehind: !0,
                  inside: {
                    punctuation: /\\/
                  }
                }
              ],
              constant: r,
              number: n,
              operator: i,
              punctuation: s
            }
          },
          delimiter: {
            pattern: /^#\[|\]$/,
            alias: "punctuation"
          }
        }
      }
    }), e.hooks.add("before-tokenize", function(l) {
      if (/<\?/.test(l.code)) {
        var p = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
        e.languages["markup-templating"].buildPlaceholders(l, "php", p);
      }
    }), e.hooks.add("after-tokenize", function(l) {
      e.languages["markup-templating"].tokenizePlaceholders(l, "php");
    });
  }(Prism)), mC;
}
var yC = {}, vC;
function YQ() {
  return vC || (vC = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), yC;
}
var bC = {}, wC;
function GQ() {
  return wC || (wC = 1, Prism.languages.q = {
    string: /"(?:\\.|[^"\\\r\n])*"/,
    comment: [
      // From http://code.kx.com/wiki/Reference/Slash:
      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
      {
        pattern: /([\t )\]}])\/.*/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
      // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
      // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
      // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
      {
        pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A \ on a line by itself with no preceding matching / will comment to end of file.
      {
        pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
        greedy: !0
      },
      {
        pattern: /^#!.+/m,
        greedy: !0
      }
    ],
    symbol: /`(?::\S+|[\w.]*)/,
    datetime: {
      pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
      alias: "number"
    },
    // The negative look-ahead prevents bad highlighting
    // of verbs 0: and 1:
    number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
    keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
    adverb: {
      pattern: /['\/\\]:?|\beach\b/,
      alias: "function"
    },
    verb: {
      pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
      alias: "operator"
    },
    punctuation: /[(){}\[\];.]/
  }), bC;
}
var SC = {}, xC;
function KQ() {
  return xC || (xC = 1, function(e) {
    e.languages.ruby = e.languages.extend("clike", {
      comment: {
        pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
      operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
      punctuation: /[(){}[\].,;]/
    }), e.languages.insertBefore("ruby", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    var t = {
      pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
      lookbehind: !0,
      inside: {
        content: {
          pattern: /^(#\{)[\s\S]+(?=\}$)/,
          lookbehind: !0,
          inside: e.languages.ruby
        },
        delimiter: {
          pattern: /^#\{|\}$/,
          alias: "punctuation"
        }
      }
    };
    delete e.languages.ruby.function;
    var r = "(?:" + [
      /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
      /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
      /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
      /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
      /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
    ].join("|") + ")", n = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
    e.languages.insertBefore("ruby", "keyword", {
      "regex-literal": [
        {
          pattern: RegExp(/%r/.source + r + /[egimnosux]{0,6}/.source),
          greedy: !0,
          inside: {
            interpolation: t,
            regex: /[\s\S]+/
          }
        },
        {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: t,
            regex: /[\s\S]+/
          }
        }
      ],
      variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
      symbol: [
        {
          pattern: RegExp(/(^|[^:]):/.source + n),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: RegExp(/([\r\n{(,][ \t]*)/.source + n + /(?=:(?!:))/.source),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "method-definition": {
        pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
        lookbehind: !0,
        inside: {
          function: /\b\w+$/,
          keyword: /^self\b/,
          "class-name": /^\w+/,
          punctuation: /\./
        }
      }
    }), e.languages.insertBefore("ruby", "string", {
      "string-literal": [
        {
          pattern: RegExp(/%[qQiIwWs]?/.source + r),
          greedy: !0,
          inside: {
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
          greedy: !0,
          inside: {
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?/
              }
            },
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?'|'$/
              }
            },
            string: /[\s\S]+/
          }
        }
      ],
      "command-literal": [
        {
          pattern: RegExp(/%x/.source + r),
          greedy: !0,
          inside: {
            interpolation: t,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        },
        {
          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
          greedy: !0,
          inside: {
            interpolation: t,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }
      ]
    }), delete e.languages.ruby.string, e.languages.insertBefore("ruby", "number", {
      builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
      constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
    }), e.languages.rb = e.languages.ruby;
  }(Prism)), SC;
}
var _C = {}, EC;
function XQ() {
  return EC || (EC = 1, Prism.languages.scala = Prism.languages.extend("java", {
    "triple-quoted-string": {
      pattern: /"""[\s\S]*?"""/,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    keyword: /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
    number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
    builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
    symbol: /'[^\d\s\\]\w*/
  }), Prism.languages.insertBefore("scala", "triple-quoted-string", {
    "string-interpolation": {
      pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
      greedy: !0,
      inside: {
        id: {
          pattern: /^\w+/,
          greedy: !0,
          alias: "function"
        },
        escape: {
          pattern: /\\\$"|\$[$"]/,
          greedy: !0,
          alias: "symbol"
        },
        interpolation: {
          pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
          greedy: !0,
          inside: {
            punctuation: /^\$\{?|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              inside: Prism.languages.scala
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  }), delete Prism.languages.scala["class-name"], delete Prism.languages.scala.function, delete Prism.languages.scala.constant), _C;
}
var OC = {}, kC;
function JQ() {
  return kC || (kC = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), OC;
}
var AC = {}, PC;
function ZQ() {
  return PC || (PC = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(e) {
    e.inside.interpolation.inside = Prism.languages.swift;
  })), AC;
}
var CC = {}, TC;
function eY() {
  return TC || (TC = 1, function(e) {
    var t = /[*&][^\s[\]{},]+/, r = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, n = "(?:" + r.source + "(?:[ 	]+" + t.source + ")?|" + t.source + "(?:[ 	]+" + r.source + ")?)", i = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
      return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    }), s = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    function o(a, l) {
      l = (l || "").replace(/m/g, "") + "m";
      var p = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
        return n;
      }).replace(/<<value>>/g, function() {
        return a;
      });
      return RegExp(p, l);
    }
    e.languages.yaml = {
      scalar: {
        pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
          return n;
        })),
        lookbehind: !0,
        alias: "string"
      },
      comment: /#.*/,
      key: {
        pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
          return n;
        }).replace(/<<key>>/g, function() {
          return "(?:" + i + "|" + s + ")";
        })),
        lookbehind: !0,
        greedy: !0,
        alias: "atrule"
      },
      directive: {
        pattern: /(^[ \t]*)%.+/m,
        lookbehind: !0,
        alias: "important"
      },
      datetime: {
        pattern: o(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
        lookbehind: !0,
        alias: "number"
      },
      boolean: {
        pattern: o(/false|true/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      null: {
        pattern: o(/null|~/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      string: {
        pattern: o(s),
        lookbehind: !0,
        greedy: !0
      },
      number: {
        pattern: o(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
        lookbehind: !0
      },
      tag: r,
      important: t,
      punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
    }, e.languages.yml = e.languages.yaml;
  }(Prism)), CC;
}
var $C = {}, RC;
function tY() {
  return RC || (RC = 1, Prism.languages.csv = {
    value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
    punctuation: /,/
  }), $C;
}
var r0 = { exports: {} };
/*!***************************************************
* mark.js v8.11.1
* https://markjs.io/
* Copyright (c) 2014–2018, Julian Kühnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
var IC;
function rY() {
  return IC || (IC = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(pn, function() {
      var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p) {
        return typeof p;
      } : function(p) {
        return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
      }, n = function(p, f) {
        if (!(p instanceof f))
          throw new TypeError("Cannot call a class as a function");
      }, i = /* @__PURE__ */ function() {
        function p(f, d) {
          for (var m = 0; m < d.length; m++) {
            var v = d[m];
            v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(f, v.key, v);
          }
        }
        return function(f, d, m) {
          return d && p(f.prototype, d), m && p(f, m), f;
        };
      }(), s = Object.assign || function(p) {
        for (var f = 1; f < arguments.length; f++) {
          var d = arguments[f];
          for (var m in d)
            Object.prototype.hasOwnProperty.call(d, m) && (p[m] = d[m]);
        }
        return p;
      }, o = function() {
        function p(f) {
          var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          n(this, p), this.ctx = f, this.iframes = d, this.exclude = m, this.iframesTimeout = v;
        }
        return i(p, [{
          key: "getContexts",
          value: function() {
            var d = void 0, m = [];
            return typeof this.ctx > "u" || !this.ctx ? d = [] : NodeList.prototype.isPrototypeOf(this.ctx) ? d = Array.prototype.slice.call(this.ctx) : Array.isArray(this.ctx) ? d = this.ctx : typeof this.ctx == "string" ? d = Array.prototype.slice.call(document.querySelectorAll(this.ctx)) : d = [this.ctx], d.forEach(function(v) {
              var g = m.filter(function(S) {
                return S.contains(v);
              }).length > 0;
              m.indexOf(v) === -1 && !g && m.push(v);
            }), m;
          }
        }, {
          key: "getIframeContents",
          value: function(d, m) {
            var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            }, g = void 0;
            try {
              var S = d.contentWindow;
              if (g = S.document, !S || !g)
                throw new Error("iframe inaccessible");
            } catch {
              v();
            }
            g && m(g);
          }
        }, {
          key: "isIframeBlank",
          value: function(d) {
            var m = "about:blank", v = d.getAttribute("src").trim(), g = d.contentWindow.location.href;
            return g === m && v !== m && v;
          }
        }, {
          key: "observeIframeLoad",
          value: function(d, m, v) {
            var g = this, S = !1, _ = null, x = function y() {
              if (!S) {
                S = !0, clearTimeout(_);
                try {
                  g.isIframeBlank(d) || (d.removeEventListener("load", y), g.getIframeContents(d, m, v));
                } catch {
                  v();
                }
              }
            };
            d.addEventListener("load", x), _ = setTimeout(x, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function(d, m, v) {
            try {
              d.contentWindow.document.readyState === "complete" ? this.isIframeBlank(d) ? this.observeIframeLoad(d, m, v) : this.getIframeContents(d, m, v) : this.observeIframeLoad(d, m, v);
            } catch {
              v();
            }
          }
        }, {
          key: "waitForIframes",
          value: function(d, m) {
            var v = this, g = 0;
            this.forEachIframe(d, function() {
              return !0;
            }, function(S) {
              g++, v.waitForIframes(S.querySelector("html"), function() {
                --g || m();
              });
            }, function(S) {
              S || m();
            });
          }
        }, {
          key: "forEachIframe",
          value: function(d, m, v) {
            var g = this, S = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, _ = d.querySelectorAll("iframe"), x = _.length, y = 0;
            _ = Array.prototype.slice.call(_);
            var w = function() {
              --x <= 0 && S(y);
            };
            x || w(), _.forEach(function(k) {
              p.matches(k, g.exclude) ? w() : g.onIframeReady(k, function(A) {
                m(k) && (y++, v(A)), w();
              }, w);
            });
          }
        }, {
          key: "createIterator",
          value: function(d, m, v) {
            return document.createNodeIterator(d, m, v, !1);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function(d) {
            return new p(d.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function(d, m, v) {
            var g = d.compareDocumentPosition(v), S = Node.DOCUMENT_POSITION_PRECEDING;
            if (g & S)
              if (m !== null) {
                var _ = m.compareDocumentPosition(v), x = Node.DOCUMENT_POSITION_FOLLOWING;
                if (_ & x)
                  return !0;
              } else
                return !0;
            return !1;
          }
        }, {
          key: "getIteratorNode",
          value: function(d) {
            var m = d.previousNode(), v = void 0;
            return m === null ? v = d.nextNode() : v = d.nextNode() && d.nextNode(), {
              prevNode: m,
              node: v
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function(d, m, v, g) {
            var S = !1, _ = !1;
            return g.forEach(function(x, y) {
              x.val === v && (S = y, _ = x.handled);
            }), this.compareNodeIframe(d, m, v) ? (S === !1 && !_ ? g.push({
              val: v,
              handled: !0
            }) : S !== !1 && !_ && (g[S].handled = !0), !0) : (S === !1 && g.push({
              val: v,
              handled: !1
            }), !1);
          }
        }, {
          key: "handleOpenIframes",
          value: function(d, m, v, g) {
            var S = this;
            d.forEach(function(_) {
              _.handled || S.getIframeContents(_.val, function(x) {
                S.createInstanceOnIframe(x).forEachNode(m, v, g);
              });
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function(d, m, v, g, S) {
            for (var _ = this, x = this.createIterator(m, d, g), y = [], w = [], k = void 0, A = void 0, T = function() {
              var I = _.getIteratorNode(x);
              return A = I.prevNode, k = I.node, k;
            }; T(); )
              this.iframes && this.forEachIframe(m, function(R) {
                return _.checkIframeFilter(k, A, R, y);
              }, function(R) {
                _.createInstanceOnIframe(R).forEachNode(d, function(I) {
                  return w.push(I);
                }, g);
              }), w.push(k);
            w.forEach(function(R) {
              v(R);
            }), this.iframes && this.handleOpenIframes(y, d, v, g), S();
          }
        }, {
          key: "forEachNode",
          value: function(d, m, v) {
            var g = this, S = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, _ = this.getContexts(), x = _.length;
            x || S(), _.forEach(function(y) {
              var w = function() {
                g.iterateThroughNodes(d, y, m, v, function() {
                  --x <= 0 && S();
                });
              };
              g.iframes ? g.waitForIframes(y, w) : w();
            });
          }
        }], [{
          key: "matches",
          value: function(d, m) {
            var v = typeof m == "string" ? [m] : m, g = d.matches || d.matchesSelector || d.msMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.webkitMatchesSelector;
            if (g) {
              var S = !1;
              return v.every(function(_) {
                return g.call(d, _) ? (S = !0, !1) : !0;
              }), S;
            } else
              return !1;
          }
        }]), p;
      }(), a = function() {
        function p(f) {
          n(this, p), this.ctx = f, this.ie = !1;
          var d = window.navigator.userAgent;
          (d.indexOf("MSIE") > -1 || d.indexOf("Trident") > -1) && (this.ie = !0);
        }
        return i(p, [{
          key: "log",
          value: function(d) {
            var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug", v = this.opt.log;
            this.opt.debug && (typeof v > "u" ? "undefined" : r(v)) === "object" && typeof v[m] == "function" && v[m]("mark.js: " + d);
          }
        }, {
          key: "escapeStr",
          value: function(d) {
            return d.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function(d) {
            return this.opt.wildcards !== "disabled" && (d = this.setupWildcardsRegExp(d)), d = this.escapeStr(d), Object.keys(this.opt.synonyms).length && (d = this.createSynonymsRegExp(d)), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (d = this.setupIgnoreJoinersRegExp(d)), this.opt.diacritics && (d = this.createDiacriticsRegExp(d)), d = this.createMergedBlanksRegExp(d), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (d = this.createJoinersRegExp(d)), this.opt.wildcards !== "disabled" && (d = this.createWildcardsRegExp(d)), d = this.createAccuracyRegExp(d), d;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function(d) {
            var m = this.opt.synonyms, v = this.opt.caseSensitive ? "" : "i", g = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var S in m)
              if (m.hasOwnProperty(S)) {
                var _ = m[S], x = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(S) : this.escapeStr(S), y = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(_) : this.escapeStr(_);
                x !== "" && y !== "" && (d = d.replace(new RegExp("(" + this.escapeStr(x) + "|" + this.escapeStr(y) + ")", "gm" + v), g + ("(" + this.processSynomyms(x) + "|") + (this.processSynomyms(y) + ")") + g));
              }
            return d;
          }
        }, {
          key: "processSynomyms",
          value: function(d) {
            return (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (d = this.setupIgnoreJoinersRegExp(d)), d;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function(d) {
            return d = d.replace(/(?:\\)*\?/g, function(m) {
              return m.charAt(0) === "\\" ? "?" : "";
            }), d.replace(/(?:\\)*\*/g, function(m) {
              return m.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function(d) {
            var m = this.opt.wildcards === "withSpaces";
            return d.replace(/\u0001/g, m ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, m ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function(d) {
            return d.replace(/[^(|)\\]/g, function(m, v, g) {
              var S = g.charAt(v + 1);
              return /[(|)\\]/.test(S) || S === "" ? m : m + "\0";
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function(d) {
            var m = [], v = this.opt.ignorePunctuation;
            return Array.isArray(v) && v.length && m.push(this.escapeStr(v.join(""))), this.opt.ignoreJoiners && m.push("\\u00ad\\u200b\\u200c\\u200d"), m.length ? d.split(/\u0000+/).join("[" + m.join("") + "]*") : d;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function(d) {
            var m = this.opt.caseSensitive ? "" : "i", v = this.opt.caseSensitive ? ["aàáảãạăằắẳẵặâầấẩẫậäåāą", "AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ", "cçćč", "CÇĆČ", "dđď", "DĐĎ", "eèéẻẽẹêềếểễệëěēę", "EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ", "iìíỉĩịîïī", "IÌÍỈĨỊÎÏĪ", "lł", "LŁ", "nñňń", "NÑŇŃ", "oòóỏõọôồốổỗộơởỡớờợöøō", "OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ", "rř", "RŘ", "sšśșş", "SŠŚȘŞ", "tťțţ", "TŤȚŢ", "uùúủũụưừứửữựûüůū", "UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ", "yýỳỷỹỵÿ", "YÝỲỶỸỴŸ", "zžżź", "ZŽŻŹ"] : ["aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ", "cçćčCÇĆČ", "dđďDĐĎ", "eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ", "iìíỉĩịîïīIÌÍỈĨỊÎÏĪ", "lłLŁ", "nñňńNÑŇŃ", "oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ", "rřRŘ", "sšśșşSŠŚȘŞ", "tťțţTŤȚŢ", "uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ", "yýỳỷỹỵÿYÝỲỶỸỴŸ", "zžżźZŽŻŹ"], g = [];
            return d.split("").forEach(function(S) {
              v.every(function(_) {
                if (_.indexOf(S) !== -1) {
                  if (g.indexOf(_) > -1)
                    return !1;
                  d = d.replace(new RegExp("[" + _ + "]", "gm" + m), "[" + _ + "]"), g.push(_);
                }
                return !0;
              });
            }), d;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function(d) {
            return d.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function(d) {
            var m = this, v = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~¡¿", g = this.opt.accuracy, S = typeof g == "string" ? g : g.value, _ = typeof g == "string" ? [] : g.limiters, x = "";
            switch (_.forEach(function(y) {
              x += "|" + m.escapeStr(y);
            }), S) {
              case "partially":
              default:
                return "()(" + d + ")";
              case "complementary":
                return x = "\\s" + (x || this.escapeStr(v)), "()([^" + x + "]*" + d + "[^" + x + "]*)";
              case "exactly":
                return "(^|\\s" + x + ")(" + d + ")(?=$|\\s" + x + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function(d) {
            var m = this, v = [];
            return d.forEach(function(g) {
              m.opt.separateWordSearch ? g.split(" ").forEach(function(S) {
                S.trim() && v.indexOf(S) === -1 && v.push(S);
              }) : g.trim() && v.indexOf(g) === -1 && v.push(g);
            }), {
              keywords: v.sort(function(g, S) {
                return S.length - g.length;
              }),
              length: v.length
            };
          }
        }, {
          key: "isNumeric",
          value: function(d) {
            return Number(parseFloat(d)) == d;
          }
        }, {
          key: "checkRanges",
          value: function(d) {
            var m = this;
            if (!Array.isArray(d) || Object.prototype.toString.call(d[0]) !== "[object Object]")
              return this.log("markRanges() will only accept an array of objects"), this.opt.noMatch(d), [];
            var v = [], g = 0;
            return d.sort(function(S, _) {
              return S.start - _.start;
            }).forEach(function(S) {
              var _ = m.callNoMatchOnInvalidRanges(S, g), x = _.start, y = _.end, w = _.valid;
              w && (S.start = x, S.length = y - x, v.push(S), g = y);
            }), v;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function(d, m) {
            var v = void 0, g = void 0, S = !1;
            return d && typeof d.start < "u" ? (v = parseInt(d.start, 10), g = v + parseInt(d.length, 10), this.isNumeric(d.start) && this.isNumeric(d.length) && g - m > 0 && g - v > 0 ? S = !0 : (this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(d))), this.opt.noMatch(d))) : (this.log("Ignoring invalid range: " + JSON.stringify(d)), this.opt.noMatch(d)), {
              start: v,
              end: g,
              valid: S
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function(d, m, v) {
            var g = void 0, S = !0, _ = v.length, x = m - _, y = parseInt(d.start, 10) - x;
            return y = y > _ ? _ : y, g = y + parseInt(d.length, 10), g > _ && (g = _, this.log("End range automatically set to the max value of " + _)), y < 0 || g - y < 0 || y > _ || g > _ ? (S = !1, this.log("Invalid range: " + JSON.stringify(d)), this.opt.noMatch(d)) : v.substring(y, g).replace(/\s+/g, "") === "" && (S = !1, this.log("Skipping whitespace only range: " + JSON.stringify(d)), this.opt.noMatch(d)), {
              start: y,
              end: g,
              valid: S
            };
          }
        }, {
          key: "getTextNodes",
          value: function(d) {
            var m = this, v = "", g = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(S) {
              g.push({
                start: v.length,
                end: (v += S.textContent).length,
                node: S
              });
            }, function(S) {
              return m.matchesExclude(S.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, function() {
              d({
                value: v,
                nodes: g
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function(d) {
            return o.matches(d, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function(d, m, v) {
            var g = this.opt.element ? this.opt.element : "mark", S = d.splitText(m), _ = S.splitText(v - m), x = document.createElement(g);
            return x.setAttribute("data-markjs", "true"), this.opt.className && x.setAttribute("class", this.opt.className), x.textContent = S.textContent, S.parentNode.replaceChild(x, S), _;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function(d, m, v, g, S) {
            var _ = this;
            d.nodes.every(function(x, y) {
              var w = d.nodes[y + 1];
              if (typeof w > "u" || w.start > m) {
                if (!g(x.node))
                  return !1;
                var k = m - x.start, A = (v > x.end ? x.end : v) - x.start, T = d.value.substr(0, x.start), R = d.value.substr(A + x.start);
                if (x.node = _.wrapRangeInTextNode(x.node, k, A), d.value = T + R, d.nodes.forEach(function(I, B) {
                  B >= y && (d.nodes[B].start > 0 && B !== y && (d.nodes[B].start -= A), d.nodes[B].end -= A);
                }), v -= A, S(x.node.previousSibling, x.start), v > x.end)
                  m = x.end;
                else
                  return !1;
              }
              return !0;
            });
          }
        }, {
          key: "wrapMatches",
          value: function(d, m, v, g, S) {
            var _ = this, x = m === 0 ? 0 : m + 1;
            this.getTextNodes(function(y) {
              y.nodes.forEach(function(w) {
                w = w.node;
                for (var k = void 0; (k = d.exec(w.textContent)) !== null && k[x] !== ""; )
                  if (v(k[x], w)) {
                    var A = k.index;
                    if (x !== 0)
                      for (var T = 1; T < x; T++)
                        A += k[T].length;
                    w = _.wrapRangeInTextNode(w, A, A + k[x].length), g(w.previousSibling), d.lastIndex = 0;
                  }
              }), S();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function(d, m, v, g, S) {
            var _ = this, x = m === 0 ? 0 : m + 1;
            this.getTextNodes(function(y) {
              for (var w = void 0; (w = d.exec(y.value)) !== null && w[x] !== ""; ) {
                var k = w.index;
                if (x !== 0)
                  for (var A = 1; A < x; A++)
                    k += w[A].length;
                var T = k + w[x].length;
                _.wrapRangeInMappedTextNode(y, k, T, function(R) {
                  return v(w[x], R);
                }, function(R, I) {
                  d.lastIndex = I, g(R);
                });
              }
              S();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function(d, m, v, g) {
            var S = this;
            this.getTextNodes(function(_) {
              var x = _.value.length;
              d.forEach(function(y, w) {
                var k = S.checkWhitespaceRanges(y, x, _.value), A = k.start, T = k.end, R = k.valid;
                R && S.wrapRangeInMappedTextNode(_, A, T, function(I) {
                  return m(I, y, _.value.substring(A, T), w);
                }, function(I) {
                  v(I, y);
                });
              }), g();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function(d) {
            for (var m = d.parentNode, v = document.createDocumentFragment(); d.firstChild; )
              v.appendChild(d.removeChild(d.firstChild));
            m.replaceChild(v, d), this.ie ? this.normalizeTextNode(m) : m.normalize();
          }
        }, {
          key: "normalizeTextNode",
          value: function(d) {
            if (d) {
              if (d.nodeType === 3)
                for (; d.nextSibling && d.nextSibling.nodeType === 3; )
                  d.nodeValue += d.nextSibling.nodeValue, d.parentNode.removeChild(d.nextSibling);
              else
                this.normalizeTextNode(d.firstChild);
              this.normalizeTextNode(d.nextSibling);
            }
          }
        }, {
          key: "markRegExp",
          value: function(d, m) {
            var v = this;
            this.opt = m, this.log('Searching with expression "' + d + '"');
            var g = 0, S = "wrapMatches", _ = function(y) {
              g++, v.opt.each(y);
            };
            this.opt.acrossElements && (S = "wrapMatchesAcrossElements"), this[S](d, this.opt.ignoreGroups, function(x, y) {
              return v.opt.filter(y, x, g);
            }, _, function() {
              g === 0 && v.opt.noMatch(d), v.opt.done(g);
            });
          }
        }, {
          key: "mark",
          value: function(d, m) {
            var v = this;
            this.opt = m;
            var g = 0, S = "wrapMatches", _ = this.getSeparatedKeywords(typeof d == "string" ? [d] : d), x = _.keywords, y = _.length, w = this.opt.caseSensitive ? "" : "i", k = function A(T) {
              var R = new RegExp(v.createRegExp(T), "gm" + w), I = 0;
              v.log('Searching with expression "' + R + '"'), v[S](R, 1, function(B, L) {
                return v.opt.filter(L, T, g, I);
              }, function(B) {
                I++, g++, v.opt.each(B);
              }, function() {
                I === 0 && v.opt.noMatch(T), x[y - 1] === T ? v.opt.done(g) : A(x[x.indexOf(T) + 1]);
              });
            };
            this.opt.acrossElements && (S = "wrapMatchesAcrossElements"), y === 0 ? this.opt.done(g) : k(x[0]);
          }
        }, {
          key: "markRanges",
          value: function(d, m) {
            var v = this;
            this.opt = m;
            var g = 0, S = this.checkRanges(d);
            S && S.length ? (this.log("Starting to mark with the following ranges: " + JSON.stringify(S)), this.wrapRangeFromIndex(S, function(_, x, y, w) {
              return v.opt.filter(_, x, y, w);
            }, function(_, x) {
              g++, v.opt.each(_, x);
            }, function() {
              v.opt.done(g);
            })) : this.opt.done(g);
          }
        }, {
          key: "unmark",
          value: function(d) {
            var m = this;
            this.opt = d;
            var v = this.opt.element ? this.opt.element : "*";
            v += "[data-markjs]", this.opt.className && (v += "." + this.opt.className), this.log('Removal selector "' + v + '"'), this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(g) {
              m.unwrapMatches(g);
            }, function(g) {
              var S = o.matches(g, v), _ = m.matchesExclude(g);
              return !S || _ ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function(d) {
            this._opt = s({}, {
              element: "",
              className: "",
              exclude: [],
              iframes: !1,
              iframesTimeout: 5e3,
              separateWordSearch: !0,
              diacritics: !0,
              synonyms: {},
              accuracy: "partially",
              acrossElements: !1,
              caseSensitive: !1,
              ignoreJoiners: !1,
              ignoreGroups: 0,
              ignorePunctuation: [],
              wildcards: "disabled",
              each: function() {
              },
              noMatch: function() {
              },
              filter: function() {
                return !0;
              },
              done: function() {
              },
              debug: !1,
              log: window.console
            }, d);
          },
          get: function() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function() {
            return new o(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]), p;
      }();
      function l(p) {
        var f = this, d = new a(p);
        return this.mark = function(m, v) {
          return d.mark(m, v), f;
        }, this.markRegExp = function(m, v) {
          return d.markRegExp(m, v), f;
        }, this.markRanges = function(m, v) {
          return d.markRanges(m, v), f;
        }, this.unmark = function(m) {
          return d.unmark(m), f;
        }, this;
      }
      return l;
    });
  }(r0)), r0.exports;
}
function ec(e) {
  return e < 10 ? "0" + e : e;
}
function nY(e, t, r, n) {
  var i = r ? "" : e.getUTCFullYear() + "-" + ec(e.getUTCMonth() + 1) + "-" + ec(e.getUTCDate());
  return t || (i += "T" + ec(e.getUTCHours()) + ":" + ec(e.getUTCMinutes()) + ":" + ec(e.getUTCSeconds()) + "Z"), i;
}
function zN(e, t) {
  return t > e.length ? e.repeat(Math.trunc(t / e.length) + 1).substring(0, t) : e;
}
function Em(...e) {
  const t = (r) => r && typeof r == "object";
  return e.reduce((r, n) => (Object.keys(n || {}).forEach((i) => {
    const s = r[i], o = n[i];
    t(s) && t(o) ? r[i] = Em(s, o) : r[i] = o;
  }), r), Array.isArray(e[e.length - 1]) ? [] : {});
}
function iY(e) {
  var t = oY(e), r = sY(t, t, t, t), n = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (i) => {
    var s = r() * 16 % 16 | 0;
    return (i == "x" ? s : s & 3 | 8).toString(16);
  });
  return n;
}
function n0(e) {
  return {
    value: e === "object" ? {} : e === "array" ? [] : void 0
  };
}
function Po(e, t) {
  t && e.pop();
}
function oY(e) {
  var t = 0;
  if (e.length == 0) return t;
  for (var r = 0; r < e.length; r++) {
    var n = e.charCodeAt(r);
    t = (t << 5) - t + n, t = t & t;
  }
  return t;
}
function sY(e, t, r, n) {
  return function() {
    e |= 0, t |= 0, r |= 0, n |= 0;
    var i = e - (t << 27 | t >>> 5) | 0;
    return e = t ^ (r << 17 | r >>> 15), t = r + n | 0, r = n + i | 0, n = e + i | 0, (n >>> 0) / 4294967296;
  };
}
function aY(e, t, r, n, i) {
  let s = Gn(e, r, n);
  const o = [];
  for (let a of t) {
    const { type: l, readOnly: p, writeOnly: f, value: d } = Gn({ type: s.type, ...a }, r, n, i);
    s.type && l && l !== s.type && (console.warn("allOf: schemas with different types can't be merged"), s.type = l), s.type = s.type || l, s.readOnly = s.readOnly || p, s.writeOnly = s.writeOnly || f, d != null && o.push(d);
  }
  if (s.type === "object")
    return s.value = Em(s.value || {}, ...o.filter((a) => typeof a == "object")), s;
  {
    s.type === "array" && (r.quiet || console.warn('OpenAPI Sampler: found allOf with "array" type. Result may be incorrect'));
    const a = o[o.length - 1];
    return s.value = a ?? s.value, s;
  }
}
const jC = {
  multipleOf: "number",
  maximum: "number",
  exclusiveMaximum: "number",
  minimum: "number",
  exclusiveMinimum: "number",
  maxLength: "string",
  minLength: "string",
  pattern: "string",
  items: "array",
  maxItems: "array",
  minItems: "array",
  uniqueItems: "array",
  additionalItems: "array",
  maxProperties: "object",
  minProperties: "object",
  required: "object",
  additionalProperties: "object",
  properties: "object",
  patternProperties: "object",
  dependencies: "object"
};
function lc(e) {
  if (e.type !== void 0)
    return Array.isArray(e.type) ? e.type.length === 0 ? null : e.type[0] : e.type;
  const t = Object.keys(jC);
  for (var r = 0; r < t.length; r++) {
    let n = t[r], i = jC[n];
    if (e[n] !== void 0)
      return i;
  }
  return null;
}
var lY = FN();
const uY = /* @__PURE__ */ Hb(lY);
let Ch = {}, Vn = [];
function cY() {
  Ch = {}, Vn = [];
}
function qN(e) {
  let t;
  return e.const !== void 0 ? t = e.const : e.examples !== void 0 && e.examples.length ? t = e.examples[0] : e.enum !== void 0 && e.enum.length ? t = e.enum[0] : e.default !== void 0 && (t = e.default), t;
}
function NC(e) {
  const t = qN(e);
  if (t !== void 0)
    return {
      value: t,
      readOnly: e.readOnly,
      writeOnly: e.writeOnly,
      type: null
    };
}
function Gn(e, t, r, n) {
  if (n) {
    if (Vn.includes(e)) return n0(lc(e));
    Vn.push(e);
  }
  if (n && n.depth > t.maxSampleDepth)
    return Po(Vn, n), n0(lc(e));
  if (e.$ref) {
    if (!r)
      throw new Error("Your schema contains $ref. You must provide full specification in the third parameter.");
    let a = decodeURIComponent(e.$ref);
    a.startsWith("#") && (a = a.substring(1));
    const l = uY.get(r, a);
    let p;
    if (Ch[a] !== !0)
      Ch[a] = !0, p = Gn(l, t, r, n), Ch[a] = !1;
    else {
      const f = lc(l);
      p = n0(f);
    }
    return Po(Vn, n), p;
  }
  if (e.example !== void 0)
    return Po(Vn, n), {
      value: e.example,
      readOnly: e.readOnly,
      writeOnly: e.writeOnly,
      type: e.type
    };
  if (e.allOf !== void 0)
    return Po(Vn, n), NC(e) || aY(
      { ...e, allOf: void 0 },
      e.allOf,
      t,
      r,
      n
    );
  if (e.oneOf && e.oneOf.length) {
    e.anyOf && (t.quiet || console.warn("oneOf and anyOf are not supported on the same level. Skipping anyOf")), Po(Vn, n);
    const a = Object.assign({
      readOnly: e.readOnly,
      writeOnly: e.writeOnly
    }, e.oneOf[0]);
    return o(e, a);
  }
  if (e.anyOf && e.anyOf.length) {
    Po(Vn, n);
    const a = Object.assign({
      readOnly: e.readOnly,
      writeOnly: e.writeOnly
    }, e.anyOf[0]);
    return o(e, a);
  }
  if (e.if && e.then) {
    Po(Vn, n);
    const { if: a, then: l, ...p } = e;
    return Gn(Em(p, a, l), t, r, n);
  }
  let i = qN(e), s = null;
  if (i === void 0) {
    i = null, s = e.type, Array.isArray(s) && e.type.length > 0 && (s = e.type[0]), s || (s = lc(e));
    let a = IS[s];
    a && (i = a(e, t, r, n));
  }
  return Po(Vn, n), {
    value: i,
    readOnly: e.readOnly,
    writeOnly: e.writeOnly,
    type: s
  };
  function o(a, l) {
    const p = NC(a);
    if (p !== void 0)
      return p;
    const f = Gn({ ...a, oneOf: void 0, anyOf: void 0 }, t, r, n), d = Gn(l, t, r, n);
    if (typeof f.value == "object" && typeof d.value == "object") {
      const m = Em(f.value, d.value);
      return { ...d, value: m };
    }
    return d;
  }
}
function pY(e, t = {}, r, n) {
  const i = n && n.depth || 1;
  let s = Math.min(e.maxItems != null ? e.maxItems : 1 / 0, e.minItems || 1);
  const o = e.prefixItems || e.items || e.contains;
  Array.isArray(o) && (s = Math.max(s, o.length));
  let a = (p) => Array.isArray(o) ? o[p] || {} : o || {}, l = [];
  if (!o) return l;
  for (let p = 0; p < s; p++) {
    let f = a(p), { value: d } = Gn(f, t, r, { depth: i + 1 });
    l.push(d);
  }
  return l;
}
function fY(e) {
  return !0;
}
function BN(e) {
  let t = 0;
  if (e.type === "number" && (e.format === "float" || e.format === "double") && (t = 0.1), typeof e.exclusiveMinimum == "boolean" || typeof e.exclusiveMaximum == "boolean") {
    if (e.maximum && e.minimum)
      return t = e.exclusiveMinimum ? Math.floor(e.minimum) + 1 : e.minimum, (e.exclusiveMaximum && t >= e.maximum || !e.exclusiveMaximum && t > e.maximum) && (t = (e.maximum + e.minimum) / 2), t;
    if (e.minimum)
      return e.exclusiveMinimum ? Math.floor(e.minimum) + 1 : e.minimum;
    if (e.maximum)
      return e.exclusiveMaximum ? e.maximum > 0 ? 0 : Math.floor(e.maximum) - 1 : e.maximum > 0 ? 0 : e.maximum;
  } else {
    if (e.minimum)
      return e.minimum;
    e.exclusiveMinimum ? (t = Math.floor(e.exclusiveMinimum) + 1, t === e.exclusiveMaximum && (t = (t + Math.floor(e.exclusiveMaximum) - 1) / 2)) : e.exclusiveMaximum ? t = Math.floor(e.exclusiveMaximum) - 1 : e.maximum && (t = e.maximum);
  }
  return t;
}
function dY(e, t = {}, r, n) {
  let i = {};
  const s = n && n.depth || 1;
  if (e && typeof e.properties == "object") {
    const o = Array.isArray(e.required) ? e.required : [], a = {};
    for (const l of o)
      a[l] = !0;
    Object.keys(e.properties).forEach((l) => {
      if (t.skipNonRequired && !a.hasOwnProperty(l))
        return;
      const p = Gn(e.properties[l], t, r, { propertyName: l, depth: s + 1 });
      t.skipReadOnly && p.readOnly || t.skipWriteOnly && p.writeOnly || (i[l] = p.value);
    });
  }
  if (e && typeof e.additionalProperties == "object") {
    const o = e.additionalProperties["x-additionalPropertiesName"] || "property";
    i[`${String(o)}1`] = Gn(e.additionalProperties, t, r, { depth: s + 1 }).value, i[`${String(o)}2`] = Gn(e.additionalProperties, t, r, { depth: s + 1 }).value;
  }
  if (e && typeof e.properties == "object" && e.maxProperties !== void 0 && Object.keys(i).length > e.maxProperties) {
    const o = {};
    let a = 0;
    (Array.isArray(e.required) ? e.required : []).forEach((p) => {
      i[p] !== void 0 && (o[p] = i[p], a++);
    }), Object.keys(i).forEach((p) => {
      a < e.maxProperties && !o.hasOwnProperty(p) && (o[p] = i[p], a++);
    }), i = o;
  }
  return i;
}
function Ec(e, t) {
  return e;
}
function LC(e, t, r) {
  let n = 1;
  if (e)
    switch (e) {
      case "?": {
        n = 0;
        break;
      }
      case "*": {
        n = Ec(0);
        break;
      }
      case "+": {
        n = Ec(1);
        break;
      }
      default:
        throw new Error("Unknown quantifier symbol provided.");
    }
  else t != null && r != null ? n = Ec(parseInt(t)) : t != null && r == null && (n = parseInt(t));
  return n;
}
function hY(e) {
  var d;
  let t = !1;
  e instanceof RegExp && (t = e.flags.includes("i"), e = e.toString(), e = ((d = e.match(/\/(.+?)\//)) == null ? void 0 : d[1]) ?? "");
  let r, n, i;
  const s = /([.A-Za-z0-9])(?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+))(?![^[]*]|[^{]*})/;
  let o = e.match(s);
  for (; o != null; ) {
    const m = o[2], v = o[3], g = o[4];
    i = LC(
      g,
      m,
      v
    ), e = e.slice(0, o.index) + o[1].repeat(i) + e.slice(o.index + o[0].length), o = e.match(s);
  }
  const a = /(\d-\d|\w-\w|\d|\w|[-!@#$&()`.+,/"])/, l = /\[(\^|)(-|)(.+?)\](?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+)|)/;
  for (o = e.match(l); o != null; ) {
    const m = o[1] === "^", v = o[2] === "-", g = o[4], S = o[5], _ = o[6], x = [];
    let y = o[3], w = y.match(a);
    for (v && x.push(45); w != null; ) {
      if (w[0].indexOf("-") === -1)
        t && isNaN(Number(w[0])) ? (x.push(w[0].toUpperCase().charCodeAt(0)), x.push(w[0].toLowerCase().charCodeAt(0))) : x.push(w[0].charCodeAt(0));
      else {
        const A = w[0].split("-").map((T) => T.charCodeAt(0));
        if (r = A[0], n = A[1], r > n)
          throw new Error("Character range provided is out of order.");
        for (let T = r; T <= n; T++)
          if (t && isNaN(Number(String.fromCharCode(T)))) {
            const R = String.fromCharCode(T);
            x.push(R.toUpperCase().charCodeAt(0)), x.push(R.toLowerCase().charCodeAt(0));
          } else
            x.push(T);
      }
      y = y.substring(w[0].length), w = y.match(a);
    }
    if (i = LC(
      _,
      g,
      S
    ), m) {
      let A = -1;
      for (let T = 48; T <= 57; T++) {
        if (A = x.indexOf(T), A > -1) {
          x.splice(A, 1);
          continue;
        }
        x.push(T);
      }
      for (let T = 65; T <= 90; T++) {
        if (A = x.indexOf(T), A > -1) {
          x.splice(A, 1);
          continue;
        }
        x.push(T);
      }
      for (let T = 97; T <= 122; T++) {
        if (A = x.indexOf(T), A > -1) {
          x.splice(A, 1);
          continue;
        }
        x.push(T);
      }
    }
    const k = Array.from(
      { length: i },
      () => String.fromCharCode(x[Ec(0)])
    ).join("");
    e = e.slice(0, o.index) + k + e.slice(o.index + o[0].length), o = e.match(l);
  }
  const p = /(.)\{(\d+)\,(\d+)\}/;
  for (o = e.match(p); o != null; ) {
    if (r = parseInt(o[2]), n = parseInt(o[3]), r > n)
      throw new Error("Numbers out of order in {} quantifier.");
    i = Ec(r), e = e.slice(0, o.index) + o[1].repeat(i) + e.slice(o.index + o[0].length), o = e.match(p);
  }
  const f = /(.)\{(\d+)\}/;
  for (o = e.match(f); o != null; )
    i = parseInt(o[2]), e = e.slice(0, o.index) + o[1].repeat(i) + e.slice(o.index + o[0].length), o = e.match(f);
  return e;
}
const mY = "qwerty!@#$%^123456";
function gY() {
  return "user@example.com";
}
function yY() {
  return "пошта@укр.нет";
}
function vY(e, t) {
  let r = "pa$$word";
  return e > r.length && (r += "_", r += zN(mY, e - r.length).substring(0, e - r.length)), r;
}
function RS({ min: e, max: t, omitTime: r, omitDate: n }) {
  let i = nY(/* @__PURE__ */ new Date("2019-08-24T14:15:22.123Z"), r, n);
  return i.length < e && console.warn(`Using minLength = ${e} is incorrect with format "date-time"`), t && i.length > t && console.warn(`Using maxLength = ${t} is incorrect with format "date-time"`), i;
}
function bY(e, t) {
  return RS({ min: e, max: t, omitTime: !1, omitDate: !1 });
}
function wY(e, t) {
  return RS({ min: e, max: t, omitTime: !0, omitDate: !1 });
}
function SY(e, t) {
  return RS({ min: e, max: t, omitTime: !1, omitDate: !0 }).slice(1);
}
function UN(e, t, r, n, i = !1) {
  if (n && i)
    return hY(n);
  let s = zN("string", e);
  return t && s.length > t && (s = s.substring(0, t)), s;
}
function xY() {
  return "192.168.0.1";
}
function _Y() {
  return "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
}
function EY() {
  return "example.com";
}
function OY() {
  return "приклад.укр";
}
function kY() {
  return "http://example.com";
}
function AY() {
  return "../dictionary";
}
function PY() {
  return "http://example.com/{endpoint}";
}
function CY() {
  return "http://example.com/entity/1";
}
function TY() {
  return "/entity/1";
}
function $Y(e, t, r) {
  return iY(r || "id");
}
function RY() {
  return "/json/pointer";
}
function IY() {
  return "1/relative/json/pointer";
}
function jY() {
  return "/regex/";
}
const NY = {
  email: gY,
  "idn-email": yY,
  // https://tools.ietf.org/html/rfc6531#section-3.3
  password: vY,
  "date-time": bY,
  date: wY,
  time: SY,
  // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
  ipv4: xY,
  ipv6: _Y,
  hostname: EY,
  "idn-hostname": OY,
  // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
  iri: CY,
  // https://tools.ietf.org/html/rfc3987
  "iri-reference": TY,
  uri: kY,
  "uri-reference": AY,
  // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
  "uri-template": PY,
  uuid: $Y,
  default: UN,
  "json-pointer": RY,
  "relative-json-pointer": IY,
  // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
  regex: jY
};
function LY(e, t, r, n) {
  let i = e.format || "default", s = NY[i] || UN, o = n && n.propertyName;
  return s(
    e.minLength || 0,
    e.maxLength,
    o,
    e.pattern,
    t == null ? void 0 : t.enablePatterns
  );
}
var IS = {};
const MY = {
  skipReadOnly: !1,
  maxSampleDepth: 15
};
function DY(e, t, r) {
  let n = Object.assign({}, MY, t);
  return cY(), Gn(e, n, r).value;
}
function fa(e, t) {
  IS[e] = t;
}
fa("array", pY);
fa("boolean", fY);
fa("integer", BN);
fa("number", BN);
fa("object", dY);
fa("string", LY);
const FY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _registerSampler: fa,
  _samplers: IS,
  inferType: lc,
  sample: DY
}, Symbol.toStringTag, { value: "Module" })), zY = /* @__PURE__ */ Ri(FY);
FI();
function jS(e) {
  return (t) => !!t.type && t.type.tabsRole === e;
}
const Sg = jS("Tab"), NS = jS("TabList"), LS = jS("TabPanel");
function qY(e) {
  return Sg(e) || NS(e) || LS(e);
}
function Ub(e, t) {
  return et.Children.map(e, (r) => r === null ? null : qY(r) ? t(r) : r.props && r.props.children && typeof r.props.children == "object" ? et.cloneElement(r, { ...r.props, children: Ub(r.props.children, t) }) : r);
}
function VN(e, t) {
  return et.Children.forEach(e, (r) => {
    r !== null && (Sg(r) || LS(r) ? t(r) : r.props && r.props.children && typeof r.props.children == "object" && (NS(r) && t(r), VN(r.props.children, t)));
  });
}
function WN(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = WN(e[t])) && (n && (n += " "), n += r);
  } else for (r in e) e[r] && (n && (n += " "), n += r);
  return n;
}
function xg() {
  for (var e, t, r = 0, n = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = WN(e)) && (n && (n += " "), n += t);
  return n;
}
function HN(e) {
  let t = 0;
  return VN(e, (r) => {
    Sg(r) && t++;
  }), t;
}
function QN(e) {
  return e && "getAttribute" in e;
}
function MC(e) {
  return QN(e) && e.getAttribute("data-rttab");
}
function Ns(e) {
  return QN(e) && e.getAttribute("aria-disabled") === "true";
}
let Om;
function BY(e) {
  const t = e || (typeof window < "u" ? window : void 0);
  try {
    Om = !!(typeof t < "u" && t.document && t.document.activeElement);
  } catch {
    Om = !1;
  }
}
const UY = { className: "react-tabs", focus: !1 }, YN = (e) => {
  let t = et.useRef([]), r = et.useRef([]);
  const n = et.useRef();
  function i(re, oe) {
    if (re < 0 || re >= p()) return;
    const { onSelect: ce, selectedIndex: pe } = e;
    ce(re, pe, oe);
  }
  function s(re) {
    const oe = p();
    for (let ce = re + 1; ce < oe; ce++)
      if (!Ns(f(ce)))
        return ce;
    for (let ce = 0; ce < re; ce++)
      if (!Ns(f(ce)))
        return ce;
    return re;
  }
  function o(re) {
    let oe = re;
    for (; oe--; )
      if (!Ns(f(oe)))
        return oe;
    for (oe = p(); oe-- > re; )
      if (!Ns(f(oe)))
        return oe;
    return re;
  }
  function a() {
    const re = p();
    for (let oe = 0; oe < re; oe++)
      if (!Ns(f(oe)))
        return oe;
    return null;
  }
  function l() {
    let re = p();
    for (; re--; )
      if (!Ns(f(re)))
        return re;
    return null;
  }
  function p() {
    const { children: re } = e;
    return HN(re);
  }
  function f(re) {
    return t.current[`tabs-${re}`];
  }
  function d() {
    let re = 0;
    const { children: oe, disabledTabClassName: ce, focus: pe, forceRenderTabPanel: fe, selectedIndex: G, selectedTabClassName: Z, selectedTabPanelClassName: K, environment: z } = e;
    r.current = r.current || [];
    let te = r.current.length - p();
    const q = et.useId();
    for (; te++ < 0; )
      r.current.push(`${q}${r.current.length}`);
    return Ub(oe, (j) => {
      let H = j;
      if (NS(j)) {
        let F = 0, ue = !1;
        Om == null && BY(z);
        const ge = z || (typeof window < "u" ? window : void 0);
        Om && ge && (ue = at.Children.toArray(j.props.children).filter(Sg).some((Ae, C) => ge.document.activeElement === f(C))), H = et.cloneElement(j, { children: Ub(j.props.children, (Ae) => {
          const C = `tabs-${F}`, N = G === F, J = { tabRef: (X) => {
            t.current[C] = X;
          }, id: r.current[F], selected: N, focus: N && (pe || ue) };
          return Z && (J.selectedClassName = Z), ce && (J.disabledClassName = ce), F++, et.cloneElement(Ae, J);
        }) });
      } else if (LS(j)) {
        const F = { id: r.current[re], selected: G === re };
        fe && (F.forceRender = fe), K && (F.selectedClassName = K), re++, H = et.cloneElement(j, F);
      }
      return H;
    });
  }
  function m(re) {
    const { direction: oe, disableUpDownKeys: ce, disableLeftRightKeys: pe } = e;
    if (g(re.target)) {
      let { selectedIndex: fe } = e, G = !1, Z = !1;
      (re.code === "Space" || re.keyCode === 32 || re.code === "Enter" || re.keyCode === 13) && (G = !0, Z = !1, v(re)), !pe && (re.keyCode === 37 || re.code === "ArrowLeft") || !ce && (re.keyCode === 38 || re.code === "ArrowUp") ? (oe === "rtl" ? fe = s(fe) : fe = o(fe), G = !0, Z = !0) : !pe && (re.keyCode === 39 || re.code === "ArrowRight") || !ce && (re.keyCode === 40 || re.code === "ArrowDown") ? (oe === "rtl" ? fe = o(fe) : fe = s(fe), G = !0, Z = !0) : re.keyCode === 35 || re.code === "End" ? (fe = l(), G = !0, Z = !0) : (re.keyCode === 36 || re.code === "Home") && (fe = a(), G = !0, Z = !0), G && re.preventDefault(), Z && i(fe, re);
    }
  }
  function v(re) {
    let oe = re.target;
    do
      if (g(oe)) {
        if (Ns(oe))
          return;
        const ce = [].slice.call(oe.parentNode.children).filter(MC).indexOf(oe);
        i(ce, re);
        return;
      }
    while ((oe = oe.parentNode) != null);
  }
  function g(re) {
    if (!MC(re))
      return !1;
    let oe = re.parentElement;
    do {
      if (oe === n.current) return !0;
      if (oe.getAttribute("data-rttabs")) break;
      oe = oe.parentElement;
    } while (oe);
    return !1;
  }
  const { children: S, className: _, disabledTabClassName: x, domRef: y, focus: w, forceRenderTabPanel: k, onSelect: A, selectedIndex: T, selectedTabClassName: R, selectedTabPanelClassName: I, environment: B, disableUpDownKeys: L, disableLeftRightKeys: Y, ...Q } = { ...UY, ...e };
  return at.createElement("div", Object.assign({}, Q, { className: xg(_), onClick: v, onKeyDown: m, ref: (re) => {
    n.current = re, y && y(re);
  }, "data-rttabs": !0 }), d());
};
YN.propTypes = {};
const VY = 0, Th = 1, WY = { defaultFocus: !1, focusTabOnClick: !0, forceRenderTabPanel: !1, selectedIndex: null, defaultIndex: null, environment: null, disableUpDownKeys: !1, disableLeftRightKeys: !1 }, HY = (e) => e.selectedIndex === null ? Th : VY, MS = (e) => {
  const { children: t, defaultFocus: r, defaultIndex: n, focusTabOnClick: i, onSelect: s, ...o } = { ...WY, ...e }, [a, l] = et.useState(r), [p] = et.useState(HY(o)), [f, d] = et.useState(p === Th ? n || 0 : null);
  if (et.useEffect(() => {
    l(!1);
  }, []), p === Th) {
    const g = HN(t);
    et.useEffect(() => {
      if (f != null) {
        const S = Math.max(0, g - 1);
        d(Math.min(f, S));
      }
    }, [g]);
  }
  const m = (g, S, _) => {
    typeof s == "function" && s(g, S, _) === !1 || (i && l(!0), p === Th && d(g));
  };
  let v = { ...e, ...o };
  return v.focus = a, v.onSelect = m, f != null && (v.selectedIndex = f), delete v.defaultFocus, delete v.defaultIndex, delete v.focusTabOnClick, at.createElement(YN, v, t);
};
MS.propTypes = {};
MS.tabsRole = "Tabs";
const QY = { className: "react-tabs__tab-list" }, DS = (e) => {
  const { children: t, className: r, ...n } = { ...QY, ...e };
  return at.createElement("ul", Object.assign({}, n, { className: xg(r), role: "tablist" }), t);
};
DS.tabsRole = "TabList";
DS.propTypes = {};
const i0 = "react-tabs__tab", YY = { className: i0, disabledClassName: `${i0}--disabled`, focus: !1, id: null, selected: !1, selectedClassName: `${i0}--selected` }, FS = (e) => {
  let t = et.useRef();
  const { children: r, className: n, disabled: i, disabledClassName: s, focus: o, id: a, selected: l, selectedClassName: p, tabIndex: f, tabRef: d, ...m } = { ...YY, ...e };
  return et.useEffect(() => {
    l && o && t.current.focus();
  }, [l, o]), at.createElement("li", Object.assign({}, m, { className: xg(n, { [p]: l, [s]: i }), ref: (v) => {
    t.current = v, d && d(v);
  }, role: "tab", id: `tab${a}`, "aria-selected": l ? "true" : "false", "aria-disabled": i ? "true" : "false", "aria-controls": `panel${a}`, tabIndex: f || (l ? "0" : null), "data-rttab": !0 }), r);
};
FS.propTypes = {};
FS.tabsRole = "Tab";
const DC = "react-tabs__tab-panel", GY = { className: DC, forceRender: !1, selectedClassName: `${DC}--selected` }, zS = (e) => {
  const { children: t, className: r, forceRender: n, id: i, selected: s, selectedClassName: o, ...a } = { ...GY, ...e };
  return at.createElement("div", Object.assign({}, a, { className: xg(r, { [o]: s }), role: "tabpanel", id: `panel${i}`, "aria-labelledby": `tab${i}` }), n || s ? t : null);
};
zS.tabsRole = "TabPanel";
zS.propTypes = {};
const KY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Tab: FS,
  TabList: DS,
  TabPanel: zS,
  Tabs: MS
}, Symbol.toStringTag, { value: "Module" })), XY = /* @__PURE__ */ Ri(KY);
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function Oi(e) {
  return getComputedStyle(e);
}
function Yr(e, t) {
  for (var r in t) {
    var n = t[r];
    typeof n == "number" && (n = n + "px"), e.style[r] = n;
  }
  return e;
}
function ih(e) {
  var t = document.createElement("div");
  return t.className = e, t;
}
var FC = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Fo(e, t) {
  if (!FC)
    throw new Error("No element matching method supported");
  return FC.call(e, t);
}
function pl(e) {
  e.remove ? e.remove() : e.parentNode && e.parentNode.removeChild(e);
}
function zC(e, t) {
  return Array.prototype.filter.call(
    e.children,
    function(r) {
      return Fo(r, t);
    }
  );
}
var rr = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(e) {
      return "ps__thumb-" + e;
    },
    rail: function(e) {
      return "ps__rail-" + e;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(e) {
      return "ps--active-" + e;
    },
    scrolling: function(e) {
      return "ps--scrolling-" + e;
    }
  }
}, GN = { x: null, y: null };
function KN(e, t) {
  var r = e.element.classList, n = rr.state.scrolling(t);
  r.contains(n) ? clearTimeout(GN[t]) : r.add(n);
}
function XN(e, t) {
  GN[t] = setTimeout(
    function() {
      return e.isAlive && e.element.classList.remove(rr.state.scrolling(t));
    },
    e.settings.scrollingThreshold
  );
}
function JY(e, t) {
  KN(e, t), XN(e, t);
}
var wp = function(t) {
  this.element = t, this.handlers = {};
}, JN = { isEmpty: { configurable: !0 } };
wp.prototype.bind = function(t, r) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(r), this.element.addEventListener(t, r, !1);
};
wp.prototype.unbind = function(t, r) {
  var n = this;
  this.handlers[t] = this.handlers[t].filter(function(i) {
    return r && i !== r ? !0 : (n.element.removeEventListener(t, i, !1), !1);
  });
};
wp.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
JN.isEmpty.get = function() {
  var e = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return e.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(wp.prototype, JN);
var Xl = function() {
  this.eventElements = [];
};
Xl.prototype.eventElement = function(t) {
  var r = this.eventElements.filter(function(n) {
    return n.element === t;
  })[0];
  return r || (r = new wp(t), this.eventElements.push(r)), r;
};
Xl.prototype.bind = function(t, r, n) {
  this.eventElement(t).bind(r, n);
};
Xl.prototype.unbind = function(t, r, n) {
  var i = this.eventElement(t);
  i.unbind(r, n), i.isEmpty && this.eventElements.splice(this.eventElements.indexOf(i), 1);
};
Xl.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
Xl.prototype.once = function(t, r, n) {
  var i = this.eventElement(t), s = function(o) {
    i.unbind(r, s), n(o);
  };
  i.bind(r, s);
};
function oh(e) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(e);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(e, !1, !1, void 0), t;
}
function km(e, t, r, n, i) {
  n === void 0 && (n = !0), i === void 0 && (i = !1);
  var s;
  if (t === "top")
    s = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    s = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  ZY(e, r, s, n, i);
}
function ZY(e, t, r, n, i) {
  var s = r[0], o = r[1], a = r[2], l = r[3], p = r[4], f = r[5];
  n === void 0 && (n = !0), i === void 0 && (i = !1);
  var d = e.element;
  e.reach[l] = null, d[a] < 1 && (e.reach[l] = "start"), d[a] > e[s] - e[o] - 1 && (e.reach[l] = "end"), t && (d.dispatchEvent(oh("ps-scroll-" + l)), t < 0 ? d.dispatchEvent(oh("ps-scroll-" + p)) : t > 0 && d.dispatchEvent(oh("ps-scroll-" + f)), n && JY(e, l)), e.reach[l] && (t || i) && d.dispatchEvent(oh("ps-" + l + "-reach-" + e.reach[l]));
}
function zt(e) {
  return parseInt(e, 10) || 0;
}
function eG(e) {
  return Fo(e, "input,[contenteditable]") || Fo(e, "select,[contenteditable]") || Fo(e, "textarea,[contenteditable]") || Fo(e, "button,[contenteditable]");
}
function tG(e) {
  var t = Oi(e);
  return zt(t.width) + zt(t.paddingLeft) + zt(t.paddingRight) + zt(t.borderLeftWidth) + zt(t.borderRightWidth);
}
var Ya = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function yo(e) {
  var t = e.element, r = Math.floor(t.scrollTop), n = t.getBoundingClientRect();
  e.containerWidth = Math.round(n.width), e.containerHeight = Math.round(n.height), e.contentWidth = t.scrollWidth, e.contentHeight = t.scrollHeight, t.contains(e.scrollbarXRail) || (zC(t, rr.element.rail("x")).forEach(
    function(i) {
      return pl(i);
    }
  ), t.appendChild(e.scrollbarXRail)), t.contains(e.scrollbarYRail) || (zC(t, rr.element.rail("y")).forEach(
    function(i) {
      return pl(i);
    }
  ), t.appendChild(e.scrollbarYRail)), !e.settings.suppressScrollX && e.containerWidth + e.settings.scrollXMarginOffset < e.contentWidth ? (e.scrollbarXActive = !0, e.railXWidth = e.containerWidth - e.railXMarginWidth, e.railXRatio = e.containerWidth / e.railXWidth, e.scrollbarXWidth = qC(
    e,
    zt(e.railXWidth * e.containerWidth / e.contentWidth)
  ), e.scrollbarXLeft = zt(
    (e.negativeScrollAdjustment + t.scrollLeft) * (e.railXWidth - e.scrollbarXWidth) / (e.contentWidth - e.containerWidth)
  )) : e.scrollbarXActive = !1, !e.settings.suppressScrollY && e.containerHeight + e.settings.scrollYMarginOffset < e.contentHeight ? (e.scrollbarYActive = !0, e.railYHeight = e.containerHeight - e.railYMarginHeight, e.railYRatio = e.containerHeight / e.railYHeight, e.scrollbarYHeight = qC(
    e,
    zt(e.railYHeight * e.containerHeight / e.contentHeight)
  ), e.scrollbarYTop = zt(
    r * (e.railYHeight - e.scrollbarYHeight) / (e.contentHeight - e.containerHeight)
  )) : e.scrollbarYActive = !1, e.scrollbarXLeft >= e.railXWidth - e.scrollbarXWidth && (e.scrollbarXLeft = e.railXWidth - e.scrollbarXWidth), e.scrollbarYTop >= e.railYHeight - e.scrollbarYHeight && (e.scrollbarYTop = e.railYHeight - e.scrollbarYHeight), rG(t, e), e.scrollbarXActive ? t.classList.add(rr.state.active("x")) : (t.classList.remove(rr.state.active("x")), e.scrollbarXWidth = 0, e.scrollbarXLeft = 0, t.scrollLeft = e.isRtl === !0 ? e.contentWidth : 0), e.scrollbarYActive ? t.classList.add(rr.state.active("y")) : (t.classList.remove(rr.state.active("y")), e.scrollbarYHeight = 0, e.scrollbarYTop = 0, t.scrollTop = 0);
}
function qC(e, t) {
  return e.settings.minScrollbarLength && (t = Math.max(t, e.settings.minScrollbarLength)), e.settings.maxScrollbarLength && (t = Math.min(t, e.settings.maxScrollbarLength)), t;
}
function rG(e, t) {
  var r = { width: t.railXWidth }, n = Math.floor(e.scrollTop);
  t.isRtl ? r.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth - t.contentWidth : r.left = e.scrollLeft, t.isScrollbarXUsingBottom ? r.bottom = t.scrollbarXBottom - n : r.top = t.scrollbarXTop + n, Yr(t.scrollbarXRail, r);
  var i = { top: n, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? i.right = t.contentWidth - (t.negativeScrollAdjustment + e.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : i.right = t.scrollbarYRight - e.scrollLeft : t.isRtl ? i.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : i.left = t.scrollbarYLeft + e.scrollLeft, Yr(t.scrollbarYRail, i), Yr(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), Yr(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function nG(e) {
  e.element, e.event.bind(e.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarYRail, "mousedown", function(t) {
    var r = t.pageY - window.pageYOffset - e.scrollbarYRail.getBoundingClientRect().top, n = r > e.scrollbarYTop ? 1 : -1;
    e.element.scrollTop += n * e.containerHeight, yo(e), t.stopPropagation();
  }), e.event.bind(e.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarXRail, "mousedown", function(t) {
    var r = t.pageX - window.pageXOffset - e.scrollbarXRail.getBoundingClientRect().left, n = r > e.scrollbarXLeft ? 1 : -1;
    e.element.scrollLeft += n * e.containerWidth, yo(e), t.stopPropagation();
  });
}
function iG(e) {
  BC(e, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), BC(e, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function BC(e, t) {
  var r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], p = t[7], f = t[8], d = e.element, m = null, v = null, g = null;
  function S(y) {
    y.touches && y.touches[0] && (y[i] = y.touches[0].pageY), d[l] = m + g * (y[i] - v), KN(e, p), yo(e), y.stopPropagation(), y.type.startsWith("touch") && y.changedTouches.length > 1 && y.preventDefault();
  }
  function _() {
    XN(e, p), e[f].classList.remove(rr.state.clicking), e.event.unbind(e.ownerDocument, "mousemove", S);
  }
  function x(y, w) {
    m = d[l], w && y.touches && (y[i] = y.touches[0].pageY), v = y[i], g = (e[n] - e[r]) / (e[s] - e[a]), w ? e.event.bind(e.ownerDocument, "touchmove", S) : (e.event.bind(e.ownerDocument, "mousemove", S), e.event.once(e.ownerDocument, "mouseup", _), y.preventDefault()), e[f].classList.add(rr.state.clicking), y.stopPropagation();
  }
  e.event.bind(e[o], "mousedown", function(y) {
    x(y);
  }), e.event.bind(e[o], "touchstart", function(y) {
    x(y, !0);
  });
}
function oG(e) {
  var t = e.element, r = function() {
    return Fo(t, ":hover");
  }, n = function() {
    return Fo(e.scrollbarX, ":focus") || Fo(e.scrollbarY, ":focus");
  };
  function i(s, o) {
    var a = Math.floor(t.scrollTop);
    if (s === 0) {
      if (!e.scrollbarYActive)
        return !1;
      if (a === 0 && o > 0 || a >= e.contentHeight - e.containerHeight && o < 0)
        return !e.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (o === 0) {
      if (!e.scrollbarXActive)
        return !1;
      if (l === 0 && s < 0 || l >= e.contentWidth - e.containerWidth && s > 0)
        return !e.settings.wheelPropagation;
    }
    return !0;
  }
  e.event.bind(e.ownerDocument, "keydown", function(s) {
    if (!(s.isDefaultPrevented && s.isDefaultPrevented() || s.defaultPrevented) && !(!r() && !n())) {
      var o = document.activeElement ? document.activeElement : e.ownerDocument.activeElement;
      if (o) {
        if (o.tagName === "IFRAME")
          o = o.contentDocument.activeElement;
        else
          for (; o.shadowRoot; )
            o = o.shadowRoot.activeElement;
        if (eG(o))
          return;
      }
      var a = 0, l = 0;
      switch (s.which) {
        case 37:
          s.metaKey ? a = -e.contentWidth : s.altKey ? a = -e.containerWidth : a = -30;
          break;
        case 38:
          s.metaKey ? l = e.contentHeight : s.altKey ? l = e.containerHeight : l = 30;
          break;
        case 39:
          s.metaKey ? a = e.contentWidth : s.altKey ? a = e.containerWidth : a = 30;
          break;
        case 40:
          s.metaKey ? l = -e.contentHeight : s.altKey ? l = -e.containerHeight : l = -30;
          break;
        case 32:
          s.shiftKey ? l = e.containerHeight : l = -e.containerHeight;
          break;
        case 33:
          l = e.containerHeight;
          break;
        case 34:
          l = -e.containerHeight;
          break;
        case 36:
          l = e.contentHeight;
          break;
        case 35:
          l = -e.contentHeight;
          break;
        default:
          return;
      }
      e.settings.suppressScrollX && a !== 0 || e.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, yo(e), i(a, l) && s.preventDefault());
    }
  });
}
function sG(e) {
  var t = e.element;
  function r(o, a) {
    var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, f = l + t.offsetHeight === t.scrollHeight, d = t.scrollLeft === 0, m = t.scrollLeft + t.offsetWidth === t.scrollWidth, v;
    return Math.abs(a) > Math.abs(o) ? v = p || f : v = d || m, v ? !e.settings.wheelPropagation : !0;
  }
  function n(o) {
    var a = o.deltaX, l = -1 * o.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * o.wheelDeltaX / 6, l = o.wheelDeltaY / 6), o.deltaMode && o.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = o.wheelDelta), o.shiftKey ? [-l, -a] : [a, l];
  }
  function i(o, a, l) {
    if (!Ya.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(o))
      return !1;
    for (var p = o; p && p !== t; ) {
      if (p.classList.contains(rr.element.consuming))
        return !0;
      var f = Oi(p);
      if (l && f.overflowY.match(/(scroll|auto)/)) {
        var d = p.scrollHeight - p.clientHeight;
        if (d > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < d && l > 0))
          return !0;
      }
      if (a && f.overflowX.match(/(scroll|auto)/)) {
        var m = p.scrollWidth - p.clientWidth;
        if (m > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < m && a > 0))
          return !0;
      }
      p = p.parentNode;
    }
    return !1;
  }
  function s(o) {
    var a = n(o), l = a[0], p = a[1];
    if (!i(o.target, l, p)) {
      var f = !1;
      e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (p ? t.scrollTop -= p * e.settings.wheelSpeed : t.scrollTop += l * e.settings.wheelSpeed, f = !0) : e.scrollbarXActive && !e.scrollbarYActive && (l ? t.scrollLeft += l * e.settings.wheelSpeed : t.scrollLeft -= p * e.settings.wheelSpeed, f = !0) : (t.scrollTop -= p * e.settings.wheelSpeed, t.scrollLeft += l * e.settings.wheelSpeed), yo(e), f = f || r(l, p), f && !o.ctrlKey && (o.stopPropagation(), o.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? e.event.bind(t, "wheel", s) : typeof window.onmousewheel < "u" && e.event.bind(t, "mousewheel", s);
}
function aG(e) {
  if (!Ya.supportsTouch && !Ya.supportsIePointer)
    return;
  var t = e.element;
  function r(g, S) {
    var _ = Math.floor(t.scrollTop), x = t.scrollLeft, y = Math.abs(g), w = Math.abs(S);
    if (w > y) {
      if (S < 0 && _ === e.contentHeight - e.containerHeight || S > 0 && _ === 0)
        return window.scrollY === 0 && S > 0 && Ya.isChrome;
    } else if (y > w && (g < 0 && x === e.contentWidth - e.containerWidth || g > 0 && x === 0))
      return !0;
    return !0;
  }
  function n(g, S) {
    t.scrollTop -= S, t.scrollLeft -= g, yo(e);
  }
  var i = {}, s = 0, o = {}, a = null;
  function l(g) {
    return g.targetTouches ? g.targetTouches[0] : g;
  }
  function p(g) {
    return g.pointerType && g.pointerType === "pen" && g.buttons === 0 ? !1 : !!(g.targetTouches && g.targetTouches.length === 1 || g.pointerType && g.pointerType !== "mouse" && g.pointerType !== g.MSPOINTER_TYPE_MOUSE);
  }
  function f(g) {
    if (p(g)) {
      var S = l(g);
      i.pageX = S.pageX, i.pageY = S.pageY, s = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
    }
  }
  function d(g, S, _) {
    if (!t.contains(g))
      return !1;
    for (var x = g; x && x !== t; ) {
      if (x.classList.contains(rr.element.consuming))
        return !0;
      var y = Oi(x);
      if (_ && y.overflowY.match(/(scroll|auto)/)) {
        var w = x.scrollHeight - x.clientHeight;
        if (w > 0 && (x.scrollTop > 0 && _ < 0 || x.scrollTop < w && _ > 0))
          return !0;
      }
      if (S && y.overflowX.match(/(scroll|auto)/)) {
        var k = x.scrollWidth - x.clientWidth;
        if (k > 0 && (x.scrollLeft > 0 && S < 0 || x.scrollLeft < k && S > 0))
          return !0;
      }
      x = x.parentNode;
    }
    return !1;
  }
  function m(g) {
    if (p(g)) {
      var S = l(g), _ = { pageX: S.pageX, pageY: S.pageY }, x = _.pageX - i.pageX, y = _.pageY - i.pageY;
      if (d(g.target, x, y))
        return;
      n(x, y), i = _;
      var w = (/* @__PURE__ */ new Date()).getTime(), k = w - s;
      k > 0 && (o.x = x / k, o.y = y / k, s = w), r(x, y) && g.preventDefault();
    }
  }
  function v() {
    e.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
      if (e.isInitialized) {
        clearInterval(a);
        return;
      }
      if (!o.x && !o.y) {
        clearInterval(a);
        return;
      }
      if (Math.abs(o.x) < 0.01 && Math.abs(o.y) < 0.01) {
        clearInterval(a);
        return;
      }
      if (!e.element) {
        clearInterval(a);
        return;
      }
      n(o.x * 30, o.y * 30), o.x *= 0.8, o.y *= 0.8;
    }, 10));
  }
  Ya.supportsTouch ? (e.event.bind(t, "touchstart", f), e.event.bind(t, "touchmove", m), e.event.bind(t, "touchend", v)) : Ya.supportsIePointer && (window.PointerEvent ? (e.event.bind(t, "pointerdown", f), e.event.bind(t, "pointermove", m), e.event.bind(t, "pointerup", v)) : window.MSPointerEvent && (e.event.bind(t, "MSPointerDown", f), e.event.bind(t, "MSPointerMove", m), e.event.bind(t, "MSPointerUp", v)));
}
var lG = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, uG = {
  "click-rail": nG,
  "drag-thumb": iG,
  keyboard: oG,
  wheel: sG,
  touch: aG
}, Sp = function(t, r) {
  var n = this;
  if (r === void 0 && (r = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(rr.main), this.settings = lG();
  for (var i in r)
    this.settings[i] = r[i];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var s = function() {
    return t.classList.add(rr.state.focus);
  }, o = function() {
    return t.classList.remove(rr.state.focus);
  };
  this.isRtl = Oi(t).direction === "rtl", this.isRtl === !0 && t.classList.add(rr.rtl), this.isNegativeScroll = function() {
    var p = t.scrollLeft, f = null;
    return t.scrollLeft = -1, f = t.scrollLeft < 0, t.scrollLeft = p, f;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new Xl(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = ih(rr.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = ih(rr.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", s), this.event.bind(this.scrollbarX, "blur", o), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = Oi(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = zt(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = zt(a.borderLeftWidth) + zt(a.borderRightWidth), Yr(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = zt(a.marginLeft) + zt(a.marginRight), Yr(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = ih(rr.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = ih(rr.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", s), this.event.bind(this.scrollbarY, "blur", o), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = Oi(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = zt(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? tG(this.scrollbarY) : null, this.railBorderYWidth = zt(l.borderTopWidth) + zt(l.borderBottomWidth), Yr(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = zt(l.marginTop) + zt(l.marginBottom), Yr(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(p) {
    return uG[p](n);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(p) {
    return n.onScroll(p);
  }), yo(this);
};
Sp.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, Yr(this.scrollbarXRail, { display: "block" }), Yr(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = zt(Oi(this.scrollbarXRail).marginLeft) + zt(Oi(this.scrollbarXRail).marginRight), this.railYMarginHeight = zt(Oi(this.scrollbarYRail).marginTop) + zt(Oi(this.scrollbarYRail).marginBottom), Yr(this.scrollbarXRail, { display: "none" }), Yr(this.scrollbarYRail, { display: "none" }), yo(this), km(this, "top", 0, !1, !0), km(this, "left", 0, !1, !0), Yr(this.scrollbarXRail, { display: "" }), Yr(this.scrollbarYRail, { display: "" }));
};
Sp.prototype.onScroll = function(t) {
  this.isAlive && (yo(this), km(this, "top", this.element.scrollTop - this.lastScrollTop), km(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Sp.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), pl(this.scrollbarX), pl(this.scrollbarY), pl(this.scrollbarXRail), pl(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Sp.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const cG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Sp
}, Symbol.toStringTag, { value: "Module" })), pG = /* @__PURE__ */ Ri(cG);
var o0 = { exports: {} };
/*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
var UC;
function fG() {
  return UC || (UC = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(pn, function() {
      const {
        entries: r,
        setPrototypeOf: n,
        isFrozen: i,
        getPrototypeOf: s,
        getOwnPropertyDescriptor: o
      } = Object;
      let {
        freeze: a,
        seal: l,
        create: p
      } = Object, {
        apply: f,
        construct: d
      } = typeof Reflect < "u" && Reflect;
      a || (a = function(M) {
        return M;
      }), l || (l = function(M) {
        return M;
      }), f || (f = function(M, le, ye) {
        return M.apply(le, ye);
      }), d || (d = function(M, le) {
        return new M(...le);
      });
      const m = I(Array.prototype.forEach), v = I(Array.prototype.pop), g = I(Array.prototype.push), S = I(String.prototype.toLowerCase), _ = I(String.prototype.toString), x = I(String.prototype.match), y = I(String.prototype.replace), w = I(String.prototype.indexOf), k = I(String.prototype.trim), A = I(Object.prototype.hasOwnProperty), T = I(RegExp.prototype.test), R = B(TypeError);
      function I(O) {
        return function(M) {
          for (var le = arguments.length, ye = new Array(le > 1 ? le - 1 : 0), be = 1; be < le; be++)
            ye[be - 1] = arguments[be];
          return f(O, M, ye);
        };
      }
      function B(O) {
        return function() {
          for (var M = arguments.length, le = new Array(M), ye = 0; ye < M; ye++)
            le[ye] = arguments[ye];
          return d(O, le);
        };
      }
      function L(O, M) {
        let le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S;
        n && n(O, null);
        let ye = M.length;
        for (; ye--; ) {
          let be = M[ye];
          if (typeof be == "string") {
            const Pe = le(be);
            Pe !== be && (i(M) || (M[ye] = Pe), be = Pe);
          }
          O[be] = !0;
        }
        return O;
      }
      function Y(O) {
        for (let M = 0; M < O.length; M++)
          A(O, M) || (O[M] = null);
        return O;
      }
      function Q(O) {
        const M = p(null);
        for (const [le, ye] of r(O))
          A(O, le) && (Array.isArray(ye) ? M[le] = Y(ye) : ye && typeof ye == "object" && ye.constructor === Object ? M[le] = Q(ye) : M[le] = ye);
        return M;
      }
      function re(O, M) {
        for (; O !== null; ) {
          const ye = o(O, M);
          if (ye) {
            if (ye.get)
              return I(ye.get);
            if (typeof ye.value == "function")
              return I(ye.value);
          }
          O = s(O);
        }
        function le() {
          return null;
        }
        return le;
      }
      const oe = a(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), ce = a(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), pe = a(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), fe = a(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), G = a(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Z = a(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), K = a(["#text"]), z = a(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), te = a(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), q = a(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), j = a(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), H = l(/\{\{[\w\W]*|[\w\W]*\}\}/gm), F = l(/<%[\w\W]*|[\w\W]*%>/gm), ue = l(/\${[\w\W]*}/gm), ge = l(/^data-[\-\w.\u00B7-\uFFFF]/), Ae = l(/^aria-[\-\w]+$/), C = l(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      ), N = l(/^(?:\w+script|data):/i), J = l(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      ), X = l(/^html$/i), ae = l(/^[a-z][.\w]*(-[.\w]+)+$/i);
      var U = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MUSTACHE_EXPR: H,
        ERB_EXPR: F,
        TMPLIT_EXPR: ue,
        DATA_ATTR: ge,
        ARIA_ATTR: Ae,
        IS_ALLOWED_URI: C,
        IS_SCRIPT_OR_DATA: N,
        ATTR_WHITESPACE: J,
        DOCTYPE_NAME: X,
        CUSTOM_ELEMENT: ae
      });
      const W = {
        element: 1,
        attribute: 2,
        text: 3,
        cdataSection: 4,
        entityReference: 5,
        // Deprecated
        entityNode: 6,
        // Deprecated
        progressingInstruction: 7,
        comment: 8,
        document: 9,
        documentType: 10,
        documentFragment: 11,
        notation: 12
        // Deprecated
      }, ve = function() {
        return typeof window > "u" ? null : window;
      }, he = function(M, le) {
        if (typeof M != "object" || typeof M.createPolicy != "function")
          return null;
        let ye = null;
        const be = "data-tt-policy-suffix";
        le && le.hasAttribute(be) && (ye = le.getAttribute(be));
        const Pe = "dompurify" + (ye ? "#" + ye : "");
        try {
          return M.createPolicy(Pe, {
            createHTML(ke) {
              return ke;
            },
            createScriptURL(ke) {
              return ke;
            }
          });
        } catch {
          return console.warn("TrustedTypes policy " + Pe + " could not be created."), null;
        }
      };
      function Te() {
        let O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ve();
        const M = (He) => Te(He);
        if (M.version = "3.1.7", M.removed = [], !O || !O.document || O.document.nodeType !== W.document)
          return M.isSupported = !1, M;
        let {
          document: le
        } = O;
        const ye = le, be = ye.currentScript, {
          DocumentFragment: Pe,
          HTMLTemplateElement: ke,
          Node: Me,
          Element: We,
          NodeFilter: Xe,
          NamedNodeMap: Ge = O.NamedNodeMap || O.MozNamedAttrMap,
          HTMLFormElement: Ue,
          DOMParser: Et,
          trustedTypes: D
        } = O, we = We.prototype, Oe = re(we, "cloneNode"), Ee = re(we, "remove"), Ce = re(we, "nextSibling"), $e = re(we, "childNodes"), Fe = re(we, "parentNode");
        if (typeof ke == "function") {
          const He = le.createElement("template");
          He.content && He.content.ownerDocument && (le = He.content.ownerDocument);
        }
        let xe, Le = "";
        const {
          implementation: Ye,
          createNodeIterator: mt,
          createDocumentFragment: rt,
          getElementsByTagName: ut
        } = le, {
          importNode: gt
        } = ye;
        let Jt = {};
        M.isSupported = typeof r == "function" && typeof Fe == "function" && Ye && Ye.createHTMLDocument !== void 0;
        const {
          MUSTACHE_EXPR: Fn,
          ERB_EXPR: Zl,
          TMPLIT_EXPR: da,
          DATA_ATTR: _g,
          ARIA_ATTR: Eg,
          IS_SCRIPT_OR_DATA: xp,
          ATTR_WHITESPACE: ci,
          CUSTOM_ELEMENT: eu
        } = U;
        let {
          IS_ALLOWED_URI: tu
        } = U, Yt = null;
        const ha = L({}, [...oe, ...ce, ...pe, ...G, ...K]);
        let Zt = null;
        const ps = L({}, [...z, ...te, ...q, ...j]);
        let Lt = Object.seal(p(null, {
          tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
          },
          attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1
          }
        })), bo = null, ma = null, ga = !0, Ii = !0, ru = !1, nu = !0, ji = !1, Ni = !0, pi = !1, fs = !1, ya = !1, xn = !1, ds = !1, hs = !1, va = !0, ba = !1;
        const iu = "user-content-";
        let wa = !0, Li = !1, fi = {}, di = null;
        const ou = L({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        let su = null;
        const au = L({}, ["audio", "video", "img", "source", "image", "track"]);
        let ms = null;
        const lu = L({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), gs = "http://www.w3.org/1998/Math/MathML", ys = "http://www.w3.org/2000/svg", Nr = "http://www.w3.org/1999/xhtml";
        let wo = Nr, vs = !1, Sa = null;
        const bs = L({}, [gs, ys, Nr], _);
        let So = null;
        const _p = ["application/xhtml+xml", "text/html"], ws = "text/html";
        let Gt = null, Mi = null;
        const uu = le.createElement("form"), cu = function(de) {
          return de instanceof RegExp || de instanceof Function;
        }, pu = function() {
          let de = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!(Mi && Mi === de)) {
            if ((!de || typeof de != "object") && (de = {}), de = Q(de), So = // eslint-disable-next-line unicorn/prefer-includes
            _p.indexOf(de.PARSER_MEDIA_TYPE) === -1 ? ws : de.PARSER_MEDIA_TYPE, Gt = So === "application/xhtml+xml" ? _ : S, Yt = A(de, "ALLOWED_TAGS") ? L({}, de.ALLOWED_TAGS, Gt) : ha, Zt = A(de, "ALLOWED_ATTR") ? L({}, de.ALLOWED_ATTR, Gt) : ps, Sa = A(de, "ALLOWED_NAMESPACES") ? L({}, de.ALLOWED_NAMESPACES, _) : bs, ms = A(de, "ADD_URI_SAFE_ATTR") ? L(
              Q(lu),
              // eslint-disable-line indent
              de.ADD_URI_SAFE_ATTR,
              // eslint-disable-line indent
              Gt
              // eslint-disable-line indent
            ) : lu, su = A(de, "ADD_DATA_URI_TAGS") ? L(
              Q(au),
              // eslint-disable-line indent
              de.ADD_DATA_URI_TAGS,
              // eslint-disable-line indent
              Gt
              // eslint-disable-line indent
            ) : au, di = A(de, "FORBID_CONTENTS") ? L({}, de.FORBID_CONTENTS, Gt) : ou, bo = A(de, "FORBID_TAGS") ? L({}, de.FORBID_TAGS, Gt) : {}, ma = A(de, "FORBID_ATTR") ? L({}, de.FORBID_ATTR, Gt) : {}, fi = A(de, "USE_PROFILES") ? de.USE_PROFILES : !1, ga = de.ALLOW_ARIA_ATTR !== !1, Ii = de.ALLOW_DATA_ATTR !== !1, ru = de.ALLOW_UNKNOWN_PROTOCOLS || !1, nu = de.ALLOW_SELF_CLOSE_IN_ATTR !== !1, ji = de.SAFE_FOR_TEMPLATES || !1, Ni = de.SAFE_FOR_XML !== !1, pi = de.WHOLE_DOCUMENT || !1, xn = de.RETURN_DOM || !1, ds = de.RETURN_DOM_FRAGMENT || !1, hs = de.RETURN_TRUSTED_TYPE || !1, ya = de.FORCE_BODY || !1, va = de.SANITIZE_DOM !== !1, ba = de.SANITIZE_NAMED_PROPS || !1, wa = de.KEEP_CONTENT !== !1, Li = de.IN_PLACE || !1, tu = de.ALLOWED_URI_REGEXP || C, wo = de.NAMESPACE || Nr, Lt = de.CUSTOM_ELEMENT_HANDLING || {}, de.CUSTOM_ELEMENT_HANDLING && cu(de.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Lt.tagNameCheck = de.CUSTOM_ELEMENT_HANDLING.tagNameCheck), de.CUSTOM_ELEMENT_HANDLING && cu(de.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Lt.attributeNameCheck = de.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), de.CUSTOM_ELEMENT_HANDLING && typeof de.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Lt.allowCustomizedBuiltInElements = de.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ji && (Ii = !1), ds && (xn = !0), fi && (Yt = L({}, K), Zt = [], fi.html === !0 && (L(Yt, oe), L(Zt, z)), fi.svg === !0 && (L(Yt, ce), L(Zt, te), L(Zt, j)), fi.svgFilters === !0 && (L(Yt, pe), L(Zt, te), L(Zt, j)), fi.mathMl === !0 && (L(Yt, G), L(Zt, q), L(Zt, j))), de.ADD_TAGS && (Yt === ha && (Yt = Q(Yt)), L(Yt, de.ADD_TAGS, Gt)), de.ADD_ATTR && (Zt === ps && (Zt = Q(Zt)), L(Zt, de.ADD_ATTR, Gt)), de.ADD_URI_SAFE_ATTR && L(ms, de.ADD_URI_SAFE_ATTR, Gt), de.FORBID_CONTENTS && (di === ou && (di = Q(di)), L(di, de.FORBID_CONTENTS, Gt)), wa && (Yt["#text"] = !0), pi && L(Yt, ["html", "head", "body"]), Yt.table && (L(Yt, ["tbody"]), delete bo.tbody), de.TRUSTED_TYPES_POLICY) {
              if (typeof de.TRUSTED_TYPES_POLICY.createHTML != "function")
                throw R('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
              if (typeof de.TRUSTED_TYPES_POLICY.createScriptURL != "function")
                throw R('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
              xe = de.TRUSTED_TYPES_POLICY, Le = xe.createHTML("");
            } else
              xe === void 0 && (xe = he(D, be)), xe !== null && typeof Le == "string" && (Le = xe.createHTML(""));
            a && a(de), Mi = de;
          }
        }, Ep = L({}, ["mi", "mo", "mn", "ms", "mtext"]), Op = L({}, ["annotation-xml"]), Og = L({}, ["title", "style", "font", "a", "script"]), kp = L({}, [...ce, ...pe, ...fe]), fu = L({}, [...G, ...Z]), kg = function(de) {
          let Re = Fe(de);
          (!Re || !Re.tagName) && (Re = {
            namespaceURI: wo,
            tagName: "template"
          });
          const Ve = S(de.tagName), xt = S(Re.tagName);
          return Sa[de.namespaceURI] ? de.namespaceURI === ys ? Re.namespaceURI === Nr ? Ve === "svg" : Re.namespaceURI === gs ? Ve === "svg" && (xt === "annotation-xml" || Ep[xt]) : !!kp[Ve] : de.namespaceURI === gs ? Re.namespaceURI === Nr ? Ve === "math" : Re.namespaceURI === ys ? Ve === "math" && Op[xt] : !!fu[Ve] : de.namespaceURI === Nr ? Re.namespaceURI === ys && !Op[xt] || Re.namespaceURI === gs && !Ep[xt] ? !1 : !fu[Ve] && (Og[Ve] || !kp[Ve]) : !!(So === "application/xhtml+xml" && Sa[de.namespaceURI]) : !1;
        }, _n = function(de) {
          g(M.removed, {
            element: de
          });
          try {
            Fe(de).removeChild(de);
          } catch {
            Ee(de);
          }
        }, Ss = function(de, Re) {
          try {
            g(M.removed, {
              attribute: Re.getAttributeNode(de),
              from: Re
            });
          } catch {
            g(M.removed, {
              attribute: null,
              from: Re
            });
          }
          if (Re.removeAttribute(de), de === "is" && !Zt[de])
            if (xn || ds)
              try {
                _n(Re);
              } catch {
              }
            else
              try {
                Re.setAttribute(de, "");
              } catch {
              }
        }, du = function(de) {
          let Re = null, Ve = null;
          if (ya)
            de = "<remove></remove>" + de;
          else {
            const ar = x(de, /^[\r\n\t ]+/);
            Ve = ar && ar[0];
          }
          So === "application/xhtml+xml" && wo === Nr && (de = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + de + "</body></html>");
          const xt = xe ? xe.createHTML(de) : de;
          if (wo === Nr)
            try {
              Re = new Et().parseFromString(xt, So);
            } catch {
            }
          if (!Re || !Re.documentElement) {
            Re = Ye.createDocument(wo, "template", null);
            try {
              Re.documentElement.innerHTML = vs ? Le : xt;
            } catch {
            }
          }
          const sr = Re.body || Re.documentElement;
          return de && Ve && sr.insertBefore(le.createTextNode(Ve), sr.childNodes[0] || null), wo === Nr ? ut.call(Re, pi ? "html" : "body")[0] : pi ? Re.documentElement : sr;
        }, hu = function(de) {
          return mt.call(
            de.ownerDocument || de,
            de,
            // eslint-disable-next-line no-bitwise
            Xe.SHOW_ELEMENT | Xe.SHOW_COMMENT | Xe.SHOW_TEXT | Xe.SHOW_PROCESSING_INSTRUCTION | Xe.SHOW_CDATA_SECTION,
            null
          );
        }, xs = function(de) {
          return de instanceof Ue && (typeof de.nodeName != "string" || typeof de.textContent != "string" || typeof de.removeChild != "function" || !(de.attributes instanceof Ge) || typeof de.removeAttribute != "function" || typeof de.setAttribute != "function" || typeof de.namespaceURI != "string" || typeof de.insertBefore != "function" || typeof de.hasChildNodes != "function");
        }, Di = function(de) {
          return typeof Me == "function" && de instanceof Me;
        }, nn = function(de, Re, Ve) {
          Jt[de] && m(Jt[de], (xt) => {
            xt.call(M, Re, Ve, Mi);
          });
        }, Ap = function(de) {
          let Re = null;
          if (nn("beforeSanitizeElements", de, null), xs(de))
            return _n(de), !0;
          const Ve = Gt(de.nodeName);
          if (nn("uponSanitizeElement", de, {
            tagName: Ve,
            allowedTags: Yt
          }), de.hasChildNodes() && !Di(de.firstElementChild) && T(/<[/\w]/g, de.innerHTML) && T(/<[/\w]/g, de.textContent) || de.nodeType === W.progressingInstruction || Ni && de.nodeType === W.comment && T(/<[/\w]/g, de.data))
            return _n(de), !0;
          if (!Yt[Ve] || bo[Ve]) {
            if (!bo[Ve] && xa(Ve) && (Lt.tagNameCheck instanceof RegExp && T(Lt.tagNameCheck, Ve) || Lt.tagNameCheck instanceof Function && Lt.tagNameCheck(Ve)))
              return !1;
            if (wa && !di[Ve]) {
              const xt = Fe(de) || de.parentNode, sr = $e(de) || de.childNodes;
              if (sr && xt) {
                const ar = sr.length;
                for (let _r = ar - 1; _r >= 0; --_r) {
                  const on = Oe(sr[_r], !0);
                  on.__removalCount = (de.__removalCount || 0) + 1, xt.insertBefore(on, Ce(de));
                }
              }
            }
            return _n(de), !0;
          }
          return de instanceof We && !kg(de) || (Ve === "noscript" || Ve === "noembed" || Ve === "noframes") && T(/<\/no(script|embed|frames)/i, de.innerHTML) ? (_n(de), !0) : (ji && de.nodeType === W.text && (Re = de.textContent, m([Fn, Zl, da], (xt) => {
            Re = y(Re, xt, " ");
          }), de.textContent !== Re && (g(M.removed, {
            element: de.cloneNode()
          }), de.textContent = Re)), nn("afterSanitizeElements", de, null), !1);
        }, Pp = function(de, Re, Ve) {
          if (va && (Re === "id" || Re === "name") && (Ve in le || Ve in uu))
            return !1;
          if (!(Ii && !ma[Re] && T(_g, Re))) {
            if (!(ga && T(Eg, Re))) {
              if (!Zt[Re] || ma[Re]) {
                if (
                  // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                  // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                  // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                  !(xa(de) && (Lt.tagNameCheck instanceof RegExp && T(Lt.tagNameCheck, de) || Lt.tagNameCheck instanceof Function && Lt.tagNameCheck(de)) && (Lt.attributeNameCheck instanceof RegExp && T(Lt.attributeNameCheck, Re) || Lt.attributeNameCheck instanceof Function && Lt.attributeNameCheck(Re)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                  // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                  Re === "is" && Lt.allowCustomizedBuiltInElements && (Lt.tagNameCheck instanceof RegExp && T(Lt.tagNameCheck, Ve) || Lt.tagNameCheck instanceof Function && Lt.tagNameCheck(Ve)))
                ) return !1;
              } else if (!ms[Re]) {
                if (!T(tu, y(Ve, ci, ""))) {
                  if (!((Re === "src" || Re === "xlink:href" || Re === "href") && de !== "script" && w(Ve, "data:") === 0 && su[de])) {
                    if (!(ru && !T(xp, y(Ve, ci, "")))) {
                      if (Ve)
                        return !1;
                    }
                  }
                }
              }
            }
          }
          return !0;
        }, xa = function(de) {
          return de !== "annotation-xml" && x(de, eu);
        }, _a = function(de) {
          nn("beforeSanitizeAttributes", de, null);
          const {
            attributes: Re
          } = de;
          if (!Re)
            return;
          const Ve = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: Zt
          };
          let xt = Re.length;
          for (; xt--; ) {
            const sr = Re[xt], {
              name: ar,
              namespaceURI: _r,
              value: on
            } = sr, Vt = Gt(ar);
            let gr = ar === "value" ? on : k(on);
            if (Ve.attrName = Vt, Ve.attrValue = gr, Ve.keepAttr = !0, Ve.forceKeepAttr = void 0, nn("uponSanitizeAttribute", de, Ve), gr = Ve.attrValue, Ve.forceKeepAttr || (Ss(ar, de), !Ve.keepAttr))
              continue;
            if (!nu && T(/\/>/i, gr)) {
              Ss(ar, de);
              continue;
            }
            ji && m([Fn, Zl, da], (Cp) => {
              gr = y(gr, Cp, " ");
            });
            const mu = Gt(de.nodeName);
            if (Pp(mu, Vt, gr)) {
              if (ba && (Vt === "id" || Vt === "name") && (Ss(ar, de), gr = iu + gr), Ni && T(/((--!?|])>)|<\/(style|title)/i, gr)) {
                Ss(ar, de);
                continue;
              }
              if (xe && typeof D == "object" && typeof D.getAttributeType == "function" && !_r)
                switch (D.getAttributeType(mu, Vt)) {
                  case "TrustedHTML": {
                    gr = xe.createHTML(gr);
                    break;
                  }
                  case "TrustedScriptURL": {
                    gr = xe.createScriptURL(gr);
                    break;
                  }
                }
              try {
                _r ? de.setAttributeNS(_r, ar, gr) : de.setAttribute(ar, gr), xs(de) ? _n(de) : v(M.removed);
              } catch {
              }
            }
          }
          nn("afterSanitizeAttributes", de, null);
        }, Ea = function He(de) {
          let Re = null;
          const Ve = hu(de);
          for (nn("beforeSanitizeShadowDOM", de, null); Re = Ve.nextNode(); )
            nn("uponSanitizeShadowNode", Re, null), !Ap(Re) && (Re.content instanceof Pe && He(Re.content), _a(Re));
          nn("afterSanitizeShadowDOM", de, null);
        };
        return M.sanitize = function(He) {
          let de = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Re = null, Ve = null, xt = null, sr = null;
          if (vs = !He, vs && (He = "<!-->"), typeof He != "string" && !Di(He))
            if (typeof He.toString == "function") {
              if (He = He.toString(), typeof He != "string")
                throw R("dirty is not a string, aborting");
            } else
              throw R("toString is not a function");
          if (!M.isSupported)
            return He;
          if (fs || pu(de), M.removed = [], typeof He == "string" && (Li = !1), Li) {
            if (He.nodeName) {
              const on = Gt(He.nodeName);
              if (!Yt[on] || bo[on])
                throw R("root node is forbidden and cannot be sanitized in-place");
            }
          } else if (He instanceof Me)
            Re = du("<!---->"), Ve = Re.ownerDocument.importNode(He, !0), Ve.nodeType === W.element && Ve.nodeName === "BODY" || Ve.nodeName === "HTML" ? Re = Ve : Re.appendChild(Ve);
          else {
            if (!xn && !ji && !pi && // eslint-disable-next-line unicorn/prefer-includes
            He.indexOf("<") === -1)
              return xe && hs ? xe.createHTML(He) : He;
            if (Re = du(He), !Re)
              return xn ? null : hs ? Le : "";
          }
          Re && ya && _n(Re.firstChild);
          const ar = hu(Li ? He : Re);
          for (; xt = ar.nextNode(); )
            Ap(xt) || (xt.content instanceof Pe && Ea(xt.content), _a(xt));
          if (Li)
            return He;
          if (xn) {
            if (ds)
              for (sr = rt.call(Re.ownerDocument); Re.firstChild; )
                sr.appendChild(Re.firstChild);
            else
              sr = Re;
            return (Zt.shadowroot || Zt.shadowrootmode) && (sr = gt.call(ye, sr, !0)), sr;
          }
          let _r = pi ? Re.outerHTML : Re.innerHTML;
          return pi && Yt["!doctype"] && Re.ownerDocument && Re.ownerDocument.doctype && Re.ownerDocument.doctype.name && T(X, Re.ownerDocument.doctype.name) && (_r = "<!DOCTYPE " + Re.ownerDocument.doctype.name + `>
` + _r), ji && m([Fn, Zl, da], (on) => {
            _r = y(_r, on, " ");
          }), xe && hs ? xe.createHTML(_r) : _r;
        }, M.setConfig = function() {
          let He = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          pu(He), fs = !0;
        }, M.clearConfig = function() {
          Mi = null, fs = !1;
        }, M.isValidAttribute = function(He, de, Re) {
          Mi || pu({});
          const Ve = Gt(He), xt = Gt(de);
          return Pp(Ve, xt, Re);
        }, M.addHook = function(He, de) {
          typeof de == "function" && (Jt[He] = Jt[He] || [], g(Jt[He], de));
        }, M.removeHook = function(He) {
          if (Jt[He])
            return v(Jt[He]);
        }, M.removeHooks = function(He) {
          Jt[He] && (Jt[He] = []);
        }, M.removeAllHooks = function() {
          Jt = {};
        }, M;
      }
      var Se = Te();
      return Se;
    });
  }(o0)), o0.exports;
}
if (!et.useState)
  throw new Error("mobx-react-lite requires React with Hooks support");
if (!Rj)
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
function dG(e) {
  e();
}
function ZN(e) {
  e || (e = dG), xj({ reactionScheduler: e });
}
function hG(e) {
  return _j(e);
}
var eL = !1;
function tL(e) {
  eL = e;
}
function Ml() {
  return eL;
}
var mG = 1e4, gG = 1e4, yG = (
  /** @class */
  function() {
    function e(t) {
      var r = this;
      Object.defineProperty(this, "finalize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
      }), Object.defineProperty(this, "registrations", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /* @__PURE__ */ new Map()
      }), Object.defineProperty(this, "sweepTimeout", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "sweep", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function(n) {
          n === void 0 && (n = mG), clearTimeout(r.sweepTimeout), r.sweepTimeout = void 0;
          var i = Date.now();
          r.registrations.forEach(function(s, o) {
            i - s.registeredAt >= n && (r.finalize(s.value), r.registrations.delete(o));
          }), r.registrations.size > 0 && r.scheduleSweep();
        }
      }), Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function() {
          r.sweep(0);
        }
      });
    }
    return Object.defineProperty(e.prototype, "register", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function(t, r, n) {
        this.registrations.set(n, {
          value: r,
          registeredAt: Date.now()
        }), this.scheduleSweep();
      }
    }), Object.defineProperty(e.prototype, "unregister", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function(t) {
        this.registrations.delete(t);
      }
    }), Object.defineProperty(e.prototype, "scheduleSweep", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function() {
        this.sweepTimeout === void 0 && (this.sweepTimeout = setTimeout(this.sweep, gG));
      }
    }), e;
  }()
), vG = typeof FinalizationRegistry < "u" ? FinalizationRegistry : yG, rp = new vG(function(e) {
  var t;
  (t = e.reaction) === null || t === void 0 || t.dispose(), e.reaction = null;
}), rL = { exports: {} }, nL = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dl = et;
function bG(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var wG = typeof Object.is == "function" ? Object.is : bG, SG = Dl.useState, xG = Dl.useEffect, _G = Dl.useLayoutEffect, EG = Dl.useDebugValue;
function OG(e, t) {
  var r = t(), n = SG({ inst: { value: r, getSnapshot: t } }), i = n[0].inst, s = n[1];
  return _G(function() {
    i.value = r, i.getSnapshot = t, s0(i) && s({ inst: i });
  }, [e, r, t]), xG(function() {
    return s0(i) && s({ inst: i }), e(function() {
      s0(i) && s({ inst: i });
    });
  }, [e]), EG(r), r;
}
function s0(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var r = t();
    return !wG(e, r);
  } catch {
    return !0;
  }
}
function kG(e, t) {
  return t();
}
var AG = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? kG : OG;
nL.useSyncExternalStore = Dl.useSyncExternalStore !== void 0 ? Dl.useSyncExternalStore : AG;
rL.exports = nL;
var PG = rL.exports;
function VC(e) {
  e.reaction = new Mn("observer".concat(e.name), function() {
    var t;
    e.stateVersion = Symbol(), (t = e.onStoreChange) === null || t === void 0 || t.call(e);
  });
}
function qS(e, t) {
  if (t === void 0 && (t = "observed"), Ml())
    return e();
  var r = at.useRef(null);
  if (!r.current) {
    var n = {
      reaction: null,
      onStoreChange: null,
      stateVersion: Symbol(),
      name: t,
      subscribe: function(a) {
        return rp.unregister(n), n.onStoreChange = a, n.reaction || (VC(n), n.stateVersion = Symbol()), function() {
          var l;
          n.onStoreChange = null, (l = n.reaction) === null || l === void 0 || l.dispose(), n.reaction = null;
        };
      },
      getSnapshot: function() {
        return n.stateVersion;
      }
    };
    r.current = n;
  }
  var i = r.current;
  i.reaction || (VC(i), rp.register(r, i, i)), at.useDebugValue(i.reaction, hG), PG.useSyncExternalStore(
    // Both of these must be stable, otherwise it would keep resubscribing every render.
    i.subscribe,
    i.getSnapshot,
    i.getSnapshot
  );
  var s, o;
  if (i.reaction.track(function() {
    try {
      s = e();
    } catch (a) {
      o = a;
    }
  }), o)
    throw o;
  return s;
}
var a0, l0, iL = typeof Symbol == "function" && Symbol.for, CG = (l0 = (a0 = Object.getOwnPropertyDescriptor(function() {
}, "name")) === null || a0 === void 0 ? void 0 : a0.configurable) !== null && l0 !== void 0 ? l0 : !1, WC = iL ? Symbol.for("react.forward_ref") : typeof et.forwardRef == "function" && et.forwardRef(function(e) {
  return null;
}).$$typeof, HC = iL ? Symbol.for("react.memo") : typeof et.memo == "function" && et.memo(function(e) {
  return null;
}).$$typeof;
function TG(e, t) {
  var r;
  if (HC && e.$$typeof === HC)
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  if (Ml())
    return e;
  var n = (r = void 0) !== null && r !== void 0 ? r : !1, i = e, s = e.displayName || e.name;
  if (WC && e.$$typeof === WC && (n = !0, i = e.render, typeof i != "function"))
    throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
  var o = function(a, l) {
    return qS(function() {
      return i(a, l);
    }, s);
  };
  return o.displayName = e.displayName, CG && Object.defineProperty(o, "name", {
    value: e.name,
    writable: !0,
    configurable: !0
  }), e.contextTypes && (o.contextTypes = e.contextTypes), n && (o = et.forwardRef(o)), o = et.memo(o), RG(e, o), o;
}
var $G = {
  $$typeof: !0,
  render: !0,
  compare: !0,
  type: !0,
  // Don't redefine `displayName`,
  // it's defined as getter-setter pair on `memo` (see #3192).
  displayName: !0
};
function RG(e, t) {
  Object.keys(e).forEach(function(r) {
    $G[r] || Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
  });
}
function oL(e) {
  var t = e.children, r = e.render, n = t || r;
  return typeof n != "function" ? null : qS(n);
}
oL.displayName = "Observer";
function IG(e, t) {
  return et.useState(function() {
    return Qt(e(), t, { autoBind: !0 });
  })[0];
}
function sL(e) {
  var t = et.useState(function() {
    return Qt(e, {}, { deep: !1 });
  })[0];
  return Rb(function() {
    Object.assign(t, e);
  }), t;
}
function jG(e, t) {
  var r = t && sL(t);
  return et.useState(function() {
    return Qt(e(r), void 0, { autoBind: !0 });
  })[0];
}
var u0;
ZN(mR.unstable_batchedUpdates);
u0 = rp.finalizeAllImmediately;
function NG(e, t) {
  return t === void 0 && (t = "observed"), qS(e, t);
}
function LG(e) {
  tL(e);
}
function MG(e, t) {
  if (QC(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  var r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (var i = 0; i < r.length; i++)
    if (!Object.hasOwnProperty.call(t, r[i]) || !QC(e[r[i]], t[r[i]]))
      return !1;
  return !0;
}
function QC(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
var DG = {
  $$typeof: 1,
  render: 1,
  compare: 1,
  type: 1,
  childContextTypes: 1,
  contextType: 1,
  contextTypes: 1,
  defaultProps: 1,
  getDefaultProps: 1,
  getDerivedStateFromError: 1,
  getDerivedStateFromProps: 1,
  mixins: 1,
  displayName: 1,
  propTypes: 1
};
function FG(e, t) {
  var r = Object.getOwnPropertyNames(Object.getPrototypeOf(e));
  Object.getOwnPropertyNames(e).forEach(function(n) {
    !DG[n] && r.indexOf(n) === -1 && Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
  });
}
var YC = /* @__PURE__ */ Symbol("patchMixins"), aL = /* @__PURE__ */ Symbol("patchedDefinition");
function zG(e, t) {
  var r = e[YC] = e[YC] || {}, n = r[t] = r[t] || {};
  return n.locks = n.locks || 0, n.methods = n.methods || [], n;
}
function GC(e, t) {
  for (var r = this, n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
    i[s - 2] = arguments[s];
  t.locks++;
  try {
    var o;
    return e != null && (o = e.apply(this, i)), o;
  } finally {
    t.locks--, t.locks === 0 && t.methods.forEach(function(a) {
      a.apply(r, i);
    });
  }
}
function KC(e, t) {
  var r = function() {
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    GC.call.apply(GC, [this, e, t].concat(s));
  };
  return r;
}
function lL(e, t, r) {
  var n = zG(e, t);
  n.methods.indexOf(r) < 0 && n.methods.push(r);
  var i = Object.getOwnPropertyDescriptor(e, t);
  if (!(i && i[aL])) {
    var s = e[t], o = uL(e, t, i ? i.enumerable : void 0, n, s);
    Object.defineProperty(e, t, o);
  }
}
function uL(e, t, r, n, i) {
  var s, o = KC(i, n);
  return s = {}, s[aL] = !0, s.get = function() {
    return o;
  }, s.set = function(l) {
    if (this === e)
      o = KC(l, n);
    else {
      var p = uL(this, t, r, n, l);
      Object.defineProperty(this, t, p);
    }
  }, s.configurable = !0, s.enumerable = r, s;
}
var XC = /* @__PURE__ */ Symbol("ObserverAdministration"), JC = /* @__PURE__ */ Symbol("isMobXReactObserver");
function Vb(e) {
  var t;
  return (t = e[XC]) != null ? t : e[XC] = {
    reaction: null,
    mounted: !1,
    reactionInvalidatedBeforeMount: !1,
    forceUpdate: null,
    name: Wb(e.constructor),
    state: void 0,
    props: void 0,
    context: void 0
  };
}
function qG(e) {
  var t = e.prototype;
  if (e[JC]) {
    var r = Wb(e);
    throw new Error("The provided component class (" + r + ") has already been declared as an observer component.");
  } else
    e[JC] = !0;
  if (t.componentWillReact)
    throw new Error("The componentWillReact life-cycle event is no longer supported");
  if (e.__proto__ !== et.PureComponent) {
    if (!t.shouldComponentUpdate)
      t.shouldComponentUpdate = ZC;
    else if (t.shouldComponentUpdate !== ZC)
      throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
  }
  var n = t.render;
  if (typeof n != "function") {
    var i = Wb(e);
    throw new Error("[mobx-react] class component (" + i + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
  }
  t.render = function() {
    return Object.defineProperty(this, "render", {
      // There is no safe way to replace render, therefore it's forbidden.
      configurable: !1,
      writable: !1,
      value: Ml() ? n : BG.call(this, n)
    }), this.render();
  };
  var s = t.componentDidMount;
  return t.componentDidMount = function() {
    var o = this, a = Vb(this);
    return a.mounted = !0, rp.unregister(this), a.forceUpdate = function() {
      return o.forceUpdate();
    }, (!a.reaction || a.reactionInvalidatedBeforeMount) && a.forceUpdate(), s == null ? void 0 : s.apply(this, arguments);
  }, lL(t, "componentWillUnmount", function() {
    var o;
    if (!Ml()) {
      var a = Vb(this);
      (o = a.reaction) == null || o.dispose(), a.reaction = null, a.forceUpdate = null, a.mounted = !1, a.reactionInvalidatedBeforeMount = !1;
    }
  }), e;
}
function Wb(e) {
  return e.displayName || e.name || "<component>";
}
function BG(e) {
  var t = e.bind(this), r = Vb(this);
  function n() {
    r.reaction || (r.reaction = UG(r), r.mounted || rp.register(this, r, this));
    var i = void 0, s = void 0;
    if (r.reaction.track(function() {
      try {
        s = ug(!1, t);
      } catch (o) {
        i = o;
      }
    }), i)
      throw i;
    return s;
  }
  return n;
}
function UG(e) {
  return new Mn(e.name + ".render()", function() {
    if (!e.mounted) {
      e.reactionInvalidatedBeforeMount = !0;
      return;
    }
    try {
      e.forceUpdate == null || e.forceUpdate();
    } catch {
      var t;
      (t = e.reaction) == null || t.dispose(), e.reaction = null;
    }
  });
}
function ZC(e, t) {
  return Ml() && console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."), this.state !== t ? !0 : !MG(this.props, e);
}
function cL(e, t) {
  if (t && t.kind !== "class")
    throw new Error("The @observer decorator can be used on classes only");
  return e.isMobxInjector === !0 && console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`"), Object.prototype.isPrototypeOf.call(et.Component, e) || Object.prototype.isPrototypeOf.call(et.PureComponent, e) ? qG(e) : TG(e);
}
function Am() {
  return Am = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Am.apply(this, arguments);
}
function VG(e, t) {
  if (e == null) return {};
  var r = {}, n = Object.keys(e), i, s;
  for (s = 0; s < n.length; s++)
    i = n[s], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var WG = ["children"], Pm = /* @__PURE__ */ at.createContext({});
function pL(e) {
  var t = e.children, r = VG(e, WG), n = at.useContext(Pm), i = at.useRef(Am({}, n, r)), s = i.current;
  return at.createElement(Pm.Provider, {
    value: s
  }, t);
}
pL.displayName = "MobXProvider";
function eT(e, t, r, n) {
  var i = at.forwardRef(function(s, o) {
    var a = Am({}, s), l = at.useContext(Pm);
    return Object.assign(a, e(l || {}, a) || {}), o && (a.ref = o), at.createElement(t, a);
  });
  return n && (i = cL(i)), i.isMobxInjector = !0, FG(t, i), i.wrappedComponent = t, i.displayName = HG(t, r), i;
}
function HG(e, t) {
  var r, n = e.displayName || e.name || e.constructor && e.constructor.name || "Component";
  return t ? r = "inject-with-" + t + "(" + n + ")" : r = "inject(" + n + ")", r;
}
function QG(e) {
  return function(t, r) {
    return e.forEach(function(n) {
      if (!(n in r)) {
        if (!(n in t)) throw new Error("MobX injector: Store '" + n + "' is not available! Make sure it is provided by some Provider");
        r[n] = t[n];
      }
    }), r;
  };
}
function YG() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (typeof arguments[0] == "function") {
    var n = arguments[0];
    return function(i) {
      return eT(n, i, n.name, !0);
    };
  } else
    return function(i) {
      return eT(QG(t), i, t.join("-"), !1);
    };
}
var GG = /* @__PURE__ */ Number.parseInt(at.version.split(".")[0]), tT = !1, $h = /* @__PURE__ */ Symbol("disposeOnUnmountProto"), Rh = /* @__PURE__ */ Symbol("disposeOnUnmountInst");
function KG() {
  var e = this;
  [].concat(this[$h] || [], this[Rh] || []).forEach(function(t) {
    var r = typeof t == "string" ? e[t] : t;
    r != null && (Array.isArray(r) ? r.map(function(n) {
      return n();
    }) : r());
  });
}
function fL(e, t) {
  if (Array.isArray(t))
    return t.map(function(l) {
      return fL(e, l);
    });
  tT || (GG >= 18 ? console.error("[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it.") : console.warn("[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher."), tT = !0);
  var r = Object.getPrototypeOf(e).constructor, n = Object.getPrototypeOf(e.constructor), i = Object.getPrototypeOf(Object.getPrototypeOf(e));
  if (!(r === at.Component || r === at.PureComponent || n === at.Component || n === at.PureComponent || i === at.Component || i === at.PureComponent))
    throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");
  if (typeof t != "string" && typeof t != "function" && !Array.isArray(t))
    throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");
  var s = typeof t == "string", o = !!e[$h] || !!e[Rh], a = s ? (
    // decorators are added to the prototype store
    e[$h] || (e[$h] = [])
  ) : (
    // functions are added to the instance store
    e[Rh] || (e[Rh] = [])
  );
  if (a.push(t), o || lL(e, "componentWillUnmount", KG), typeof t != "string")
    return t;
}
function dL(e) {
  function t(n, i, s, o, a, l) {
    for (var p = arguments.length, f = new Array(p > 6 ? p - 6 : 0), d = 6; d < p; d++)
      f[d - 6] = arguments[d];
    return Yl(function() {
      if (o = o || "<<anonymous>>", l = l || s, i[s] == null) {
        if (n) {
          var m = i[s] === null ? "null" : "undefined";
          return new Error("The " + a + " `" + l + "` is marked as required in `" + o + "`, but its value is `" + m + "`.");
        }
        return null;
      } else
        return e.apply(void 0, [i, s, o, a, l].concat(f));
    });
  }
  var r = t.bind(null, !1);
  return r.isRequired = t.bind(null, !0), r;
}
function XG(e, t) {
  return e === "symbol" || t["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && t instanceof Symbol;
}
function hL(e) {
  var t = typeof e;
  return Array.isArray(e) ? "array" : e instanceof RegExp ? "object" : XG(t, e) ? "symbol" : t;
}
function JG(e) {
  var t = hL(e);
  if (t === "object") {
    if (e instanceof Date)
      return "date";
    if (e instanceof RegExp)
      return "regexp";
  }
  return t;
}
function Jl(e, t) {
  return dL(function(r, n, i, s, o) {
    return Yl(function() {
      if (e && hL(r[n]) === t.toLowerCase())
        return null;
      var a;
      switch (t) {
        case "Array":
          a = Br;
          break;
        case "Object":
          a = hr;
          break;
        case "Map":
          a = mr;
          break;
        default:
          throw new Error("Unexpected mobxType: " + t);
      }
      var l = r[n];
      if (!a(l)) {
        var p = JG(l), f = e ? " or javascript `" + t.toLowerCase() + "`" : "";
        return new Error("Invalid prop `" + o + "` of type `" + p + "` supplied to `" + i + "`, expected `mobx.Observable" + t + "`" + f + ".");
      }
      return null;
    });
  });
}
function mL(e, t) {
  return dL(function(r, n, i, s, o) {
    for (var a = arguments.length, l = new Array(a > 5 ? a - 5 : 0), p = 5; p < a; p++)
      l[p - 5] = arguments[p];
    return Yl(function() {
      if (typeof t != "function")
        return new Error("Property `" + o + "` of component `" + i + "` has invalid PropType notation.");
      var f = Jl(e, "Array")(r, n, i, s, o);
      if (f instanceof Error) return f;
      for (var d = r[n], m = 0; m < d.length; m++)
        if (f = t.apply(void 0, [d, m, i, s, o + "[" + m + "]"].concat(l)), f instanceof Error) return f;
      return null;
    });
  });
}
var ZG = /* @__PURE__ */ Jl(!1, "Array"), eK = /* @__PURE__ */ mL.bind(null, !1), tK = /* @__PURE__ */ Jl(!1, "Map"), rK = /* @__PURE__ */ Jl(!1, "Object"), nK = /* @__PURE__ */ Jl(!0, "Array"), iK = /* @__PURE__ */ mL.bind(null, !0), oK = /* @__PURE__ */ Jl(!0, "Object"), sK = {
  observableArray: ZG,
  observableArrayOf: eK,
  observableMap: tK,
  observableObject: rK,
  arrayOrObservableArray: nK,
  arrayOrObservableArrayOf: iK,
  objectOrObservableObject: oK
};
if (!et.Component)
  throw new Error("mobx-react requires React to be available");
if (!Qt)
  throw new Error("mobx-react requires mobx to be available");
const aK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MobXProviderContext: Pm,
  Observer: oL,
  PropTypes: sK,
  Provider: pL,
  disposeOnUnmount: fL,
  enableStaticRendering: tL,
  inject: YG,
  isUsingStaticRendering: Ml,
  observer: cL,
  observerBatching: ZN,
  useAsObservableSource: sL,
  useLocalObservable: IG,
  useLocalStore: jG,
  useObserver: NG,
  useStaticRendering: LG
}, Symbol.toStringTag, { value: "Module" })), lK = /* @__PURE__ */ Ri(aK);
var c0 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var rT;
function uK() {
  return rT || (rT = 1, function(e) {
    (function() {
      var t = {}.hasOwnProperty;
      function r() {
        for (var s = "", o = 0; o < arguments.length; o++) {
          var a = arguments[o];
          a && (s = i(s, n(a)));
        }
        return s;
      }
      function n(s) {
        if (typeof s == "string" || typeof s == "number")
          return s;
        if (typeof s != "object")
          return "";
        if (Array.isArray(s))
          return r.apply(null, s);
        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
          return s.toString();
        var o = "";
        for (var a in s)
          t.call(s, a) && s[a] && (o = i(o, a));
        return o;
      }
      function i(s, o) {
        return o ? s ? s + " " + o : s + o : s;
      }
      e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
    })();
  }(c0)), c0.exports;
}
/*! For license information please see redoc.browser.lib.js.LICENSE.txt */
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(pn, function() {
    return function() {
      var r = { 260: function(o, a, l) {
        var p = l(15), f = l.n(p), d = l(645), m = l.n(d)()(f());
        m.push([o.id, `.ps{overflow:hidden!important;overflow-anchor:none;-ms-overflow-style:none;touch-action:auto;-ms-touch-action:auto}.ps__rail-x{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;height:15px;bottom:0;position:absolute}.ps__rail-y{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;width:15px;right:0;position:absolute}.ps--active-x>.ps__rail-x,.ps--active-y>.ps__rail-y{display:block;background-color:transparent}.ps:hover>.ps__rail-x,.ps:hover>.ps__rail-y,.ps--focus>.ps__rail-x,.ps--focus>.ps__rail-y,.ps--scrolling-x>.ps__rail-x,.ps--scrolling-y>.ps__rail-y{opacity:.6}.ps .ps__rail-x:hover,.ps .ps__rail-y:hover,.ps .ps__rail-x:focus,.ps .ps__rail-y:focus,.ps .ps__rail-x.ps--clicking,.ps .ps__rail-y.ps--clicking{background-color:#eee;opacity:.9}.ps__thumb-x{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,height .2s ease-in-out;-webkit-transition:background-color .2s linear,height .2s ease-in-out;height:6px;bottom:2px;position:absolute}.ps__thumb-y{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,width .2s ease-in-out;-webkit-transition:background-color .2s linear,width .2s ease-in-out;width:6px;right:2px;position:absolute}.ps__rail-x:hover>.ps__thumb-x,.ps__rail-x:focus>.ps__thumb-x,.ps__rail-x.ps--clicking .ps__thumb-x{background-color:#999;height:11px}.ps__rail-y:hover>.ps__thumb-y,.ps__rail-y:focus>.ps__thumb-y,.ps__rail-y.ps--clicking .ps__thumb-y{background-color:#999;width:11px}@supports (-ms-overflow-style: none){.ps{overflow:auto!important}}@media screen and (-ms-high-contrast: active),(-ms-high-contrast: none){.ps{overflow:auto!important}}
`, "", { version: 3, sources: ["webpack://./node_modules/perfect-scrollbar/css/perfect-scrollbar.css"], names: [], mappings: "AAGA,IACE,yBAAA,CACA,oBAAA,CACA,uBAAA,CACA,iBAAA,CACA,qBAAA,CAMF,YACE,YAAA,CACA,SAAA,CACA,yDAAA,CACA,iEAAA,CACA,WAAA,CAEA,QAAA,CAEA,iBAAA,CAGF,YACE,YAAA,CACA,SAAA,CACA,yDAAA,CACA,iEAAA,CACA,UAAA,CAEA,OAAA,CAEA,iBAAA,CAGF,oDAEE,aAAA,CACA,4BAAA,CAGF,oJAME,UAAA,CAGF,kJAME,qBAAA,CACA,UAAA,CAMF,aACE,qBAAA,CAnEF,iBAAA,CAqEE,6DAAA,CACA,qEAAA,CACA,UAAA,CAEA,UAAA,CAEA,iBAAA,CAGF,aACE,qBAAA,CA/EF,iBAAA,CAiFE,4DAAA,CACA,oEAAA,CACA,SAAA,CAEA,SAAA,CAEA,iBAAA,CAGF,oGAGE,qBAAA,CACA,WAAA,CAGF,oGAGE,qBAAA,CACA,UAAA,CAIF,qCACE,IACE,uBAAA,CAAA,CAIJ,wEACE,IACE,uBAAA,CAAA", sourcesContent: [`/*
 * Container style
 */
.ps {
  overflow: hidden !important;
  overflow-anchor: none;
  -ms-overflow-style: none;
  touch-action: auto;
  -ms-touch-action: auto;
}

/*
 * Scrollbar rail styles
 */
.ps__rail-x {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  height: 15px;
  /* there must be 'bottom' or 'top' for ps__rail-x */
  bottom: 0px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__rail-y {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  width: 15px;
  /* there must be 'right' or 'left' for ps__rail-y */
  right: 0;
  /* please don't change 'position' */
  position: absolute;
}

.ps--active-x > .ps__rail-x,
.ps--active-y > .ps__rail-y {
  display: block;
  background-color: transparent;
}

.ps:hover > .ps__rail-x,
.ps:hover > .ps__rail-y,
.ps--focus > .ps__rail-x,
.ps--focus > .ps__rail-y,
.ps--scrolling-x > .ps__rail-x,
.ps--scrolling-y > .ps__rail-y {
  opacity: 0.6;
}

.ps .ps__rail-x:hover,
.ps .ps__rail-y:hover,
.ps .ps__rail-x:focus,
.ps .ps__rail-y:focus,
.ps .ps__rail-x.ps--clicking,
.ps .ps__rail-y.ps--clicking {
  background-color: #eee;
  opacity: 0.9;
}

/*
 * Scrollbar thumb styles
 */
.ps__thumb-x {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, height .2s ease-in-out;
  -webkit-transition: background-color .2s linear, height .2s ease-in-out;
  height: 6px;
  /* there must be 'bottom' for ps__thumb-x */
  bottom: 2px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__thumb-y {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, width .2s ease-in-out;
  -webkit-transition: background-color .2s linear, width .2s ease-in-out;
  width: 6px;
  /* there must be 'right' for ps__thumb-y */
  right: 2px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__rail-x:hover > .ps__thumb-x,
.ps__rail-x:focus > .ps__thumb-x,
.ps__rail-x.ps--clicking .ps__thumb-x {
  background-color: #999;
  height: 11px;
}

.ps__rail-y:hover > .ps__thumb-y,
.ps__rail-y:focus > .ps__thumb-y,
.ps__rail-y.ps--clicking .ps__thumb-y {
  background-color: #999;
  width: 11px;
}

/* MS supports */
@supports (-ms-overflow-style: none) {
  .ps {
    overflow: auto !important;
  }
}

@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
  .ps {
    overflow: auto !important;
  }
}
`], sourceRoot: "" }]), a.Z = m;
      }, 645: function(o) {
        o.exports = function(a) {
          var l = [];
          return l.toString = function() {
            return this.map(function(p) {
              var f = a(p);
              return p[2] ? "@media ".concat(p[2], " {").concat(f, "}") : f;
            }).join("");
          }, l.i = function(p, f, d) {
            typeof p == "string" && (p = [[null, p, ""]]);
            var m = {};
            if (d) for (var v = 0; v < this.length; v++) {
              var g = this[v][0];
              g != null && (m[g] = !0);
            }
            for (var S = 0; S < p.length; S++) {
              var _ = [].concat(p[S]);
              d && m[_[0]] || (f && (_[2] ? _[2] = "".concat(f, " and ").concat(_[2]) : _[2] = f), l.push(_));
            }
          }, l;
        };
      }, 15: function(o) {
        function a(l, p) {
          (p == null || p > l.length) && (p = l.length);
          for (var f = 0, d = new Array(p); f < p; f++) d[f] = l[f];
          return d;
        }
        o.exports = function(l) {
          var p, f, d = (f = 4, function(y) {
            if (Array.isArray(y)) return y;
          }(p = l) || function(y, w) {
            var k = y && (typeof Symbol < "u" && y[Symbol.iterator] || y["@@iterator"]);
            if (k != null) {
              var A, T, R = [], I = !0, B = !1;
              try {
                for (k = k.call(y); !(I = (A = k.next()).done) && (R.push(A.value), !w || R.length !== w); I = !0) ;
              } catch (L) {
                B = !0, T = L;
              } finally {
                try {
                  I || k.return == null || k.return();
                } finally {
                  if (B) throw T;
                }
              }
              return R;
            }
          }(p, f) || function(y, w) {
            if (y) {
              if (typeof y == "string") return a(y, w);
              var k = Object.prototype.toString.call(y).slice(8, -1);
              return k === "Object" && y.constructor && (k = y.constructor.name), k === "Map" || k === "Set" ? Array.from(y) : k === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(k) ? a(y, w) : void 0;
            }
          }(p, f) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }()), m = d[1], v = d[3];
          if (typeof btoa == "function") {
            var g = btoa(unescape(encodeURIComponent(JSON.stringify(v)))), S = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(g), _ = "/*# ".concat(S, " */"), x = v.sources.map(function(y) {
              return "/*# sourceURL=".concat(v.sourceRoot || "").concat(y, " */");
            });
            return [m].concat(x).concat([_]).join(`
`);
          }
          return [m].join(`
`);
        };
      }, 825: function(o) {
        o.exports = {};
      }, 388: function(o, a, l) {
        l.d(a, { ZP: function() {
          return d;
        } });
        var p = OB(), f = (B, L, Y) => new Promise((Q, re) => {
          var oe = (fe) => {
            try {
              pe(Y.next(fe));
            } catch (G) {
              re(G);
            }
          }, ce = (fe) => {
            try {
              pe(Y.throw(fe));
            } catch (G) {
              re(G);
            }
          }, pe = (fe) => fe.done ? Q(fe.value) : Promise.resolve(fe.value).then(oe, ce);
          pe((Y = Y.apply(B, L)).next());
        });
        class d {
          constructor() {
            this.add = y, this.done = w, this.search = I, this.toJS = k, this.load = T, this.dispose = R, this.fromExternalJS = A;
          }
        }
        let m, v, g, S = [];
        function _() {
          m = new p.Builder(), m.field("title"), m.field("description"), m.ref("ref"), m.pipeline.add(p.trimmer, p.stopWordFilter, p.stemmer), g = new Promise((B) => {
            v = B;
          });
        }
        p.tokenizer.separator = /\s+/, _();
        const x = (B) => {
          const L = p.trimmer(new p.Token(B, {}));
          return "*" + p.stemmer(L) + "*";
        };
        function y(B, L, Y) {
          const Q = S.push(Y) - 1, re = { title: B.toLowerCase(), description: L.toLowerCase(), ref: Q };
          m.add(re);
        }
        function w() {
          return f(this, null, function* () {
            v(m.build());
          });
        }
        function k() {
          return f(this, null, function* () {
            return { store: S, index: (yield g).toJSON() };
          });
        }
        function A(B, L) {
          return f(this, null, function* () {
            try {
              if (importScripts(B), !self[L]) throw new Error("Broken index file format");
              T(self[L]);
            } catch (Y) {
              console.error("Failed to load search index: " + Y.message);
            }
          });
        }
        function T(B) {
          return f(this, null, function* () {
            S = B.store, v(p.Index.load(B.index));
          });
        }
        function R() {
          return f(this, null, function* () {
            S = [], _();
          });
        }
        function I(B, L = 0) {
          return f(this, null, function* () {
            if (B.trim().length === 0) return [];
            let Y = (yield g).query((Q) => {
              B.trim().toLowerCase().split(/\s+/).forEach((re) => {
                if (re.length === 1) return;
                const oe = x(re);
                Q.term(oe, {});
              });
            });
            return L > 0 && (Y = Y.slice(0, L)), Y.map((Q) => ({ meta: S[Q.ref], score: Q.score }));
          });
        }
      }, 342: function(o, a, l) {
        const p = l(376), f = {}.NODE_DISABLE_COLORS ? { red: "", yellow: "", green: "", normal: "" } : { red: "\x1B[31m", yellow: "\x1B[33;1m", green: "\x1B[32m", normal: "\x1B[0m" };
        function d(v, g) {
          function S(_, x) {
            return p.stringify(_) === p.stringify(Object.assign({}, _, x));
          }
          return S(v, g) && S(g, v);
        }
        function m(v) {
          let g = (v = v.replace("[]", "Array")).split("/");
          return g[0] = g[0].replace(/[^A-Za-z0-9_\-\.]+|\s+/gm, "_"), g.join("/");
        }
        String.prototype.toCamelCase = function() {
          return this.toLowerCase().replace(/[-_ \/\.](.)/g, function(v, g) {
            return g.toUpperCase();
          });
        }, o.exports = { colour: f, uniqueOnly: function(v, g, S) {
          return S.indexOf(v) === g;
        }, hasDuplicates: function(v) {
          return new Set(v).size !== v.length;
        }, allSame: function(v) {
          return new Set(v).size <= 1;
        }, distinctArray: function(v) {
          return v.length === function(g) {
            let S = [];
            for (let _ of g) S.find(function(x, y, w) {
              return d(x, _);
            }) || S.push(_);
            return S;
          }(v).length;
        }, firstDupe: function(v) {
          return v.find(function(g, S, _) {
            return v.indexOf(g) < S;
          });
        }, hash: function(v) {
          let g, S = 0;
          if (v.length === 0) return S;
          for (let _ = 0; _ < v.length; _++) g = v.charCodeAt(_), S = (S << 5) - S + g, S |= 0;
          return S;
        }, parameterTypeProperties: ["format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "minLength", "maxLength", "multipleOf", "minItems", "maxItems", "uniqueItems", "minProperties", "maxProperties", "additionalProperties", "pattern", "enum", "default"], arrayProperties: ["items", "minItems", "maxItems", "uniqueItems"], httpMethods: ["get", "post", "put", "delete", "patch", "head", "options", "trace"], sanitise: m, sanitiseAll: function(v) {
          return m(v.split("/").join("_"));
        } };
      }, 856: function(o, a, l) {
        const p = l(825), f = l(470), d = l(416), m = l(416), v = l(66), g = l(53).jptr, S = l(401).recurse, _ = l(683).clone, x = l(593).dereference, y = l(592).isRef, w = l(342);
        function k(L, Y, Q, re, oe, ce) {
          let pe = ce.externalRefs[Q + re].paths[0], fe = d.parse(oe), G = {}, Z = 1;
          for (; Z; ) Z = 0, S(L, { identityDetection: !0 }, function(K, z, te) {
            if (y(K, z)) {
              if (K[z].startsWith("#")) if (G[K[z]] || K.$fixed) {
                if (!K.$fixed) {
                  let q = (pe + "/" + G[K[z]]).split("/#/").join("/");
                  te.parent[te.pkey] = { $ref: q, "x-miro": K[z], $fixed: !0 }, ce.verbose > 1 && console.warn("Replacing with", q), Z++;
                }
              } else {
                let q = _(g(Y, K[z]));
                if (ce.verbose > 1 && console.warn((q === !1 ? w.colour.red : w.colour.green) + "Fragment resolution", K[z], w.colour.normal), q === !1) {
                  if (te.parent[te.pkey] = {}, ce.fatal) {
                    let j = new Error("Fragment $ref resolution failed " + K[z]);
                    if (!ce.promise) throw j;
                    ce.promise.reject(j);
                  }
                } else Z++, te.parent[te.pkey] = q, G[K[z]] = te.path.replace("/%24ref", "");
              }
              else if (fe.protocol) {
                let q = d.resolve(oe, K[z]).toString();
                ce.verbose > 1 && console.warn(w.colour.yellow + "Rewriting external url ref", K[z], "as", q, w.colour.normal), K["x-miro"] = K[z], ce.externalRefs[K[z]] && (ce.externalRefs[q] || (ce.externalRefs[q] = ce.externalRefs[K[z]]), ce.externalRefs[q].failed = ce.externalRefs[K[z]].failed), K[z] = q;
              } else if (!K["x-miro"]) {
                let q = d.resolve(oe, K[z]).toString(), j = !1;
                ce.externalRefs[K[z]] && (j = ce.externalRefs[K[z]].failed), j || (ce.verbose > 1 && console.warn(w.colour.yellow + "Rewriting external ref", K[z], "as", q, w.colour.normal), K["x-miro"] = K[z], K[z] = q);
              }
            }
          });
          return S(L, {}, function(K, z, te) {
            y(K, z) && K.$fixed !== void 0 && delete K.$fixed;
          }), ce.verbose > 1 && console.warn("Finished fragment resolution"), L;
        }
        function A(L, Y) {
          if (!Y.filters || !Y.filters.length) return L;
          for (let Q of Y.filters) L = Q(L, Y);
          return L;
        }
        function T(L, Y, Q, re) {
          var oe = d.parse(Q.source), ce = Q.source.split("\\").join("/").split("/");
          ce.pop() || ce.pop();
          let pe = "", fe = Y.split("#");
          fe.length > 1 && (pe = "#" + fe[1], Y = fe[0]), ce = ce.join("/");
          let G = (Z = d.parse(Y).protocol, K = oe.protocol, Z && Z.length > 2 ? Z : K && K.length > 2 ? K : "file:");
          var Z, K;
          let z;
          if (z = G === "file:" ? f.resolve(ce ? ce + "/" : "", Y) : d.resolve(ce ? ce + "/" : "", Y), Q.cache[z]) {
            Q.verbose && console.warn("CACHED", z, pe);
            let te = _(Q.cache[z]), q = Q.externalRef = te;
            if (pe && (q = g(q, pe), q === !1 && (q = {}, Q.fatal))) {
              let j = new Error("Cached $ref resolution failed " + z + pe);
              if (!Q.promise) throw j;
              Q.promise.reject(j);
            }
            return q = k(q, te, Y, pe, z, Q), q = A(q, Q), re(_(q), z, Q), Promise.resolve(q);
          }
          if (Q.verbose && console.warn("GET", z, pe), Q.handlers && Q.handlers[G]) return Q.handlers[G](ce, Y, pe, Q).then(function(te) {
            return Q.externalRef = te, te = A(te, Q), Q.cache[z] = te, re(te, z, Q), te;
          }).catch(function(te) {
            throw Q.verbose && console.warn(te), te;
          });
          if (G && G.startsWith("http")) {
            const te = Object.assign({}, Q.fetchOptions, { agent: Q.agent });
            return Q.fetch(z, te).then(function(q) {
              if (q.status !== 200) {
                if (Q.ignoreIOErrors) return Q.verbose && console.warn("FAILED", Y), Q.externalRefs[Y].failed = !0, '{"$ref":"' + Y + '"}';
                throw new Error(`Received status code ${q.status}: ${z}`);
              }
              return q.text();
            }).then(function(q) {
              try {
                let j = v.parse(q, { schema: "core", prettyErrors: !0 });
                if (q = Q.externalRef = j, Q.cache[z] = _(q), pe && (q = g(q, pe)) === !1 && (q = {}, Q.fatal)) {
                  let H = new Error("Remote $ref resolution failed " + z + pe);
                  if (!Q.promise) throw H;
                  Q.promise.reject(H);
                }
                q = A(q = k(q, j, Y, pe, z, Q), Q);
              } catch (j) {
                if (Q.verbose && console.warn(j), !Q.promise || !Q.fatal) throw j;
                Q.promise.reject(j);
              }
              return re(q, z, Q), q;
            }).catch(function(q) {
              if (Q.verbose && console.warn(q), Q.cache[z] = {}, !Q.promise || !Q.fatal) throw q;
              Q.promise.reject(q);
            });
          }
          {
            const te = '{"$ref":"' + Y + '"}';
            return function(q, j, H, F, ue) {
              return new Promise(function(ge, Ae) {
                p.readFile(q, j, function(C, N) {
                  C ? H.ignoreIOErrors && ue ? (H.verbose && console.warn("FAILED", F), H.externalRefs[F].failed = !0, ge(ue)) : Ae(C) : ge(N);
                });
              });
            }(z, Q.encoding || "utf8", Q, Y, te).then(function(q) {
              try {
                let j = v.parse(q, { schema: "core", prettyErrors: !0 });
                if (q = Q.externalRef = j, Q.cache[z] = _(q), pe && (q = g(q, pe)) === !1 && (q = {}, Q.fatal)) {
                  let H = new Error("File $ref resolution failed " + z + pe);
                  if (!Q.promise) throw H;
                  Q.promise.reject(H);
                }
                q = A(q = k(q, j, Y, pe, z, Q), Q);
              } catch (j) {
                if (Q.verbose && console.warn(j), !Q.promise || !Q.fatal) throw j;
                Q.promise.reject(j);
              }
              return re(q, z, Q), q;
            }).catch(function(q) {
              if (Q.verbose && console.warn(q), !Q.promise || !Q.fatal) throw q;
              Q.promise.reject(q);
            });
          }
        }
        function R(L) {
          return new Promise(function(Y, Q) {
            (function(oe) {
              return new Promise(function(ce, pe) {
                function fe(Z, K, z) {
                  if (Z[K] && y(Z[K], "$ref")) {
                    let te = Z[K].$ref;
                    if (!te.startsWith("#")) {
                      let q = "";
                      if (!G[te]) {
                        let j = Object.keys(G).find(function(H, F, ue) {
                          return te.startsWith(H + "/");
                        });
                        j && (oe.verbose && console.warn("Found potential subschema at", j), q = "/" + (te.split("#")[1] || "").replace(j.split("#")[1] || ""), q = q.split("/undefined").join(""), te = j);
                      }
                      if (G[te] || (G[te] = { resolved: !1, paths: [], extras: {}, description: Z[K].description }), G[te].resolved) {
                        if (!G[te].failed) if (oe.rewriteRefs) {
                          let j = G[te].resolvedAt;
                          oe.verbose > 1 && console.warn("Rewriting ref", te, j), Z[K]["x-miro"] = te, Z[K].$ref = j + q;
                        } else Z[K] = _(G[te].data);
                      } else G[te].paths.push(z.path), G[te].extras[z.path] = q;
                    }
                  }
                }
                let G = oe.externalRefs;
                if (oe.resolver.depth > 0 && oe.source === oe.resolver.base) return ce(G);
                S(oe.openapi.definitions, { identityDetection: !0, path: "#/definitions" }, fe), S(oe.openapi.components, { identityDetection: !0, path: "#/components" }, fe), S(oe.openapi, { identityDetection: !0 }, fe), ce(G);
              });
            })(L).then(function(oe) {
              for (let ce in oe) if (!oe[ce].resolved) {
                let pe = L.resolver.depth;
                pe > 0 && pe++, L.resolver.actions[pe].push(function() {
                  return T(L.openapi, ce, L, function(fe, G, Z) {
                    if (!oe[ce].resolved) {
                      let q = {};
                      q.context = oe[ce], q.$ref = ce, q.original = _(fe), q.updated = fe, q.source = G, Z.externals.push(q), oe[ce].resolved = !0;
                    }
                    let K = Object.assign({}, Z, { source: "", resolver: { actions: Z.resolver.actions, depth: Z.resolver.actions.length - 1, base: Z.resolver.base } });
                    Z.patch && oe[ce].description && !fe.description && typeof fe == "object" && (fe.description = oe[ce].description), oe[ce].data = fe;
                    let z = (te = oe[ce].paths, [...new Set(te)]);
                    var te;
                    z = z.sort(function(q, j) {
                      const H = q.startsWith("#/components/") || q.startsWith("#/definitions/"), F = j.startsWith("#/components/") || j.startsWith("#/definitions/");
                      return H && !F ? -1 : F && !H ? 1 : 0;
                    });
                    for (let q of z) if (oe[ce].resolvedAt && q !== oe[ce].resolvedAt && q.indexOf("x-ms-examples/") < 0) Z.verbose > 1 && console.warn("Creating pointer to data at", q), g(Z.openapi, q, { $ref: oe[ce].resolvedAt + oe[ce].extras[q], "x-miro": ce + oe[ce].extras[q] });
                    else {
                      oe[ce].resolvedAt ? Z.verbose > 1 && console.warn("Avoiding circular reference") : (oe[ce].resolvedAt = q, Z.verbose > 1 && console.warn("Creating initial clone of data at", q));
                      let j = _(fe);
                      g(Z.openapi, q, j);
                    }
                    Z.resolver.actions[K.resolver.depth].length === 0 && Z.resolver.actions[K.resolver.depth].push(function() {
                      return R(K);
                    });
                  });
                });
              }
            }).catch(function(oe) {
              L.verbose && console.warn(oe), Q(oe);
            });
            let re = { options: L };
            re.actions = L.resolver.actions[L.resolver.depth], Y(re);
          });
        }
        function I(L, Y, Q) {
          L.resolver.actions.push([]), R(L).then(function(re) {
            var oe;
            (oe = re.actions, oe.reduce((ce, pe) => ce.then((fe) => pe().then(Array.prototype.concat.bind(fe))), Promise.resolve([]))).then(function() {
              if (L.resolver.depth >= L.resolver.actions.length) return console.warn("Ran off the end of resolver actions"), Y(!0);
              L.resolver.depth++, L.resolver.actions[L.resolver.depth].length ? setTimeout(function() {
                I(re.options, Y, Q);
              }, 0) : (L.verbose > 1 && console.warn(w.colour.yellow + "Finished external resolution!", w.colour.normal), L.resolveInternal && (L.verbose > 1 && console.warn(w.colour.yellow + "Starting internal resolution!", w.colour.normal), L.openapi = x(L.openapi, L.original, { verbose: L.verbose - 1 }), L.verbose > 1 && console.warn(w.colour.yellow + "Finished internal resolution!", w.colour.normal)), S(L.openapi, {}, function(ce, pe, fe) {
                y(ce, pe) && (L.preserveMiro || delete ce["x-miro"]);
              }), Y(L));
            }).catch(function(ce) {
              L.verbose && console.warn(ce), Q(ce);
            });
          }).catch(function(re) {
            L.verbose && console.warn(re), Q(re);
          });
        }
        function B(L) {
          if (L.cache || (L.cache = {}), L.fetch || (L.fetch = m), L.source) {
            let Y = d.parse(L.source);
            (!Y.protocol || Y.protocol.length <= 2) && (L.source = f.resolve(L.source));
          }
          L.externals = [], L.externalRefs = {}, L.rewriteRefs = !0, L.resolver = {}, L.resolver.depth = 0, L.resolver.base = L.source, L.resolver.actions = [[]];
        }
        o.exports = { optionalResolve: function(L) {
          return B(L), new Promise(function(Y, Q) {
            L.resolve ? I(L, Y, Q) : Y(L);
          });
        }, resolve: function(L, Y, Q) {
          return Q || (Q = {}), Q.openapi = L, Q.source = Y, Q.resolve = !0, B(Q), new Promise(function(re, oe) {
            I(Q, re, oe);
          });
        } };
      }, 804: function(o) {
        function a() {
          return { depth: 0, seen: /* @__PURE__ */ new WeakMap(), top: !0, combine: !1, allowRefSiblings: !1 };
        }
        o.exports = { getDefaultState: a, walkSchema: function l(p, f, d, m) {
          if (d.depth === void 0 && (d = a()), p == null) return p;
          if (p.$ref !== void 0) {
            let v = { $ref: p.$ref };
            return d.allowRefSiblings && p.description && (v.description = p.description), m(v, f, d), v;
          }
          if (d.combine && (p.allOf && Array.isArray(p.allOf) && p.allOf.length === 1 && delete (p = Object.assign({}, p.allOf[0], p)).allOf, p.anyOf && Array.isArray(p.anyOf) && p.anyOf.length === 1 && delete (p = Object.assign({}, p.anyOf[0], p)).anyOf, p.oneOf && Array.isArray(p.oneOf) && p.oneOf.length === 1 && delete (p = Object.assign({}, p.oneOf[0], p)).oneOf), m(p, f, d), d.seen.has(p)) return p;
          if (typeof p == "object" && p !== null && d.seen.set(p, !0), d.top = !1, d.depth++, p.items !== void 0 && (d.property = "items", l(p.items, p, d, m)), p.additionalItems && typeof p.additionalItems == "object" && (d.property = "additionalItems", l(p.additionalItems, p, d, m)), p.additionalProperties && typeof p.additionalProperties == "object" && (d.property = "additionalProperties", l(p.additionalProperties, p, d, m)), p.properties) for (let v in p.properties) {
            let g = p.properties[v];
            d.property = "properties/" + v, l(g, p, d, m);
          }
          if (p.patternProperties) for (let v in p.patternProperties) {
            let g = p.patternProperties[v];
            d.property = "patternProperties/" + v, l(g, p, d, m);
          }
          if (p.allOf) for (let v in p.allOf) {
            let g = p.allOf[v];
            d.property = "allOf/" + v, l(g, p, d, m);
          }
          if (p.anyOf) for (let v in p.anyOf) {
            let g = p.anyOf[v];
            d.property = "anyOf/" + v, l(g, p, d, m);
          }
          if (p.oneOf) for (let v in p.oneOf) {
            let g = p.oneOf[v];
            d.property = "oneOf/" + v, l(g, p, d, m);
          }
          return p.not && (d.property = "not", l(p.not, p, d, m)), d.depth--, p;
        } };
      }, 470: function(o) {
        function a(f) {
          if (typeof f != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(f));
        }
        function l(f, d) {
          for (var m, v = "", g = 0, S = -1, _ = 0, x = 0; x <= f.length; ++x) {
            if (x < f.length) m = f.charCodeAt(x);
            else {
              if (m === 47) break;
              m = 47;
            }
            if (m === 47) {
              if (!(S === x - 1 || _ === 1)) if (S !== x - 1 && _ === 2) {
                if (v.length < 2 || g !== 2 || v.charCodeAt(v.length - 1) !== 46 || v.charCodeAt(v.length - 2) !== 46) {
                  if (v.length > 2) {
                    var y = v.lastIndexOf("/");
                    if (y !== v.length - 1) {
                      y === -1 ? (v = "", g = 0) : g = (v = v.slice(0, y)).length - 1 - v.lastIndexOf("/"), S = x, _ = 0;
                      continue;
                    }
                  } else if (v.length === 2 || v.length === 1) {
                    v = "", g = 0, S = x, _ = 0;
                    continue;
                  }
                }
                d && (v.length > 0 ? v += "/.." : v = "..", g = 2);
              } else v.length > 0 ? v += "/" + f.slice(S + 1, x) : v = f.slice(S + 1, x), g = x - S - 1;
              S = x, _ = 0;
            } else m === 46 && _ !== -1 ? ++_ : _ = -1;
          }
          return v;
        }
        var p = { resolve: function() {
          for (var f, d = "", m = !1, v = arguments.length - 1; v >= -1 && !m; v--) {
            var g;
            v >= 0 ? g = arguments[v] : (f === void 0 && (f = process.cwd()), g = f), a(g), g.length !== 0 && (d = g + "/" + d, m = g.charCodeAt(0) === 47);
          }
          return d = l(d, !m), m ? d.length > 0 ? "/" + d : "/" : d.length > 0 ? d : ".";
        }, normalize: function(f) {
          if (a(f), f.length === 0) return ".";
          var d = f.charCodeAt(0) === 47, m = f.charCodeAt(f.length - 1) === 47;
          return (f = l(f, !d)).length !== 0 || d || (f = "."), f.length > 0 && m && (f += "/"), d ? "/" + f : f;
        }, isAbsolute: function(f) {
          return a(f), f.length > 0 && f.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0) return ".";
          for (var f, d = 0; d < arguments.length; ++d) {
            var m = arguments[d];
            a(m), m.length > 0 && (f === void 0 ? f = m : f += "/" + m);
          }
          return f === void 0 ? "." : p.normalize(f);
        }, relative: function(f, d) {
          if (a(f), a(d), f === d || (f = p.resolve(f)) === (d = p.resolve(d))) return "";
          for (var m = 1; m < f.length && f.charCodeAt(m) === 47; ++m) ;
          for (var v = f.length, g = v - m, S = 1; S < d.length && d.charCodeAt(S) === 47; ++S) ;
          for (var _ = d.length - S, x = g < _ ? g : _, y = -1, w = 0; w <= x; ++w) {
            if (w === x) {
              if (_ > x) {
                if (d.charCodeAt(S + w) === 47) return d.slice(S + w + 1);
                if (w === 0) return d.slice(S + w);
              } else g > x && (f.charCodeAt(m + w) === 47 ? y = w : w === 0 && (y = 0));
              break;
            }
            var k = f.charCodeAt(m + w);
            if (k !== d.charCodeAt(S + w)) break;
            k === 47 && (y = w);
          }
          var A = "";
          for (w = m + y + 1; w <= v; ++w) w !== v && f.charCodeAt(w) !== 47 || (A.length === 0 ? A += ".." : A += "/..");
          return A.length > 0 ? A + d.slice(S + y) : (S += y, d.charCodeAt(S) === 47 && ++S, d.slice(S));
        }, _makeLong: function(f) {
          return f;
        }, dirname: function(f) {
          if (a(f), f.length === 0) return ".";
          for (var d = f.charCodeAt(0), m = d === 47, v = -1, g = !0, S = f.length - 1; S >= 1; --S) if ((d = f.charCodeAt(S)) === 47) {
            if (!g) {
              v = S;
              break;
            }
          } else g = !1;
          return v === -1 ? m ? "/" : "." : m && v === 1 ? "//" : f.slice(0, v);
        }, basename: function(f, d) {
          if (d !== void 0 && typeof d != "string") throw new TypeError('"ext" argument must be a string');
          a(f);
          var m, v = 0, g = -1, S = !0;
          if (d !== void 0 && d.length > 0 && d.length <= f.length) {
            if (d.length === f.length && d === f) return "";
            var _ = d.length - 1, x = -1;
            for (m = f.length - 1; m >= 0; --m) {
              var y = f.charCodeAt(m);
              if (y === 47) {
                if (!S) {
                  v = m + 1;
                  break;
                }
              } else x === -1 && (S = !1, x = m + 1), _ >= 0 && (y === d.charCodeAt(_) ? --_ == -1 && (g = m) : (_ = -1, g = x));
            }
            return v === g ? g = x : g === -1 && (g = f.length), f.slice(v, g);
          }
          for (m = f.length - 1; m >= 0; --m) if (f.charCodeAt(m) === 47) {
            if (!S) {
              v = m + 1;
              break;
            }
          } else g === -1 && (S = !1, g = m + 1);
          return g === -1 ? "" : f.slice(v, g);
        }, extname: function(f) {
          a(f);
          for (var d = -1, m = 0, v = -1, g = !0, S = 0, _ = f.length - 1; _ >= 0; --_) {
            var x = f.charCodeAt(_);
            if (x !== 47) v === -1 && (g = !1, v = _ + 1), x === 46 ? d === -1 ? d = _ : S !== 1 && (S = 1) : d !== -1 && (S = -1);
            else if (!g) {
              m = _ + 1;
              break;
            }
          }
          return d === -1 || v === -1 || S === 0 || S === 1 && d === v - 1 && d === m + 1 ? "" : f.slice(d, v);
        }, format: function(f) {
          if (f === null || typeof f != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof f);
          return function(d, m) {
            var v = m.dir || m.root, g = m.base || (m.name || "") + (m.ext || "");
            return v ? v === m.root ? v + g : v + "/" + g : g;
          }(0, f);
        }, parse: function(f) {
          a(f);
          var d = { root: "", dir: "", base: "", ext: "", name: "" };
          if (f.length === 0) return d;
          var m, v = f.charCodeAt(0), g = v === 47;
          g ? (d.root = "/", m = 1) : m = 0;
          for (var S = -1, _ = 0, x = -1, y = !0, w = f.length - 1, k = 0; w >= m; --w) if ((v = f.charCodeAt(w)) !== 47) x === -1 && (y = !1, x = w + 1), v === 46 ? S === -1 ? S = w : k !== 1 && (k = 1) : S !== -1 && (k = -1);
          else if (!y) {
            _ = w + 1;
            break;
          }
          return S === -1 || x === -1 || k === 0 || k === 1 && S === x - 1 && S === _ + 1 ? x !== -1 && (d.base = d.name = _ === 0 && g ? f.slice(1, x) : f.slice(_, x)) : (_ === 0 && g ? (d.name = f.slice(1, S), d.base = f.slice(1, x)) : (d.name = f.slice(_, S), d.base = f.slice(_, x)), d.ext = f.slice(S, x)), _ > 0 ? d.dir = f.slice(0, _ - 1) : g && (d.dir = "/"), d;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        p.posix = p, o.exports = p;
      }, 683: function(o) {
        o.exports = { nop: function(a) {
          return a;
        }, clone: function(a) {
          return JSON.parse(JSON.stringify(a));
        }, shallowClone: function(a) {
          let l = {};
          for (let p in a) a.hasOwnProperty(p) && (l[p] = a[p]);
          return l;
        }, deepClone: function a(l) {
          let p = Array.isArray(l) ? [] : {};
          for (let f in l) (l.hasOwnProperty(f) || Array.isArray(l)) && (p[f] = typeof l[f] == "object" ? a(l[f]) : l[f]);
          return p;
        }, fastClone: function(a) {
          return Object.assign({}, a);
        }, circularClone: function a(l, p) {
          if (p || (p = /* @__PURE__ */ new WeakMap()), Object(l) !== l || l instanceof Function) return l;
          if (p.has(l)) return p.get(l);
          try {
            var f = new l.constructor();
          } catch {
            f = Object.create(Object.getPrototypeOf(l));
          }
          return p.set(l, f), Object.assign(f, ...Object.keys(l).map((d) => ({ [d]: a(l[d], p) })));
        } };
      }, 593: function(o, a, l) {
        const p = l(401).recurse, f = l(683).shallowClone, d = l(53).jptr, m = l(592).isRef;
        o.exports = { dereference: function v(g, S, _) {
          _ || (_ = {}), _.cache || (_.cache = {}), _.state || (_.state = {}), _.state.identityDetection = !0, _.depth = _.depth ? _.depth + 1 : 1;
          let x = _.depth > 1 ? g : f(g), y = { data: x }, w = _.depth > 1 ? S : f(S);
          _.master || (_.master = x);
          let k = function(T) {
            return T && T.verbose ? { warn: function() {
              var R = Array.prototype.slice.call(arguments);
              console.warn.apply(console, R);
            } } : { warn: function() {
            } };
          }(_), A = 1;
          for (; A > 0; ) A = 0, p(y, _.state, function(T, R, I) {
            if (m(T, R)) {
              let B = T[R];
              if (A++, _.cache[B]) {
                let L = _.cache[B];
                if (L.resolved) k.warn("Patching %s for %s", B, L.path), I.parent[I.pkey] = L.data, _.$ref && typeof I.parent[I.pkey] == "object" && I.parent[I.pkey] !== null && (I.parent[I.pkey][_.$ref] = B);
                else {
                  if (B === L.path) throw new Error(`Tight circle at ${L.path}`);
                  k.warn("Unresolved ref"), I.parent[I.pkey] = d(L.source, L.path), I.parent[I.pkey] === !1 && (I.parent[I.pkey] = d(L.source, L.key)), _.$ref && typeof I.parent[I.pkey] == "object" && I.parent[I.pkey] !== null && (I.parent[_.$ref] = B);
                }
              } else {
                let L = {};
                L.path = I.path.split("/$ref")[0], L.key = B, k.warn("Dereffing %s at %s", B, L.path), L.source = w, L.data = d(L.source, L.key), L.data === !1 && (L.data = d(_.master, L.key), L.source = _.master), L.data === !1 && k.warn("Missing $ref target", L.key), _.cache[B] = L, L.data = I.parent[I.pkey] = v(d(L.source, L.key), L.source, _), _.$ref && typeof I.parent[I.pkey] == "object" && I.parent[I.pkey] !== null && (I.parent[I.pkey][_.$ref] = B), L.resolved = !0;
              }
            }
          });
          return y.data;
        } };
      }, 592: function(o) {
        o.exports = { isRef: function(a, l) {
          return l === "$ref" && !!a && typeof a[l] == "string";
        } };
      }, 53: function(o) {
        function a(l) {
          return l.replace(/\~1/g, "/").replace(/~0/g, "~");
        }
        o.exports = { jptr: function(l, p, f) {
          if (l === void 0) return !1;
          if (!p || typeof p != "string" || p === "#") return f !== void 0 ? f : l;
          if (p.indexOf("#") >= 0) {
            let m = p.split("#");
            if (m[0]) return !1;
            p = m[1], p = decodeURIComponent(p.slice(1).split("+").join(" "));
          }
          p.startsWith("/") && (p = p.slice(1));
          let d = p.split("/");
          for (let m = 0; m < d.length; m++) {
            d[m] = a(d[m]);
            let v = f !== void 0 && m == d.length - 1, g = parseInt(d[m], 10);
            if (!Array.isArray(l) || isNaN(g) || g.toString() !== d[m] ? g = Array.isArray(l) && d[m] === "-" ? -2 : -1 : d[m] = m > 0 ? d[m - 1] : "", g != -1 || l && l.hasOwnProperty(d[m])) if (g >= 0) v && (l[g] = f), l = l[g];
            else {
              if (g === -2) return v ? (Array.isArray(l) && l.push(f), f) : void 0;
              v && (l[d[m]] = f), l = l[d[m]];
            }
            else {
              if (f === void 0 || typeof l != "object" || Array.isArray(l)) return !1;
              l[d[m]] = v ? f : d[m + 1] === "0" || d[m + 1] === "-" ? [] : {}, l = l[d[m]];
            }
          }
          return l;
        }, jpescape: function(l) {
          return l.replace(/\~/g, "~0").replace(/\//g, "~1");
        }, jpunescape: a };
      }, 401: function(o, a, l) {
        const p = l(53).jpescape;
        o.exports = { recurse: function f(d, m, v) {
          if (m || (m = { depth: 0 }), m.depth || (m = Object.assign({}, { path: "#", depth: 0, pkey: "", parent: {}, payload: {}, seen: /* @__PURE__ */ new WeakMap(), identity: !1, identityDetection: !1 }, m)), typeof d != "object") return;
          let g = m.path;
          for (let S in d) {
            if (m.key = S, m.path = m.path + "/" + encodeURIComponent(p(S)), m.identityPath = m.seen.get(d[S]), m.identity = m.identityPath !== void 0, d.hasOwnProperty(S) && v(d, S, m), typeof d[S] == "object" && !m.identity) {
              m.identityDetection && !Array.isArray(d[S]) && d[S] !== null && m.seen.set(d[S], m.path);
              let _ = {};
              _.parent = d, _.path = m.path, _.depth = m.depth ? m.depth + 1 : 1, _.pkey = S, _.payload = m.payload, _.seen = m.seen, _.identity = !1, _.identityDetection = m.identityDetection, f(d[S], _, v);
            }
            m.path = g;
          }
        } };
      }, 232: function(o, a, l) {
        l.r(a);
        var p = l(379), f = l.n(p), d = l(795), m = l.n(d), v = l(569), g = l.n(v), S = l(565), _ = l.n(S), x = l(216), y = l.n(x), w = l(589), k = l.n(w), A = l(260), T = {};
        T.styleTagTransform = k(), T.setAttributes = _(), T.insert = g().bind(null, "head"), T.domAPI = m(), T.insertStyleElement = y(), f()(A.Z, T), a.default = A.Z && A.Z.locals ? A.Z.locals : void 0;
      }, 379: function(o) {
        var a = [];
        function l(d) {
          for (var m = -1, v = 0; v < a.length; v++) if (a[v].identifier === d) {
            m = v;
            break;
          }
          return m;
        }
        function p(d, m) {
          for (var v = {}, g = [], S = 0; S < d.length; S++) {
            var _ = d[S], x = m.base ? _[0] + m.base : _[0], y = v[x] || 0, w = "".concat(x, " ").concat(y);
            v[x] = y + 1;
            var k = l(w), A = { css: _[1], media: _[2], sourceMap: _[3], supports: _[4], layer: _[5] };
            if (k !== -1) a[k].references++, a[k].updater(A);
            else {
              var T = f(A, m);
              m.byIndex = S, a.splice(S, 0, { identifier: w, updater: T, references: 1 });
            }
            g.push(w);
          }
          return g;
        }
        function f(d, m) {
          var v = m.domAPI(m);
          return v.update(d), function(g) {
            if (g) {
              if (g.css === d.css && g.media === d.media && g.sourceMap === d.sourceMap && g.supports === d.supports && g.layer === d.layer) return;
              v.update(d = g);
            } else v.remove();
          };
        }
        o.exports = function(d, m) {
          var v = p(d = d || [], m = m || {});
          return function(g) {
            g = g || [];
            for (var S = 0; S < v.length; S++) {
              var _ = l(v[S]);
              a[_].references--;
            }
            for (var x = p(g, m), y = 0; y < v.length; y++) {
              var w = l(v[y]);
              a[w].references === 0 && (a[w].updater(), a.splice(w, 1));
            }
            v = x;
          };
        };
      }, 569: function(o) {
        var a = {};
        o.exports = function(l, p) {
          var f = function(d) {
            if (a[d] === void 0) {
              var m = document.querySelector(d);
              if (window.HTMLIFrameElement && m instanceof window.HTMLIFrameElement) try {
                m = m.contentDocument.head;
              } catch {
                m = null;
              }
              a[d] = m;
            }
            return a[d];
          }(l);
          if (!f) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          f.appendChild(p);
        };
      }, 216: function(o) {
        o.exports = function(a) {
          var l = document.createElement("style");
          return a.setAttributes(l, a.attributes), a.insert(l, a.options), l;
        };
      }, 565: function(o, a, l) {
        o.exports = function(p) {
          var f = l.nc;
          f && p.setAttribute("nonce", f);
        };
      }, 795: function(o) {
        o.exports = function(a) {
          var l = a.insertStyleElement(a);
          return { update: function(p) {
            (function(f, d, m) {
              var v = "";
              m.supports && (v += "@supports (".concat(m.supports, ") {")), m.media && (v += "@media ".concat(m.media, " {"));
              var g = m.layer !== void 0;
              g && (v += "@layer".concat(m.layer.length > 0 ? " ".concat(m.layer) : "", " {")), v += m.css, g && (v += "}"), m.media && (v += "}"), m.supports && (v += "}");
              var S = m.sourceMap;
              S && typeof btoa < "u" && (v += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(S)))), " */")), d.styleTagTransform(v, f, d.options);
            })(l, a, p);
          }, remove: function() {
            (function(p) {
              if (p.parentNode === null) return !1;
              p.parentNode.removeChild(p);
            })(l);
          } };
        };
      }, 589: function(o) {
        o.exports = function(a, l) {
          if (l.styleSheet) l.styleSheet.cssText = a;
          else {
            for (; l.firstChild; ) l.removeChild(l.firstChild);
            l.appendChild(document.createTextNode(a));
          }
        };
      }, 925: function(o, a, l) {
        const p = l(825), f = l(416), d = (l(470), l(766)), m = l(416), v = l(66), g = l(53), S = g.jptr, _ = l(592).isRef, x = l(683).clone, y = l(683).circularClone, w = l(401).recurse, k = l(856), A = l(804), T = l(342), R = l(711).statusCodes, I = l(109).i8, B = "3.0.0";
        let L;
        class Y extends Error {
          constructor(N) {
            super(N), this.name = "S2OError";
          }
        }
        function Q(C, N) {
          let J = new Y(C);
          if (J.options = N, !N.promise) throw J;
          N.promise.reject(J);
        }
        function re(C, N, J) {
          J.warnOnly ? N[J.warnProperty || "x-s2o-warning"] = C : Q(C, J);
        }
        function oe(C, N) {
          A.walkSchema(C, {}, {}, function(J, X, ae) {
            (function(U, W) {
              if (U["x-required"] && Array.isArray(U["x-required"]) && (U.required || (U.required = []), U.required = U.required.concat(U["x-required"]), delete U["x-required"]), U["x-anyOf"] && (U.anyOf = U["x-anyOf"], delete U["x-anyOf"]), U["x-oneOf"] && (U.oneOf = U["x-oneOf"], delete U["x-oneOf"]), U["x-not"] && (U.not = U["x-not"], delete U["x-not"]), typeof U["x-nullable"] == "boolean" && (U.nullable = U["x-nullable"], delete U["x-nullable"]), typeof U["x-discriminator"] == "object" && typeof U["x-discriminator"].propertyName == "string") {
                U.discriminator = U["x-discriminator"], delete U["x-discriminator"];
                for (let ve in U.discriminator.mapping) {
                  let he = U.discriminator.mapping[ve];
                  he.startsWith("#/definitions/") && (U.discriminator.mapping[ve] = he.replace("#/definitions/", "#/components/schemas/"));
                }
              }
            })(J), function(U, W, ve) {
              if (U.nullable && ve.patches++, U.discriminator && typeof U.discriminator == "string" && (U.discriminator = { propertyName: U.discriminator }), U.items && Array.isArray(U.items) && (U.items.length === 0 ? U.items = {} : U.items.length === 1 ? U.items = U.items[0] : U.items = { anyOf: U.items }), U.type && Array.isArray(U.type)) if (ve.patch) {
                if (ve.patches++, U.type.length === 0) delete U.type;
                else {
                  U.oneOf || (U.oneOf = []);
                  for (let he of U.type) {
                    let Te = {};
                    if (he === "null") U.nullable = !0;
                    else {
                      Te.type = he;
                      for (let Se of T.arrayProperties) U.prop !== void 0 && (Te[Se] = U[Se], delete U[Se]);
                    }
                    Te.type && U.oneOf.push(Te);
                  }
                  delete U.type, U.oneOf.length === 0 ? delete U.oneOf : U.oneOf.length < 2 && (U.type = U.oneOf[0].type, Object.keys(U.oneOf[0]).length > 1 && re("Lost properties from oneOf", U, ve), delete U.oneOf);
                }
                U.type && Array.isArray(U.type) && U.type.length === 1 && (U.type = U.type[0]);
              } else Q("(Patchable) schema type must not be an array", ve);
              U.type && U.type === "null" && (delete U.type, U.nullable = !0), U.type !== "array" || U.items || (U.items = {}), U.type === "file" && (U.type = "string", U.format = "binary"), typeof U.required == "boolean" && (U.required && U.name && (W.required === void 0 && (W.required = []), Array.isArray(W.required) && W.required.push(U.name)), delete U.required), U.xml && typeof U.xml.namespace == "string" && (U.xml.namespace || delete U.xml.namespace), U.allowEmptyValue !== void 0 && (ve.patches++, delete U.allowEmptyValue);
            }(J, X, N);
          });
        }
        function ce(C, N, J) {
          let X = J.payload.options;
          if (_(C, N)) {
            if (!C[N].startsWith("#/components/")) {
              if (C[N] === "#/consumes") delete C[N], J.parent[J.pkey] = x(X.openapi.consumes);
              else if (C[N] === "#/produces") delete C[N], J.parent[J.pkey] = x(X.openapi.produces);
              else if (C[N].startsWith("#/definitions/")) {
                let U = C[N].replace("#/definitions/", "").split("/");
                const W = g.jpunescape(U[0]);
                let ve = L.schemas[decodeURIComponent(W)];
                ve ? U[0] = ve : re("Could not resolve reference " + C[N], C, X), C[N] = "#/components/schemas/" + U.join("/");
              } else if (C[N].startsWith("#/parameters/")) C[N] = "#/components/parameters/" + T.sanitise(C[N].replace("#/parameters/", ""));
              else if (C[N].startsWith("#/responses/")) C[N] = "#/components/responses/" + T.sanitise(C[N].replace("#/responses/", ""));
              else if (C[N].startsWith("#")) {
                let U = x(g.jptr(X.openapi, C[N]));
                if (U === !1) re("direct $ref not found " + C[N], C, X);
                else if (X.refmap[C[N]]) C[N] = X.refmap[C[N]];
                else {
                  let W = C[N];
                  W = W.replace("/properties/headers/", ""), W = W.replace("/properties/responses/", ""), W = W.replace("/properties/parameters/", ""), W = W.replace("/properties/schemas/", "");
                  let ve = "schemas", he = W.lastIndexOf("/schema");
                  if (ve = W.indexOf("/headers/") > he ? "headers" : W.indexOf("/responses/") > he ? "responses" : W.indexOf("/example") > he ? "examples" : W.indexOf("/x-") > he ? "extensions" : W.indexOf("/parameters/") > he ? "parameters" : "schemas", ve === "schemas" && oe(U, X), ve !== "responses" && ve !== "extensions") {
                    let Te = ve.substr(0, ve.length - 1);
                    Te === "parameter" && U.name && U.name === T.sanitise(U.name) && (Te = encodeURIComponent(U.name));
                    let Se = 1;
                    for (C["x-miro"] && (ae = (ae = C["x-miro"]).indexOf("#") >= 0 ? ae.split("#")[1].split("/").pop() : ae.split("/").pop().split(".")[0], Te = encodeURIComponent(T.sanitise(ae)), Se = ""); g.jptr(X.openapi, "#/components/" + ve + "/" + Te + Se); ) Se = Se === "" ? 2 : ++Se;
                    let O = "#/components/" + ve + "/" + Te + Se, M = "";
                    ve === "examples" && (U = { value: U }, M = "/value"), g.jptr(X.openapi, O, U), X.refmap[C[N]] = O + M, C[N] = O + M;
                  }
                }
              }
            }
            if (delete C["x-miro"], Object.keys(C).length > 1) {
              const U = C[N], W = J.path.indexOf("/schema") >= 0;
              X.refSiblings === "preserve" || (W && X.refSiblings === "allOf" ? (delete C.$ref, J.parent[J.pkey] = { allOf: [{ $ref: U }, C] }) : J.parent[J.pkey] = { $ref: U });
            }
          }
          var ae;
          if (N === "x-ms-odata" && typeof C[N] == "string" && C[N].startsWith("#/")) {
            let U = C[N].replace("#/definitions/", "").replace("#/components/schemas/", "").split("/"), W = L.schemas[decodeURIComponent(U[0])];
            W ? U[0] = W : re("Could not resolve reference " + C[N], C, X), C[N] = "#/components/schemas/" + U.join("/");
          }
        }
        function pe(C) {
          for (let N in C) for (let J in C[N]) {
            let X = T.sanitise(J);
            J !== X && (C[N][X] = C[N][J], delete C[N][J]);
          }
        }
        function fe(C, N) {
          if (C.type === "basic" && (C.type = "http", C.scheme = "basic"), C.type === "oauth2") {
            let J = {}, X = C.flow;
            C.flow === "application" && (X = "clientCredentials"), C.flow === "accessCode" && (X = "authorizationCode"), C.authorizationUrl !== void 0 && (J.authorizationUrl = C.authorizationUrl.split("?")[0].trim() || "/"), typeof C.tokenUrl == "string" && (J.tokenUrl = C.tokenUrl.split("?")[0].trim() || "/"), J.scopes = C.scopes || {}, C.flows = {}, C.flows[X] = J, delete C.flow, delete C.authorizationUrl, delete C.tokenUrl, delete C.scopes, C.name !== void 0 && (N.patch ? (N.patches++, delete C.name) : Q("(Patchable) oauth2 securitySchemes should not have name property", N));
          }
        }
        function G(C) {
          return C && !C["x-s2o-delete"];
        }
        function Z(C, N) {
          if (C.$ref) C.$ref = C.$ref.replace("#/responses/", "#/components/responses/");
          else {
            C.type && !C.schema && (C.schema = {}), C.type && (C.schema.type = C.type), C.items && C.items.type !== "array" && (C.items.collectionFormat !== C.collectionFormat && re("Nested collectionFormats are not supported", C, N), delete C.items.collectionFormat), C.type === "array" ? (C.collectionFormat === "ssv" ? re("collectionFormat:ssv is no longer supported for headers", C, N) : C.collectionFormat === "pipes" ? re("collectionFormat:pipes is no longer supported for headers", C, N) : C.collectionFormat === "multi" ? C.explode = !0 : C.collectionFormat === "tsv" ? (re("collectionFormat:tsv is no longer supported", C, N), C["x-collectionFormat"] = "tsv") : C.style = "simple", delete C.collectionFormat) : C.collectionFormat && (N.patch ? (N.patches++, delete C.collectionFormat) : Q("(Patchable) collectionFormat is only applicable to header.type array", N)), delete C.type;
            for (let J of T.parameterTypeProperties) C[J] !== void 0 && (C.schema[J] = C[J], delete C[J]);
            for (let J of T.arrayProperties) C[J] !== void 0 && (C.schema[J] = C[J], delete C[J]);
          }
        }
        function K(C, N) {
          if (C.$ref.indexOf("#/parameters/") >= 0) {
            let J = C.$ref.split("#/parameters/");
            C.$ref = J[0] + "#/components/parameters/" + T.sanitise(J[1]);
          }
          C.$ref.indexOf("#/definitions/") >= 0 && re("Definition used as parameter", C, N);
        }
        function z(C, N, J, X, ae, U, W) {
          let ve, he = {}, Te = !0;
          if (N && N.consumes && typeof N.consumes == "string") {
            if (!W.patch) return Q("(Patchable) operation.consumes must be an array", W);
            W.patches++, N.consumes = [N.consumes];
          }
          Array.isArray(U.consumes) || delete U.consumes;
          let Se = ((N ? N.consumes : null) || U.consumes || []).filter(T.uniqueOnly);
          if (C && C.$ref && typeof C.$ref == "string") {
            K(C, W);
            let O = decodeURIComponent(C.$ref.replace("#/components/parameters/", "")), M = !1, le = U.components.parameters[O];
            if (le && !le["x-s2o-delete"] || !C.$ref.startsWith("#/") || (C["x-s2o-delete"] = !0, M = !0), M) {
              let ye = C.$ref, be = S(U, C.$ref);
              !be && ye.startsWith("#/") ? re("Could not resolve reference " + ye, C, W) : be && (C = be);
            }
          }
          if (C && (C.name || C.in)) {
            typeof C["x-deprecated"] == "boolean" && (C.deprecated = C["x-deprecated"], delete C["x-deprecated"]), C["x-example"] !== void 0 && (C.example = C["x-example"], delete C["x-example"]), C.in === "body" || C.type || (W.patch ? (W.patches++, C.type = "string") : Q("(Patchable) parameter.type is mandatory for non-body parameters", W)), C.type && typeof C.type == "object" && C.type.$ref && (C.type = S(U, C.type.$ref)), C.type === "file" && (C["x-s2o-originalType"] = C.type, ve = C.type), C.description && typeof C.description == "object" && C.description.$ref && (C.description = S(U, C.description.$ref)), C.description === null && delete C.description;
            let O = C.collectionFormat;
            if (C.type !== "array" || O || (O = "csv"), O && (C.type !== "array" && (W.patch ? (W.patches++, delete C.collectionFormat) : Q("(Patchable) collectionFormat is only applicable to param.type array", W)), O !== "csv" || C.in !== "query" && C.in !== "cookie" || (C.style = "form", C.explode = !1), O !== "csv" || C.in !== "path" && C.in !== "header" || (C.style = "simple"), O === "ssv" && (C.in === "query" ? C.style = "spaceDelimited" : re("collectionFormat:ssv is no longer supported except for in:query parameters", C, W)), O === "pipes" && (C.in === "query" ? C.style = "pipeDelimited" : re("collectionFormat:pipes is no longer supported except for in:query parameters", C, W)), O === "multi" && (C.explode = !0), O === "tsv" && (re("collectionFormat:tsv is no longer supported", C, W), C["x-collectionFormat"] = "tsv"), delete C.collectionFormat), C.type && C.type !== "body" && C.in !== "formData") if (C.items && C.schema) re("parameter has array,items and schema", C, W);
            else {
              C.schema && W.patches++, C.schema && typeof C.schema == "object" || (C.schema = {}), C.schema.type = C.type, C.items && (C.schema.items = C.items, delete C.items, w(C.schema.items, null, function(M, le, ye) {
                le === "collectionFormat" && typeof M[le] == "string" && (O && M[le] !== O && re("Nested collectionFormats are not supported", C, W), delete M[le]);
              }));
              for (let M of T.parameterTypeProperties) C[M] !== void 0 && (C.schema[M] = C[M]), delete C[M];
            }
            C.schema && oe(C.schema, W), C["x-ms-skip-url-encoding"] && C.in === "query" && (C.allowReserved = !0, delete C["x-ms-skip-url-encoding"]);
          }
          if (C && C.in === "formData") {
            Te = !1, he.content = {};
            let O = "application/x-www-form-urlencoded";
            if (Se.length && Se.indexOf("multipart/form-data") >= 0 && (O = "multipart/form-data"), he.content[O] = {}, C.schema) he.content[O].schema = C.schema, C.schema.$ref && (he["x-s2o-name"] = decodeURIComponent(C.schema.$ref.replace("#/components/schemas/", "")));
            else {
              he.content[O].schema = {}, he.content[O].schema.type = "object", he.content[O].schema.properties = {}, he.content[O].schema.properties[C.name] = {};
              let M = he.content[O].schema, le = he.content[O].schema.properties[C.name];
              C.description && (le.description = C.description), C.example && (le.example = C.example), C.type && (le.type = C.type);
              for (let ye of T.parameterTypeProperties) C[ye] !== void 0 && (le[ye] = C[ye]);
              C.required === !0 && (M.required || (M.required = []), M.required.push(C.name), he.required = !0), C.default !== void 0 && (le.default = C.default), le.properties && (le.properties = C.properties), C.allOf && (le.allOf = C.allOf), C.type === "array" && C.items && (le.items = C.items, le.items.collectionFormat && delete le.items.collectionFormat), ve !== "file" && C["x-s2o-originalType"] !== "file" || (le.type = "string", le.format = "binary"), te(C, le);
            }
          } else C && C.type === "file" && (C.required && (he.required = C.required), he.content = {}, he.content["application/octet-stream"] = {}, he.content["application/octet-stream"].schema = {}, he.content["application/octet-stream"].schema.type = "string", he.content["application/octet-stream"].schema.format = "binary", te(C, he));
          if (C && C.in === "body") {
            he.content = {}, C.name && (he["x-s2o-name"] = (N && N.operationId ? T.sanitiseAll(N.operationId) : "") + ("_" + C.name).toCamelCase()), C.description && (he.description = C.description), C.required && (he.required = C.required), N && W.rbname && C.name && (N[W.rbname] = C.name), C.schema && C.schema.$ref ? he["x-s2o-name"] = decodeURIComponent(C.schema.$ref.replace("#/components/schemas/", "")) : C.schema && C.schema.type === "array" && C.schema.items && C.schema.items.$ref && (he["x-s2o-name"] = decodeURIComponent(C.schema.items.$ref.replace("#/components/schemas/", "")) + "Array"), Se.length || Se.push("application/json");
            for (let O of Se) he.content[O] = {}, he.content[O].schema = x(C.schema || {}), oe(he.content[O].schema, W);
            te(C, he);
          }
          if (Object.keys(he).length > 0 && (C["x-s2o-delete"] = !0, N) && (N.requestBody && Te ? (N.requestBody["x-s2o-overloaded"] = !0, re("Operation " + (N.operationId || ae) + " has multiple requestBodies", N, W)) : (N.requestBody || (N = J[X] = function(O, M) {
            let le = {};
            for (let ye of Object.keys(O)) le[ye] = O[ye], ye === "parameters" && (le.requestBody = {}, M.rbname && (le[M.rbname] = ""));
            return le.requestBody = {}, le;
          }(N, W)), N.requestBody.content && N.requestBody.content["multipart/form-data"] && N.requestBody.content["multipart/form-data"].schema && N.requestBody.content["multipart/form-data"].schema.properties && he.content["multipart/form-data"] && he.content["multipart/form-data"].schema && he.content["multipart/form-data"].schema.properties ? (N.requestBody.content["multipart/form-data"].schema.properties = Object.assign(N.requestBody.content["multipart/form-data"].schema.properties, he.content["multipart/form-data"].schema.properties), N.requestBody.content["multipart/form-data"].schema.required = (N.requestBody.content["multipart/form-data"].schema.required || []).concat(he.content["multipart/form-data"].schema.required || []), N.requestBody.content["multipart/form-data"].schema.required.length || delete N.requestBody.content["multipart/form-data"].schema.required) : N.requestBody.content && N.requestBody.content["application/x-www-form-urlencoded"] && N.requestBody.content["application/x-www-form-urlencoded"].schema && N.requestBody.content["application/x-www-form-urlencoded"].schema.properties && he.content["application/x-www-form-urlencoded"] && he.content["application/x-www-form-urlencoded"].schema && he.content["application/x-www-form-urlencoded"].schema.properties ? (N.requestBody.content["application/x-www-form-urlencoded"].schema.properties = Object.assign(N.requestBody.content["application/x-www-form-urlencoded"].schema.properties, he.content["application/x-www-form-urlencoded"].schema.properties), N.requestBody.content["application/x-www-form-urlencoded"].schema.required = (N.requestBody.content["application/x-www-form-urlencoded"].schema.required || []).concat(he.content["application/x-www-form-urlencoded"].schema.required || []), N.requestBody.content["application/x-www-form-urlencoded"].schema.required.length || delete N.requestBody.content["application/x-www-form-urlencoded"].schema.required) : (N.requestBody = Object.assign(N.requestBody, he), N.requestBody["x-s2o-name"] || (N.requestBody.schema && N.requestBody.schema.$ref ? N.requestBody["x-s2o-name"] = decodeURIComponent(N.requestBody.schema.$ref.replace("#/components/schemas/", "")).split("/").join("") : N.operationId && (N.requestBody["x-s2o-name"] = T.sanitiseAll(N.operationId)))))), C && !C["x-s2o-delete"]) {
            delete C.type;
            for (let O of T.parameterTypeProperties) delete C[O];
            C.in !== "path" || C.required !== void 0 && C.required === !0 || (W.patch ? (W.patches++, C.required = !0) : Q("(Patchable) path parameters must be required:true [" + C.name + " in " + ae + "]", W));
          }
          return N;
        }
        function te(C, N) {
          for (let J in C) J.startsWith("x-") && !J.startsWith("x-s2o") && (N[J] = C[J]);
        }
        function q(C, N, J, X, ae) {
          if (!C) return !1;
          if (C.$ref && typeof C.$ref == "string") C.$ref.indexOf("#/definitions/") >= 0 ? re("definition used as response: " + C.$ref, C, ae) : C.$ref.startsWith("#/responses/") && (C.$ref = "#/components/responses/" + T.sanitise(decodeURIComponent(C.$ref.replace("#/responses/", ""))));
          else {
            if ((C.description === void 0 || C.description === null || C.description === "" && ae.patch) && (ae.patch ? typeof C != "object" || Array.isArray(C) || (ae.patches++, C.description = R[C] || "") : Q("(Patchable) response.description is mandatory", ae)), C.schema !== void 0) {
              if (oe(C.schema, ae), C.schema.$ref && typeof C.schema.$ref == "string" && C.schema.$ref.startsWith("#/responses/") && (C.schema.$ref = "#/components/responses/" + T.sanitise(decodeURIComponent(C.schema.$ref.replace("#/responses/", "")))), J && J.produces && typeof J.produces == "string") {
                if (!ae.patch) return Q("(Patchable) operation.produces must be an array", ae);
                ae.patches++, J.produces = [J.produces];
              }
              X.produces && !Array.isArray(X.produces) && delete X.produces;
              let U = ((J ? J.produces : null) || X.produces || []).filter(T.uniqueOnly);
              U.length || U.push("*/*"), C.content = {};
              for (let W of U) {
                if (C.content[W] = {}, C.content[W].schema = x(C.schema), C.examples && C.examples[W]) {
                  let ve = {};
                  ve.value = C.examples[W], C.content[W].examples = {}, C.content[W].examples.response = ve, delete C.examples[W];
                }
                C.content[W].schema.type === "file" && (C.content[W].schema = { type: "string", format: "binary" });
              }
              delete C.schema;
            }
            for (let U in C.examples) C.content || (C.content = {}), C.content[U] || (C.content[U] = {}), C.content[U].examples = {}, C.content[U].examples.response = {}, C.content[U].examples.response.value = C.examples[U];
            if (delete C.examples, C.headers) for (let U in C.headers) U.toLowerCase() === "status code" ? ae.patch ? (ae.patches++, delete C.headers[U]) : Q('(Patchable) "Status Code" is not a valid header', ae) : Z(C.headers[U], ae);
          }
        }
        function j(C, N, J, X, ae) {
          for (let U in C) {
            let W = C[U];
            W && W["x-trace"] && typeof W["x-trace"] == "object" && (W.trace = W["x-trace"], delete W["x-trace"]), W && W["x-summary"] && typeof W["x-summary"] == "string" && (W.summary = W["x-summary"], delete W["x-summary"]), W && W["x-description"] && typeof W["x-description"] == "string" && (W.description = W["x-description"], delete W["x-description"]), W && W["x-servers"] && Array.isArray(W["x-servers"]) && (W.servers = W["x-servers"], delete W["x-servers"]);
            for (let ve in W) if (T.httpMethods.indexOf(ve) >= 0 || ve === "x-amazon-apigateway-any-method") {
              let he = W[ve];
              if (he && he.parameters && Array.isArray(he.parameters)) {
                if (W.parameters) for (let Te of W.parameters) typeof Te.$ref == "string" && (K(Te, J), Te = S(ae, Te.$ref)), he.parameters.find(function(Se, O, M) {
                  return Se.name === Te.name && Se.in === Te.in;
                }) || Te.in !== "formData" && Te.in !== "body" && Te.type !== "file" || (he = z(Te, he, W, ve, U, ae, J), J.rbname && he[J.rbname] === "" && delete he[J.rbname]);
                for (let Te of he.parameters) he = z(Te, he, W, ve, ve + ":" + U, ae, J);
                J.rbname && he[J.rbname] === "" && delete he[J.rbname], J.debug || he.parameters && (he.parameters = he.parameters.filter(G));
              }
              if (he && he.security && pe(he.security), typeof he == "object") {
                if (!he.responses) {
                  let Te = { description: "Default response" };
                  he.responses = { default: Te };
                }
                for (let Te in he.responses) q(he.responses[Te], 0, he, ae, J);
              }
              if (he && he["x-servers"] && Array.isArray(he["x-servers"])) he.servers = he["x-servers"], delete he["x-servers"];
              else if (he && he.schemes && he.schemes.length) {
                for (let Te of he.schemes) if ((!ae.schemes || ae.schemes.indexOf(Te) < 0) && (he.servers || (he.servers = []), Array.isArray(ae.servers))) for (let Se of ae.servers) {
                  let O = x(Se), M = f.parse(O.url);
                  M.protocol = Te, O.url = M.format(), he.servers.push(O);
                }
              }
              if (J.debug && (he["x-s2o-consumes"] = he.consumes || [], he["x-s2o-produces"] = he.produces || []), he) {
                if (delete he.consumes, delete he.produces, delete he.schemes, he["x-ms-examples"]) {
                  for (let Te in he["x-ms-examples"]) {
                    let Se = he["x-ms-examples"][Te], O = T.sanitiseAll(Te);
                    if (Se.parameters) for (let M in Se.parameters) {
                      let le = Se.parameters[M];
                      for (let ye of (he.parameters || []).concat(W.parameters || [])) ye.$ref && (ye = g.jptr(ae, ye.$ref)), ye.name !== M || ye.example || (ye.examples || (ye.examples = {}), ye.examples[Te] = { value: le });
                    }
                    if (Se.responses) for (let M in Se.responses) {
                      if (Se.responses[M].headers) for (let le in Se.responses[M].headers) {
                        let ye = Se.responses[M].headers[le];
                        for (let be in he.responses[M].headers) be === le && (he.responses[M].headers[be].example = ye);
                      }
                      if (Se.responses[M].body && (ae.components.examples[O] = { value: x(Se.responses[M].body) }, he.responses[M] && he.responses[M].content)) for (let le in he.responses[M].content) {
                        let ye = he.responses[M].content[le];
                        ye.examples || (ye.examples = {}), ye.examples[Te] = { $ref: "#/components/examples/" + O };
                      }
                    }
                  }
                  delete he["x-ms-examples"];
                }
                if (he.parameters && he.parameters.length === 0 && delete he.parameters, he.requestBody) {
                  let Te = he.operationId ? T.sanitiseAll(he.operationId) : T.sanitiseAll(ve + U).toCamelCase(), Se = T.sanitise(he.requestBody["x-s2o-name"] || Te || "");
                  delete he.requestBody["x-s2o-name"];
                  let O = JSON.stringify(he.requestBody), M = T.hash(O);
                  if (!X[M]) {
                    let ye = {};
                    ye.name = Se, ye.body = he.requestBody, ye.refs = [], X[M] = ye;
                  }
                  let le = "#/" + N + "/" + encodeURIComponent(g.jpescape(U)) + "/" + ve + "/requestBody";
                  X[M].refs.push(le);
                }
              }
            }
            if (W && W.parameters) {
              for (let ve in W.parameters) z(W.parameters[ve], null, W, null, U, ae, J);
              !J.debug && Array.isArray(W.parameters) && (W.parameters = W.parameters.filter(G));
            }
          }
        }
        function H(C) {
          return C && C.url && typeof C.url == "string" && (C.url = C.url.split("{{").join("{"), C.url = C.url.split("}}").join("}"), C.url.replace(/\{(.+?)\}/g, function(N, J) {
            C.variables || (C.variables = {}), C.variables[J] = { default: "unknown" };
          })), C;
        }
        function F(C, N, J) {
          if (C.info === void 0 || C.info === null) {
            if (!N.patch) return J(new Y("(Patchable) info object is mandatory"));
            N.patches++, C.info = { version: "", title: "" };
          }
          if (typeof C.info != "object" || Array.isArray(C.info)) return J(new Y("info must be an object"));
          if (C.info.title === void 0 || C.info.title === null) {
            if (!N.patch) return J(new Y("(Patchable) info.title cannot be null"));
            N.patches++, C.info.title = "";
          }
          if (C.info.version === void 0 || C.info.version === null) {
            if (!N.patch) return J(new Y("(Patchable) info.version cannot be null"));
            N.patches++, C.info.version = "";
          }
          if (typeof C.info.version != "string") {
            if (!N.patch) return J(new Y("(Patchable) info.version must be a string"));
            N.patches++, C.info.version = C.info.version.toString();
          }
          if (C.info.logo !== void 0) {
            if (!N.patch) return J(new Y("(Patchable) info should not have logo property"));
            N.patches++, C.info["x-logo"] = C.info.logo, delete C.info.logo;
          }
          if (C.info.termsOfService !== void 0) {
            if (C.info.termsOfService === null) {
              if (!N.patch) return J(new Y("(Patchable) info.termsOfService cannot be null"));
              N.patches++, C.info.termsOfService = "";
            }
            try {
              new URL(C.info.termsOfService);
            } catch {
              if (!N.patch) return J(new Y("(Patchable) info.termsOfService must be a URL"));
              N.patches++, delete C.info.termsOfService;
            }
          }
        }
        function ue(C, N, J) {
          if (C.paths === void 0) {
            if (!N.patch) return J(new Y("(Patchable) paths object is mandatory"));
            N.patches++, C.paths = {};
          }
        }
        function ge(C, N, J) {
          return d(J, new Promise(function(X, ae) {
            if (C || (C = {}), N.original = C, N.text || (N.text = v.stringify(C)), N.externals = [], N.externalRefs = {}, N.rewriteRefs = !0, N.preserveMiro = !0, N.promise = {}, N.promise.resolve = X, N.promise.reject = ae, N.patches = 0, N.cache || (N.cache = {}), N.source && (N.cache[N.source] = N.original), function(W, ve) {
              const he = /* @__PURE__ */ new WeakSet();
              w(W, { identityDetection: !0 }, function(Te, Se, O) {
                typeof Te[Se] == "object" && Te[Se] !== null && (he.has(Te[Se]) ? ve.anchors ? Te[Se] = x(Te[Se]) : Q("YAML anchor or merge key at " + O.path, ve) : he.add(Te[Se]));
              });
            }(C, N), C.openapi && typeof C.openapi == "string" && C.openapi.startsWith("3.")) return N.openapi = y(C), F(N.openapi, N, ae), ue(N.openapi, N, ae), void k.optionalResolve(N).then(function() {
              return N.direct ? X(N.openapi) : X(N);
            }).catch(function(W) {
              console.warn(W), ae(W);
            });
            if (!C.swagger || C.swagger != "2.0") return ae(new Y("Unsupported swagger/OpenAPI version: " + (C.openapi ? C.openapi : C.swagger)));
            let U = N.openapi = {};
            if (U.openapi = typeof N.targetVersion == "string" && N.targetVersion.startsWith("3.") ? N.targetVersion : B, N.origin) {
              U["x-origin"] || (U["x-origin"] = []);
              let W = {};
              W.url = N.source || N.origin, W.format = "swagger", W.version = C.swagger, W.converter = {}, W.converter.url = "https://github.com/mermade/oas-kit", W.converter.version = I, U["x-origin"].push(W);
            }
            if (U = Object.assign(U, y(C)), delete U.swagger, w(U, {}, function(W, ve, he) {
              W[ve] === null && !ve.startsWith("x-") && ve !== "default" && he.path.indexOf("/example") < 0 && delete W[ve];
            }), C.host) for (let W of Array.isArray(C.schemes) ? C.schemes : [""]) {
              let ve = {}, he = (C.basePath || "").replace(/\/$/, "");
              ve.url = (W ? W + ":" : "") + "//" + C.host + he, H(ve), U.servers || (U.servers = []), U.servers.push(ve);
            }
            else if (C.basePath) {
              let W = {};
              W.url = C.basePath, H(W), U.servers || (U.servers = []), U.servers.push(W);
            }
            if (delete U.host, delete U.basePath, U["x-servers"] && Array.isArray(U["x-servers"]) && (U.servers = U["x-servers"], delete U["x-servers"]), C["x-ms-parameterized-host"]) {
              let W = C["x-ms-parameterized-host"], ve = {};
              ve.url = W.hostTemplate + (C.basePath ? C.basePath : ""), ve.variables = {};
              const he = ve.url.match(/\{\w+\}/g);
              for (let Te in W.parameters) {
                let Se = W.parameters[Te];
                Se.$ref && (Se = x(S(U, Se.$ref))), Te.startsWith("x-") || (delete Se.required, delete Se.type, delete Se.in, Se.default === void 0 && (Se.enum ? Se.default = Se.enum[0] : Se.default = "none"), Se.name || (Se.name = he[Te].replace("{", "").replace("}", "")), ve.variables[Se.name] = Se, delete Se.name);
              }
              U.servers || (U.servers = []), W.useSchemePrefix === !1 ? U.servers.push(ve) : C.schemes.forEach((Te) => {
                U.servers.push(Object.assign({}, ve, { url: Te + "://" + ve.url }));
              }), delete U["x-ms-parameterized-host"];
            }
            F(U, N, ae), ue(U, N, ae), typeof U.consumes == "string" && (U.consumes = [U.consumes]), typeof U.produces == "string" && (U.produces = [U.produces]), U.components = {}, U["x-callbacks"] && (U.components.callbacks = U["x-callbacks"], delete U["x-callbacks"]), U.components.examples = {}, U.components.headers = {}, U["x-links"] && (U.components.links = U["x-links"], delete U["x-links"]), U.components.parameters = U.parameters || {}, U.components.responses = U.responses || {}, U.components.requestBodies = {}, U.components.securitySchemes = U.securityDefinitions || {}, U.components.schemas = U.definitions || {}, delete U.definitions, delete U.responses, delete U.parameters, delete U.securityDefinitions, k.optionalResolve(N).then(function() {
              (function(W, ve) {
                let he = {};
                L = { schemas: {} }, W.security && pe(W.security);
                for (let Se in W.components.securitySchemes) {
                  let O = T.sanitise(Se);
                  Se !== O && (W.components.securitySchemes[O] && Q("Duplicate sanitised securityScheme name " + O, ve), W.components.securitySchemes[O] = W.components.securitySchemes[Se], delete W.components.securitySchemes[Se]), fe(W.components.securitySchemes[O], ve);
                }
                for (let Se in W.components.schemas) {
                  let O = T.sanitiseAll(Se), M = "";
                  if (Se !== O) {
                    for (; W.components.schemas[O + M]; ) M = M ? ++M : 2;
                    W.components.schemas[O + M] = W.components.schemas[Se], delete W.components.schemas[Se];
                  }
                  L.schemas[Se] = O + M, oe(W.components.schemas[O + M], ve);
                }
                ve.refmap = {}, w(W, { payload: { options: ve } }, ce), function(Se, O) {
                  for (let M in O.refmap) g.jptr(Se, M, { $ref: O.refmap[M] });
                }(W, ve);
                for (let Se in W.components.parameters) {
                  let O = T.sanitise(Se);
                  Se !== O && (W.components.parameters[O] && Q("Duplicate sanitised parameter name " + O, ve), W.components.parameters[O] = W.components.parameters[Se], delete W.components.parameters[Se]), z(W.components.parameters[O], null, null, null, O, W, ve);
                }
                for (let Se in W.components.responses) {
                  let O = T.sanitise(Se);
                  Se !== O && (W.components.responses[O] && Q("Duplicate sanitised response name " + O, ve), W.components.responses[O] = W.components.responses[Se], delete W.components.responses[Se]);
                  let M = W.components.responses[O];
                  if (q(M, 0, null, W, ve), M.headers) for (let le in M.headers) le.toLowerCase() === "status code" ? ve.patch ? (ve.patches++, delete M.headers[le]) : Q('(Patchable) "Status Code" is not a valid header', ve) : Z(M.headers[le], ve);
                }
                for (let Se in W.components.requestBodies) {
                  let O = W.components.requestBodies[Se], M = JSON.stringify(O), le = T.hash(M), ye = {};
                  ye.name = Se, ye.body = O, ye.refs = [], he[le] = ye;
                }
                if (j(W.paths, "paths", ve, he, W), W["x-ms-paths"] && j(W["x-ms-paths"], "x-ms-paths", ve, he, W), !ve.debug) for (let Se in W.components.parameters) W.components.parameters[Se]["x-s2o-delete"] && delete W.components.parameters[Se];
                ve.debug && (W["x-s2o-consumes"] = W.consumes || [], W["x-s2o-produces"] = W.produces || []), delete W.consumes, delete W.produces, delete W.schemes;
                let Te = [];
                if (W.components.requestBodies = {}, !ve.resolveInternal) {
                  let Se = 1;
                  for (let O in he) {
                    let M = he[O];
                    if (M.refs.length > 1) {
                      let le = "";
                      for (M.name || (M.name = "requestBody", le = Se++); Te.indexOf(M.name + le) >= 0; ) le = le ? ++le : 2;
                      M.name = M.name + le, Te.push(M.name), W.components.requestBodies[M.name] = x(M.body);
                      for (let ye in M.refs) {
                        let be = {};
                        be.$ref = "#/components/requestBodies/" + M.name, g.jptr(W, M.refs[ye], be);
                      }
                    }
                  }
                }
                W.components.responses && Object.keys(W.components.responses).length === 0 && delete W.components.responses, W.components.parameters && Object.keys(W.components.parameters).length === 0 && delete W.components.parameters, W.components.examples && Object.keys(W.components.examples).length === 0 && delete W.components.examples, W.components.requestBodies && Object.keys(W.components.requestBodies).length === 0 && delete W.components.requestBodies, W.components.securitySchemes && Object.keys(W.components.securitySchemes).length === 0 && delete W.components.securitySchemes, W.components.headers && Object.keys(W.components.headers).length === 0 && delete W.components.headers, W.components.schemas && Object.keys(W.components.schemas).length === 0 && delete W.components.schemas, W.components && Object.keys(W.components).length === 0 && delete W.components;
              })(N.openapi, N), N.direct ? X(N.openapi) : X(N);
            }).catch(function(W) {
              console.warn(W), ae(W);
            });
          }));
        }
        function Ae(C, N, J) {
          return d(J, new Promise(function(X, ae) {
            let U = null, W = null;
            try {
              U = JSON.parse(C), N.text = JSON.stringify(U, null, 2);
            } catch (ve) {
              W = ve;
              try {
                U = v.parse(C, { schema: "core", prettyErrors: !0 }), N.sourceYaml = !0, N.text = C;
              } catch (he) {
                W = he;
              }
            }
            U ? ge(U, N).then((ve) => X(ve)).catch((ve) => ae(ve)) : ae(new Y(W ? W.message : "Could not parse string"));
          }));
        }
        o.exports = { S2OError: Y, targetVersion: B, convert: ge, convertObj: ge, convertUrl: function(C, N, J) {
          return d(J, new Promise(function(X, ae) {
            N.origin = !0, N.source || (N.source = C), N.verbose && console.warn("GET " + C), N.fetch || (N.fetch = m);
            const U = Object.assign({}, N.fetchOptions, { agent: N.agent });
            N.fetch(C, U).then(function(W) {
              if (W.status !== 200) throw new Y(`Received status code ${W.status}: ${C}`);
              return W.text();
            }).then(function(W) {
              Ae(W, N).then((ve) => X(ve)).catch((ve) => ae(ve));
            }).catch(function(W) {
              ae(W);
            });
          }));
        }, convertStr: Ae, convertFile: function(C, N, J) {
          return d(J, new Promise(function(X, ae) {
            p.readFile(C, N.encoding || "utf8", function(U, W) {
              U ? ae(U) : (N.sourceFile = C, Ae(W, N).then((ve) => X(ve)).catch((ve) => ae(ve)));
            });
          }));
        }, convertStream: function(C, N, J) {
          return d(J, new Promise(function(X, ae) {
            let U = "";
            C.on("data", function(W) {
              U += W;
            }).on("end", function() {
              Ae(U, N).then((W) => X(W)).catch((W) => ae(W));
            });
          }));
        } };
      }, 711: function(o, a, l) {
        const p = l(177);
        o.exports = { statusCodes: Object.assign({}, { default: "Default response", "1XX": "Informational", 103: "Early hints", "2XX": "Successful", "3XX": "Redirection", "4XX": "Client Error", "5XX": "Server Error", "7XX": "Developer Error" }, p.STATUS_CODES) };
      }, 595: function(o, a, l) {
        var p = l(314), f = ["add", "done", "toJS", "fromExternalJS", "load", "dispose", "search", "Worker"];
        o.exports = function() {
          var d = new Worker(URL.createObjectURL(new Blob([`/*! For license information please see 756674defce81e90acea.worker.js.LICENSE.txt */
!function(){var e={336:function(e,t,r){var n,i;!function(){var s,o,a,u,l,c,h,d,f,p,y,m,g,x,v,w,Q,k,S,E,L,P,b,T,O,I,R,F,C,N,j=function(e){var t=new j.Builder;return t.pipeline.add(j.trimmer,j.stopWordFilter,j.stemmer),t.searchPipeline.add(j.stemmer),e.call(t,t),t.build()};j.version="2.3.9",j.utils={},j.utils.warn=(s=this,function(e){s.console&&console.warn&&console.warn(e)}),j.utils.asString=function(e){return null==e?"":e.toString()},j.utils.clone=function(e){if(null==e)return e;for(var t=Object.create(null),r=Object.keys(e),n=0;n<r.length;n++){var i=r[n],s=e[i];if(Array.isArray(s))t[i]=s.slice();else{if("string"!=typeof s&&"number"!=typeof s&&"boolean"!=typeof s)throw new TypeError("clone is not deep and does not support nested objects");t[i]=s}}return t},j.FieldRef=function(e,t,r){this.docRef=e,this.fieldName=t,this._stringValue=r},j.FieldRef.joiner="/",j.FieldRef.fromString=function(e){var t=e.indexOf(j.FieldRef.joiner);if(-1===t)throw"malformed field ref string";var r=e.slice(0,t),n=e.slice(t+1);return new j.FieldRef(n,r,e)},j.FieldRef.prototype.toString=function(){return null==this._stringValue&&(this._stringValue=this.fieldName+j.FieldRef.joiner+this.docRef),this._stringValue},j.Set=function(e){if(this.elements=Object.create(null),e){this.length=e.length;for(var t=0;t<this.length;t++)this.elements[e[t]]=!0}else this.length=0},j.Set.complete={intersect:function(e){return e},union:function(){return this},contains:function(){return!0}},j.Set.empty={intersect:function(){return this},union:function(e){return e},contains:function(){return!1}},j.Set.prototype.contains=function(e){return!!this.elements[e]},j.Set.prototype.intersect=function(e){var t,r,n,i=[];if(e===j.Set.complete)return this;if(e===j.Set.empty)return e;this.length<e.length?(t=this,r=e):(t=e,r=this),n=Object.keys(t.elements);for(var s=0;s<n.length;s++){var o=n[s];o in r.elements&&i.push(o)}return new j.Set(i)},j.Set.prototype.union=function(e){return e===j.Set.complete?j.Set.complete:e===j.Set.empty?this:new j.Set(Object.keys(this.elements).concat(Object.keys(e.elements)))},j.idf=function(e,t){var r=0;for(var n in e)"_index"!=n&&(r+=Object.keys(e[n]).length);var i=(t-r+.5)/(r+.5);return Math.log(1+Math.abs(i))},j.Token=function(e,t){this.str=e||"",this.metadata=t||{}},j.Token.prototype.toString=function(){return this.str},j.Token.prototype.update=function(e){return this.str=e(this.str,this.metadata),this},j.Token.prototype.clone=function(e){return e=e||function(e){return e},new j.Token(e(this.str,this.metadata),this.metadata)},j.tokenizer=function(e,t){if(null==e||null==e)return[];if(Array.isArray(e))return e.map((function(e){return new j.Token(j.utils.asString(e).toLowerCase(),j.utils.clone(t))}));for(var r=e.toString().toLowerCase(),n=r.length,i=[],s=0,o=0;s<=n;s++){var a=s-o;if(r.charAt(s).match(j.tokenizer.separator)||s==n){if(a>0){var u=j.utils.clone(t)||{};u.position=[o,a],u.index=i.length,i.push(new j.Token(r.slice(o,s),u))}o=s+1}}return i},j.tokenizer.separator=/[\\s\\-]+/,j.Pipeline=function(){this._stack=[]},j.Pipeline.registeredFunctions=Object.create(null),j.Pipeline.registerFunction=function(e,t){t in this.registeredFunctions&&j.utils.warn("Overwriting existing registered function: "+t),e.label=t,j.Pipeline.registeredFunctions[e.label]=e},j.Pipeline.warnIfFunctionNotRegistered=function(e){e.label&&e.label in this.registeredFunctions||j.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\\n",e)},j.Pipeline.load=function(e){var t=new j.Pipeline;return e.forEach((function(e){var r=j.Pipeline.registeredFunctions[e];if(!r)throw new Error("Cannot load unregistered function: "+e);t.add(r)})),t},j.Pipeline.prototype.add=function(){Array.prototype.slice.call(arguments).forEach((function(e){j.Pipeline.warnIfFunctionNotRegistered(e),this._stack.push(e)}),this)},j.Pipeline.prototype.after=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");r+=1,this._stack.splice(r,0,t)},j.Pipeline.prototype.before=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");this._stack.splice(r,0,t)},j.Pipeline.prototype.remove=function(e){var t=this._stack.indexOf(e);-1!=t&&this._stack.splice(t,1)},j.Pipeline.prototype.run=function(e){for(var t=this._stack.length,r=0;r<t;r++){for(var n=this._stack[r],i=[],s=0;s<e.length;s++){var o=n(e[s],s,e);if(null!=o&&""!==o)if(Array.isArray(o))for(var a=0;a<o.length;a++)i.push(o[a]);else i.push(o)}e=i}return e},j.Pipeline.prototype.runString=function(e,t){var r=new j.Token(e,t);return this.run([r]).map((function(e){return e.toString()}))},j.Pipeline.prototype.reset=function(){this._stack=[]},j.Pipeline.prototype.toJSON=function(){return this._stack.map((function(e){return j.Pipeline.warnIfFunctionNotRegistered(e),e.label}))},j.Vector=function(e){this._magnitude=0,this.elements=e||[]},j.Vector.prototype.positionForIndex=function(e){if(0==this.elements.length)return 0;for(var t=0,r=this.elements.length/2,n=r-t,i=Math.floor(n/2),s=this.elements[2*i];n>1&&(s<e&&(t=i),s>e&&(r=i),s!=e);)n=r-t,i=t+Math.floor(n/2),s=this.elements[2*i];return s==e||s>e?2*i:s<e?2*(i+1):void 0},j.Vector.prototype.insert=function(e,t){this.upsert(e,t,(function(){throw"duplicate index"}))},j.Vector.prototype.upsert=function(e,t,r){this._magnitude=0;var n=this.positionForIndex(e);this.elements[n]==e?this.elements[n+1]=r(this.elements[n+1],t):this.elements.splice(n,0,e,t)},j.Vector.prototype.magnitude=function(){if(this._magnitude)return this._magnitude;for(var e=0,t=this.elements.length,r=1;r<t;r+=2){var n=this.elements[r];e+=n*n}return this._magnitude=Math.sqrt(e)},j.Vector.prototype.dot=function(e){for(var t=0,r=this.elements,n=e.elements,i=r.length,s=n.length,o=0,a=0,u=0,l=0;u<i&&l<s;)(o=r[u])<(a=n[l])?u+=2:o>a?l+=2:o==a&&(t+=r[u+1]*n[l+1],u+=2,l+=2);return t},j.Vector.prototype.similarity=function(e){return this.dot(e)/this.magnitude()||0},j.Vector.prototype.toArray=function(){for(var e=new Array(this.elements.length/2),t=1,r=0;t<this.elements.length;t+=2,r++)e[r]=this.elements[t];return e},j.Vector.prototype.toJSON=function(){return this.elements},j.stemmer=(o={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},a={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},h="^("+(l="[^aeiou][^aeiouy]*")+")?"+(c=(u="[aeiouy]")+"[aeiou]*")+l+"("+c+")?$",d="^("+l+")?"+c+l+c+l,f="^("+l+")?"+u,p=new RegExp("^("+l+")?"+c+l),y=new RegExp(d),m=new RegExp(h),g=new RegExp(f),x=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,w=/^(.+?)eed$/,Q=/^(.+?)(ed|ing)$/,k=/.$/,S=/(at|bl|iz)$/,E=new RegExp("([^aeiouylsz])\\\\1$"),L=new RegExp("^"+l+u+"[^aeiouwxy]$"),P=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,T=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,O=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,I=/^(.+?)(s|t)(ion)$/,R=/^(.+?)e$/,F=/ll$/,C=new RegExp("^"+l+u+"[^aeiouwxy]$"),N=function(e){var t,r,n,i,s,u,l;if(e.length<3)return e;if("y"==(n=e.substr(0,1))&&(e=n.toUpperCase()+e.substr(1)),s=v,(i=x).test(e)?e=e.replace(i,"$1$2"):s.test(e)&&(e=e.replace(s,"$1$2")),s=Q,(i=w).test(e)){var c=i.exec(e);(i=p).test(c[1])&&(i=k,e=e.replace(i,""))}else s.test(e)&&(t=(c=s.exec(e))[1],(s=g).test(t)&&(u=E,l=L,(s=S).test(e=t)?e+="e":u.test(e)?(i=k,e=e.replace(i,"")):l.test(e)&&(e+="e")));return(i=P).test(e)&&(e=(t=(c=i.exec(e))[1])+"i"),(i=b).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+o[r])),(i=T).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+a[r])),s=I,(i=O).test(e)?(t=(c=i.exec(e))[1],(i=y).test(t)&&(e=t)):s.test(e)&&(t=(c=s.exec(e))[1]+c[2],(s=y).test(t)&&(e=t)),(i=R).test(e)&&(t=(c=i.exec(e))[1],s=m,u=C,((i=y).test(t)||s.test(t)&&!u.test(t))&&(e=t)),s=y,(i=F).test(e)&&s.test(e)&&(i=k,e=e.replace(i,"")),"y"==n&&(e=n.toLowerCase()+e.substr(1)),e},function(e){return e.update(N)}),j.Pipeline.registerFunction(j.stemmer,"stemmer"),j.generateStopWordFilter=function(e){var t=e.reduce((function(e,t){return e[t]=t,e}),{});return function(e){if(e&&t[e.toString()]!==e.toString())return e}},j.stopWordFilter=j.generateStopWordFilter(["a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","do","does","either","else","ever","every","for","from","get","got","had","has","have","he","her","hers","him","his","how","however","i","if","in","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","this","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","while","who","whom","why","will","with","would","yet","you","your"]),j.Pipeline.registerFunction(j.stopWordFilter,"stopWordFilter"),j.trimmer=function(e){return e.update((function(e){return e.replace(/^\\W+/,"").replace(/\\W+$/,"")}))},j.Pipeline.registerFunction(j.trimmer,"trimmer"),j.TokenSet=function(){this.final=!1,this.edges={},this.id=j.TokenSet._nextId,j.TokenSet._nextId+=1},j.TokenSet._nextId=1,j.TokenSet.fromArray=function(e){for(var t=new j.TokenSet.Builder,r=0,n=e.length;r<n;r++)t.insert(e[r]);return t.finish(),t.root},j.TokenSet.fromClause=function(e){return"editDistance"in e?j.TokenSet.fromFuzzyString(e.term,e.editDistance):j.TokenSet.fromString(e.term)},j.TokenSet.fromFuzzyString=function(e,t){for(var r=new j.TokenSet,n=[{node:r,editsRemaining:t,str:e}];n.length;){var i=n.pop();if(i.str.length>0){var s,o=i.str.charAt(0);o in i.node.edges?s=i.node.edges[o]:(s=new j.TokenSet,i.node.edges[o]=s),1==i.str.length&&(s.final=!0),n.push({node:s,editsRemaining:i.editsRemaining,str:i.str.slice(1)})}if(0!=i.editsRemaining){if("*"in i.node.edges)var a=i.node.edges["*"];else a=new j.TokenSet,i.node.edges["*"]=a;if(0==i.str.length&&(a.final=!0),n.push({node:a,editsRemaining:i.editsRemaining-1,str:i.str}),i.str.length>1&&n.push({node:i.node,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)}),1==i.str.length&&(i.node.final=!0),i.str.length>=1){if("*"in i.node.edges)var u=i.node.edges["*"];else u=new j.TokenSet,i.node.edges["*"]=u;1==i.str.length&&(u.final=!0),n.push({node:u,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)})}if(i.str.length>1){var l,c=i.str.charAt(0),h=i.str.charAt(1);h in i.node.edges?l=i.node.edges[h]:(l=new j.TokenSet,i.node.edges[h]=l),1==i.str.length&&(l.final=!0),n.push({node:l,editsRemaining:i.editsRemaining-1,str:c+i.str.slice(2)})}}}return r},j.TokenSet.fromString=function(e){for(var t=new j.TokenSet,r=t,n=0,i=e.length;n<i;n++){var s=e[n],o=n==i-1;if("*"==s)t.edges[s]=t,t.final=o;else{var a=new j.TokenSet;a.final=o,t.edges[s]=a,t=a}}return r},j.TokenSet.prototype.toArray=function(){for(var e=[],t=[{prefix:"",node:this}];t.length;){var r=t.pop(),n=Object.keys(r.node.edges),i=n.length;r.node.final&&(r.prefix.charAt(0),e.push(r.prefix));for(var s=0;s<i;s++){var o=n[s];t.push({prefix:r.prefix.concat(o),node:r.node.edges[o]})}}return e},j.TokenSet.prototype.toString=function(){if(this._str)return this._str;for(var e=this.final?"1":"0",t=Object.keys(this.edges).sort(),r=t.length,n=0;n<r;n++){var i=t[n];e=e+i+this.edges[i].id}return e},j.TokenSet.prototype.intersect=function(e){for(var t=new j.TokenSet,r=void 0,n=[{qNode:e,output:t,node:this}];n.length;){r=n.pop();for(var i=Object.keys(r.qNode.edges),s=i.length,o=Object.keys(r.node.edges),a=o.length,u=0;u<s;u++)for(var l=i[u],c=0;c<a;c++){var h=o[c];if(h==l||"*"==l){var d=r.node.edges[h],f=r.qNode.edges[l],p=d.final&&f.final,y=void 0;h in r.output.edges?(y=r.output.edges[h]).final=y.final||p:((y=new j.TokenSet).final=p,r.output.edges[h]=y),n.push({qNode:f,output:y,node:d})}}}return t},j.TokenSet.Builder=function(){this.previousWord="",this.root=new j.TokenSet,this.uncheckedNodes=[],this.minimizedNodes={}},j.TokenSet.Builder.prototype.insert=function(e){var t,r=0;if(e<this.previousWord)throw new Error("Out of order word insertion");for(var n=0;n<e.length&&n<this.previousWord.length&&e[n]==this.previousWord[n];n++)r++;for(this.minimize(r),t=0==this.uncheckedNodes.length?this.root:this.uncheckedNodes[this.uncheckedNodes.length-1].child,n=r;n<e.length;n++){var i=new j.TokenSet,s=e[n];t.edges[s]=i,this.uncheckedNodes.push({parent:t,char:s,child:i}),t=i}t.final=!0,this.previousWord=e},j.TokenSet.Builder.prototype.finish=function(){this.minimize(0)},j.TokenSet.Builder.prototype.minimize=function(e){for(var t=this.uncheckedNodes.length-1;t>=e;t--){var r=this.uncheckedNodes[t],n=r.child.toString();n in this.minimizedNodes?r.parent.edges[r.char]=this.minimizedNodes[n]:(r.child._str=n,this.minimizedNodes[n]=r.child),this.uncheckedNodes.pop()}},j.Index=function(e){this.invertedIndex=e.invertedIndex,this.fieldVectors=e.fieldVectors,this.tokenSet=e.tokenSet,this.fields=e.fields,this.pipeline=e.pipeline},j.Index.prototype.search=function(e){return this.query((function(t){new j.QueryParser(e,t).parse()}))},j.Index.prototype.query=function(e){for(var t=new j.Query(this.fields),r=Object.create(null),n=Object.create(null),i=Object.create(null),s=Object.create(null),o=Object.create(null),a=0;a<this.fields.length;a++)n[this.fields[a]]=new j.Vector;for(e.call(t,t),a=0;a<t.clauses.length;a++){var u,l=t.clauses[a],c=j.Set.empty;u=l.usePipeline?this.pipeline.runString(l.term,{fields:l.fields}):[l.term];for(var h=0;h<u.length;h++){var d=u[h];l.term=d;var f=j.TokenSet.fromClause(l),p=this.tokenSet.intersect(f).toArray();if(0===p.length&&l.presence===j.Query.presence.REQUIRED){for(var y=0;y<l.fields.length;y++)s[R=l.fields[y]]=j.Set.empty;break}for(var m=0;m<p.length;m++){var g=p[m],x=this.invertedIndex[g],v=x._index;for(y=0;y<l.fields.length;y++){var w=x[R=l.fields[y]],Q=Object.keys(w),k=g+"/"+R,S=new j.Set(Q);if(l.presence==j.Query.presence.REQUIRED&&(c=c.union(S),void 0===s[R]&&(s[R]=j.Set.complete)),l.presence!=j.Query.presence.PROHIBITED){if(n[R].upsert(v,l.boost,(function(e,t){return e+t})),!i[k]){for(var E=0;E<Q.length;E++){var L,P=Q[E],b=new j.FieldRef(P,R),T=w[P];void 0===(L=r[b])?r[b]=new j.MatchData(g,R,T):L.add(g,R,T)}i[k]=!0}}else void 0===o[R]&&(o[R]=j.Set.empty),o[R]=o[R].union(S)}}}if(l.presence===j.Query.presence.REQUIRED)for(y=0;y<l.fields.length;y++)s[R=l.fields[y]]=s[R].intersect(c)}var O=j.Set.complete,I=j.Set.empty;for(a=0;a<this.fields.length;a++){var R;s[R=this.fields[a]]&&(O=O.intersect(s[R])),o[R]&&(I=I.union(o[R]))}var F=Object.keys(r),C=[],N=Object.create(null);if(t.isNegated())for(F=Object.keys(this.fieldVectors),a=0;a<F.length;a++){b=F[a];var _=j.FieldRef.fromString(b);r[b]=new j.MatchData}for(a=0;a<F.length;a++){var D=(_=j.FieldRef.fromString(F[a])).docRef;if(O.contains(D)&&!I.contains(D)){var A,B=this.fieldVectors[_],z=n[_.fieldName].similarity(B);if(void 0!==(A=N[D]))A.score+=z,A.matchData.combine(r[_]);else{var V={ref:D,score:z,matchData:r[_]};N[D]=V,C.push(V)}}}return C.sort((function(e,t){return t.score-e.score}))},j.Index.prototype.toJSON=function(){var e=Object.keys(this.invertedIndex).sort().map((function(e){return[e,this.invertedIndex[e]]}),this),t=Object.keys(this.fieldVectors).map((function(e){return[e,this.fieldVectors[e].toJSON()]}),this);return{version:j.version,fields:this.fields,fieldVectors:t,invertedIndex:e,pipeline:this.pipeline.toJSON()}},j.Index.load=function(e){var t={},r={},n=e.fieldVectors,i=Object.create(null),s=e.invertedIndex,o=new j.TokenSet.Builder,a=j.Pipeline.load(e.pipeline);e.version!=j.version&&j.utils.warn("Version mismatch when loading serialised index. Current version of lunr '"+j.version+"' does not match serialized index '"+e.version+"'");for(var u=0;u<n.length;u++){var l=(h=n[u])[0],c=h[1];r[l]=new j.Vector(c)}for(u=0;u<s.length;u++){var h,d=(h=s[u])[0],f=h[1];o.insert(d),i[d]=f}return o.finish(),t.fields=e.fields,t.fieldVectors=r,t.invertedIndex=i,t.tokenSet=o.root,t.pipeline=a,new j.Index(t)},j.Builder=function(){this._ref="id",this._fields=Object.create(null),this._documents=Object.create(null),this.invertedIndex=Object.create(null),this.fieldTermFrequencies={},this.fieldLengths={},this.tokenizer=j.tokenizer,this.pipeline=new j.Pipeline,this.searchPipeline=new j.Pipeline,this.documentCount=0,this._b=.75,this._k1=1.2,this.termIndex=0,this.metadataWhitelist=[]},j.Builder.prototype.ref=function(e){this._ref=e},j.Builder.prototype.field=function(e,t){if(/\\//.test(e))throw new RangeError("Field '"+e+"' contains illegal character '/'");this._fields[e]=t||{}},j.Builder.prototype.b=function(e){this._b=e<0?0:e>1?1:e},j.Builder.prototype.k1=function(e){this._k1=e},j.Builder.prototype.add=function(e,t){var r=e[this._ref],n=Object.keys(this._fields);this._documents[r]=t||{},this.documentCount+=1;for(var i=0;i<n.length;i++){var s=n[i],o=this._fields[s].extractor,a=o?o(e):e[s],u=this.tokenizer(a,{fields:[s]}),l=this.pipeline.run(u),c=new j.FieldRef(r,s),h=Object.create(null);this.fieldTermFrequencies[c]=h,this.fieldLengths[c]=0,this.fieldLengths[c]+=l.length;for(var d=0;d<l.length;d++){var f=l[d];if(null==h[f]&&(h[f]=0),h[f]+=1,null==this.invertedIndex[f]){var p=Object.create(null);p._index=this.termIndex,this.termIndex+=1;for(var y=0;y<n.length;y++)p[n[y]]=Object.create(null);this.invertedIndex[f]=p}null==this.invertedIndex[f][s][r]&&(this.invertedIndex[f][s][r]=Object.create(null));for(var m=0;m<this.metadataWhitelist.length;m++){var g=this.metadataWhitelist[m],x=f.metadata[g];null==this.invertedIndex[f][s][r][g]&&(this.invertedIndex[f][s][r][g]=[]),this.invertedIndex[f][s][r][g].push(x)}}}},j.Builder.prototype.calculateAverageFieldLengths=function(){for(var e=Object.keys(this.fieldLengths),t=e.length,r={},n={},i=0;i<t;i++){var s=j.FieldRef.fromString(e[i]),o=s.fieldName;n[o]||(n[o]=0),n[o]+=1,r[o]||(r[o]=0),r[o]+=this.fieldLengths[s]}var a=Object.keys(this._fields);for(i=0;i<a.length;i++){var u=a[i];r[u]=r[u]/n[u]}this.averageFieldLength=r},j.Builder.prototype.createFieldVectors=function(){for(var e={},t=Object.keys(this.fieldTermFrequencies),r=t.length,n=Object.create(null),i=0;i<r;i++){for(var s=j.FieldRef.fromString(t[i]),o=s.fieldName,a=this.fieldLengths[s],u=new j.Vector,l=this.fieldTermFrequencies[s],c=Object.keys(l),h=c.length,d=this._fields[o].boost||1,f=this._documents[s.docRef].boost||1,p=0;p<h;p++){var y,m,g,x=c[p],v=l[x],w=this.invertedIndex[x]._index;void 0===n[x]?(y=j.idf(this.invertedIndex[x],this.documentCount),n[x]=y):y=n[x],m=y*((this._k1+1)*v)/(this._k1*(1-this._b+this._b*(a/this.averageFieldLength[o]))+v),m*=d,m*=f,g=Math.round(1e3*m)/1e3,u.insert(w,g)}e[s]=u}this.fieldVectors=e},j.Builder.prototype.createTokenSet=function(){this.tokenSet=j.TokenSet.fromArray(Object.keys(this.invertedIndex).sort())},j.Builder.prototype.build=function(){return this.calculateAverageFieldLengths(),this.createFieldVectors(),this.createTokenSet(),new j.Index({invertedIndex:this.invertedIndex,fieldVectors:this.fieldVectors,tokenSet:this.tokenSet,fields:Object.keys(this._fields),pipeline:this.searchPipeline})},j.Builder.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},j.MatchData=function(e,t,r){for(var n=Object.create(null),i=Object.keys(r||{}),s=0;s<i.length;s++){var o=i[s];n[o]=r[o].slice()}this.metadata=Object.create(null),void 0!==e&&(this.metadata[e]=Object.create(null),this.metadata[e][t]=n)},j.MatchData.prototype.combine=function(e){for(var t=Object.keys(e.metadata),r=0;r<t.length;r++){var n=t[r],i=Object.keys(e.metadata[n]);null==this.metadata[n]&&(this.metadata[n]=Object.create(null));for(var s=0;s<i.length;s++){var o=i[s],a=Object.keys(e.metadata[n][o]);null==this.metadata[n][o]&&(this.metadata[n][o]=Object.create(null));for(var u=0;u<a.length;u++){var l=a[u];null==this.metadata[n][o][l]?this.metadata[n][o][l]=e.metadata[n][o][l]:this.metadata[n][o][l]=this.metadata[n][o][l].concat(e.metadata[n][o][l])}}}},j.MatchData.prototype.add=function(e,t,r){if(!(e in this.metadata))return this.metadata[e]=Object.create(null),void(this.metadata[e][t]=r);if(t in this.metadata[e])for(var n=Object.keys(r),i=0;i<n.length;i++){var s=n[i];s in this.metadata[e][t]?this.metadata[e][t][s]=this.metadata[e][t][s].concat(r[s]):this.metadata[e][t][s]=r[s]}else this.metadata[e][t]=r},j.Query=function(e){this.clauses=[],this.allFields=e},j.Query.wildcard=new String("*"),j.Query.wildcard.NONE=0,j.Query.wildcard.LEADING=1,j.Query.wildcard.TRAILING=2,j.Query.presence={OPTIONAL:1,REQUIRED:2,PROHIBITED:3},j.Query.prototype.clause=function(e){return"fields"in e||(e.fields=this.allFields),"boost"in e||(e.boost=1),"usePipeline"in e||(e.usePipeline=!0),"wildcard"in e||(e.wildcard=j.Query.wildcard.NONE),e.wildcard&j.Query.wildcard.LEADING&&e.term.charAt(0)!=j.Query.wildcard&&(e.term="*"+e.term),e.wildcard&j.Query.wildcard.TRAILING&&e.term.slice(-1)!=j.Query.wildcard&&(e.term=e.term+"*"),"presence"in e||(e.presence=j.Query.presence.OPTIONAL),this.clauses.push(e),this},j.Query.prototype.isNegated=function(){for(var e=0;e<this.clauses.length;e++)if(this.clauses[e].presence!=j.Query.presence.PROHIBITED)return!1;return!0},j.Query.prototype.term=function(e,t){if(Array.isArray(e))return e.forEach((function(e){this.term(e,j.utils.clone(t))}),this),this;var r=t||{};return r.term=e.toString(),this.clause(r),this},j.QueryParseError=function(e,t,r){this.name="QueryParseError",this.message=e,this.start=t,this.end=r},j.QueryParseError.prototype=new Error,j.QueryLexer=function(e){this.lexemes=[],this.str=e,this.length=e.length,this.pos=0,this.start=0,this.escapeCharPositions=[]},j.QueryLexer.prototype.run=function(){for(var e=j.QueryLexer.lexText;e;)e=e(this)},j.QueryLexer.prototype.sliceString=function(){for(var e=[],t=this.start,r=this.pos,n=0;n<this.escapeCharPositions.length;n++)r=this.escapeCharPositions[n],e.push(this.str.slice(t,r)),t=r+1;return e.push(this.str.slice(t,this.pos)),this.escapeCharPositions.length=0,e.join("")},j.QueryLexer.prototype.emit=function(e){this.lexemes.push({type:e,str:this.sliceString(),start:this.start,end:this.pos}),this.start=this.pos},j.QueryLexer.prototype.escapeCharacter=function(){this.escapeCharPositions.push(this.pos-1),this.pos+=1},j.QueryLexer.prototype.next=function(){if(this.pos>=this.length)return j.QueryLexer.EOS;var e=this.str.charAt(this.pos);return this.pos+=1,e},j.QueryLexer.prototype.width=function(){return this.pos-this.start},j.QueryLexer.prototype.ignore=function(){this.start==this.pos&&(this.pos+=1),this.start=this.pos},j.QueryLexer.prototype.backup=function(){this.pos-=1},j.QueryLexer.prototype.acceptDigitRun=function(){var e,t;do{t=(e=this.next()).charCodeAt(0)}while(t>47&&t<58);e!=j.QueryLexer.EOS&&this.backup()},j.QueryLexer.prototype.more=function(){return this.pos<this.length},j.QueryLexer.EOS="EOS",j.QueryLexer.FIELD="FIELD",j.QueryLexer.TERM="TERM",j.QueryLexer.EDIT_DISTANCE="EDIT_DISTANCE",j.QueryLexer.BOOST="BOOST",j.QueryLexer.PRESENCE="PRESENCE",j.QueryLexer.lexField=function(e){return e.backup(),e.emit(j.QueryLexer.FIELD),e.ignore(),j.QueryLexer.lexText},j.QueryLexer.lexTerm=function(e){if(e.width()>1&&(e.backup(),e.emit(j.QueryLexer.TERM)),e.ignore(),e.more())return j.QueryLexer.lexText},j.QueryLexer.lexEditDistance=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.EDIT_DISTANCE),j.QueryLexer.lexText},j.QueryLexer.lexBoost=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.BOOST),j.QueryLexer.lexText},j.QueryLexer.lexEOS=function(e){e.width()>0&&e.emit(j.QueryLexer.TERM)},j.QueryLexer.termSeparator=j.tokenizer.separator,j.QueryLexer.lexText=function(e){for(;;){var t=e.next();if(t==j.QueryLexer.EOS)return j.QueryLexer.lexEOS;if(92!=t.charCodeAt(0)){if(":"==t)return j.QueryLexer.lexField;if("~"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexEditDistance;if("^"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexBoost;if("+"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if("-"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if(t.match(j.QueryLexer.termSeparator))return j.QueryLexer.lexTerm}else e.escapeCharacter()}},j.QueryParser=function(e,t){this.lexer=new j.QueryLexer(e),this.query=t,this.currentClause={},this.lexemeIdx=0},j.QueryParser.prototype.parse=function(){this.lexer.run(),this.lexemes=this.lexer.lexemes;for(var e=j.QueryParser.parseClause;e;)e=e(this);return this.query},j.QueryParser.prototype.peekLexeme=function(){return this.lexemes[this.lexemeIdx]},j.QueryParser.prototype.consumeLexeme=function(){var e=this.peekLexeme();return this.lexemeIdx+=1,e},j.QueryParser.prototype.nextClause=function(){var e=this.currentClause;this.query.clause(e),this.currentClause={}},j.QueryParser.parseClause=function(e){var t=e.peekLexeme();if(null!=t)switch(t.type){case j.QueryLexer.PRESENCE:return j.QueryParser.parsePresence;case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:var r="expected either a field or a term, found "+t.type;throw t.str.length>=1&&(r+=" with value '"+t.str+"'"),new j.QueryParseError(r,t.start,t.end)}},j.QueryParser.parsePresence=function(e){var t=e.consumeLexeme();if(null!=t){switch(t.str){case"-":e.currentClause.presence=j.Query.presence.PROHIBITED;break;case"+":e.currentClause.presence=j.Query.presence.REQUIRED;break;default:var r="unrecognised presence operator'"+t.str+"'";throw new j.QueryParseError(r,t.start,t.end)}var n=e.peekLexeme();if(null==n)throw r="expecting term or field, found nothing",new j.QueryParseError(r,t.start,t.end);switch(n.type){case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:throw r="expecting term or field, found '"+n.type+"'",new j.QueryParseError(r,n.start,n.end)}}},j.QueryParser.parseField=function(e){var t=e.consumeLexeme();if(null!=t){if(-1==e.query.allFields.indexOf(t.str)){var r=e.query.allFields.map((function(e){return"'"+e+"'"})).join(", "),n="unrecognised field '"+t.str+"', possible fields: "+r;throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.fields=[t.str];var i=e.peekLexeme();if(null==i)throw n="expecting term, found nothing",new j.QueryParseError(n,t.start,t.end);if(i.type===j.QueryLexer.TERM)return j.QueryParser.parseTerm;throw n="expecting term, found '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}},j.QueryParser.parseTerm=function(e){var t=e.consumeLexeme();if(null!=t){e.currentClause.term=t.str.toLowerCase(),-1!=t.str.indexOf("*")&&(e.currentClause.usePipeline=!1);var r=e.peekLexeme();if(null!=r)switch(r.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:var n="Unexpected lexeme type '"+r.type+"'";throw new j.QueryParseError(n,r.start,r.end)}else e.nextClause()}},j.QueryParser.parseEditDistance=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="edit distance must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.editDistance=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},j.QueryParser.parseBoost=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="boost must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.boost=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},void 0===(i="function"==typeof(n=function(){return j})?n.call(t,r,t,e):n)||(e.exports=i)}()}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,{a:t}),t},r.d=function(e,t){for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)};var n={};!function(){"use strict";r.d(n,{add:function(){return c},dispose:function(){return y},done:function(){return h},fromExternalJS:function(){return f},load:function(){return p},search:function(){return m},toJS:function(){return d}});var e=r(336),t=(e,t,r)=>new Promise(((n,i)=>{var s=e=>{try{a(r.next(e))}catch(e){i(e)}},o=e=>{try{a(r.throw(e))}catch(e){i(e)}},a=e=>e.done?n(e.value):Promise.resolve(e.value).then(s,o);a((r=r.apply(e,t)).next())}));let i,s,o,a=[];function u(){i=new e.Builder,i.field("title"),i.field("description"),i.ref("ref"),i.pipeline.add(e.trimmer,e.stopWordFilter,e.stemmer),o=new Promise((e=>{s=e}))}e.tokenizer.separator=/\\s+/,u();const l=t=>{const r=e.trimmer(new e.Token(t,{}));return"*"+e.stemmer(r)+"*"};function c(e,t,r){const n=a.push(r)-1,s={title:e.toLowerCase(),description:t.toLowerCase(),ref:n};i.add(s)}function h(){return t(this,null,(function*(){s(i.build())}))}function d(){return t(this,null,(function*(){return{store:a,index:(yield o).toJSON()}}))}function f(e,r){return t(this,null,(function*(){try{if(importScripts(e),!self[r])throw new Error("Broken index file format");p(self[r])}catch(e){console.error("Failed to load search index: "+e.message)}}))}function p(r){return t(this,null,(function*(){a=r.store,s(e.Index.load(r.index))}))}function y(){return t(this,null,(function*(){a=[],u()}))}function m(e,r=0){return t(this,null,(function*(){if(0===e.trim().length)return[];let t=(yield o).query((t=>{e.trim().toLowerCase().split(/\\s+/).forEach((e=>{if(1===e.length)return;const r=l(e);t.term(r,{})}))}));return r>0&&(t=t.slice(0,r)),t.map((e=>({meta:a[e.ref],score:e.score})))}))}addEventListener("message",(function(e){var t,r=e.data,i=r.type,s=r.method,o=r.id,a=r.params;"RPC"===i&&s&&((t=n[s])?Promise.resolve().then((function(){return t.apply(n,a)})):Promise.reject("No such method")).then((function(e){postMessage({type:"RPC",id:o,result:e})})).catch((function(e){var t={message:e};e.stack&&(t.message=e.message,t.stack=e.stack,t.name=e.name),postMessage({type:"RPC",id:o,error:t})}))})),postMessage({type:"RPC",method:"ready"})}()}();
//# sourceMappingURL=756674defce81e90acea.worker.js.map`])), { name: "[fullhash].worker.js" });
          return p(d, f), d;
        };
      }, 314: function(o) {
        o.exports = function(a, l) {
          var p = 0, f = {};
          a.addEventListener("message", function(d) {
            var m = d.data;
            if (m.type === "RPC") if (m.id) {
              var v = f[m.id];
              v && (delete f[m.id], m.error ? v[1](Object.assign(Error(m.error.message), m.error)) : v[0](m.result));
            } else {
              var g = document.createEvent("Event");
              g.initEvent(m.method, !1, !1), g.data = m.params, a.dispatchEvent(g);
            }
          }), l.forEach(function(d) {
            a[d] = function() {
              var m = arguments;
              return new Promise(function(v, g) {
                var S = ++p;
                f[S] = [v, g], a.postMessage({ type: "RPC", id: S, method: d, params: [].slice.call(m) });
              });
            };
          });
        };
      }, 766: function(o) {
        o.exports = AB();
      }, 376: function(o) {
        o.exports = PB();
      }, 322: function(o) {
        o.exports = CB();
      }, 66: function(o) {
        o.exports = B3();
      }, 416: function(o) {
        o.exports = void 0;
      }, 177: function() {
      }, 109: function(o) {
        o.exports = { i8: "7.0.8" };
      } }, n = {};
      function i(o) {
        var a = n[o];
        if (a !== void 0) return a.exports;
        var l = n[o] = { id: o, exports: {} };
        return r[o](l, l.exports, i), l.exports;
      }
      i.n = function(o) {
        var a = o && o.__esModule ? function() {
          return o.default;
        } : function() {
          return o;
        };
        return i.d(a, { a }), a;
      }, i.d = function(o, a) {
        for (var l in a) i.o(a, l) && !i.o(o, l) && Object.defineProperty(o, l, { enumerable: !0, get: a[l] });
      }, i.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      }(), i.o = function(o, a) {
        return Object.prototype.hasOwnProperty.call(o, a);
      }, i.r = function(o) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 });
      }, i.nc = void 0;
      var s = {};
      return function() {
        i.r(s), i.d(s, { AUTH_TYPES: function() {
          return cf;
        }, ApiContentWrap: function() {
          return I_;
        }, ApiInfo: function() {
          return ff;
        }, ApiInfoModel: function() {
          return t1;
        }, ApiLogo: function() {
          return df;
        }, AppStore: function() {
          return Ia;
        }, ArraySchema: function() {
          return Mx;
        }, BackgroundStub: function() {
          return j_;
        }, BodyContent: function() {
          return l_;
        }, COMPONENT_REGEXP: function() {
          return Cg;
        }, CallbackModel: function() {
          return jp;
        }, ClipboardService: function() {
          return Ui;
        }, ContentItem: function() {
          return Sf;
        }, ContentItems: function() {
          return ku;
        }, DiscriminatorDropdown: function() {
          return rf;
        }, Dropdown: function() {
          return Qp;
        }, DropdownLabel: function() {
          return Kp;
        }, DropdownOrLabel: function() {
          return $a;
        }, DropdownWrapper: function() {
          return Xp;
        }, ErrorBoundary: function() {
          return be;
        }, Example: function() {
          return Hg;
        }, ExampleModel: function() {
          return Aa;
        }, ExternalExample: function() {
          return gx;
        }, FieldModel: function() {
          return sn;
        }, GROUP_DEPTH: function() {
          return Bp;
        }, GroupModel: function() {
          return qn;
        }, HistoryService: function() {
          return _a;
        }, IS_BROWSER: function() {
          return f;
        }, InvertedSimpleDropdown: function() {
          return Jp;
        }, JsonPointer: function() {
          return rt;
        }, JsonViewer: function() {
          return dx;
        }, LEGACY_REGEXP: function() {
          return ZS;
        }, Loading: function() {
          return We;
        }, MDX_COMPONENT_REGEXP: function() {
          return e1;
        }, Markdown: function() {
          return Mr;
        }, MarkdownRenderer: function() {
          return Oa;
        }, MarkerService: function() {
          return de;
        }, MediaContentModel: function() {
          return Pa;
        }, MediaTypeModel: function() {
          return Ig;
        }, MediaTypesSwitch: function() {
          return ja;
        }, MenuBuilder: function() {
          return hi;
        }, MenuItem: function() {
          return Au;
        }, MenuItemLabel: function() {
          return mf;
        }, MenuItemLi: function() {
          return e_;
        }, MenuItemTitle: function() {
          return ty;
        }, MenuItemUl: function() {
          return Zx;
        }, MenuItems: function() {
          return Pu;
        }, MenuStore: function() {
          return zi;
        }, MiddlePanel: function() {
          return Eo;
        }, MimeLabel: function() {
          return Qg;
        }, NoSampleLabel: function() {
          return yx;
        }, OLD_SECURITY_DEFINITIONS_JSX_NAME: function() {
          return gs;
        }, ObjectSchema: function() {
          return nf;
        }, OneOfButton: function() {
          return of;
        }, OneOfSchema: function() {
          return sf;
        }, OpenAPIParser: function() {
          return f1;
        }, Operation: function() {
          return __;
        }, OperationBadge: function() {
          return Ou;
        }, OperationItem: function() {
          return _f;
        }, OperationMenuItemContent: function() {
          return P_;
        }, OperationModel: function() {
          return Lr;
        }, OptionsConsumer: function() {
          return Et;
        }, OptionsContext: function() {
          return Ge;
        }, OptionsProvider: function() {
          return Ue;
        }, Parameters: function() {
          return ny;
        }, PayloadSamples: function() {
          return Na;
        }, Redoc: function() {
          return uy;
        }, RedocAttribution: function() {
          return r_;
        }, RedocNormalizedOptions: function() {
          return X;
        }, RedocStandalone: function() {
          return KF;
        }, RedocWrap: function() {
          return R_;
        }, RequestBodyModel: function() {
          return x1;
        }, ResponseDetails: function() {
          return h_;
        }, ResponseHeaders: function() {
          return p_;
        }, ResponseModel: function() {
          return qp;
        }, ResponseSamples: function() {
          return bf;
        }, ResponseTitle: function() {
          return c_;
        }, ResponseView: function() {
          return m_;
        }, ResponsesList: function() {
          return iy;
        }, RightPanel: function() {
          return q1;
        }, Row: function() {
          return Es;
        }, SCHEMA_DEFINITION_JSX_NAME: function() {
          return ys;
        }, SECTION_ATTR: function() {
          return _s;
        }, SECURITY_DEFINITIONS_JSX_NAME: function() {
          return lu;
        }, SECURITY_SCHEMES_SECTION_PREFIX: function() {
          return Nr;
        }, Schema: function() {
          return Wi;
        }, SchemaDefinition: function() {
          return uf;
        }, SchemaModel: function() {
          return yu;
        }, ScrollService: function() {
          return Lg;
        }, SearchBox: function() {
          return Of;
        }, SearchStore: function() {
          return z1;
        }, Section: function() {
          return vu;
        }, SectionItem: function() {
          return xf;
        }, SecurityDefs: function() {
          return Zg;
        }, SecuritySchemeModel: function() {
          return T1;
        }, SecuritySchemesModel: function() {
          return $1;
        }, SideMenu: function() {
          return Cu;
        }, SideNavStyleEnum: function() {
          return te;
        }, SimpleDropdown: function() {
          return rx;
        }, SourceCode: function() {
          return hx;
        }, SourceCodeWithCopy: function() {
          return Wg;
        }, SpecStore: function() {
          return N1;
        }, StickyResponsiveSidebar: function() {
          return Tu;
        }, StoreBuilder: function() {
          return W1;
        }, StoreConsumer: function() {
          return V1;
        }, StoreContext: function() {
          return Vp;
        }, StoreProvider: function() {
          return U1;
        }, StyledMarkdownBlock: function() {
          return Ra;
        }, ThemeProvider: function() {
          return Se;
        }, Throttle: function() {
          return cu;
        }, alphabeticallyByProp: function() {
          return nn;
        }, appendToMdHeading: function() {
          return A;
        }, argValueToBoolean: function() {
          return N;
        }, buildComponentComment: function() {
          return PL;
        }, concatRefStacks: function() {
          return Dp;
        }, convertSwagger2OpenAPI: function() {
          return Fe;
        }, createGlobalStyle: function() {
          return he;
        }, createStore: function() {
          return cD;
        }, css: function() {
          return ve;
        }, debugTime: function() {
          return pu;
        }, debugTimeEnd: function() {
          return Ep;
        }, detectType: function() {
          return ma;
        }, escapeHTMLAttrChars: function() {
          return pe;
        }, expandDefaultServerVariables: function() {
          return au;
        }, extensionsHook: function() {
          return le;
        }, extractExtensions: function() {
          return bs;
        }, flattenByProp: function() {
          return y;
        }, getBasePath: function() {
          return Q;
        }, getContentWithLegacyExamples: function() {
          return _p;
        }, getDefinitionName: function() {
          return ba;
        }, getOperationSummary: function() {
          return Lt;
        }, getSerializedValue: function() {
          return xn;
        }, getStatusCodeType: function() {
          return ha;
        }, highlight: function() {
          return uu;
        }, history: function() {
          return Ea;
        }, html2Str: function() {
          return m;
        }, humanizeConstraints: function() {
          return Li;
        }, humanizeNumberRange: function() {
          return wa;
        }, isAbsoluteUrl: function() {
          return L;
        }, isArray: function() {
          return G;
        }, isBoolean: function() {
          return Z;
        }, isFormUrlEncoded: function() {
          return ru;
        }, isJsonLike: function() {
          return Ii;
        }, isNamedDefinition: function() {
          return va;
        }, isNumeric: function() {
          return k;
        }, isObject: function() {
          return R;
        }, isOperationName: function() {
          return ps;
        }, isPayloadSample: function() {
          return Ng;
        }, isPrimitiveType: function() {
          return ga;
        }, isRedocExtension: function() {
          return Sa;
        }, isStatusCode: function() {
          return Yt;
        }, keyframes: function() {
          return Te;
        }, langFromMime: function() {
          return ds;
        }, loadAndBundleSpec: function() {
          return $e;
        }, mapLang: function() {
          return Mi;
        }, mapValues: function() {
          return x;
        }, mapWithLast: function() {
          return _;
        }, media: function() {
          return O;
        }, memoize: function() {
          return Di;
        }, menuItemDepth: function() {
          return t_;
        }, mergeObjects: function() {
          return T;
        }, mergeParams: function() {
          return ou;
        }, mergeSimilarMediaTypes: function() {
          return su;
        }, normalizeServers: function() {
          return ms;
        }, pluralizeType: function() {
          return So;
        }, pushRef: function() {
          return Mp;
        }, querySelector: function() {
          return d;
        }, removeQueryStringAndHash: function() {
          return oe;
        }, resolveUrl: function() {
          return Y;
        }, safeSlugify: function() {
          return B;
        }, scrollIntoViewIfNeeded: function() {
          return v;
        }, serializeParameterValue: function() {
          return ya;
        }, serializeParameterValueWithMime: function() {
          return fs;
        }, setSecuritySchemePrefix: function() {
          return wo;
        }, shortenHTTPVerb: function() {
          return vs;
        }, sortByField: function() {
          return di;
        }, sortByRequired: function() {
          return fi;
        }, stripTrailingSlash: function() {
          return w;
        }, styled: function() {
          return M;
        }, titleize: function() {
          return re;
        }, unescapeHTMLChars: function() {
          return fe;
        }, urlFormEncodePayload: function() {
          return pi;
        }, useStore: function() {
          return H1;
        } });
        var o = et, a = P4;
        const l = { spacing: { unit: 5, sectionHorizontal: ({ spacing: u }) => 8 * u.unit, sectionVertical: ({ spacing: u }) => 8 * u.unit }, breakpoints: { small: "50rem", medium: "75rem", large: "105rem" }, colors: { tonalOffset: 0.2, primary: { main: "#32329f", light: ({ colors: u }) => (0, a.lighten)(u.tonalOffset, u.primary.main), dark: ({ colors: u }) => (0, a.darken)(u.tonalOffset, u.primary.main), contrastText: ({ colors: u }) => (0, a.readableColor)(u.primary.main) }, success: { main: "#1d8127", light: ({ colors: u }) => (0, a.lighten)(2 * u.tonalOffset, u.success.main), dark: ({ colors: u }) => (0, a.darken)(u.tonalOffset, u.success.main), contrastText: ({ colors: u }) => (0, a.readableColor)(u.success.main) }, warning: { main: "#ffa500", light: ({ colors: u }) => (0, a.lighten)(u.tonalOffset, u.warning.main), dark: ({ colors: u }) => (0, a.darken)(u.tonalOffset, u.warning.main), contrastText: "#ffffff" }, error: { main: "#d41f1c", light: ({ colors: u }) => (0, a.lighten)(u.tonalOffset, u.error.main), dark: ({ colors: u }) => (0, a.darken)(u.tonalOffset, u.error.main), contrastText: ({ colors: u }) => (0, a.readableColor)(u.error.main) }, gray: { 50: "#FAFAFA", 100: "#F5F5F5" }, text: { primary: "#333333", secondary: ({ colors: u }) => (0, a.lighten)(u.tonalOffset, u.text.primary) }, border: { dark: "rgba(0,0,0, 0.1)", light: "#ffffff" }, responses: { success: { color: ({ colors: u }) => u.success.main, backgroundColor: ({ colors: u }) => (0, a.transparentize)(0.93, u.success.main), tabTextColor: ({ colors: u }) => u.responses.success.color }, error: { color: ({ colors: u }) => u.error.main, backgroundColor: ({ colors: u }) => (0, a.transparentize)(0.93, u.error.main), tabTextColor: ({ colors: u }) => u.responses.error.color }, redirect: { color: ({ colors: u }) => u.warning.main, backgroundColor: ({ colors: u }) => (0, a.transparentize)(0.9, u.responses.redirect.color), tabTextColor: ({ colors: u }) => u.responses.redirect.color }, info: { color: "#87ceeb", backgroundColor: ({ colors: u }) => (0, a.transparentize)(0.9, u.responses.info.color), tabTextColor: ({ colors: u }) => u.responses.info.color } }, http: { get: "#2F8132", post: "#186FAF", put: "#95507c", options: "#947014", patch: "#bf581d", delete: "#cc3333", basic: "#707070", link: "#07818F", head: "#A23DAD" } }, schema: { linesColor: (u) => (0, a.lighten)(u.colors.tonalOffset, (0, a.desaturate)(u.colors.tonalOffset, u.colors.primary.main)), defaultDetailsWidth: "75%", typeNameColor: (u) => u.colors.text.secondary, typeTitleColor: (u) => u.schema.typeNameColor, requireLabelColor: (u) => u.colors.error.main, labelsTextSize: "0.9em", nestingSpacing: "1em", nestedBackground: "#fafafa", arrow: { size: "1.1em", color: (u) => u.colors.text.secondary } }, typography: { fontSize: "14px", lineHeight: "1.5em", fontWeightRegular: "400", fontWeightBold: "600", fontWeightLight: "300", fontFamily: "Roboto, sans-serif", smoothing: "antialiased", optimizeSpeed: !0, headings: { fontFamily: "Montserrat, sans-serif", fontWeight: "400", lineHeight: "1.6em" }, code: { fontSize: "13px", fontFamily: "Courier, monospace", lineHeight: ({ typography: u }) => u.lineHeight, fontWeight: ({ typography: u }) => u.fontWeightRegular, color: "#e53935", backgroundColor: "rgba(38, 50, 56, 0.05)", wrap: !1 }, links: { color: ({ colors: u }) => u.primary.main, visited: ({ typography: u }) => u.links.color, hover: ({ typography: u }) => (0, a.lighten)(0.2, u.links.color), textDecoration: "auto", hoverTextDecoration: "auto" } }, sidebar: { width: "260px", backgroundColor: "#fafafa", textColor: "#333333", activeTextColor: (u) => u.sidebar.textColor !== l.sidebar.textColor ? u.sidebar.textColor : u.colors.primary.main, groupItems: { activeBackgroundColor: (u) => (0, a.darken)(0.1, u.sidebar.backgroundColor), activeTextColor: (u) => u.sidebar.activeTextColor, textTransform: "uppercase" }, level1Items: { activeBackgroundColor: (u) => (0, a.darken)(0.05, u.sidebar.backgroundColor), activeTextColor: (u) => u.sidebar.activeTextColor, textTransform: "none" }, arrow: { size: "1.5em", color: (u) => u.sidebar.textColor } }, logo: { maxHeight: ({ sidebar: u }) => u.width, maxWidth: ({ sidebar: u }) => u.width, gutter: "2px" }, rightPanel: { backgroundColor: "#263238", width: "40%", textColor: "#ffffff", servers: { overlay: { backgroundColor: "#fafafa", textColor: "#263238" }, url: { backgroundColor: "#fff" } } }, codeBlock: { backgroundColor: ({ rightPanel: u }) => (0, a.darken)(0.1, u.backgroundColor) }, fab: { backgroundColor: "#f2f2f2", color: "#0065FB" } };
        var p = l;
        const f = typeof window < "u" && "HTMLElement" in window;
        function d(u) {
          return typeof document < "u" ? document.querySelector(u) : null;
        }
        function m(u) {
          return u.split(/<[^>]+>/).map((c) => c.trim()).filter((c) => c.length > 0).join(" ");
        }
        function v(u, c = !0) {
          const h = u.parentNode;
          if (!h) return;
          const b = window.getComputedStyle(h, void 0), E = parseInt(b.getPropertyValue("border-top-width"), 10), P = parseInt(b.getPropertyValue("border-left-width"), 10), $ = u.offsetTop - h.offsetTop < h.scrollTop, V = u.offsetTop - h.offsetTop + u.clientHeight - E > h.scrollTop + h.clientHeight, ee = u.offsetLeft - h.offsetLeft < h.scrollLeft, ie = u.offsetLeft - h.offsetLeft + u.clientWidth - P > h.scrollLeft + h.clientWidth, ne = $ && !V;
          ($ || V) && c && (h.scrollTop = u.offsetTop - h.offsetTop - h.clientHeight / 2 - E + u.clientHeight / 2), (ee || ie) && c && (h.scrollLeft = u.offsetLeft - h.offsetLeft - h.clientWidth / 2 - P + u.clientWidth / 2), ($ || V || ee || ie) && !c && u.scrollIntoView(ne);
        }
        var g = C4(), S = i.n(g);
        function _(u, c) {
          const h = [];
          for (let b = 0; b < u.length - 1; b++) h.push(c(u[b], !1));
          return u.length !== 0 && h.push(c(u[u.length - 1], !0)), h;
        }
        function x(u, c) {
          const h = {};
          for (const b in u) u.hasOwnProperty(b) && (h[b] = c(u[b], b, u));
          return h;
        }
        function y(u, c) {
          const h = [], b = (E) => {
            for (const P of E) h.push(P), P[c] && b(P[c]);
          };
          return b(u), h;
        }
        function w(u) {
          return u.endsWith("/") ? u.substring(0, u.length - 1) : u;
        }
        function k(u) {
          return !isNaN(parseFloat(u)) && isFinite(u);
        }
        function A(u, c, h) {
          const b = new RegExp(`(^|\\n)#\\s?${c}\\s*\\n`, "i"), E = new RegExp(`((\\n|^)#\\s*${c}\\s*(\\n|$)(?:.|\\n)*?)(\\n#|$)`, "i");
          if (b.test(u)) return u.replace(E, `$1

${h}
$4`);
          {
            const P = u === "" || u.endsWith(`

`) ? "" : u.endsWith(`
`) ? `
` : `

`;
            return `${u}${P}# ${c}

${h}`;
          }
        }
        const T = (u, ...c) => {
          if (!c.length) return u;
          const h = c.shift();
          return h === void 0 ? u : (I(u) && I(h) && Object.keys(h).forEach((b) => {
            I(h[b]) ? (u[b] || (u[b] = {}), T(u[b], h[b])) : u[b] = h[b];
          }), T(u, ...c));
        }, R = (u) => u !== null && typeof u == "object", I = (u) => R(u) && !G(u);
        function B(u) {
          return S()(u) || u.toString().toLowerCase().replace(/\s+/g, "-").replace(/&/g, "-and-").replace(/\--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
        }
        function L(u) {
          return /(?:^[a-z][a-z0-9+.-]*:|\/\/)/i.test(u);
        }
        function Y(u, c) {
          let h;
          if (c.startsWith("//")) try {
            h = `${new URL(u).protocol || "https:"}${c}`;
          } catch {
            h = `https:${c}`;
          }
          else if (L(c)) h = c;
          else if (c.startsWith("/")) try {
            const b = new URL(u);
            b.pathname = c, h = b.href;
          } catch {
            h = c;
          }
          else h = w(u) + "/" + c;
          return w(h);
        }
        function Q(u) {
          try {
            return ce(u).pathname;
          } catch {
            return u;
          }
        }
        function re(u) {
          return u.charAt(0).toUpperCase() + u.slice(1);
        }
        function oe(u) {
          try {
            const c = ce(u);
            return c.search = "", c.hash = "", c.toString();
          } catch {
            return u;
          }
        }
        function ce(u) {
          return typeof URL > "u" ? new (i(416)).URL(u) : new URL(u);
        }
        function pe(u) {
          return u.replace(/["\\]/g, "\\$&");
        }
        function fe(u) {
          return u.replace(/&#(\d+);/g, (c, h) => String.fromCharCode(parseInt(h, 10))).replace(/&amp;/g, "&").replace(/&quot;/g, '"');
        }
        function G(u) {
          return Array.isArray(u);
        }
        function Z(u) {
          return typeof u == "boolean";
        }
        const K = { enum: "Enum", enumSingleValue: "Value", enumArray: "Items", default: "Default", deprecated: "Deprecated", example: "Example", examples: "Examples", recursive: "Recursive", arrayOf: "Array of ", webhook: "Event", const: "Value", noResultsFound: "No results found", download: "Download", downloadSpecification: "Download OpenAPI specification", responses: "Responses", callbackResponses: "Callback responses", requestSamples: "Request samples", responseSamples: "Response samples" };
        function z(u, c) {
          const h = K[u];
          return c !== void 0 ? h[c] : h;
        }
        var te = ((u) => (u.SummaryOnly = "summary-only", u.PathOnly = "path-only", u.IdOnly = "id-only", u))(te || {}), q = Object.defineProperty, j = Object.defineProperties, H = Object.getOwnPropertyDescriptors, F = Object.getOwnPropertySymbols, ue = Object.prototype.hasOwnProperty, ge = Object.prototype.propertyIsEnumerable, Ae = (u, c, h) => c in u ? q(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, C = (u, c) => {
          for (var h in c || (c = {})) ue.call(c, h) && Ae(u, h, c[h]);
          if (F) for (var h of F(c)) ge.call(c, h) && Ae(u, h, c[h]);
          return u;
        };
        function N(u, c) {
          return u === void 0 ? c || !1 : typeof u == "string" ? u !== "false" : u;
        }
        function J(u) {
          return typeof u == "string" ? parseInt(u, 10) : typeof u == "number" ? u : void 0;
        }
        class X {
          static normalizeExpandResponses(c) {
            if (c === "all") return "all";
            if (typeof c == "string") {
              const h = {};
              return c.split(",").forEach((b) => {
                h[b.trim()] = !0;
              }), h;
            }
            return c !== void 0 && console.warn(`expandResponses must be a string but received value "${c}" of type ${typeof c}`), {};
          }
          static normalizeHideHostname(c) {
            return !!c;
          }
          static normalizeScrollYOffset(c) {
            if (typeof c == "string" && !k(c)) {
              const h = d(c);
              h || console.warn("scrollYOffset value is a selector to non-existing element. Using offset 0 by default");
              const b = h && h.getBoundingClientRect().bottom || 0;
              return () => b;
            }
            return typeof c == "number" || k(c) ? () => typeof c == "number" ? c : parseFloat(c) : typeof c == "function" ? () => {
              const h = c();
              return typeof h != "number" && console.warn(`scrollYOffset should return number but returned value "${h}" of type ${typeof h}`), h;
            } : (c !== void 0 && console.warn("Wrong value for scrollYOffset ReDoc option: should be string, number or function"), () => 0);
          }
          static normalizeShowExtensions(c) {
            if (c === void 0) return !1;
            if (c === "") return !0;
            if (typeof c != "string") return c;
            switch (c) {
              case "true":
                return !0;
              case "false":
                return !1;
              default:
                return c.split(",").map((h) => h.trim());
            }
          }
          static normalizeSideNavStyle(c) {
            const h = te.SummaryOnly;
            if (typeof c != "string") return h;
            switch (c) {
              case h:
                return c;
              case te.PathOnly:
                return te.PathOnly;
              case te.IdOnly:
                return te.IdOnly;
              default:
                return h;
            }
          }
          static normalizePayloadSampleIdx(c) {
            return typeof c == "number" ? Math.max(0, c) : typeof c == "string" && isFinite(c) ? parseInt(c, 10) : 0;
          }
          static normalizeJsonSampleExpandLevel(c) {
            return c === "all" ? 1 / 0 : isNaN(Number(c)) ? 2 : Math.ceil(Number(c));
          }
          static normalizeGeneratedPayloadSamplesMaxDepth(c) {
            return isNaN(Number(c)) ? 10 : Math.max(0, Number(c));
          }
          constructor(c, h = {}) {
            var b, E, P, $, V;
            const ee = (c = C(C({}, h), c)).theme && c.theme.extensionsHook;
            var ie, ne;
            (b = c.theme) != null && b.menu && !((E = c.theme) != null && E.sidebar) && (console.warn('Theme setting "menu" is deprecated. Rename to "sidebar"'), c.theme.sidebar = c.theme.menu), (P = c.theme) != null && P.codeSample && !(($ = c.theme) != null && $.codeBlock) && (console.warn('Theme setting "codeSample" is deprecated. Rename to "codeBlock"'), c.theme.codeBlock = c.theme.codeSample), this.theme = function(me) {
              const Ie = {};
              let ze = 0;
              const yt = (kt, it) => {
                Object.keys(kt).forEach((an) => {
                  const Vr = (it ? it + "." : "") + an, Kt = kt[an];
                  typeof Kt == "function" ? Object.defineProperty(kt, an, { get() {
                    if (!Ie[Vr]) {
                      if (ze++, ze > 1e3) throw new Error(`Theme probably contains circular dependency at ${Vr}: ${Kt.toString()}`);
                      Ie[Vr] = Kt(me);
                    }
                    return Ie[Vr];
                  }, enumerable: !0 }) : typeof Kt == "object" && yt(Kt, Vr);
                });
              };
              return yt(me, ""), JSON.parse(JSON.stringify(me));
            }(T({}, p, (ie = C({}, c.theme), j(ie, H({ extensionsHook: void 0 }))))), this.theme.extensionsHook = ee, ne = c.labels, Object.assign(K, ne), this.scrollYOffset = X.normalizeScrollYOffset(c.scrollYOffset), this.hideHostname = X.normalizeHideHostname(c.hideHostname), this.expandResponses = X.normalizeExpandResponses(c.expandResponses), this.requiredPropsFirst = N(c.requiredPropsFirst), this.sortPropsAlphabetically = N(c.sortPropsAlphabetically), this.sortEnumValuesAlphabetically = N(c.sortEnumValuesAlphabetically), this.sortOperationsAlphabetically = N(c.sortOperationsAlphabetically), this.sortTagsAlphabetically = N(c.sortTagsAlphabetically), this.nativeScrollbars = N(c.nativeScrollbars), this.pathInMiddlePanel = N(c.pathInMiddlePanel), this.untrustedSpec = N(c.untrustedSpec), this.hideDownloadButton = N(c.hideDownloadButton), this.downloadFileName = c.downloadFileName, this.downloadDefinitionUrl = c.downloadDefinitionUrl, this.disableSearch = N(c.disableSearch), this.onlyRequiredInSamples = N(c.onlyRequiredInSamples), this.showExtensions = X.normalizeShowExtensions(c.showExtensions), this.sideNavStyle = X.normalizeSideNavStyle(c.sideNavStyle), this.hideSingleRequestSampleTab = N(c.hideSingleRequestSampleTab), this.hideRequestPayloadSample = N(c.hideRequestPayloadSample), this.menuToggle = N(c.menuToggle, !0), this.jsonSampleExpandLevel = X.normalizeJsonSampleExpandLevel(c.jsonSampleExpandLevel), this.enumSkipQuotes = N(c.enumSkipQuotes), this.hideSchemaTitles = N(c.hideSchemaTitles), this.simpleOneOfTypeLabel = N(c.simpleOneOfTypeLabel), this.payloadSampleIdx = X.normalizePayloadSampleIdx(c.payloadSampleIdx), this.expandSingleSchemaField = N(c.expandSingleSchemaField), this.schemaExpansionLevel = function(me, Ie = 0) {
              return me === "all" ? 1 / 0 : J(me) || Ie;
            }(c.schemaExpansionLevel), this.showObjectSchemaExamples = N(c.showObjectSchemaExamples), this.showSecuritySchemeType = N(c.showSecuritySchemeType), this.hideSecuritySection = N(c.hideSecuritySection), this.unstable_ignoreMimeParameters = N(c.unstable_ignoreMimeParameters), this.allowedMdComponents = c.allowedMdComponents || {}, this.expandDefaultServerVariables = N(c.expandDefaultServerVariables), this.maxDisplayedEnumValues = J(c.maxDisplayedEnumValues);
            const se = G(c.ignoreNamedSchemas) ? c.ignoreNamedSchemas : (V = c.ignoreNamedSchemas) == null ? void 0 : V.split(",").map((me) => me.trim());
            this.ignoreNamedSchemas = new Set(se), this.hideSchemaPattern = N(c.hideSchemaPattern), this.generatedPayloadSamplesMaxDepth = X.normalizeGeneratedPayloadSamplesMaxDepth(c.generatedPayloadSamplesMaxDepth), this.nonce = c.nonce, this.hideFab = N(c.hideFab), this.minCharacterLengthToInitSearch = J(c.minCharacterLengthToInitSearch) || 3, this.showWebhookVerb = N(c.showWebhookVerb);
          }
        }
        var ae = D6, U = i.n(ae);
        const { default: W, css: ve, createGlobalStyle: he, keyframes: Te, ThemeProvider: Se } = ae, O = { lessThan(u, c, h) {
          return (...b) => ve`
      @media ${c ? "print, " : ""} screen and (max-width: ${(E) => E.theme.breakpoints[u]}) ${h || ""} {
        ${ve(...b)};
      }
    `;
        }, greaterThan(u) {
          return (...c) => ve`
      @media (min-width: ${(h) => h.theme.breakpoints[u]}) {
        ${ve(...c)};
      }
    `;
        }, between(u, c) {
          return (...h) => ve`
      @media (min-width: ${(b) => b.theme.breakpoints[u]}) and (max-width: ${(b) => b.theme.breakpoints[c]}) {
        ${ve(...h)};
      }
    `;
        } };
        var M = W;
        function le(u) {
          return (c) => {
            if (c.theme.extensionsHook) return c.theme.extensionsHook(u, c);
          };
        }
        const ye = M.div`
  padding: 20px;
  color: red;
`;
        class be extends o.Component {
          constructor(c) {
            super(c), this.state = { error: void 0 };
          }
          componentDidCatch(c) {
            return this.setState({ error: c }), !1;
          }
          render() {
            return this.state.error ? o.createElement(ye, null, o.createElement("h1", null, "Something went wrong..."), o.createElement("small", null, " ", this.state.error.message, " "), o.createElement("p", null, o.createElement("details", null, o.createElement("summary", null, "Stack trace"), o.createElement("pre", null, this.state.error.stack))), o.createElement("small", null, " ReDoc Version: ", "2.1.5"), " ", o.createElement("br", null), o.createElement("small", null, " Commit: ", "3658b6d")) : o.createElement(o.Fragment, null, o.Children.only(this.props.children));
          }
        }
        const Pe = Te`
  0% {
    transform: rotate(0deg); }
  100% {
    transform: rotate(360deg);
  }
`, ke = M((u) => o.createElement("svg", { className: u.className, version: "1.1", width: "512", height: "512", viewBox: "0 0 512 512" }, o.createElement("path", { d: "M275.682 147.999c0 10.864-8.837 19.661-19.682 19.661v0c-10.875 0-19.681-8.796-19.681-19.661v-96.635c0-10.885 8.806-19.661 19.681-19.661v0c10.844 0 19.682 8.776 19.682 19.661v96.635z" }), o.createElement("path", { d: "M275.682 460.615c0 10.865-8.837 19.682-19.682 19.682v0c-10.875 0-19.681-8.817-19.681-19.682v-96.604c0-10.885 8.806-19.681 19.681-19.681v0c10.844 0 19.682 8.796 19.682 19.682v96.604z" }), o.createElement("path", { d: "M147.978 236.339c10.885 0 19.681 8.755 19.681 19.641v0c0 10.885-8.796 19.702-19.681 19.702h-96.624c-10.864 0-19.661-8.817-19.661-19.702v0c0-10.885 8.796-19.641 19.661-19.641h96.624z" }), o.createElement("path", { d: "M460.615 236.339c10.865 0 19.682 8.755 19.682 19.641v0c0 10.885-8.817 19.702-19.682 19.702h-96.584c-10.885 0-19.722-8.817-19.722-19.702v0c0-10.885 8.837-19.641 19.722-19.641h96.584z" }), o.createElement("path", { d: "M193.546 165.703c7.69 7.66 7.68 20.142 0 27.822v0c-7.701 7.701-20.162 7.701-27.853 0.020l-68.311-68.322c-7.68-7.701-7.68-20.142 0-27.863v0c7.68-7.68 20.121-7.68 27.822 0l68.342 68.342z" }), o.createElement("path", { d: "M414.597 386.775c7.7 7.68 7.7 20.163 0.021 27.863v0c-7.7 7.659-20.142 7.659-27.843-0.062l-68.311-68.26c-7.68-7.7-7.68-20.204 0-27.863v0c7.68-7.7 20.163-7.7 27.842 0l68.291 68.322z" }), o.createElement("path", { d: "M165.694 318.464c7.69-7.7 20.153-7.7 27.853 0v0c7.68 7.659 7.69 20.163 0 27.863l-68.342 68.322c-7.67 7.659-20.142 7.659-27.822-0.062v0c-7.68-7.68-7.68-20.122 0-27.801l68.311-68.322z" }), o.createElement("path", { d: "M386.775 97.362c7.7-7.68 20.142-7.68 27.822 0v0c7.7 7.68 7.7 20.183 0.021 27.863l-68.322 68.311c-7.68 7.68-20.163 7.68-27.843-0.020v0c-7.68-7.68-7.68-20.162 0-27.822l68.322-68.332z" })))`
  animation: 2s ${Pe} linear infinite;
  width: 50px;
  height: 50px;
  content: '';
  display: inline-block;
  margin-left: -25px;

  path {
    fill: ${(u) => u.color};
  }
`, Me = M.div`
  font-family: helvetica, sans;
  width: 100%;
  text-align: center;
  font-size: 25px;
  margin: 30px 0 20px 0;
  color: ${(u) => u.color};
`;
        class We extends o.PureComponent {
          render() {
            return o.createElement("div", { style: { textAlign: "center" } }, o.createElement(Me, { color: this.props.color }, "Loading ..."), o.createElement(ke, { color: this.props.color }));
          }
        }
        var Xe = FI();
        const Ge = o.createContext(new X({})), Ue = Ge.Provider, Et = Ge.Consumer;
        var D = oW, we = kQ(), Oe = DN(), Ee = i(925), Ce = (u, c, h) => new Promise((b, E) => {
          var P = (ee) => {
            try {
              V(h.next(ee));
            } catch (ie) {
              E(ie);
            }
          }, $ = (ee) => {
            try {
              V(h.throw(ee));
            } catch (ie) {
              E(ie);
            }
          }, V = (ee) => ee.done ? b(ee.value) : Promise.resolve(ee.value).then(P, $);
          V((h = h.apply(u, c)).next());
        });
        function $e(u) {
          return Ce(this, null, function* () {
            const c = new Oe.Config({}), h = { config: c, base: f ? window.location.href : process.cwd() };
            f && (c.resolve.http.customFetch = i.g.fetch), typeof u == "object" && u !== null ? h.doc = { source: { absoluteRef: "" }, parsed: u } : h.ref = u;
            const { bundle: { parsed: b } } = yield (0, we.bundle)(h);
            return b.swagger !== void 0 ? Fe(b) : b;
          });
        }
        function Fe(u) {
          return console.warn("[ReDoc Compatibility mode]: Converting OpenAPI 2.0 to OpenAPI 3.0"), new Promise((c, h) => (0, Ee.convertObj)(u, { patch: !0, warnOnly: !0, text: "{}", anchors: !0 }, (b, E) => {
            if (b) return h(b);
            c(E && E.openapi);
          }));
        }
        var xe = PQ(), Le = CQ(), Ye = FN();
        const mt = Ye.parse;
        class rt {
          static baseName(c, h = 1) {
            const b = rt.parse(c);
            return b[b.length - h];
          }
          static dirName(c, h = 1) {
            const b = rt.parse(c);
            return Ye.compile(b.slice(0, b.length - h));
          }
          static relative(c, h) {
            const b = rt.parse(c);
            return rt.parse(h).slice(b.length);
          }
          static parse(c) {
            let h = c;
            return h.charAt(0) === "#" && (h = h.substring(1)), mt(h);
          }
          static join(c, h) {
            const b = rt.parse(c).concat(h);
            return Ye.compile(b);
          }
          static get(c, h) {
            return Ye.get(c, h);
          }
          static compile(c) {
            return Ye.compile(c);
          }
          static escape(c) {
            return Ye.escape(c);
          }
        }
        Ye.parse = rt.parse, Object.assign(rt, Ye);
        var ut = i(470), gt = $Q(), Jt = Object.defineProperty, Fn = Object.defineProperties, Zl = Object.getOwnPropertyDescriptors, da = Object.getOwnPropertySymbols, _g = Object.prototype.hasOwnProperty, Eg = Object.prototype.propertyIsEnumerable, xp = (u, c, h) => c in u ? Jt(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, ci = (u, c) => {
          for (var h in c || (c = {})) _g.call(c, h) && xp(u, h, c[h]);
          if (da) for (var h of da(c)) Eg.call(c, h) && xp(u, h, c[h]);
          return u;
        }, eu = (u, c) => Fn(u, Zl(c));
        function tu(u) {
          return typeof u == "string" && /\dxx/i.test(u);
        }
        function Yt(u) {
          return u === "default" || k(u) || tu(u);
        }
        function ha(u, c = !1) {
          if (u === "default") return c ? "error" : "success";
          let h = typeof u == "string" ? parseInt(u, 10) : u;
          if (tu(u) && (h *= 100), h < 100 || h > 599) throw new Error("invalid HTTP code");
          let b = "success";
          return h >= 300 && h < 400 ? b = "redirect" : h >= 400 ? b = "error" : h < 200 && (b = "info"), b;
        }
        const Zt = { get: !0, post: !0, put: !0, head: !0, patch: !0, delete: !0, options: !0, $ref: !0 };
        function ps(u) {
          return u in Zt;
        }
        function Lt(u) {
          return u.summary || u.operationId || u.description && u.description.substring(0, 50) || u.pathName || "<no summary>";
        }
        const bo = { multipleOf: "number", maximum: "number", exclusiveMaximum: "number", minimum: "number", exclusiveMinimum: "number", maxLength: "string", minLength: "string", pattern: "string", contentEncoding: "string", contentMediaType: "string", items: "array", maxItems: "array", minItems: "array", uniqueItems: "array", maxProperties: "object", minProperties: "object", required: "object", additionalProperties: "object", unevaluatedProperties: "object", properties: "object", patternProperties: "object" };
        function ma(u) {
          if (u.type !== void 0 && !G(u.type)) return u.type;
          const c = Object.keys(bo);
          for (const h of c) {
            const b = bo[h];
            if (u[h] !== void 0) return b;
          }
          return "any";
        }
        function ga(u, c = u.type) {
          if (u["x-circular-ref"]) return !0;
          if (u.oneOf !== void 0 || u.anyOf !== void 0 || u.if && u.then || u.if && u.else) return !1;
          let h = !0;
          const b = G(c);
          return (c === "object" || b && (c != null && c.includes("object"))) && (h = u.properties !== void 0 ? Object.keys(u.properties).length === 0 : u.additionalProperties === void 0 && u.unevaluatedProperties === void 0 && u.patternProperties === void 0), !G(u.items) && !G(u.prefixItems) && (u.items !== void 0 && !Z(u.items) && (c === "array" || b && (c != null && c.includes("array"))) && (h = ga(u.items, u.items.type)), h);
        }
        function Ii(u) {
          return u.search(/json/i) !== -1;
        }
        function ru(u) {
          return u === "application/x-www-form-urlencoded";
        }
        function nu(u, c, h) {
          return G(u) ? u.map((b) => b.toString()).join(h) : typeof u == "object" ? Object.keys(u).map((b) => `${b}${h}${u[b]}`).join(h) : c + "=" + u.toString();
        }
        function ji(u, c) {
          return G(u) ? (console.warn("deepObject style cannot be used with array value:" + u.toString()), "") : typeof u == "object" ? Object.keys(u).map((h) => `${c}[${h}]=${u[h]}`).join("&") : (console.warn("deepObject style cannot be used with non-object value:" + u.toString()), "");
        }
        function Ni(u, c, h) {
          const b = "__redoc_param_name__", E = c ? "*" : "";
          return gt.parse(`{?${b}${E}}`).expand({ [b]: h }).substring(1).replace(/__redoc_param_name__/g, u);
        }
        function pi(u, c = {}) {
          if (G(u)) throw new Error("Payload must have fields: " + u.toString());
          return Object.keys(u).map((h) => {
            const b = u[h], { style: E = "form", explode: P = !0 } = c[h] || {};
            switch (E) {
              case "form":
                return Ni(h, P, b);
              case "spaceDelimited":
                return nu(b, h, "%20");
              case "pipeDelimited":
                return nu(b, h, "|");
              case "deepObject":
                return ji(b, h);
              default:
                return console.warn("Incorrect or unsupported encoding style: " + E), "";
            }
          }).join("&");
        }
        function fs(u, c) {
          return Ii(c) ? JSON.stringify(u) : (console.warn(`Parameter serialization as ${c} is not supported`), "");
        }
        function ya(u, c) {
          const { name: h, style: b, explode: E = !1, serializationMime: P } = u;
          if (P) switch (u.in) {
            case "path":
            case "header":
              return fs(c, P);
            case "cookie":
            case "query":
              return `${h}=${fs(c, P)}`;
            default:
              return console.warn("Unexpected parameter location: " + u.in), "";
          }
          if (!b) return console.warn(`Missing style attribute or content for parameter ${h}`), "";
          switch (u.in) {
            case "path":
              return function($, V, ee, ie) {
                const ne = ee ? "*" : "";
                let se = "";
                V === "label" ? se = "." : V === "matrix" && (se = ";");
                const me = "__redoc_param_name__";
                return gt.parse(`{${se}${me}${ne}}`).expand({ [me]: ie }).replace(/__redoc_param_name__/g, $);
              }(h, b, E, c);
            case "query":
              return function($, V, ee, ie) {
                switch (V) {
                  case "form":
                    return Ni($, ee, ie);
                  case "spaceDelimited":
                    return G(ie) ? ee ? Ni($, ee, ie) : `${$}=${ie.join("%20")}` : (console.warn("The style spaceDelimited is only applicable to arrays"), "");
                  case "pipeDelimited":
                    return G(ie) ? ee ? Ni($, ee, ie) : `${$}=${ie.join("|")}` : (console.warn("The style pipeDelimited is only applicable to arrays"), "");
                  case "deepObject":
                    return !ee || G(ie) || typeof ie != "object" ? (console.warn("The style deepObject is only applicable for objects with explode=true"), "") : ji(ie, $);
                  default:
                    return console.warn("Unexpected style for query: " + V), "";
                }
              }(h, b, E, c);
            case "header":
              return function($, V, ee) {
                if ($ === "simple") {
                  const ie = V ? "*" : "", ne = "__redoc_param_name__", se = gt.parse(`{${ne}${ie}}`);
                  return decodeURIComponent(se.expand({ [ne]: ee }));
                }
                return console.warn("Unexpected style for header: " + $), "";
              }(b, E, c);
            case "cookie":
              return function($, V, ee, ie) {
                return V === "form" ? Ni($, ee, ie) : (console.warn("Unexpected style for cookie: " + V), "");
              }(h, b, E, c);
            default:
              return console.warn("Unexpected parameter location: " + u.in), "";
          }
        }
        function xn(u, c) {
          return u.in ? decodeURIComponent(ya(u, c)) : String(c);
        }
        function ds(u) {
          return u.search(/xml/i) !== -1 ? "xml" : u.search(/csv/i) !== -1 ? "csv" : u.search(/plain/i) !== -1 ? "tex" : "clike";
        }
        const hs = /^#\/components\/(schemas|pathItems)\/([^/]+)$/;
        function va(u) {
          return hs.test(u || "");
        }
        function ba(u) {
          var c;
          const [h] = ((c = u == null ? void 0 : u.match(hs)) == null ? void 0 : c.reverse()) || [];
          return h;
        }
        function iu(u, c, h) {
          let b;
          return c !== void 0 && h !== void 0 ? b = c === h ? `= ${c} ${u}` : `[ ${c} .. ${h} ] ${u}` : h !== void 0 ? b = `<= ${h} ${u}` : c !== void 0 && (b = c === 1 ? "non-empty" : `>= ${c} ${u}`), b;
        }
        function wa(u) {
          var c, h;
          const b = typeof u.exclusiveMinimum == "number" ? Math.min(u.exclusiveMinimum, (c = u.minimum) != null ? c : 1 / 0) : u.minimum, E = typeof u.exclusiveMaximum == "number" ? Math.max(u.exclusiveMaximum, (h = u.maximum) != null ? h : -1 / 0) : u.maximum, P = typeof u.exclusiveMinimum == "number" || u.exclusiveMinimum, $ = typeof u.exclusiveMaximum == "number" || u.exclusiveMaximum;
          return b !== void 0 && E !== void 0 ? `${P ? "( " : "[ "}${b} .. ${E}${$ ? " )" : " ]"}` : E !== void 0 ? `${$ ? "< " : "<= "}${E}` : b !== void 0 ? `${P ? "> " : ">= "}${b}` : void 0;
        }
        function Li(u) {
          const c = [], h = iu("characters", u.minLength, u.maxLength);
          h !== void 0 && c.push(h);
          const b = iu("items", u.minItems, u.maxItems);
          b !== void 0 && c.push(b);
          const E = iu("properties", u.minProperties, u.maxProperties);
          E !== void 0 && c.push(E);
          const P = function(V) {
            if (V === void 0) return;
            const ee = V.toString(10);
            return /^0\.0*1$/.test(ee) ? `decimal places <= ${ee.split(".")[1].length}` : `multiple of ${ee}`;
          }(u.multipleOf);
          P !== void 0 && c.push(P);
          const $ = wa(u);
          return $ !== void 0 && c.push($), u.uniqueItems && c.push("unique"), c;
        }
        function fi(u, c = []) {
          const h = [], b = [], E = [];
          return u.forEach((P) => {
            P.required ? c.includes(P.name) ? b.push(P) : E.push(P) : h.push(P);
          }), b.sort((P, $) => c.indexOf(P.name) - c.indexOf($.name)), [...b, ...E, ...h];
        }
        function di(u, c) {
          return [...u].sort((h, b) => h[c].localeCompare(b[c]));
        }
        function ou(u, c = [], h = []) {
          const b = {};
          return h.forEach((E) => {
            ({ resolved: E } = u.deref(E)), b[E.name + "_" + E.in] = !0;
          }), (c = c.filter((E) => ({ resolved: E } = u.deref(E), !b[E.name + "_" + E.in]))).concat(h);
        }
        function su(u) {
          const c = {};
          return Object.keys(u).forEach((h) => {
            const b = u[h], E = h.split(";")[0].trim();
            c[E] ? c[E] = ci(ci({}, c[E]), b) : c[E] = b;
          }), c;
        }
        function au(u, c = {}) {
          return u.replace(/(?:{)([\w-.]+)(?:})/g, (h, b) => c[b] && c[b].default || h);
        }
        function ms(u, c) {
          const h = u === void 0 ? oe((() => {
            if (!f) return "";
            const b = window.location.href;
            return b.endsWith(".html") ? (0, ut.dirname)(b) : b;
          })()) : (0, ut.dirname)(u);
          return c.length === 0 && (c = [{ url: "/" }]), c.map((b) => {
            return eu(ci({}, b), { url: (E = b.url, Y(h, E)), description: b.description || "" });
            var E;
          });
        }
        const lu = "SecurityDefinitions", gs = "security-definitions", ys = "SchemaDefinition";
        let Nr = "section/Authentication/";
        function wo(u) {
          Nr = u;
        }
        const vs = (u) => ({ delete: "del", options: "opts" })[u] || u;
        function Sa(u) {
          return u in { "x-circular-ref": !0, "x-parentRefs": !0, "x-refsStack": !0, "x-code-samples": !0, "x-codeSamples": !0, "x-displayName": !0, "x-examples": !0, "x-ignoredHeaderParameters": !0, "x-logo": !0, "x-nullable": !0, "x-servers": !0, "x-tagGroups": !0, "x-traitTag": !0, "x-additionalPropertiesName": !0, "x-explicitMappingOnly": !0 };
        }
        function bs(u, c) {
          return Object.keys(u).filter((h) => c === !0 ? h.startsWith("x-") && !Sa(h) : h.startsWith("x-") && c.indexOf(h) > -1).reduce((h, b) => (h[b] = u[b], h), {});
        }
        function So(u) {
          return u.split(" or ").map((c) => c.replace(/^(string|object|number|integer|array|boolean)s?( ?.*)/, "$1s$2")).join(" or ");
        }
        function _p(u) {
          let c = u.content;
          const h = u["x-examples"], b = u["x-example"];
          if (h) {
            c = ci({}, c);
            for (const E of Object.keys(h)) {
              const P = h[E];
              c[E] = eu(ci({}, c[E]), { examples: P });
            }
          } else if (b) {
            c = ci({}, c);
            for (const E of Object.keys(b)) {
              const P = b[E];
              c[E] = eu(ci({}, c[E]), { example: P });
            }
          }
          return c;
        }
        var ws = RQ();
        IQ(), jQ(), NQ(), LQ(), MQ(), DQ(), FQ(), zQ(), qQ(), BQ(), UQ(), VQ(), WQ(), HQ(), QQ(), YQ(), GQ(), KQ(), XQ(), JQ(), ZQ(), eY(), tY();
        const Gt = "clike";
        function Mi(u) {
          return { json: "js", "c++": "cpp", "c#": "csharp", "objective-c": "objectivec", shell: "bash", viml: "vim" }[u] || Gt;
        }
        function uu(u, c = Gt) {
          c = c.toLowerCase();
          let h = ws.languages[c];
          return h || (h = ws.languages[Mi(c)]), ws.highlight(u.toString(), h, c);
        }
        function cu(u) {
          return (c, h, b) => {
            b.value = /* @__PURE__ */ function(E, P) {
              let $, V, ee, ie = null, ne = 0;
              const se = () => {
                ne = (/* @__PURE__ */ new Date()).getTime(), ie = null, ee = E.apply($, V), ie || ($ = V = null);
              };
              return function() {
                const me = (/* @__PURE__ */ new Date()).getTime(), Ie = P - (me - ne);
                return $ = this, V = arguments, Ie <= 0 || Ie > P ? (ie && (clearTimeout(ie), ie = null), ne = me, ee = E.apply($, V), ie || ($ = V = null)) : ie || (ie = setTimeout(se, Ie)), ee;
              };
            }(b.value, u);
          };
        }
        function pu(u) {
        }
        function Ep(u) {
        }
        ws.languages.insertBefore("javascript", "string", { "property string": { pattern: /([{,]\s*)"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i, lookbehind: !0 } }, void 0), ws.languages.insertBefore("javascript", "punctuation", { property: { pattern: /([{,]\s*)[a-z]\w*(?=\s*:)/i, lookbehind: !0 } }, void 0);
        var Op = Object.defineProperty, Og = Object.defineProperties, kp = Object.getOwnPropertyDescriptors, fu = Object.getOwnPropertySymbols, kg = Object.prototype.hasOwnProperty, _n = Object.prototype.propertyIsEnumerable, Ss = (u, c, h) => c in u ? Op(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, du = (u, c) => {
          for (var h in c || (c = {})) kg.call(c, h) && Ss(u, h, c[h]);
          if (fu) for (var h of fu(c)) _n.call(c, h) && Ss(u, h, c[h]);
          return u;
        }, hu = (u, c) => Og(u, kp(c));
        const xs = {};
        function Di(u, c, h) {
          if (typeof h.value == "function") return function(b, E, P) {
            if (!P.value || P.value.length > 0) throw new Error("@memoize decorator can only be applied to methods of zero arguments");
            const $ = `_memoized_${E}`, V = P.value;
            return b[$] = xs, hu(du({}, P), { value() {
              return this[$] === xs && (this[$] = V.call(this)), this[$];
            } });
          }(u, c, h);
          if (typeof h.get == "function") return function(b, E, P) {
            const $ = `_memoized_${E}`, V = P.get;
            return b[$] = xs, hu(du({}, P), { get() {
              return this[$] === xs && (this[$] = V.call(this)), this[$];
            } });
          }(u, c, h);
          throw new Error("@memoize decorator can be applied to methods or getters, got " + String(h.value) + " instead");
        }
        function nn(u) {
          let c = 1;
          return u[0] === "-" && (c = -1, u = u.substr(1)), (h, b) => c == -1 ? b[u].localeCompare(h[u]) : h[u].localeCompare(b[u]);
        }
        var Ap = Object.defineProperty, Pp = Object.getOwnPropertyDescriptor;
        const xa = "hashchange";
        class _a {
          constructor() {
            this.emit = () => {
              this._emiter.emit(xa, this.currentId);
            }, this._emiter = new Le.EventEmitter(), this.bind();
          }
          get currentId() {
            return f ? decodeURIComponent(window.location.hash.substring(1)) : "";
          }
          linkForId(c) {
            return c ? "#" + c : "";
          }
          subscribe(c) {
            const h = this._emiter.addListener(xa, c);
            return () => h.removeListener(xa, c);
          }
          bind() {
            f && window.addEventListener("hashchange", this.emit, !1);
          }
          dispose() {
            f && window.removeEventListener("hashchange", this.emit);
          }
          replace(c, h = !1) {
            f && c != null && c !== this.currentId && (h ? window.history.replaceState(null, "", window.location.href.split("#")[0] + this.linkForId(c)) : (window.history.pushState(null, "", window.location.href.split("#")[0] + this.linkForId(c)), this.emit()));
          }
        }
        ((u, c, h, b) => {
          for (var E, P = Pp(c, h), $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(c, h, P) || P);
          P && Ap(c, h, P);
        })([xe.bind, xe.debounce], _a.prototype, "replace");
        const Ea = new _a();
        var He = rY();
        class de {
          constructor() {
            this.map = /* @__PURE__ */ new Map(), this.prevTerm = "";
          }
          add(c) {
            this.map.set(c, new He(c));
          }
          delete(c) {
            this.map.delete(c);
          }
          addOnly(c) {
            this.map.forEach((h, b) => {
              c.indexOf(b) === -1 && (h.unmark(), this.map.delete(b));
            });
            for (const h of c) this.map.has(h) || this.map.set(h, new He(h));
          }
          clearAll() {
            this.unmark(), this.map.clear();
          }
          mark(c) {
            (c || this.prevTerm) && (this.map.forEach((h) => {
              h.unmark(), h.mark(c || this.prevTerm);
            }), this.prevTerm = c || this.prevTerm);
          }
          unmark() {
            this.map.forEach((c) => c.unmark()), this.prevTerm = "";
          }
        }
        let Re = { async: !1, baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, hooks: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
        const Ve = /[&<>"']/, xt = new RegExp(Ve.source, "g"), sr = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, ar = new RegExp(sr.source, "g"), _r = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, on = (u) => _r[u];
        function Vt(u, c) {
          if (c) {
            if (Ve.test(u)) return u.replace(xt, on);
          } else if (sr.test(u)) return u.replace(ar, on);
          return u;
        }
        const gr = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
        function mu(u) {
          return u.replace(gr, (c, h) => (h = h.toLowerCase()) === "colon" ? ":" : h.charAt(0) === "#" ? h.charAt(1) === "x" ? String.fromCharCode(parseInt(h.substring(2), 16)) : String.fromCharCode(+h.substring(1)) : "");
        }
        const Cp = /(^|[^\[])\^/g;
        function Ot(u, c) {
          u = typeof u == "string" ? u : u.source, c = c || "";
          const h = { replace: (b, E) => (E = (E = E.source || E).replace(Cp, "$1"), u = u.replace(b, E), h), getRegex: () => new RegExp(u, c) };
          return h;
        }
        const gL = /[^\w:]/g, yL = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
        function BS(u, c, h) {
          if (u) {
            let b;
            try {
              b = decodeURIComponent(mu(h)).replace(gL, "").toLowerCase();
            } catch {
              return null;
            }
            if (b.indexOf("javascript:") === 0 || b.indexOf("vbscript:") === 0 || b.indexOf("data:") === 0) return null;
          }
          c && !yL.test(h) && (h = function(b, E) {
            Tp[" " + b] || (vL.test(b) ? Tp[" " + b] = b + "/" : Tp[" " + b] = Rp(b, "/", !0));
            const P = (b = Tp[" " + b]).indexOf(":") === -1;
            return E.substring(0, 2) === "//" ? P ? E : b.replace(bL, "$1") + E : E.charAt(0) === "/" ? P ? E : b.replace(wL, "$1") + E : b + E;
          }(c, h));
          try {
            h = encodeURI(h).replace(/%25/g, "%");
          } catch {
            return null;
          }
          return h;
        }
        const Tp = {}, vL = /^[^:]+:\/*[^/]*$/, bL = /^([^:]+:)[\s\S]*$/, wL = /^([^:]+:\/*[^/]*)[\s\S]*$/, $p = { exec: function() {
        } };
        function US(u, c) {
          const h = u.replace(/\|/g, (E, P, $) => {
            let V = !1, ee = P;
            for (; --ee >= 0 && $[ee] === "\\"; ) V = !V;
            return V ? "|" : " |";
          }).split(/ \|/);
          let b = 0;
          if (h[0].trim() || h.shift(), h.length > 0 && !h[h.length - 1].trim() && h.pop(), h.length > c) h.splice(c);
          else for (; h.length < c; ) h.push("");
          for (; b < h.length; b++) h[b] = h[b].trim().replace(/\\\|/g, "|");
          return h;
        }
        function Rp(u, c, h) {
          const b = u.length;
          if (b === 0) return "";
          let E = 0;
          for (; E < b; ) {
            const P = u.charAt(b - E - 1);
            if (P !== c || h) {
              if (P === c || !h) break;
              E++;
            } else E++;
          }
          return u.slice(0, b - E);
        }
        function VS(u, c) {
          if (c < 1) return "";
          let h = "";
          for (; c > 1; ) 1 & c && (h += u), c >>= 1, u += u;
          return h + u;
        }
        function WS(u, c, h, b) {
          const E = c.href, P = c.title ? Vt(c.title) : null, $ = u[1].replace(/\\([\[\]])/g, "$1");
          if (u[0].charAt(0) !== "!") {
            b.state.inLink = !0;
            const V = { type: "link", raw: h, href: E, title: P, text: $, tokens: b.inlineTokens($) };
            return b.state.inLink = !1, V;
          }
          return { type: "image", raw: h, href: E, title: P, text: Vt($) };
        }
        class Ag {
          constructor(c) {
            this.options = c || Re;
          }
          space(c) {
            const h = this.rules.block.newline.exec(c);
            if (h && h[0].length > 0) return { type: "space", raw: h[0] };
          }
          code(c) {
            const h = this.rules.block.code.exec(c);
            if (h) {
              const b = h[0].replace(/^ {1,4}/gm, "");
              return { type: "code", raw: h[0], codeBlockStyle: "indented", text: this.options.pedantic ? b : Rp(b, `
`) };
            }
          }
          fences(c) {
            const h = this.rules.block.fences.exec(c);
            if (h) {
              const b = h[0], E = function(P, $) {
                const V = P.match(/^(\s+)(?:```)/);
                if (V === null) return $;
                const ee = V[1];
                return $.split(`
`).map((ie) => {
                  const ne = ie.match(/^\s+/);
                  if (ne === null) return ie;
                  const [se] = ne;
                  return se.length >= ee.length ? ie.slice(ee.length) : ie;
                }).join(`
`);
              }(b, h[3] || "");
              return { type: "code", raw: b, lang: h[2] ? h[2].trim().replace(this.rules.inline._escapes, "$1") : h[2], text: E };
            }
          }
          heading(c) {
            const h = this.rules.block.heading.exec(c);
            if (h) {
              let b = h[2].trim();
              if (/#$/.test(b)) {
                const E = Rp(b, "#");
                this.options.pedantic ? b = E.trim() : E && !/ $/.test(E) || (b = E.trim());
              }
              return { type: "heading", raw: h[0], depth: h[1].length, text: b, tokens: this.lexer.inline(b) };
            }
          }
          hr(c) {
            const h = this.rules.block.hr.exec(c);
            if (h) return { type: "hr", raw: h[0] };
          }
          blockquote(c) {
            const h = this.rules.block.blockquote.exec(c);
            if (h) {
              const b = h[0].replace(/^ *>[ \t]?/gm, ""), E = this.lexer.state.top;
              this.lexer.state.top = !0;
              const P = this.lexer.blockTokens(b);
              return this.lexer.state.top = E, { type: "blockquote", raw: h[0], tokens: P, text: b };
            }
          }
          list(c) {
            let h = this.rules.block.list.exec(c);
            if (h) {
              let b, E, P, $, V, ee, ie, ne, se, me, Ie, ze, yt = h[1].trim();
              const kt = yt.length > 1, it = { type: "list", raw: "", ordered: kt, start: kt ? +yt.slice(0, -1) : "", loose: !1, items: [] };
              yt = kt ? `\\d{1,9}\\${yt.slice(-1)}` : `\\${yt}`, this.options.pedantic && (yt = kt ? yt : "[*+-]");
              const an = new RegExp(`^( {0,3}${yt})((?:[	 ][^\\n]*)?(?:\\n|$))`);
              for (; c && (ze = !1, h = an.exec(c)) && !this.rules.block.hr.test(c); ) {
                if (b = h[0], c = c.substring(b.length), ne = h[2].split(`
`, 1)[0].replace(/^\t+/, (Kt) => " ".repeat(3 * Kt.length)), se = c.split(`
`, 1)[0], this.options.pedantic ? ($ = 2, Ie = ne.trimLeft()) : ($ = h[2].search(/[^ ]/), $ = $ > 4 ? 1 : $, Ie = ne.slice($), $ += h[1].length), ee = !1, !ne && /^ *$/.test(se) && (b += se + `
`, c = c.substring(se.length + 1), ze = !0), !ze) {
                  const Kt = new RegExp(`^ {0,${Math.min(3, $ - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), On = new RegExp(`^ {0,${Math.min(3, $ - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), er = new RegExp(`^ {0,${Math.min(3, $ - 1)}}(?:\`\`\`|~~~)`), Er = new RegExp(`^ {0,${Math.min(3, $ - 1)}}#`);
                  for (; c && (me = c.split(`
`, 1)[0], se = me, this.options.pedantic && (se = se.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !er.test(se)) && !Er.test(se) && !Kt.test(se) && !On.test(c); ) {
                    if (se.search(/[^ ]/) >= $ || !se.trim()) Ie += `
` + se.slice($);
                    else {
                      if (ee || ne.search(/[^ ]/) >= 4 || er.test(ne) || Er.test(ne) || On.test(ne)) break;
                      Ie += `
` + se;
                    }
                    ee || se.trim() || (ee = !0), b += me + `
`, c = c.substring(me.length + 1), ne = se.slice($);
                  }
                }
                it.loose || (ie ? it.loose = !0 : /\n *\n *$/.test(b) && (ie = !0)), this.options.gfm && (E = /^\[[ xX]\] /.exec(Ie), E && (P = E[0] !== "[ ] ", Ie = Ie.replace(/^\[[ xX]\] +/, ""))), it.items.push({ type: "list_item", raw: b, task: !!E, checked: P, loose: !1, text: Ie }), it.raw += b;
              }
              it.items[it.items.length - 1].raw = b.trimRight(), it.items[it.items.length - 1].text = Ie.trimRight(), it.raw = it.raw.trimRight();
              const Vr = it.items.length;
              for (V = 0; V < Vr; V++) if (this.lexer.state.top = !1, it.items[V].tokens = this.lexer.blockTokens(it.items[V].text, []), !it.loose) {
                const Kt = it.items[V].tokens.filter((er) => er.type === "space"), On = Kt.length > 0 && Kt.some((er) => /\n.*\n/.test(er.raw));
                it.loose = On;
              }
              if (it.loose) for (V = 0; V < Vr; V++) it.items[V].loose = !0;
              return it;
            }
          }
          html(c) {
            const h = this.rules.block.html.exec(c);
            if (h) {
              const b = { type: "html", raw: h[0], pre: !this.options.sanitizer && (h[1] === "pre" || h[1] === "script" || h[1] === "style"), text: h[0] };
              if (this.options.sanitize) {
                const E = this.options.sanitizer ? this.options.sanitizer(h[0]) : Vt(h[0]);
                b.type = "paragraph", b.text = E, b.tokens = this.lexer.inline(E);
              }
              return b;
            }
          }
          def(c) {
            const h = this.rules.block.def.exec(c);
            if (h) {
              const b = h[1].toLowerCase().replace(/\s+/g, " "), E = h[2] ? h[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "", P = h[3] ? h[3].substring(1, h[3].length - 1).replace(this.rules.inline._escapes, "$1") : h[3];
              return { type: "def", tag: b, raw: h[0], href: E, title: P };
            }
          }
          table(c) {
            const h = this.rules.block.table.exec(c);
            if (h) {
              const b = { type: "table", header: US(h[1]).map((E) => ({ text: E })), align: h[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: h[3] && h[3].trim() ? h[3].replace(/\n[ \t]*$/, "").split(`
`) : [] };
              if (b.header.length === b.align.length) {
                b.raw = h[0];
                let E, P, $, V, ee = b.align.length;
                for (E = 0; E < ee; E++) /^ *-+: *$/.test(b.align[E]) ? b.align[E] = "right" : /^ *:-+: *$/.test(b.align[E]) ? b.align[E] = "center" : /^ *:-+ *$/.test(b.align[E]) ? b.align[E] = "left" : b.align[E] = null;
                for (ee = b.rows.length, E = 0; E < ee; E++) b.rows[E] = US(b.rows[E], b.header.length).map((ie) => ({ text: ie }));
                for (ee = b.header.length, P = 0; P < ee; P++) b.header[P].tokens = this.lexer.inline(b.header[P].text);
                for (ee = b.rows.length, P = 0; P < ee; P++) for (V = b.rows[P], $ = 0; $ < V.length; $++) V[$].tokens = this.lexer.inline(V[$].text);
                return b;
              }
            }
          }
          lheading(c) {
            const h = this.rules.block.lheading.exec(c);
            if (h) return { type: "heading", raw: h[0], depth: h[2].charAt(0) === "=" ? 1 : 2, text: h[1], tokens: this.lexer.inline(h[1]) };
          }
          paragraph(c) {
            const h = this.rules.block.paragraph.exec(c);
            if (h) {
              const b = h[1].charAt(h[1].length - 1) === `
` ? h[1].slice(0, -1) : h[1];
              return { type: "paragraph", raw: h[0], text: b, tokens: this.lexer.inline(b) };
            }
          }
          text(c) {
            const h = this.rules.block.text.exec(c);
            if (h) return { type: "text", raw: h[0], text: h[0], tokens: this.lexer.inline(h[0]) };
          }
          escape(c) {
            const h = this.rules.inline.escape.exec(c);
            if (h) return { type: "escape", raw: h[0], text: Vt(h[1]) };
          }
          tag(c) {
            const h = this.rules.inline.tag.exec(c);
            if (h) return !this.lexer.state.inLink && /^<a /i.test(h[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(h[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(h[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(h[0]) && (this.lexer.state.inRawBlock = !1), { type: this.options.sanitize ? "text" : "html", raw: h[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(h[0]) : Vt(h[0]) : h[0] };
          }
          link(c) {
            const h = this.rules.inline.link.exec(c);
            if (h) {
              const b = h[2].trim();
              if (!this.options.pedantic && /^</.test(b)) {
                if (!/>$/.test(b)) return;
                const $ = Rp(b.slice(0, -1), "\\");
                if ((b.length - $.length) % 2 == 0) return;
              } else {
                const $ = function(V, ee) {
                  if (V.indexOf(ee[1]) === -1) return -1;
                  const ie = V.length;
                  let ne = 0, se = 0;
                  for (; se < ie; se++) if (V[se] === "\\") se++;
                  else if (V[se] === ee[0]) ne++;
                  else if (V[se] === ee[1] && (ne--, ne < 0)) return se;
                  return -1;
                }(h[2], "()");
                if ($ > -1) {
                  const V = (h[0].indexOf("!") === 0 ? 5 : 4) + h[1].length + $;
                  h[2] = h[2].substring(0, $), h[0] = h[0].substring(0, V).trim(), h[3] = "";
                }
              }
              let E = h[2], P = "";
              if (this.options.pedantic) {
                const $ = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(E);
                $ && (E = $[1], P = $[3]);
              } else P = h[3] ? h[3].slice(1, -1) : "";
              return E = E.trim(), /^</.test(E) && (E = this.options.pedantic && !/>$/.test(b) ? E.slice(1) : E.slice(1, -1)), WS(h, { href: E && E.replace(this.rules.inline._escapes, "$1"), title: P && P.replace(this.rules.inline._escapes, "$1") }, h[0], this.lexer);
            }
          }
          reflink(c, h) {
            let b;
            if ((b = this.rules.inline.reflink.exec(c)) || (b = this.rules.inline.nolink.exec(c))) {
              let E = (b[2] || b[1]).replace(/\s+/g, " ");
              if (E = h[E.toLowerCase()], !E) {
                const P = b[0].charAt(0);
                return { type: "text", raw: P, text: P };
              }
              return WS(b, E, b[0], this.lexer);
            }
          }
          emStrong(c, h, b = "") {
            let E = this.rules.inline.emStrong.lDelim.exec(c);
            if (!E || E[3] && b.match(/[\p{L}\p{N}]/u)) return;
            const P = E[1] || E[2] || "";
            if (!P || P && (b === "" || this.rules.inline.punctuation.exec(b))) {
              const $ = E[0].length - 1;
              let V, ee, ie = $, ne = 0;
              const se = E[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
              for (se.lastIndex = 0, h = h.slice(-1 * c.length + $); (E = se.exec(h)) != null; ) {
                if (V = E[1] || E[2] || E[3] || E[4] || E[5] || E[6], !V) continue;
                if (ee = V.length, E[3] || E[4]) {
                  ie += ee;
                  continue;
                }
                if ((E[5] || E[6]) && $ % 3 && !(($ + ee) % 3)) {
                  ne += ee;
                  continue;
                }
                if (ie -= ee, ie > 0) continue;
                ee = Math.min(ee, ee + ie + ne);
                const me = c.slice(0, $ + E.index + (E[0].length - V.length) + ee);
                if (Math.min($, ee) % 2) {
                  const ze = me.slice(1, -1);
                  return { type: "em", raw: me, text: ze, tokens: this.lexer.inlineTokens(ze) };
                }
                const Ie = me.slice(2, -2);
                return { type: "strong", raw: me, text: Ie, tokens: this.lexer.inlineTokens(Ie) };
              }
            }
          }
          codespan(c) {
            const h = this.rules.inline.code.exec(c);
            if (h) {
              let b = h[2].replace(/\n/g, " ");
              const E = /[^ ]/.test(b), P = /^ /.test(b) && / $/.test(b);
              return E && P && (b = b.substring(1, b.length - 1)), b = Vt(b, !0), { type: "codespan", raw: h[0], text: b };
            }
          }
          br(c) {
            const h = this.rules.inline.br.exec(c);
            if (h) return { type: "br", raw: h[0] };
          }
          del(c) {
            const h = this.rules.inline.del.exec(c);
            if (h) return { type: "del", raw: h[0], text: h[2], tokens: this.lexer.inlineTokens(h[2]) };
          }
          autolink(c, h) {
            const b = this.rules.inline.autolink.exec(c);
            if (b) {
              let E, P;
              return b[2] === "@" ? (E = Vt(this.options.mangle ? h(b[1]) : b[1]), P = "mailto:" + E) : (E = Vt(b[1]), P = E), { type: "link", raw: b[0], text: E, href: P, tokens: [{ type: "text", raw: E, text: E }] };
            }
          }
          url(c, h) {
            let b;
            if (b = this.rules.inline.url.exec(c)) {
              let E, P;
              if (b[2] === "@") E = Vt(this.options.mangle ? h(b[0]) : b[0]), P = "mailto:" + E;
              else {
                let $;
                do
                  $ = b[0], b[0] = this.rules.inline._backpedal.exec(b[0])[0];
                while ($ !== b[0]);
                E = Vt(b[0]), P = b[1] === "www." ? "http://" + b[0] : b[0];
              }
              return { type: "link", raw: b[0], text: E, href: P, tokens: [{ type: "text", raw: E, text: E }] };
            }
          }
          inlineText(c, h) {
            const b = this.rules.inline.text.exec(c);
            if (b) {
              let E;
              return E = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(b[0]) : Vt(b[0]) : b[0] : Vt(this.options.smartypants ? h(b[0]) : b[0]), { type: "text", raw: b[0], text: E };
            }
          }
        }
        const Ze = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/, html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/, table: $p, lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text: /^[^\n]+/, _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/ };
        Ze.def = Ot(Ze.def).replace("label", Ze._label).replace("title", Ze._title).getRegex(), Ze.bullet = /(?:[*+-]|\d{1,9}[.)])/, Ze.listItemStart = Ot(/^( *)(bull) */).replace("bull", Ze.bullet).getRegex(), Ze.list = Ot(Ze.list).replace(/bull/g, Ze.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Ze.def.source + ")").getRegex(), Ze._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Ze._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, Ze.html = Ot(Ze.html, "i").replace("comment", Ze._comment).replace("tag", Ze._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), Ze.paragraph = Ot(Ze._paragraph).replace("hr", Ze.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ze._tag).getRegex(), Ze.blockquote = Ot(Ze.blockquote).replace("paragraph", Ze.paragraph).getRegex(), Ze.normal = { ...Ze }, Ze.gfm = { ...Ze.normal, table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }, Ze.gfm.table = Ot(Ze.gfm.table).replace("hr", Ze.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ze._tag).getRegex(), Ze.gfm.paragraph = Ot(Ze._paragraph).replace("hr", Ze.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Ze.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ze._tag).getRegex(), Ze.pedantic = { ...Ze.normal, html: Ot(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Ze._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: $p, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: Ot(Ze.normal._paragraph).replace("hr", Ze.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Ze.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() };
        const qe = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: $p, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(ref)\]/, nolink: /^!?\[(ref)\](?:\[\])?/, reflinkSearch: "reflink|nolink(?!\\()", emStrong: { lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/, rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ }, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: $p, text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation: /^([\spunctuation])/ };
        function SL(u) {
          return u.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
        }
        function HS(u) {
          let c, h, b = "";
          const E = u.length;
          for (c = 0; c < E; c++) h = u.charCodeAt(c), Math.random() > 0.5 && (h = "x" + h.toString(16)), b += "&#" + h + ";";
          return b;
        }
        qe._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", qe.punctuation = Ot(qe.punctuation).replace(/punctuation/g, qe._punctuation).getRegex(), qe.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, qe.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g, qe._comment = Ot(Ze._comment).replace("(?:-->|$)", "-->").getRegex(), qe.emStrong.lDelim = Ot(qe.emStrong.lDelim).replace(/punct/g, qe._punctuation).getRegex(), qe.emStrong.rDelimAst = Ot(qe.emStrong.rDelimAst, "g").replace(/punct/g, qe._punctuation).getRegex(), qe.emStrong.rDelimUnd = Ot(qe.emStrong.rDelimUnd, "g").replace(/punct/g, qe._punctuation).getRegex(), qe._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, qe._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, qe._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, qe.autolink = Ot(qe.autolink).replace("scheme", qe._scheme).replace("email", qe._email).getRegex(), qe._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, qe.tag = Ot(qe.tag).replace("comment", qe._comment).replace("attribute", qe._attribute).getRegex(), qe._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, qe._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, qe._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, qe.link = Ot(qe.link).replace("label", qe._label).replace("href", qe._href).replace("title", qe._title).getRegex(), qe.reflink = Ot(qe.reflink).replace("label", qe._label).replace("ref", Ze._label).getRegex(), qe.nolink = Ot(qe.nolink).replace("ref", Ze._label).getRegex(), qe.reflinkSearch = Ot(qe.reflinkSearch, "g").replace("reflink", qe.reflink).replace("nolink", qe.nolink).getRegex(), qe.normal = { ...qe }, qe.pedantic = { ...qe.normal, strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g }, em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g }, link: Ot(/^!?\[(label)\]\((.*?)\)/).replace("label", qe._label).getRegex(), reflink: Ot(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", qe._label).getRegex() }, qe.gfm = { ...qe.normal, escape: Ot(qe.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, qe.gfm.url = Ot(qe.gfm.url, "i").replace("email", qe.gfm._extended_email).getRegex(), qe.breaks = { ...qe.gfm, br: Ot(qe.br).replace("{2,}", "*").getRegex(), text: Ot(qe.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
        class xo {
          constructor(c) {
            this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = c || Re, this.options.tokenizer = this.options.tokenizer || new Ag(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
            const h = { block: Ze.normal, inline: qe.normal };
            this.options.pedantic ? (h.block = Ze.pedantic, h.inline = qe.pedantic) : this.options.gfm && (h.block = Ze.gfm, this.options.breaks ? h.inline = qe.breaks : h.inline = qe.gfm), this.tokenizer.rules = h;
          }
          static get rules() {
            return { block: Ze, inline: qe };
          }
          static lex(c, h) {
            return new xo(h).lex(c);
          }
          static lexInline(c, h) {
            return new xo(h).inlineTokens(c);
          }
          lex(c) {
            let h;
            for (c = c.replace(/\r\n|\r/g, `
`), this.blockTokens(c, this.tokens); h = this.inlineQueue.shift(); ) this.inlineTokens(h.src, h.tokens);
            return this.tokens;
          }
          blockTokens(c, h = []) {
            let b, E, P, $;
            for (c = this.options.pedantic ? c.replace(/\t/g, "    ").replace(/^ +$/gm, "") : c.replace(/^( *)(\t+)/gm, (V, ee, ie) => ee + "    ".repeat(ie.length)); c; ) if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((V) => !!(b = V.call({ lexer: this }, c, h)) && (c = c.substring(b.raw.length), h.push(b), !0)))) if (b = this.tokenizer.space(c)) c = c.substring(b.raw.length), b.raw.length === 1 && h.length > 0 ? h[h.length - 1].raw += `
` : h.push(b);
            else if (b = this.tokenizer.code(c)) c = c.substring(b.raw.length), E = h[h.length - 1], !E || E.type !== "paragraph" && E.type !== "text" ? h.push(b) : (E.raw += `
` + b.raw, E.text += `
` + b.text, this.inlineQueue[this.inlineQueue.length - 1].src = E.text);
            else if (b = this.tokenizer.fences(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.heading(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.hr(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.blockquote(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.list(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.html(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.def(c)) c = c.substring(b.raw.length), E = h[h.length - 1], !E || E.type !== "paragraph" && E.type !== "text" ? this.tokens.links[b.tag] || (this.tokens.links[b.tag] = { href: b.href, title: b.title }) : (E.raw += `
` + b.raw, E.text += `
` + b.raw, this.inlineQueue[this.inlineQueue.length - 1].src = E.text);
            else if (b = this.tokenizer.table(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.lheading(c)) c = c.substring(b.raw.length), h.push(b);
            else {
              if (P = c, this.options.extensions && this.options.extensions.startBlock) {
                let V = 1 / 0;
                const ee = c.slice(1);
                let ie;
                this.options.extensions.startBlock.forEach(function(ne) {
                  ie = ne.call({ lexer: this }, ee), typeof ie == "number" && ie >= 0 && (V = Math.min(V, ie));
                }), V < 1 / 0 && V >= 0 && (P = c.substring(0, V + 1));
              }
              if (this.state.top && (b = this.tokenizer.paragraph(P))) E = h[h.length - 1], $ && E.type === "paragraph" ? (E.raw += `
` + b.raw, E.text += `
` + b.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = E.text) : h.push(b), $ = P.length !== c.length, c = c.substring(b.raw.length);
              else if (b = this.tokenizer.text(c)) c = c.substring(b.raw.length), E = h[h.length - 1], E && E.type === "text" ? (E.raw += `
` + b.raw, E.text += `
` + b.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = E.text) : h.push(b);
              else if (c) {
                const V = "Infinite loop on byte: " + c.charCodeAt(0);
                if (this.options.silent) {
                  console.error(V);
                  break;
                }
                throw new Error(V);
              }
            }
            return this.state.top = !0, h;
          }
          inline(c, h = []) {
            return this.inlineQueue.push({ src: c, tokens: h }), h;
          }
          inlineTokens(c, h = []) {
            let b, E, P, $, V, ee, ie = c;
            if (this.tokens.links) {
              const ne = Object.keys(this.tokens.links);
              if (ne.length > 0) for (; ($ = this.tokenizer.rules.inline.reflinkSearch.exec(ie)) != null; ) ne.includes($[0].slice($[0].lastIndexOf("[") + 1, -1)) && (ie = ie.slice(0, $.index) + "[" + VS("a", $[0].length - 2) + "]" + ie.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
            }
            for (; ($ = this.tokenizer.rules.inline.blockSkip.exec(ie)) != null; ) ie = ie.slice(0, $.index) + "[" + VS("a", $[0].length - 2) + "]" + ie.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            for (; ($ = this.tokenizer.rules.inline.escapedEmSt.exec(ie)) != null; ) ie = ie.slice(0, $.index + $[0].length - 2) + "++" + ie.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex), this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
            for (; c; ) if (V || (ee = ""), V = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((ne) => !!(b = ne.call({ lexer: this }, c, h)) && (c = c.substring(b.raw.length), h.push(b), !0)))) if (b = this.tokenizer.escape(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.tag(c)) c = c.substring(b.raw.length), E = h[h.length - 1], E && b.type === "text" && E.type === "text" ? (E.raw += b.raw, E.text += b.text) : h.push(b);
            else if (b = this.tokenizer.link(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.reflink(c, this.tokens.links)) c = c.substring(b.raw.length), E = h[h.length - 1], E && b.type === "text" && E.type === "text" ? (E.raw += b.raw, E.text += b.text) : h.push(b);
            else if (b = this.tokenizer.emStrong(c, ie, ee)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.codespan(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.br(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.del(c)) c = c.substring(b.raw.length), h.push(b);
            else if (b = this.tokenizer.autolink(c, HS)) c = c.substring(b.raw.length), h.push(b);
            else if (this.state.inLink || !(b = this.tokenizer.url(c, HS))) {
              if (P = c, this.options.extensions && this.options.extensions.startInline) {
                let ne = 1 / 0;
                const se = c.slice(1);
                let me;
                this.options.extensions.startInline.forEach(function(Ie) {
                  me = Ie.call({ lexer: this }, se), typeof me == "number" && me >= 0 && (ne = Math.min(ne, me));
                }), ne < 1 / 0 && ne >= 0 && (P = c.substring(0, ne + 1));
              }
              if (b = this.tokenizer.inlineText(P, SL)) c = c.substring(b.raw.length), b.raw.slice(-1) !== "_" && (ee = b.raw.slice(-1)), V = !0, E = h[h.length - 1], E && E.type === "text" ? (E.raw += b.raw, E.text += b.text) : h.push(b);
              else if (c) {
                const ne = "Infinite loop on byte: " + c.charCodeAt(0);
                if (this.options.silent) {
                  console.error(ne);
                  break;
                }
                throw new Error(ne);
              }
            } else c = c.substring(b.raw.length), h.push(b);
            return h;
          }
        }
        class Pg {
          constructor(c) {
            this.options = c || Re;
          }
          code(c, h, b) {
            const E = (h || "").match(/\S*/)[0];
            if (this.options.highlight) {
              const P = this.options.highlight(c, E);
              P != null && P !== c && (b = !0, c = P);
            }
            return c = c.replace(/\n$/, "") + `
`, E ? '<pre><code class="' + this.options.langPrefix + Vt(E) + '">' + (b ? c : Vt(c, !0)) + `</code></pre>
` : "<pre><code>" + (b ? c : Vt(c, !0)) + `</code></pre>
`;
          }
          blockquote(c) {
            return `<blockquote>
${c}</blockquote>
`;
          }
          html(c) {
            return c;
          }
          heading(c, h, b, E) {
            return this.options.headerIds ? `<h${h} id="${this.options.headerPrefix + E.slug(b)}">${c}</h${h}>
` : `<h${h}>${c}</h${h}>
`;
          }
          hr() {
            return this.options.xhtml ? `<hr/>
` : `<hr>
`;
          }
          list(c, h, b) {
            const E = h ? "ol" : "ul";
            return "<" + E + (h && b !== 1 ? ' start="' + b + '"' : "") + `>
` + c + "</" + E + `>
`;
          }
          listitem(c) {
            return `<li>${c}</li>
`;
          }
          checkbox(c) {
            return "<input " + (c ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
          }
          paragraph(c) {
            return `<p>${c}</p>
`;
          }
          table(c, h) {
            return h && (h = `<tbody>${h}</tbody>`), `<table>
<thead>
` + c + `</thead>
` + h + `</table>
`;
          }
          tablerow(c) {
            return `<tr>
${c}</tr>
`;
          }
          tablecell(c, h) {
            const b = h.header ? "th" : "td";
            return (h.align ? `<${b} align="${h.align}">` : `<${b}>`) + c + `</${b}>
`;
          }
          strong(c) {
            return `<strong>${c}</strong>`;
          }
          em(c) {
            return `<em>${c}</em>`;
          }
          codespan(c) {
            return `<code>${c}</code>`;
          }
          br() {
            return this.options.xhtml ? "<br/>" : "<br>";
          }
          del(c) {
            return `<del>${c}</del>`;
          }
          link(c, h, b) {
            if ((c = BS(this.options.sanitize, this.options.baseUrl, c)) === null) return b;
            let E = '<a href="' + c + '"';
            return h && (E += ' title="' + h + '"'), E += ">" + b + "</a>", E;
          }
          image(c, h, b) {
            if ((c = BS(this.options.sanitize, this.options.baseUrl, c)) === null) return b;
            let E = `<img src="${c}" alt="${b}"`;
            return h && (E += ` title="${h}"`), E += this.options.xhtml ? "/>" : ">", E;
          }
          text(c) {
            return c;
          }
        }
        class QS {
          strong(c) {
            return c;
          }
          em(c) {
            return c;
          }
          codespan(c) {
            return c;
          }
          del(c) {
            return c;
          }
          html(c) {
            return c;
          }
          text(c) {
            return c;
          }
          link(c, h, b) {
            return "" + b;
          }
          image(c, h, b) {
            return "" + b;
          }
          br() {
            return "";
          }
        }
        class YS {
          constructor() {
            this.seen = {};
          }
          serialize(c) {
            return c.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
          }
          getNextSafeSlug(c, h) {
            let b = c, E = 0;
            if (this.seen.hasOwnProperty(b)) {
              E = this.seen[c];
              do
                E++, b = c + "-" + E;
              while (this.seen.hasOwnProperty(b));
            }
            return h || (this.seen[c] = E, this.seen[b] = 0), b;
          }
          slug(c, h = {}) {
            const b = this.serialize(c);
            return this.getNextSafeSlug(b, h.dryrun);
          }
        }
        class _o {
          constructor(c) {
            this.options = c || Re, this.options.renderer = this.options.renderer || new Pg(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new QS(), this.slugger = new YS();
          }
          static parse(c, h) {
            return new _o(h).parse(c);
          }
          static parseInline(c, h) {
            return new _o(h).parseInline(c);
          }
          parse(c, h = !0) {
            let b, E, P, $, V, ee, ie, ne, se, me, Ie, ze, yt, kt, it, an, Vr, Kt, On, er = "";
            const Er = c.length;
            for (b = 0; b < Er; b++) if (me = c[b], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[me.type] && (On = this.options.extensions.renderers[me.type].call({ parser: this }, me), On !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(me.type))) er += On || "";
            else switch (me.type) {
              case "space":
                continue;
              case "hr":
                er += this.renderer.hr();
                continue;
              case "heading":
                er += this.renderer.heading(this.parseInline(me.tokens), me.depth, mu(this.parseInline(me.tokens, this.textRenderer)), this.slugger);
                continue;
              case "code":
                er += this.renderer.code(me.text, me.lang, me.escaped);
                continue;
              case "table":
                for (ne = "", ie = "", $ = me.header.length, E = 0; E < $; E++) ie += this.renderer.tablecell(this.parseInline(me.header[E].tokens), { header: !0, align: me.align[E] });
                for (ne += this.renderer.tablerow(ie), se = "", $ = me.rows.length, E = 0; E < $; E++) {
                  for (ee = me.rows[E], ie = "", V = ee.length, P = 0; P < V; P++) ie += this.renderer.tablecell(this.parseInline(ee[P].tokens), { header: !1, align: me.align[P] });
                  se += this.renderer.tablerow(ie);
                }
                er += this.renderer.table(ne, se);
                continue;
              case "blockquote":
                se = this.parse(me.tokens), er += this.renderer.blockquote(se);
                continue;
              case "list":
                for (Ie = me.ordered, ze = me.start, yt = me.loose, $ = me.items.length, se = "", E = 0; E < $; E++) it = me.items[E], an = it.checked, Vr = it.task, kt = "", it.task && (Kt = this.renderer.checkbox(an), yt ? it.tokens.length > 0 && it.tokens[0].type === "paragraph" ? (it.tokens[0].text = Kt + " " + it.tokens[0].text, it.tokens[0].tokens && it.tokens[0].tokens.length > 0 && it.tokens[0].tokens[0].type === "text" && (it.tokens[0].tokens[0].text = Kt + " " + it.tokens[0].tokens[0].text)) : it.tokens.unshift({ type: "text", text: Kt }) : kt += Kt), kt += this.parse(it.tokens, yt), se += this.renderer.listitem(kt, Vr, an);
                er += this.renderer.list(se, Ie, ze);
                continue;
              case "html":
                er += this.renderer.html(me.text);
                continue;
              case "paragraph":
                er += this.renderer.paragraph(this.parseInline(me.tokens));
                continue;
              case "text":
                for (se = me.tokens ? this.parseInline(me.tokens) : me.text; b + 1 < Er && c[b + 1].type === "text"; ) me = c[++b], se += `
` + (me.tokens ? this.parseInline(me.tokens) : me.text);
                er += h ? this.renderer.paragraph(se) : se;
                continue;
              default: {
                const Hi = 'Token with "' + me.type + '" type was not found.';
                if (this.options.silent) return void console.error(Hi);
                throw new Error(Hi);
              }
            }
            return er;
          }
          parseInline(c, h) {
            h = h || this.renderer;
            let b, E, P, $ = "";
            const V = c.length;
            for (b = 0; b < V; b++) if (E = c[b], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[E.type] && (P = this.options.extensions.renderers[E.type].call({ parser: this }, E), P !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(E.type))) $ += P || "";
            else switch (E.type) {
              case "escape":
              case "text":
                $ += h.text(E.text);
                break;
              case "html":
                $ += h.html(E.text);
                break;
              case "link":
                $ += h.link(E.href, E.title, this.parseInline(E.tokens, h));
                break;
              case "image":
                $ += h.image(E.href, E.title, E.text);
                break;
              case "strong":
                $ += h.strong(this.parseInline(E.tokens, h));
                break;
              case "em":
                $ += h.em(this.parseInline(E.tokens, h));
                break;
              case "codespan":
                $ += h.codespan(E.text);
                break;
              case "br":
                $ += h.br();
                break;
              case "del":
                $ += h.del(this.parseInline(E.tokens, h));
                break;
              default: {
                const ee = 'Token with "' + E.type + '" type was not found.';
                if (this.options.silent) return void console.error(ee);
                throw new Error(ee);
              }
            }
            return $;
          }
        }
        class Ip {
          constructor(c) {
            this.options = c || Re;
          }
          preprocess(c) {
            return c;
          }
          postprocess(c) {
            return c;
          }
        }
        D_(Ip, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess"]));
        function GS(u, c) {
          return (h, b, E) => {
            typeof b == "function" && (E = b, b = null);
            const P = { ...b }, $ = /* @__PURE__ */ function(V, ee, ie) {
              return (ne) => {
                if (ne.message += `
Please report this to https://github.com/markedjs/marked.`, V) {
                  const se = "<p>An error occurred:</p><pre>" + Vt(ne.message + "", !0) + "</pre>";
                  return ee ? Promise.resolve(se) : ie ? void ie(null, se) : se;
                }
                if (ee) return Promise.reject(ne);
                if (!ie) throw ne;
                ie(ne);
              };
            }((b = { ...Ke.defaults, ...P }).silent, b.async, E);
            if (h == null) return $(new Error("marked(): input parameter is undefined or null"));
            if (typeof h != "string") return $(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(h) + ", string expected"));
            if (function(V) {
              V && V.sanitize && !V.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
            }(b), b.hooks && (b.hooks.options = b), E) {
              const V = b.highlight;
              let ee;
              try {
                b.hooks && (h = b.hooks.preprocess(h)), ee = u(h, b);
              } catch (se) {
                return $(se);
              }
              const ie = function(se) {
                let me;
                if (!se) try {
                  b.walkTokens && Ke.walkTokens(ee, b.walkTokens), me = c(ee, b), b.hooks && (me = b.hooks.postprocess(me));
                } catch (Ie) {
                  se = Ie;
                }
                return b.highlight = V, se ? $(se) : E(null, me);
              };
              if (!V || V.length < 3 || (delete b.highlight, !ee.length)) return ie();
              let ne = 0;
              return Ke.walkTokens(ee, function(se) {
                se.type === "code" && (ne++, setTimeout(() => {
                  V(se.text, se.lang, function(me, Ie) {
                    if (me) return ie(me);
                    Ie != null && Ie !== se.text && (se.text = Ie, se.escaped = !0), ne--, ne === 0 && ie();
                  });
                }, 0));
              }), void (ne === 0 && ie());
            }
            if (b.async) return Promise.resolve(b.hooks ? b.hooks.preprocess(h) : h).then((V) => u(V, b)).then((V) => b.walkTokens ? Promise.all(Ke.walkTokens(V, b.walkTokens)).then(() => V) : V).then((V) => c(V, b)).then((V) => b.hooks ? b.hooks.postprocess(V) : V).catch($);
            try {
              b.hooks && (h = b.hooks.preprocess(h));
              const V = u(h, b);
              b.walkTokens && Ke.walkTokens(V, b.walkTokens);
              let ee = c(V, b);
              return b.hooks && (ee = b.hooks.postprocess(ee)), ee;
            } catch (V) {
              return $(V);
            }
          };
        }
        function Ke(u, c, h) {
          return GS(xo.lex, _o.parse)(u, c, h);
        }
        Ke.options = Ke.setOptions = function(u) {
          var c;
          return Ke.defaults = { ...Ke.defaults, ...u }, c = Ke.defaults, Re = c, Ke;
        }, Ke.getDefaults = function() {
          return { async: !1, baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, hooks: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
        }, Ke.defaults = Re, Ke.use = function(...u) {
          const c = Ke.defaults.extensions || { renderers: {}, childTokens: {} };
          u.forEach((h) => {
            const b = { ...h };
            if (b.async = Ke.defaults.async || b.async || !1, h.extensions && (h.extensions.forEach((E) => {
              if (!E.name) throw new Error("extension name required");
              if (E.renderer) {
                const P = c.renderers[E.name];
                c.renderers[E.name] = P ? function(...$) {
                  let V = E.renderer.apply(this, $);
                  return V === !1 && (V = P.apply(this, $)), V;
                } : E.renderer;
              }
              if (E.tokenizer) {
                if (!E.level || E.level !== "block" && E.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
                c[E.level] ? c[E.level].unshift(E.tokenizer) : c[E.level] = [E.tokenizer], E.start && (E.level === "block" ? c.startBlock ? c.startBlock.push(E.start) : c.startBlock = [E.start] : E.level === "inline" && (c.startInline ? c.startInline.push(E.start) : c.startInline = [E.start]));
              }
              E.childTokens && (c.childTokens[E.name] = E.childTokens);
            }), b.extensions = c), h.renderer) {
              const E = Ke.defaults.renderer || new Pg();
              for (const P in h.renderer) {
                const $ = E[P];
                E[P] = (...V) => {
                  let ee = h.renderer[P].apply(E, V);
                  return ee === !1 && (ee = $.apply(E, V)), ee;
                };
              }
              b.renderer = E;
            }
            if (h.tokenizer) {
              const E = Ke.defaults.tokenizer || new Ag();
              for (const P in h.tokenizer) {
                const $ = E[P];
                E[P] = (...V) => {
                  let ee = h.tokenizer[P].apply(E, V);
                  return ee === !1 && (ee = $.apply(E, V)), ee;
                };
              }
              b.tokenizer = E;
            }
            if (h.hooks) {
              const E = Ke.defaults.hooks || new Ip();
              for (const P in h.hooks) {
                const $ = E[P];
                Ip.passThroughHooks.has(P) ? E[P] = (V) => {
                  if (Ke.defaults.async) return Promise.resolve(h.hooks[P].call(E, V)).then((ie) => $.call(E, ie));
                  const ee = h.hooks[P].call(E, V);
                  return $.call(E, ee);
                } : E[P] = (...V) => {
                  let ee = h.hooks[P].apply(E, V);
                  return ee === !1 && (ee = $.apply(E, V)), ee;
                };
              }
              b.hooks = E;
            }
            if (h.walkTokens) {
              const E = Ke.defaults.walkTokens;
              b.walkTokens = function(P) {
                let $ = [];
                return $.push(h.walkTokens.call(this, P)), E && ($ = $.concat(E.call(this, P))), $;
              };
            }
            Ke.setOptions(b);
          });
        }, Ke.walkTokens = function(u, c) {
          let h = [];
          for (const b of u) switch (h = h.concat(c.call(Ke, b)), b.type) {
            case "table":
              for (const E of b.header) h = h.concat(Ke.walkTokens(E.tokens, c));
              for (const E of b.rows) for (const P of E) h = h.concat(Ke.walkTokens(P.tokens, c));
              break;
            case "list":
              h = h.concat(Ke.walkTokens(b.items, c));
              break;
            default:
              Ke.defaults.extensions && Ke.defaults.extensions.childTokens && Ke.defaults.extensions.childTokens[b.type] ? Ke.defaults.extensions.childTokens[b.type].forEach(function(E) {
                h = h.concat(Ke.walkTokens(b[E], c));
              }) : b.tokens && (h = h.concat(Ke.walkTokens(b.tokens, c)));
          }
          return h;
        }, Ke.parseInline = GS(xo.lexInline, _o.parseInline), Ke.Parser = _o, Ke.parser = _o.parse, Ke.Renderer = Pg, Ke.TextRenderer = QS, Ke.Lexer = xo, Ke.lexer = xo.lex, Ke.Tokenizer = Ag, Ke.Slugger = YS, Ke.Hooks = Ip, Ke.parse = Ke, Ke.options, Ke.setOptions, Ke.use, Ke.walkTokens, Ke.parseInline, _o.parse, xo.lex;
        var xL = Object.defineProperty, _L = Object.defineProperties, EL = Object.getOwnPropertyDescriptors, KS = Object.getOwnPropertySymbols, OL = Object.prototype.hasOwnProperty, kL = Object.prototype.propertyIsEnumerable, XS = (u, c, h) => c in u ? xL(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, JS = (u, c) => {
          for (var h in c || (c = {})) OL.call(c, h) && XS(u, h, c[h]);
          if (KS) for (var h of KS(c)) kL.call(c, h) && XS(u, h, c[h]);
          return u;
        };
        const AL = new Ke.Renderer();
        Ke.setOptions({ renderer: AL, highlight: (u, c) => uu(u, c) });
        const ZS = "^ {0,3}<!-- ReDoc-Inject:\\s+?<({component}).*?/?>\\s+?-->\\s*$", e1 = "(?:^ {0,3}<({component})([\\s\\S]*?)>([\\s\\S]*?)</\\2>|^ {0,3}<({component})([\\s\\S]*?)(?:/>|\\n{2,}))", Cg = "(?:" + ZS + "|" + e1 + ")";
        function PL(u) {
          return `<!-- ReDoc-Inject: <${u}> -->`;
        }
        class Oa {
          constructor(c, h) {
            this.options = c, this.parentId = h, this.headings = [], this.headingRule = (b, E, P, $) => (E === 1 ? this.currentTopHeading = this.saveHeading(b, E) : E === 2 && this.saveHeading(b, E, this.currentTopHeading && this.currentTopHeading.items, this.currentTopHeading && this.currentTopHeading.id), this.originalHeadingRule(b, E, P, $)), this.parentId = h, this.parser = new Ke.Parser(), this.headingEnhanceRenderer = new Ke.Renderer(), this.originalHeadingRule = this.headingEnhanceRenderer.heading.bind(this.headingEnhanceRenderer), this.headingEnhanceRenderer.heading = this.headingRule;
          }
          static containsComponent(c, h) {
            return new RegExp(Cg.replace(/{component}/g, h), "gmi").test(c);
          }
          static getTextBeforeHading(c, h) {
            const b = c.search(new RegExp(`^##?\\s+${h}`, "m"));
            return b > -1 ? c.substring(0, b) : c;
          }
          saveHeading(c, h, b = this.headings, E) {
            c = fe(c);
            const P = { id: E ? `${E}/${B(c)}` : `${this.parentId || "section"}/${B(c)}`, name: c, level: h, items: [] };
            return b.push(P), P;
          }
          flattenHeadings(c) {
            if (c === void 0) return [];
            const h = [];
            for (const b of c) h.push(b), h.push(...this.flattenHeadings(b.items));
            return h;
          }
          attachHeadingsDescriptions(c) {
            const h = (V) => new RegExp(`##?\\s+${V.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")}s*(
|\r
|$|s*)`), b = this.flattenHeadings(this.headings);
            if (b.length < 1) return;
            let E = b[0], P = h(E), $ = c.search(P);
            for (let V = 1; V < b.length; V++) {
              const ee = b[V], ie = h(ee), ne = c.substr($ + 1).search(ie) + $ + 1;
              E.description = c.substring($, ne).replace(P, "").trim(), E = ee, P = ie, $ = ne;
            }
            E.description = c.substring($).replace(P, "").trim();
          }
          renderMd(c, h = !1) {
            const b = h ? { renderer: this.headingEnhanceRenderer } : void 0;
            return Ke(c.toString(), b);
          }
          extractHeadings(c) {
            this.renderMd(c, !0), this.attachHeadingsDescriptions(c);
            const h = this.headings;
            return this.headings = [], h;
          }
          renderMdWithComponents(c) {
            const h = this.options && this.options.allowedMdComponents;
            if (!h || Object.keys(h).length === 0) return [this.renderMd(c)];
            const b = Object.keys(h).join("|"), E = new RegExp(Cg.replace(/{component}/g, b), "mig"), P = [], $ = [];
            let V = E.exec(c), ee = 0;
            for (; V; ) {
              P.push(c.substring(ee, V.index)), ee = E.lastIndex;
              const me = h[V[1] || V[2] || V[5]], Ie = V[3] || V[6], ze = V[4];
              me && $.push({ component: me.component, propsSelector: me.propsSelector, props: (ie = JS(JS({}, CL(Ie)), me.props), ne = { children: ze }, _L(ie, EL(ne))) }), V = E.exec(c);
            }
            var ie, ne;
            P.push(c.substring(ee));
            const se = [];
            for (let me = 0; me < P.length; me++) {
              const Ie = P[me];
              Ie && se.push(this.renderMd(Ie)), $[me] && se.push($[me]);
            }
            return se;
          }
        }
        function CL(u) {
          if (!u) return {};
          const c = /([\w-]+)\s*=\s*(?:{([^}]+?)}|"([^"]+?)")/gim, h = {};
          let b;
          for (; (b = c.exec(u)) !== null; ) if (b[3]) h[b[1]] = b[3];
          else if (b[2]) {
            let E;
            try {
              E = JSON.parse(b[2]);
            } catch {
            }
            h[b[1]] = E;
          }
          return h;
        }
        class t1 {
          constructor(c, h = new X({})) {
            this.parser = c, this.options = h, Object.assign(this, c.spec.info), this.description = c.spec.info.description || "", this.summary = c.spec.info.summary || "";
            const b = this.description.search(/^\s*##?\s+/m);
            b > -1 && (this.description = this.description.substring(0, b)), this.downloadLink = this.getDownloadLink(), this.downloadFileName = this.getDownloadFileName();
          }
          getDownloadLink() {
            if (this.options.downloadDefinitionUrl) return this.options.downloadDefinitionUrl;
            if (this.parser.specUrl) return this.parser.specUrl;
            if (f && window.Blob && window.URL && window.URL.createObjectURL) {
              const c = new Blob([JSON.stringify(this.parser.spec, null, 2)], { type: "application/json" });
              return window.URL.createObjectURL(c);
            }
          }
          getDownloadFileName() {
            return this.parser.specUrl || this.options.downloadDefinitionUrl ? this.options.downloadFileName : this.options.downloadFileName || "openapi.json";
          }
        }
        var TL = Object.defineProperty, $L = Object.defineProperties, RL = Object.getOwnPropertyDescriptors, r1 = Object.getOwnPropertySymbols, IL = Object.prototype.hasOwnProperty, jL = Object.prototype.propertyIsEnumerable, n1 = (u, c, h) => c in u ? TL(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        class i1 {
          constructor(c, h) {
            const b = h.spec.components && h.spec.components.securitySchemes || {};
            this.schemes = Object.keys(c || {}).map((E) => {
              const { resolved: P } = h.deref(b[E]), $ = c[E] || [];
              if (!P) return void console.warn(`Non existing security scheme referenced: ${E}. Skipping`);
              const V = P["x-displayName"] || E;
              return ee = ((ie, ne) => {
                for (var se in ne || (ne = {})) IL.call(ne, se) && n1(ie, se, ne[se]);
                if (r1) for (var se of r1(ne)) jL.call(ne, se) && n1(ie, se, ne[se]);
                return ie;
              })({}, P), $L(ee, RL({ id: E, sectionId: E, displayName: V, scopes: $ }));
              var ee;
            }).filter((E) => E !== void 0);
          }
        }
        var o1 = Object.defineProperty, NL = Object.defineProperties, LL = Object.getOwnPropertyDescriptor, ML = Object.getOwnPropertyDescriptors, s1 = Object.getOwnPropertySymbols, DL = Object.prototype.hasOwnProperty, FL = Object.prototype.propertyIsEnumerable, a1 = (u, c, h) => c in u ? o1(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, zL = (u, c) => {
          for (var h in c || (c = {})) DL.call(c, h) && a1(u, h, c[h]);
          if (s1) for (var h of s1(c)) FL.call(c, h) && a1(u, h, c[h]);
          return u;
        }, l1 = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? LL(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && o1(c, h, P), P;
        };
        class jp {
          constructor(c, h, b, E, P) {
            this.expanded = !1, this.operations = [], (0, D.makeObservable)(this), this.name = h;
            const { resolved: $ } = c.deref(b);
            for (const ie of Object.keys($)) {
              const ne = $[ie], se = Object.keys(ne).filter(ps);
              for (const me of se) {
                const Ie = ne[me], ze = new Lr(c, (V = zL({}, Ie), ee = { pathName: ie, pointer: rt.compile([E, h, ie, me]), httpVerb: me, pathParameters: ne.parameters || [], pathServers: ne.servers }, NL(V, ML(ee))), void 0, P, !0);
                this.operations.push(ze);
              }
            }
            var V, ee;
          }
          toggle() {
            this.expanded = !this.expanded;
          }
        }
        l1([D.observable], jp.prototype, "expanded", 2), l1([D.action], jp.prototype, "toggle", 1);
        var qL = Object.defineProperty, BL = Object.defineProperties, UL = Object.getOwnPropertyDescriptors, Np = Object.getOwnPropertySymbols, u1 = Object.prototype.hasOwnProperty, c1 = Object.prototype.propertyIsEnumerable, p1 = (u, c, h) => c in u ? qL(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, Fi = (u, c) => {
          for (var h in c || (c = {})) u1.call(c, h) && p1(u, h, c[h]);
          if (Np) for (var h of Np(c)) c1.call(c, h) && p1(u, h, c[h]);
          return u;
        }, Lp = (u, c) => BL(u, UL(c)), Tg = (u, c) => {
          var h = {};
          for (var b in u) u1.call(u, b) && c.indexOf(b) < 0 && (h[b] = u[b]);
          if (u != null && Np) for (var b of Np(u)) c.indexOf(b) < 0 && c1.call(u, b) && (h[b] = u[b]);
          return h;
        };
        function Mp(u, c) {
          return c && u[u.length - 1] !== c ? [...u, c] : u;
        }
        function Dp(u, c) {
          return c ? u.concat(c) : u;
        }
        class f1 {
          constructor(c, h, b = new X({})) {
            this.options = b, this.allowMergeRefs = !1, this.byRef = (P) => {
              let $;
              if (this.spec) {
                P.charAt(0) !== "#" && (P = "#" + P), P = decodeURIComponent(P);
                try {
                  $ = rt.get(this.spec, P);
                } catch {
                }
                return $ || {};
              }
            }, this.validate(c), this.spec = c, this.allowMergeRefs = c.openapi.startsWith("3.1");
            const E = f ? window.location.href : "";
            typeof h == "string" && (this.specUrl = E ? new URL(h, E).href : h);
          }
          validate(c) {
            if (c.openapi === void 0) throw new Error("Document must be valid OpenAPI 3.0.0 definition");
          }
          isRef(c) {
            return !!c && c.$ref !== void 0 && c.$ref !== null;
          }
          deref(c, h = [], b = !1) {
            const E = c == null ? void 0 : c["x-refsStack"];
            if (h = Dp(h, E), this.isRef(c)) {
              const P = ba(c.$ref);
              if (P && this.options.ignoreNamedSchemas.has(P)) return { resolved: { type: "object", title: P }, refsStack: h };
              let $ = this.byRef(c.$ref);
              if (!$) throw new Error(`Failed to resolve $ref "${c.$ref}"`);
              let V = h;
              if (h.includes(c.$ref) || h.length > 999) $ = Object.assign({}, $, { "x-circular-ref": !0 });
              else if (this.isRef($)) {
                const ee = this.deref($, h, b);
                V = ee.refsStack, $ = ee.resolved;
              }
              return V = Mp(h, c.$ref), $ = this.allowMergeRefs ? this.mergeRefs(c, $, b) : $, { resolved: $, refsStack: V };
            }
            return { resolved: c, refsStack: Dp(h, E) };
          }
          mergeRefs(c, h, b) {
            const E = c, P = Tg(E, ["$ref"]), $ = Object.keys(P);
            if ($.length === 0) return h;
            if (b && $.some((V) => !["description", "title", "externalDocs", "x-refsStack", "x-parentRefs", "readOnly", "writeOnly"].includes(V))) {
              const V = P, { description: ee, title: ie, readOnly: ne, writeOnly: se } = V;
              return { allOf: [{ description: ee, title: ie, readOnly: ne, writeOnly: se }, h, Tg(V, ["description", "title", "readOnly", "writeOnly"])] };
            }
            return Fi(Fi({}, h), P);
          }
          mergeAllOf(c, h, b) {
            var E;
            if (c["x-circular-ref"] || (c = this.hoistOneOfs(c, b)).allOf === void 0) return c;
            let P = Lp(Fi({}, c), { "x-parentRefs": [], allOf: void 0, title: c.title || ba(h) });
            P.properties !== void 0 && typeof P.properties == "object" && (P.properties = Fi({}, P.properties)), P.items !== void 0 && typeof P.items == "object" && (P.items = Fi({}, P.items));
            const $ = function(V, ee) {
              const ie = /* @__PURE__ */ new Set();
              return V.filter((ne) => {
                const se = ne.$ref;
                return !se || se && !ie.has(se) && ie.add(se);
              });
            }(c.allOf.map((V) => {
              var ee;
              const { resolved: ie, refsStack: ne } = this.deref(V, b, !0), se = V.$ref || void 0, me = this.mergeAllOf(ie, se, ne);
              if (!me["x-circular-ref"] || !me.allOf) return se && ((ee = P["x-parentRefs"]) == null || ee.push(...me["x-parentRefs"] || [], se)), { $ref: se, refsStack: Mp(ne, se), schema: me };
            }).filter((V) => V !== void 0));
            for (const { schema: V, refsStack: ee } of $) {
              const ie = V, { type: ne, enum: se, properties: me, items: Ie, required: ze, title: yt, description: kt, readOnly: it, writeOnly: an, oneOf: Vr, anyOf: Kt, "x-circular-ref": On } = ie, er = Tg(ie, ["type", "enum", "properties", "items", "required", "title", "description", "readOnly", "writeOnly", "oneOf", "anyOf", "x-circular-ref"]);
              if (P.type !== ne && P.type !== void 0 && ne !== void 0 && console.warn(`Incompatible types in allOf at "${h}": "${P.type}" and "${ne}"`), ne !== void 0 && (Array.isArray(ne) && Array.isArray(P.type) ? P.type = [...ne, ...P.type] : P.type = ne), se !== void 0 && (Array.isArray(se) && Array.isArray(P.enum) ? P.enum = Array.from(/* @__PURE__ */ new Set([...se, ...P.enum])) : P.enum = se), me !== void 0 && typeof me == "object") {
                P.properties = P.properties || {};
                for (const Er in me) {
                  const Hi = Dp(ee, (E = me[Er]) == null ? void 0 : E["x-refsStack"]);
                  if (P.properties[Er]) {
                    if (!On) {
                      const XF = this.mergeAllOf({ allOf: [P.properties[Er], Lp(Fi({}, me[Er]), { "x-refsStack": Hi })], "x-refsStack": Hi }, h + "/properties/" + Er, Hi);
                      P.properties[Er] = XF;
                    }
                  } else P.properties[Er] = Lp(Fi({}, me[Er]), { "x-refsStack": Hi });
                }
              }
              if (Ie !== void 0 && !On) {
                const Er = typeof P.items == "boolean" ? {} : Object.assign({}, P.items), Hi = typeof V.items == "boolean" ? {} : Object.assign({}, V.items);
                P.items = this.mergeAllOf({ allOf: [Er, Hi] }, h + "/items", ee);
              }
              Vr !== void 0 && (P.oneOf = Vr), Kt !== void 0 && (P.anyOf = Kt), ze !== void 0 && (P.required = [...P.required || [], ...ze]), P = Fi(Lp(Fi({}, P), { title: P.title || yt, description: P.description || kt, readOnly: P.readOnly !== void 0 ? P.readOnly : it, writeOnly: P.writeOnly !== void 0 ? P.writeOnly : an, "x-circular-ref": P["x-circular-ref"] || On }), er);
            }
            return P;
          }
          findDerived(c) {
            const h = {}, b = this.spec.components && this.spec.components.schemas || {};
            for (const E in b) {
              const { resolved: P } = this.deref(b[E]);
              P.allOf !== void 0 && P.allOf.find(($) => $.$ref !== void 0 && c.indexOf($.$ref) > -1) && (h["#/components/schemas/" + E] = [P["x-discriminator-value"] || E]);
            }
            return h;
          }
          hoistOneOfs(c, h) {
            if (c.allOf === void 0) return c;
            const b = c.allOf;
            for (let E = 0; E < b.length; E++) {
              const P = b[E];
              if (Array.isArray(P.oneOf)) {
                const $ = b.slice(0, E), V = b.slice(E + 1);
                return { oneOf: P.oneOf.map((ee) => ({ allOf: [...$, ee, ...V], "x-refsStack": h })) };
              }
            }
            return c;
          }
        }
        var d1 = Object.defineProperty, VL = Object.defineProperties, WL = Object.getOwnPropertyDescriptor, HL = Object.getOwnPropertyDescriptors, Fp = Object.getOwnPropertySymbols, h1 = Object.prototype.hasOwnProperty, m1 = Object.prototype.propertyIsEnumerable, g1 = (u, c, h) => c in u ? d1(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, ka = (u, c) => {
          for (var h in c || (c = {})) h1.call(c, h) && g1(u, h, c[h]);
          if (Fp) for (var h of Fp(c)) m1.call(c, h) && g1(u, h, c[h]);
          return u;
        }, $g = (u, c) => VL(u, HL(c)), y1 = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? WL(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && d1(c, h, P), P;
        };
        const gu = class {
          constructor(u, c, h, b, E = !1, P = []) {
            this.options = b, this.refsStack = P, this.typePrefix = "", this.isCircular = !1, this.activeOneOf = 0, (0, D.makeObservable)(this), this.pointer = c.$ref || h || "";
            const { resolved: $, refsStack: V } = u.deref(c, P, !0);
            this.refsStack = Mp(V, this.pointer), this.rawSchema = $, this.schema = u.mergeAllOf(this.rawSchema, this.pointer, this.refsStack), this.init(u, E), b.showExtensions && (this.extensions = bs(this.schema, b.showExtensions));
          }
          activateOneOf(u) {
            this.activeOneOf = u;
          }
          hasType(u) {
            return this.type === u || G(this.type) && this.type.includes(u);
          }
          init(u, c) {
            var h, b, E, P, $, V, ee, ie;
            const ne = this.schema;
            if (this.isCircular = !!ne["x-circular-ref"], this.title = ne.title || va(this.pointer) && rt.baseName(this.pointer) || "", this.description = ne.description || "", this.type = ne.type || ma(ne), this.format = ne.format, this.enum = ne.enum || [], this.example = ne.example, this.examples = ne.examples, this.deprecated = !!ne.deprecated, this.pattern = ne.pattern, this.externalDocs = ne.externalDocs, this.constraints = Li(ne), this.displayFormat = this.format, this.isPrimitive = ga(ne, this.type), this.default = ne.default, this.readOnly = !!ne.readOnly, this.writeOnly = !!ne.writeOnly, this.const = ne.const || "", this.contentEncoding = ne.contentEncoding, this.contentMediaType = ne.contentMediaType, this.minItems = ne.minItems, this.maxItems = ne.maxItems, (ne.nullable || ne["x-nullable"]) && (G(this.type) && !this.type.some((se) => se === null || se === "null") ? this.type = [...this.type, "null"] : G(this.type) || this.type === null && this.type === "null" || (this.type = [this.type, "null"])), this.displayType = G(this.type) ? this.type.map((se) => se === null ? "null" : se).join(" or ") : this.type, !this.isCircular) if (ne.if && ne.then || ne.if && ne.else) this.initConditionalOperators(ne, u);
            else if (c || b1(ne) === void 0) {
              if (c && G(ne.oneOf) && ne.oneOf.find((se) => se.$ref === this.pointer) && delete ne.oneOf, ne.oneOf !== void 0) return this.initOneOf(ne.oneOf, u), this.oneOfType = "One of", void (ne.anyOf !== void 0 && console.warn(`oneOf and anyOf are not supported on the same level. Skipping anyOf at ${this.pointer}`));
              if (ne.anyOf !== void 0) return this.initOneOf(ne.anyOf, u), void (this.oneOfType = "Any of");
              if (this.hasType("object")) this.fields = v1(u, ne, this.pointer, this.options, this.refsStack);
              else if (this.hasType("array") && (G(ne.items) || G(ne.prefixItems) ? this.fields = v1(u, ne, this.pointer, this.options, this.refsStack) : ne.items && (this.items = new gu(u, ne.items, this.pointer + "/items", this.options, !1, this.refsStack)), this.displayType = ne.prefixItems || G(ne.items) ? "items" : So(((h = this.items) == null ? void 0 : h.displayType) || this.displayType), this.displayFormat = ((b = this.items) == null ? void 0 : b.format) || "", this.typePrefix = ((E = this.items) == null ? void 0 : E.typePrefix) || "" + z("arrayOf"), this.title = this.title || ((P = this.items) == null ? void 0 : P.title) || "", this.isPrimitive = (($ = this.items) == null ? void 0 : $.isPrimitive) !== void 0 ? (V = this.items) == null ? void 0 : V.isPrimitive : this.isPrimitive, this.example === void 0 && ((ee = this.items) == null ? void 0 : ee.example) !== void 0 && (this.example = [this.items.example]), (ie = this.items) != null && ie.isPrimitive && (this.enum = this.items.enum), G(this.type))) {
                const se = this.type.filter((me) => me !== "array");
                se.length && (this.displayType += ` or ${se.join(" or ")}`);
              }
              this.enum.length && this.options.sortEnumValuesAlphabetically && this.enum.sort();
            } else this.initDiscriminator(ne, u);
          }
          initOneOf(u, c) {
            if (this.oneOf = u.map((h, b) => {
              const { resolved: E, refsStack: P } = c.deref(h, this.refsStack, !0), $ = c.mergeAllOf(E, this.pointer + "/oneOf/" + b, P), V = va(h.$ref) && !$.title ? rt.baseName(h.$ref) : `${$.title || ""}${$.const !== void 0 && JSON.stringify($.const) || ""}`;
              return new gu(c, $g(ka({}, $), { title: V, allOf: [$g(ka({}, this.schema), { oneOf: void 0, anyOf: void 0 })], discriminator: E.allOf ? void 0 : $.discriminator }), h.$ref || this.pointer + "/oneOf/" + b, this.options, !1, P);
            }), this.options.simpleOneOfTypeLabel) {
              const h = function(b) {
                const E = /* @__PURE__ */ new Set();
                return function P($) {
                  for (const V of $.oneOf || []) V.oneOf ? P(V) : V.type && E.add(V.type);
                }(b), Array.from(E.values());
              }(this);
              this.displayType = h.join(" or ");
            } else this.displayType = this.oneOf.map((h) => {
              let b = h.typePrefix + (h.title ? `${h.title} (${h.displayType})` : h.displayType);
              return b.indexOf(" or ") > -1 && (b = `(${b})`), b;
            }).join(" or ");
          }
          initDiscriminator(u, c) {
            const h = b1(u);
            this.discriminatorProp = h.propertyName;
            const b = c.findDerived([...this.schema["x-parentRefs"] || [], this.pointer]);
            if (u.oneOf) for (const ne of u.oneOf) {
              if (ne.$ref === void 0) continue;
              const se = rt.baseName(ne.$ref);
              b[ne.$ref] = se;
            }
            const E = h.mapping || {};
            let P = h["x-explicitMappingOnly"] || !1;
            Object.keys(E).length === 0 && (P = !1);
            const $ = {};
            for (const ne in E) {
              const se = E[ne];
              G($[se]) ? $[se].push(ne) : $[se] = [ne];
            }
            const V = ka(P ? {} : ka({}, b), $);
            let ee = [];
            for (const ne of Object.keys(V)) {
              const se = V[ne];
              if (G(se)) for (const me of se) ee.push({ $ref: ne, name: me });
              else ee.push({ $ref: ne, name: se });
            }
            const ie = Object.keys(E);
            ie.length !== 0 && (ee = ee.sort((ne, se) => {
              const me = ie.indexOf(ne.name), Ie = ie.indexOf(se.name);
              return me < 0 && Ie < 0 ? ne.name.localeCompare(se.name) : me < 0 ? 1 : Ie < 0 ? -1 : me - Ie;
            })), this.oneOf = ee.map(({ $ref: ne, name: se }) => {
              const me = new gu(c, { $ref: ne }, ne, this.options, !0, this.refsStack.slice(0, -1));
              return me.title = se, me;
            });
          }
          initConditionalOperators(u, c) {
            const h = u, { if: b, else: E = {}, then: P = {} } = h, $ = ((ee, ie) => {
              var ne = {};
              for (var se in ee) h1.call(ee, se) && ie.indexOf(se) < 0 && (ne[se] = ee[se]);
              if (ee != null && Fp) for (var se of Fp(ee)) ie.indexOf(se) < 0 && m1.call(ee, se) && (ne[se] = ee[se]);
              return ne;
            })(h, ["if", "else", "then"]), V = [{ allOf: [$, P, b], title: b && b["x-displayName"] || (b == null ? void 0 : b.title) || "case 1" }, { allOf: [$, E], title: E && E["x-displayName"] || (E == null ? void 0 : E.title) || "case 2" }];
            this.oneOf = V.map((ee, ie) => new gu(c, ka({}, ee), this.pointer + "/oneOf/" + ie, this.options, !1, this.refsStack)), this.oneOfType = "One of";
          }
        };
        let yu = gu;
        function v1(u, c, h, b, E) {
          const P = c.properties || c.prefixItems || c.items || {}, $ = c.patternProperties || {}, V = c.additionalProperties || c.unevaluatedProperties, ee = c.prefixItems ? c.items : c.additionalItems, ie = c.default;
          let ne = Object.keys(P || []).map((se) => {
            let me = P[se];
            me || (console.warn(`Field "${se}" is invalid, skipping.
 Field must be an object but got ${typeof me} at "${h}"`), me = {});
            const Ie = c.required !== void 0 && c.required.indexOf(se) > -1;
            return new sn(u, { name: c.properties ? se : `[${se}]`, required: Ie, schema: $g(ka({}, me), { default: me.default === void 0 && ie ? ie[se] : me.default }) }, h + "/properties/" + se, b, E);
          });
          return b.sortPropsAlphabetically && (ne = di(ne, "name")), b.requiredPropsFirst && (ne = fi(ne, b.sortPropsAlphabetically ? void 0 : c.required)), ne.push(...Object.keys($).map((se) => {
            let me = $[se];
            return me || (console.warn(`Field "${se}" is invalid, skipping.
 Field must be an object but got ${typeof me} at "${h}"`), me = {}), new sn(u, { name: se, required: !1, schema: me, kind: "patternProperties" }, `${h}/patternProperties/${se}`, b, E);
          })), typeof V != "object" && V !== !0 || ne.push(new sn(u, { name: (typeof V == "object" && V["x-additionalPropertiesName"] || "property name").concat("*"), required: !1, schema: V === !0 ? {} : V, kind: "additionalProperties" }, h + "/additionalProperties", b, E)), ne.push(...function({ parser: se, schema: me = !1, fieldsCount: Ie, $ref: ze, options: yt, refsStack: kt }) {
            return Z(me) ? me ? [new sn(se, { name: `[${Ie}...]`, schema: {} }, `${ze}/additionalItems`, yt, kt)] : [] : G(me) ? [...me.map((it, an) => new sn(se, { name: `[${Ie + an}]`, schema: it }, `${ze}/additionalItems`, yt, kt))] : R(me) ? [new sn(se, { name: `[${Ie}...]`, schema: me }, `${ze}/additionalItems`, yt, kt)] : [];
          }({ parser: u, schema: ee, fieldsCount: ne.length, $ref: h, options: b, refsStack: E })), ne;
        }
        function b1(u) {
          return u.discriminator || u["x-discriminator"];
        }
        y1([D.observable], yu.prototype, "activeOneOf", 2), y1([D.action], yu.prototype, "activateOneOf", 1);
        const Rg = {};
        class Aa {
          constructor(c, h, b, E) {
            this.mime = b;
            const { resolved: P } = c.deref(h);
            this.value = P.value, this.summary = P.summary, this.description = P.description, P.externalValue && (this.externalValueUrl = new URL(P.externalValue, c.specUrl).href), ru(b) && this.value && typeof this.value == "object" && (this.value = pi(this.value, E));
          }
          getExternalValue(c) {
            return this.externalValueUrl ? (this.externalValueUrl in Rg || (Rg[this.externalValueUrl] = fetch(this.externalValueUrl).then((h) => h.text().then((b) => {
              if (!h.ok) return Promise.reject(new Error(b));
              if (!Ii(c)) return b;
              try {
                return JSON.parse(b);
              } catch {
                return b;
              }
            }))), Rg[this.externalValueUrl]) : Promise.resolve(void 0);
          }
        }
        var QL = Object.defineProperty, YL = Object.getOwnPropertyDescriptor, zp = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? YL(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && QL(c, h, P), P;
        };
        const w1 = { path: { style: "simple", explode: !1 }, query: { style: "form", explode: !0 }, header: { style: "simple", explode: !1 }, cookie: { style: "form", explode: !0 } };
        class sn {
          constructor(c, h, b, E, P) {
            var $, V, ee, ie, ne;
            this.expanded = void 0, (0, D.makeObservable)(this);
            const { resolved: se } = c.deref(h);
            this.kind = h.kind || "field", this.name = h.name || se.name, this.in = se.in, this.required = !!se.required;
            let me = se.schema, Ie = "";
            if (!me && se.in && se.content && (Ie = Object.keys(se.content)[0], me = se.content[Ie] && se.content[Ie].schema), this.schema = new yu(c, me || {}, b, E, !1, P), this.description = se.description === void 0 ? this.schema.description || "" : se.description, this.example = se.example || this.schema.example, se.examples !== void 0 || this.schema.examples !== void 0) {
              const ze = se.examples || this.schema.examples;
              this.examples = G(ze) ? ze : x(ze, (yt, kt) => new Aa(c, yt, kt, se.encoding));
            }
            Ie ? this.serializationMime = Ie : se.style ? this.style = se.style : this.in && (this.style = (V = ($ = w1[this.in]) == null ? void 0 : $.style) != null ? V : "form"), se.explode === void 0 && this.in ? this.explode = (ie = (ee = w1[this.in]) == null ? void 0 : ee.explode) == null || ie : this.explode = !!se.explode, this.deprecated = se.deprecated === void 0 ? !!this.schema.deprecated : se.deprecated, E.showExtensions && (this.extensions = bs(se, E.showExtensions)), this.const = ((ne = this.schema) == null ? void 0 : ne.const) || (se == null ? void 0 : se.const) || "";
          }
          toggle() {
            this.expanded = !this.expanded;
          }
          collapse() {
            this.expanded = !1;
          }
          expand() {
            this.expanded = !0;
          }
        }
        zp([D.observable], sn.prototype, "expanded", 2), zp([D.action], sn.prototype, "toggle", 1), zp([D.action], sn.prototype, "collapse", 1), zp([D.action], sn.prototype, "expand", 1);
        var S1 = zY;
        class Ig {
          constructor(c, h, b, E, P) {
            this.name = h, this.isRequestType = b, this.schema = E.schema && new yu(c, E.schema, "", P), this.onlyRequiredInSamples = P.onlyRequiredInSamples, this.generatedPayloadSamplesMaxDepth = P.generatedPayloadSamplesMaxDepth, E.examples !== void 0 ? this.examples = x(E.examples, ($) => new Aa(c, $, h, E.encoding)) : E.example !== void 0 ? this.examples = { default: new Aa(c, { value: c.deref(E.example).resolved }, h, E.encoding) } : Ii(h) && this.generateExample(c, E);
          }
          generateExample(c, h) {
            const b = { skipReadOnly: this.isRequestType, skipWriteOnly: !this.isRequestType, skipNonRequired: this.isRequestType && this.onlyRequiredInSamples, maxSampleDepth: this.generatedPayloadSamplesMaxDepth };
            if (this.schema && this.schema.oneOf) {
              this.examples = {};
              for (const E of this.schema.oneOf) {
                const P = S1.sample(E.rawSchema, b, c.spec);
                this.schema.discriminatorProp && typeof P == "object" && P && (P[this.schema.discriminatorProp] = E.title), this.examples[E.title] = new Aa(c, { value: P }, this.name, h.encoding);
              }
            } else this.schema && (this.examples = { default: new Aa(c, { value: S1.sample(h.schema, b, c.spec) }, this.name, h.encoding) });
          }
        }
        var GL = Object.defineProperty, KL = Object.getOwnPropertyDescriptor, jg = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? KL(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && GL(c, h, P), P;
        };
        class Pa {
          constructor(c, h, b, E) {
            this.isRequestType = b, this.activeMimeIdx = 0, (0, D.makeObservable)(this), E.unstable_ignoreMimeParameters && (h = su(h)), this.mediaTypes = Object.keys(h).map((P) => {
              const $ = h[P];
              return new Ig(c, P, b, $, E);
            });
          }
          activate(c) {
            this.activeMimeIdx = c;
          }
          get active() {
            return this.mediaTypes[this.activeMimeIdx];
          }
          get hasSample() {
            return this.mediaTypes.filter((c) => !!c.examples).length > 0;
          }
        }
        jg([D.observable], Pa.prototype, "activeMimeIdx", 2), jg([D.action], Pa.prototype, "activate", 1), jg([D.computed], Pa.prototype, "active", 1);
        class x1 {
          constructor({ parser: c, infoOrRef: h, options: b, isEvent: E }) {
            const P = !E, { resolved: $ } = c.deref(h);
            this.description = $.description || "", this.required = $.required;
            const V = _p($);
            V !== void 0 && (this.content = new Pa(c, V, P, b));
          }
        }
        var _1 = Object.defineProperty, XL = Object.defineProperties, JL = Object.getOwnPropertyDescriptor, ZL = Object.getOwnPropertyDescriptors, E1 = Object.getOwnPropertySymbols, eM = Object.prototype.hasOwnProperty, tM = Object.prototype.propertyIsEnumerable, O1 = (u, c, h) => c in u ? _1(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, k1 = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? JL(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && _1(c, h, P), P;
        };
        class qp {
          constructor({ parser: c, code: h, defaultAsError: b, infoOrRef: E, options: P, isEvent: $ }) {
            this.expanded = !1, this.headers = [], (0, D.makeObservable)(this), this.expanded = P.expandResponses === "all" || P.expandResponses[h];
            const { resolved: V } = c.deref(E);
            this.code = h, V.content !== void 0 && (this.content = new Pa(c, V.content, $, P)), V["x-summary"] !== void 0 ? (this.summary = V["x-summary"], this.description = V.description || "") : (this.summary = V.description || "", this.description = ""), this.type = ha(h, b);
            const ee = V.headers;
            ee !== void 0 && (this.headers = Object.keys(ee).map((ie) => {
              const ne = ee[ie];
              return new sn(c, (se = ((me, Ie) => {
                for (var ze in Ie || (Ie = {})) eM.call(Ie, ze) && O1(me, ze, Ie[ze]);
                if (E1) for (var ze of E1(Ie)) tM.call(Ie, ze) && O1(me, ze, Ie[ze]);
                return me;
              })({}, ne), XL(se, ZL({ name: ie }))), "", P);
              var se;
            })), P.showExtensions && (this.extensions = bs(V, P.showExtensions));
          }
          toggle() {
            this.expanded = !this.expanded;
          }
        }
        k1([D.observable], qp.prototype, "expanded", 2), k1([D.action], qp.prototype, "toggle", 1);
        var rM = Object.defineProperty, nM = Object.getOwnPropertyDescriptor, zn = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? nM(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && rM(c, h, P), P;
        };
        function Ng(u) {
          return u.lang === "payload" && u.requestBodyContent;
        }
        let A1 = !1;
        class Lr {
          constructor(c, h, b, E, P = !1) {
            this.parser = c, this.operationSpec = h, this.options = E, this.type = "operation", this.items = [], this.ready = !0, this.active = !1, this.expanded = !1, (0, D.makeObservable)(this), this.pointer = h.pointer, this.description = h.description, this.parent = b, this.externalDocs = h.externalDocs, this.deprecated = !!h.deprecated, this.httpVerb = h.httpVerb, this.deprecated = !!h.deprecated, this.operationId = h.operationId, this.path = h.pathName, this.isCallback = P, this.isWebhook = h.isWebhook, this.isEvent = this.isCallback || this.isWebhook, this.name = Lt(h), this.sidebarLabel = E.sideNavStyle === te.IdOnly ? this.operationId || this.path : E.sideNavStyle === te.PathOnly ? this.path : this.name, this.isCallback ? (this.security = (h.security || []).map(($) => new i1($, c)), this.servers = ms("", h.servers || h.pathServers || [])) : (this.operationHash = h.operationId && "operation/" + h.operationId, this.id = h.operationId !== void 0 ? (b ? b.id + "/" : "") + this.operationHash : b !== void 0 ? b.id + this.pointer : this.pointer, this.security = (h.security || c.spec.security || []).map(($) => new i1($, c)), this.servers = ms(c.specUrl, h.servers || h.pathServers || c.spec.servers || [])), E.showExtensions && (this.extensions = bs(h, E.showExtensions));
          }
          activate() {
            this.active = !0;
          }
          deactivate() {
            this.active = !1;
          }
          toggle() {
            this.expanded = !this.expanded;
          }
          expand() {
            this.parent && this.parent.expand();
          }
          collapse() {
          }
          get requestBody() {
            return this.operationSpec.requestBody && new x1({ parser: this.parser, infoOrRef: this.operationSpec.requestBody, options: this.options, isEvent: this.isEvent });
          }
          get codeSamples() {
            const { payloadSampleIdx: c, hideRequestPayloadSample: h } = this.options;
            let b = this.operationSpec["x-codeSamples"] || this.operationSpec["x-code-samples"] || [];
            this.operationSpec["x-code-samples"] && !A1 && (A1 = !0, console.warn('"x-code-samples" is deprecated. Use "x-codeSamples" instead'));
            const E = this.requestBody && this.requestBody.content;
            if (E && E.hasSample && !h) {
              const P = Math.min(b.length, c);
              b = [...b.slice(0, P), { lang: "payload", label: "Payload", source: "", requestBodyContent: E }, ...b.slice(P)];
            }
            return b;
          }
          get parameters() {
            const c = ou(this.parser, this.operationSpec.pathParameters, this.operationSpec.parameters).map((h) => new sn(this.parser, h, this.pointer, this.options));
            return this.options.sortPropsAlphabetically ? di(c, "name") : this.options.requiredPropsFirst ? fi(c) : c;
          }
          get responses() {
            let c = !1;
            return Object.keys(this.operationSpec.responses || []).filter((h) => h === "default" || (ha(h) === "success" && (c = !0), Yt(h))).map((h) => new qp({ parser: this.parser, code: h, defaultAsError: c, infoOrRef: this.operationSpec.responses[h], options: this.options, isEvent: this.isEvent }));
          }
          get callbacks() {
            return Object.keys(this.operationSpec.callbacks || []).map((c) => new jp(this.parser, c, this.operationSpec.callbacks[c], this.pointer, this.options));
          }
        }
        zn([D.observable], Lr.prototype, "ready", 2), zn([D.observable], Lr.prototype, "active", 2), zn([D.observable], Lr.prototype, "expanded", 2), zn([D.action], Lr.prototype, "activate", 1), zn([D.action], Lr.prototype, "deactivate", 1), zn([D.action], Lr.prototype, "toggle", 1), zn([Di], Lr.prototype, "requestBody", 1), zn([Di], Lr.prototype, "codeSamples", 1), zn([Di], Lr.prototype, "parameters", 1), zn([Di], Lr.prototype, "responses", 1), zn([Di], Lr.prototype, "callbacks", 1);
        var iM = Object.defineProperty, oM = Object.defineProperties, sM = Object.getOwnPropertyDescriptors, P1 = Object.getOwnPropertySymbols, aM = Object.prototype.hasOwnProperty, lM = Object.prototype.propertyIsEnumerable, C1 = (u, c, h) => c in u ? iM(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, uM = (u, c) => {
          for (var h in c || (c = {})) aM.call(c, h) && C1(u, h, c[h]);
          if (P1) for (var h of P1(c)) lM.call(c, h) && C1(u, h, c[h]);
          return u;
        };
        class cM {
          constructor(c, h, b) {
            this.operations = [];
            const { resolved: E } = c.deref(b || {});
            this.initWebhooks(c, E, h);
          }
          initWebhooks(c, h, b) {
            for (const P of Object.keys(h)) {
              const $ = h[P], V = Object.keys($).filter(ps);
              for (const ee of V) {
                const ie = $[ee];
                if ($.$ref) {
                  const se = c.deref($ || {});
                  this.initWebhooks(c, { [ee]: se }, b);
                }
                if (!ie) continue;
                const ne = new Lr(c, (E = uM({}, ie), oM(E, sM({ httpVerb: ee }))), void 0, b, !1);
                this.operations.push(ne);
              }
            }
            var E;
          }
        }
        class T1 {
          constructor(c, h, b) {
            const { resolved: E } = c.deref(b);
            this.id = h, this.sectionId = Nr + h, this.type = E.type, this.displayName = E["x-displayName"] || h, this.description = E.description || "", E.type === "apiKey" && (this.apiKey = { name: E.name, in: E.in }), E.type === "http" && (this.http = { scheme: E.scheme, bearerFormat: E.bearerFormat }), E.type === "openIdConnect" && (this.openId = { connectUrl: E.openIdConnectUrl }), E.type === "oauth2" && E.flows && (this.flows = E.flows);
          }
        }
        class $1 {
          constructor(c) {
            const h = c.spec.components && c.spec.components.securitySchemes || {};
            this.schemes = Object.keys(h).map((b) => new T1(c, b, h[b]));
          }
        }
        var pM = Object.defineProperty, R1 = Object.getOwnPropertySymbols, fM = Object.prototype.hasOwnProperty, dM = Object.prototype.propertyIsEnumerable, I1 = (u, c, h) => c in u ? pM(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, j1 = (u, c) => {
          for (var h in c || (c = {})) fM.call(c, h) && I1(u, h, c[h]);
          if (R1) for (var h of R1(c)) dM.call(c, h) && I1(u, h, c[h]);
          return u;
        };
        class N1 {
          constructor(c, h, b) {
            var E, P, $;
            this.options = b, this.parser = new f1(c, h, b), this.info = new t1(this.parser, this.options), this.externalDocs = this.parser.spec.externalDocs, this.contentItems = hi.buildStructure(this.parser, this.options), this.securitySchemes = new $1(this.parser);
            const V = j1(j1({}, (P = (E = this.parser) == null ? void 0 : E.spec) == null ? void 0 : P["x-webhooks"]), ($ = this.parser) == null ? void 0 : $.spec.webhooks);
            this.webhooks = new cM(this.parser, b, V);
          }
        }
        var hM = Object.defineProperty, mM = Object.getOwnPropertyDescriptor, Ca = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? mM(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && hM(c, h, P), P;
        };
        class qn {
          constructor(c, h, b) {
            this.items = [], this.active = !1, this.expanded = !1, (0, D.makeObservable)(this), this.id = h.id || c + "/" + B(h.name), this.type = c, this.name = h["x-displayName"] || h.name, this.level = h.level || 1, this.sidebarLabel = this.name, this.description = h.description || "";
            const E = h.items;
            E && E.length && (this.description = Oa.getTextBeforeHading(this.description, E[0].name)), this.parent = b, this.externalDocs = h.externalDocs, this.type === "group" && (this.expanded = !0);
          }
          activate() {
            this.active = !0;
          }
          expand() {
            this.parent && this.parent.expand(), this.expanded = !0;
          }
          collapse() {
            this.type !== "group" && (this.expanded = !1);
          }
          deactivate() {
            this.active = !1;
          }
        }
        Ca([D.observable], qn.prototype, "active", 2), Ca([D.observable], qn.prototype, "expanded", 2), Ca([D.action], qn.prototype, "activate", 1), Ca([D.action], qn.prototype, "expand", 1), Ca([D.action], qn.prototype, "collapse", 1), Ca([D.action], qn.prototype, "deactivate", 1);
        var gM = Object.defineProperty, yM = Object.defineProperties, vM = Object.getOwnPropertyDescriptors, L1 = Object.getOwnPropertySymbols, bM = Object.prototype.hasOwnProperty, wM = Object.prototype.propertyIsEnumerable, M1 = (u, c, h) => c in u ? gM(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, D1 = (u, c) => {
          for (var h in c || (c = {})) bM.call(c, h) && M1(u, h, c[h]);
          if (L1) for (var h of L1(c)) wM.call(c, h) && M1(u, h, c[h]);
          return u;
        }, F1 = (u, c) => yM(u, vM(c));
        const Bp = 0;
        class hi {
          static buildStructure(c, h) {
            const b = c.spec, E = [], P = hi.getTagsWithOperations(c, b);
            return E.push(...hi.addMarkdownItems(b.info.description || "", void 0, 1, h)), b["x-tagGroups"] && b["x-tagGroups"].length > 0 ? E.push(...hi.getTagGroupsItems(c, void 0, b["x-tagGroups"], P, h)) : E.push(...hi.getTagsItems(c, P, void 0, void 0, h)), E;
          }
          static addMarkdownItems(c, h, b, E) {
            const P = new Oa(E, h == null ? void 0 : h.id).extractHeadings(c || "");
            P.length && h && h.description && (h.description = Oa.getTextBeforeHading(h.description, P[0].name));
            const $ = (V, ee, ie = 1) => ee.map((ne) => {
              const se = new qn("section", ne, V);
              return se.depth = ie, ne.items && (se.items = $(se, ne.items, ie + 1)), se;
            });
            return $(h, P, b);
          }
          static getTagGroupsItems(c, h, b, E, P) {
            const $ = [];
            for (const V of b) {
              const ee = new qn("group", V, h);
              ee.depth = Bp, ee.items = hi.getTagsItems(c, E, ee, V, P), $.push(ee);
            }
            return $;
          }
          static getTagsItems(c, h, b, E, P) {
            let $;
            $ = E === void 0 ? Object.keys(h) : E.tags;
            const V = $.map((ie) => h[ie] ? (h[ie].used = !0, h[ie]) : (console.warn(`Non-existing tag "${ie}" is added to the group "${E.name}"`), null)), ee = [];
            for (const ie of V) {
              if (!ie) continue;
              const ne = new qn("tag", ie, b);
              if (ne.depth = Bp + 1, ie.name === "") {
                const me = [...hi.addMarkdownItems(ie.description || "", ne, ne.depth + 1, P), ...this.getOperationsItems(c, void 0, ie, ne.depth + 1, P)];
                ee.push(...me);
                continue;
              }
              const se = this.getTagRelatedSchema({ parser: c, tag: ie, parent: ne });
              ne.items = [...se, ...hi.addMarkdownItems(ie.description || "", ne, ne.depth + 1, P), ...this.getOperationsItems(c, ne, ie, ne.depth + 1, P)], ee.push(ne);
            }
            return P.sortTagsAlphabetically && ee.sort(nn("name")), ee;
          }
          static getOperationsItems(c, h, b, E, P) {
            if (b.operations.length === 0) return [];
            const $ = [];
            for (const V of b.operations) {
              const ee = new Lr(c, V, h, P);
              ee.depth = E, $.push(ee);
            }
            return P.sortOperationsAlphabetically && $.sort(nn("name")), $;
          }
          static getTagsWithOperations(c, h) {
            const b = {}, E = h["x-webhooks"] || h.webhooks;
            for (const $ of h.tags || []) b[$.name] = F1(D1({}, $), { operations: [] });
            function P($, V, ee) {
              for (const ie of Object.keys(V)) {
                const ne = V[ie], se = Object.keys(ne).filter(ps);
                for (const me of se) {
                  const Ie = ne[me];
                  if (ne.$ref) {
                    const { resolved: yt } = $.deref(ne);
                    P($, { [ie]: yt }, ee);
                    continue;
                  }
                  let ze = Ie == null ? void 0 : Ie.tags;
                  ze && ze.length || (ze = [""]);
                  for (const yt of ze) {
                    let kt = b[yt];
                    kt === void 0 && (kt = { name: yt, operations: [] }, b[yt] = kt), kt["x-traitTag"] || kt.operations.push(F1(D1({}, Ie), { pathName: ie, pointer: rt.compile(["paths", ie, me]), httpVerb: me, pathParameters: ne.parameters || [], pathServers: ne.servers, isWebhook: !!ee }));
                  }
                }
              }
            }
            return E && P(c, E, !0), h.paths && P(c, h.paths), b;
          }
          static getTagRelatedSchema({ parser: c, tag: h, parent: b }) {
            var E;
            return Object.entries(((E = c.spec.components) == null ? void 0 : E.schemas) || {}).map(([P, $]) => {
              const V = $["x-tags"];
              if (!(V != null && V.includes(h.name))) return null;
              const ee = new qn("schema", { name: P, "x-displayName": `${$.title || P}`, description: `<SchemaDefinition showWriteOnly={true} schemaRef="#/components/schemas/${P}" />` }, b);
              return ee.depth = b.depth + 1, ee;
            }).filter(Boolean);
          }
        }
        var SM = Object.defineProperty, xM = Object.getOwnPropertyDescriptor, Ta = (u, c, h, b) => {
          for (var E, P = b > 1 ? void 0 : b ? xM(c, h) : c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = (b ? E(c, h, P) : E(P)) || P);
          return b && P && SM(c, h, P), P;
        };
        const _s = "data-section-id";
        class zi {
          constructor(c, h, b) {
            this.scroll = h, this.history = b, this.activeItemIdx = -1, this.sideBarOpened = !1, this.updateOnScroll = (E) => {
              const P = E ? 1 : -1;
              let $ = this.activeItemIdx;
              for (; ($ !== -1 || E) && !($ >= this.flatItems.length - 1 && E); ) {
                if (E) {
                  const V = this.getElementAtOrFirstChild($ + 1);
                  if (this.scroll.isElementBellow(V)) break;
                } else {
                  const V = this.getElementAt($);
                  if (this.scroll.isElementAbove(V)) break;
                }
                $ += P;
              }
              this.activate(this.flatItems[$], !0, !0);
            }, this.updateOnHistory = (E = this.history.currentId) => {
              if (!E) return;
              let P;
              P = this.flatItems.find(($) => $.id === E), P ? this.activateAndScroll(P, !1) : (E.startsWith(Nr) && (P = this.flatItems.find(($) => Nr.startsWith($.id)), this.activateAndScroll(P, !1)), this.scroll.scrollIntoViewBySelector(`[${_s}="${pe(E)}"]`));
            }, this.getItemById = (E) => this.flatItems.find((P) => P.id === E), (0, D.makeObservable)(this), this.items = c.contentItems, this.flatItems = y(this.items || [], "items"), this.flatItems.forEach((E, P) => E.absoluteIdx = P), this.subscribe();
          }
          static updateOnHistory(c = Ea.currentId, h) {
            c && h.scrollIntoViewBySelector(`[${_s}="${pe(c)}"]`);
          }
          subscribe() {
            this._unsubscribe = this.scroll.subscribe(this.updateOnScroll), this._hashUnsubscribe = this.history.subscribe(this.updateOnHistory);
          }
          toggleSidebar() {
            this.sideBarOpened = !this.sideBarOpened;
          }
          closeSidebar() {
            this.sideBarOpened = !1;
          }
          getElementAt(c) {
            const h = this.flatItems[c];
            return h && d(`[${_s}="${pe(h.id)}"]`) || null;
          }
          getElementAtOrFirstChild(c) {
            let h = this.flatItems[c];
            return h && h.type === "group" && (h = h.items[0]), h && d(`[${_s}="${pe(h.id)}"]`) || null;
          }
          get activeItem() {
            return this.flatItems[this.activeItemIdx] || void 0;
          }
          activate(c, h = !0, b = !1) {
            if ((this.activeItem && this.activeItem.id) !== (c && c.id) && (!c || c.type !== "group")) {
              if (this.deactivate(this.activeItem), !c) return this.activeItemIdx = -1, void this.history.replace("", b);
              c.depth <= Bp || (this.activeItemIdx = c.absoluteIdx, h && this.history.replace(encodeURI(c.id), b), c.activate(), c.expand());
            }
          }
          deactivate(c) {
            if (c !== void 0) for (c.deactivate(); c !== void 0; ) c.collapse(), c = c.parent;
          }
          activateAndScroll(c, h, b) {
            const E = c && this.getItemById(c.id) || c;
            this.activate(E, h, b), this.scrollToActive(), E && E.items.length || this.closeSidebar();
          }
          scrollToActive() {
            this.scroll.scrollIntoView(this.getElementAt(this.activeItemIdx));
          }
          dispose() {
            this._unsubscribe(), this._hashUnsubscribe();
          }
        }
        Ta([D.observable], zi.prototype, "activeItemIdx", 2), Ta([D.observable], zi.prototype, "sideBarOpened", 2), Ta([D.action], zi.prototype, "toggleSidebar", 1), Ta([D.action], zi.prototype, "closeSidebar", 1), Ta([D.action], zi.prototype, "activate", 1), Ta([D.action.bound], zi.prototype, "activateAndScroll", 1);
        var _M = Object.defineProperty, EM = Object.getOwnPropertyDescriptor;
        const Up = "scroll";
        class Lg {
          constructor(c) {
            this.options = c, this._prevOffsetY = 0, this._scrollParent = f ? window : void 0, this._emiter = new Le.EventEmitter(), this.bind();
          }
          bind() {
            this._prevOffsetY = this.scrollY(), this._scrollParent && this._scrollParent.addEventListener("scroll", this.handleScroll);
          }
          dispose() {
            this._scrollParent && this._scrollParent.removeEventListener("scroll", this.handleScroll), this._emiter.removeAllListeners(Up);
          }
          scrollY() {
            return typeof HTMLElement < "u" && this._scrollParent instanceof HTMLElement ? this._scrollParent.scrollTop : this._scrollParent !== void 0 ? this._scrollParent.pageYOffset : 0;
          }
          isElementBellow(c) {
            if (c !== null) return c.getBoundingClientRect().top > this.options.scrollYOffset();
          }
          isElementAbove(c) {
            if (c === null) return;
            const h = c.getBoundingClientRect().top;
            return (h > 0 ? Math.floor(h) : Math.ceil(h)) <= this.options.scrollYOffset();
          }
          subscribe(c) {
            const h = this._emiter.addListener(Up, c);
            return () => h.removeListener(Up, c);
          }
          scrollIntoView(c) {
            c !== null && (c.scrollIntoView(), this._scrollParent && this._scrollParent.scrollBy && this._scrollParent.scrollBy(0, 1 - this.options.scrollYOffset()));
          }
          scrollIntoViewBySelector(c) {
            const h = d(c);
            this.scrollIntoView(h);
          }
          handleScroll() {
            const c = this.scrollY() - this._prevOffsetY > 0;
            this._prevOffsetY = this.scrollY(), this._emiter.emit(Up, c);
          }
        }
        ((u, c, h, b) => {
          for (var E, P = EM(c, h), $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(c, h, P) || P);
          P && _M(c, h, P);
        })([xe.bind, cu(100)], Lg.prototype, "handleScroll");
        class z1 {
          constructor() {
            this.searchWorker = function() {
              let c;
              if (f) try {
                c = i(595);
              } catch {
                c = i(388).ZP;
              }
              else c = i(388).ZP;
              return new c();
            }();
          }
          indexItems(c) {
            const h = (b) => {
              b.forEach((E) => {
                E.type !== "group" && this.add(E.name, (E.description || "").concat(" ", E.path || ""), E.id), h(E.items);
              });
            };
            h(c), this.searchWorker.done();
          }
          add(c, h, b) {
            this.searchWorker.add(c, h, b);
          }
          dispose() {
            this.searchWorker.terminate(), this.searchWorker.dispose();
          }
          search(c) {
            return this.searchWorker.search(c);
          }
          toJS() {
            return c = this, h = function* () {
              return this.searchWorker.toJS();
            }, new Promise((b, E) => {
              var P = (ee) => {
                try {
                  V(h.next(ee));
                } catch (ie) {
                  E(ie);
                }
              }, $ = (ee) => {
                try {
                  V(h.throw(ee));
                } catch (ie) {
                  E(ie);
                }
              }, V = (ee) => ee.done ? b(ee.value) : Promise.resolve(ee.value).then(P, $);
              V((h = h.apply(c, null)).next());
            });
            var c, h;
          }
          load(c) {
            this.searchWorker.load(c);
          }
          fromExternalJS(c, h) {
            c && h && this.searchWorker.fromExternalJS(c, h);
          }
        }
        const Eo = M.div`
  width: calc(100% - ${(u) => u.theme.rightPanel.width});
  padding: 0 ${(u) => u.theme.spacing.sectionHorizontal}px;

  ${({ $compact: u, theme: c }) => O.lessThan("medium", !0)`
    width: 100%;
    padding: ${`${u ? 0 : c.spacing.sectionVertical}px ${c.spacing.sectionHorizontal}px`};
  `};
`, vu = M.div.attrs((u) => ({ [_s]: u.id }))`
  padding: ${(u) => u.theme.spacing.sectionVertical}px 0;

  &:last-child {
    min-height: calc(100vh + 1px);
  }

  & > &:last-child {
    min-height: initial;
  }

  ${O.lessThan("medium", !0)`
    padding: 0;
  `}
  ${({ $underlined: u }) => u ? `
    position: relative;

    &:not(:last-of-type):after {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: block;
      content: '';
      border-bottom: 1px solid rgba(0, 0, 0, 0.2);
    }
  ` : ""}
`, q1 = M.div`
  width: ${(u) => u.theme.rightPanel.width};
  color: ${({ theme: u }) => u.rightPanel.textColor};
  background-color: ${(u) => u.theme.rightPanel.backgroundColor};
  padding: 0 ${(u) => u.theme.spacing.sectionHorizontal}px;

  ${O.lessThan("medium", !0)`
    width: 100%;
    padding: ${(u) => `${u.theme.spacing.sectionVertical}px ${u.theme.spacing.sectionHorizontal}px`};
  `};
`, B1 = M(q1)`
  background-color: ${(u) => u.theme.rightPanel.backgroundColor};
`, Es = M.div`
  display: flex;
  width: 100%;
  padding: 0;

  ${O.lessThan("medium", !0)`
    flex-direction: column;
  `};
`, OM = { 1: "1.85714em", 2: "1.57143em", 3: "1.27em" }, bu = (u) => ve`
  font-family: ${({ theme: c }) => c.typography.headings.fontFamily};
  font-weight: ${({ theme: c }) => c.typography.headings.fontWeight};
  font-size: ${OM[u]};
  line-height: ${({ theme: c }) => c.typography.headings.lineHeight};
`, kM = M.h1`
  ${bu(1)};
  color: ${({ theme: u }) => u.colors.text.primary};

  ${le("H1")};
`, Mg = M.h2`
  ${bu(2)};
  color: ${({ theme: u }) => u.colors.text.primary};
  margin: 0 0 20px;

  ${le("H2")};
`, AM = M.h2`
  ${bu(3)};
  color: ${({ theme: u }) => u.colors.text.primary};

  ${le("H3")};
`, Dg = M.h3`
  color: ${({ theme: u }) => u.rightPanel.textColor};

  ${le("RightPanelHeader")};
`, wu = M.h5`
  border-bottom: 1px solid rgba(38, 50, 56, 0.3);
  margin: 1em 0 1em 0;
  color: rgba(38, 50, 56, 0.5);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 0.929em;
  line-height: 20px;

  ${le("UnderlinedHeader")};
`;
        var PM = (u, c, h) => new Promise((b, E) => {
          var P = (ee) => {
            try {
              V(h.next(ee));
            } catch (ie) {
              E(ie);
            }
          }, $ = (ee) => {
            try {
              V(h.throw(ee));
            } catch (ie) {
              E(ie);
            }
          }, V = (ee) => ee.done ? b(ee.value) : Promise.resolve(ee.value).then(P, $);
          V((h = h.apply(u, c)).next());
        });
        const Vp = (0, o.createContext)(void 0), { Provider: U1, Consumer: V1 } = Vp;
        function W1(u) {
          const { spec: c, specUrl: h, options: b, onLoaded: E, children: P } = u, [$, V] = o.useState(null), [ee, ie] = o.useState(null);
          if (ee) throw ee;
          o.useEffect(() => {
            (function() {
              PM(this, null, function* () {
                if (c || h) {
                  V(null);
                  try {
                    const se = yield $e(c || h);
                    V(se);
                  } catch (se) {
                    throw E && E(se), ie(se), se;
                  }
                }
              });
            })();
          }, [c, h]);
          const ne = o.useMemo(() => {
            if (!$) return null;
            try {
              return new Ia($, h, b);
            } catch (se) {
              throw E && E(se), se;
            }
          }, [$, h, b]);
          return o.useEffect(() => {
            ne && E && E();
          }, [ne, E]), P({ loading: !ne, store: ne });
        }
        function H1() {
          return (0, o.useContext)(Vp);
        }
        const Q1 = (u) => ve`
  ${u} {
    cursor: pointer;
    margin-left: -20px;
    padding: 0;
    line-height: 1;
    width: 20px;
    display: inline-block;
    outline: 0;
  }
  ${u}:before {
    content: '';
    width: 15px;
    height: 15px;
    background-size: contain;
    background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSIjMDEwMTAxIiBkPSJNNDU5LjcgMjMzLjRsLTkwLjUgOTAuNWMtNTAgNTAtMTMxIDUwLTE4MSAwIC03LjktNy44LTE0LTE2LjctMTkuNC0yNS44bDQyLjEtNDIuMWMyLTIgNC41LTMuMiA2LjgtNC41IDIuOSA5LjkgOCAxOS4zIDE1LjggMjcuMiAyNSAyNSA2NS42IDI0LjkgOTAuNSAwbDkwLjUtOTAuNWMyNS0yNSAyNS02NS42IDAtOTAuNSAtMjQuOS0yNS02NS41LTI1LTkwLjUgMGwtMzIuMiAzMi4yYy0yNi4xLTEwLjItNTQuMi0xMi45LTgxLjYtOC45bDY4LjYtNjguNmM1MC01MCAxMzEtNTAgMTgxIDBDNTA5LjYgMTAyLjMgNTA5LjYgMTgzLjQgNDU5LjcgMjMzLjR6TTIyMC4zIDM4Mi4ybC0zMi4yIDMyLjJjLTI1IDI0LjktNjUuNiAyNC45LTkwLjUgMCAtMjUtMjUtMjUtNjUuNiAwLTkwLjVsOTAuNS05MC41YzI1LTI1IDY1LjUtMjUgOTAuNSAwIDcuOCA3LjggMTIuOSAxNy4yIDE1LjggMjcuMSAyLjQtMS40IDQuOC0yLjUgNi44LTQuNWw0Mi4xLTQyYy01LjQtOS4yLTExLjYtMTgtMTkuNC0yNS44IC01MC01MC0xMzEtNTAtMTgxIDBsLTkwLjUgOTAuNWMtNTAgNTAtNTAgMTMxIDAgMTgxIDUwIDUwIDEzMSA1MCAxODEgMGw2OC42LTY4LjZDMjc0LjYgMzk1LjEgMjQ2LjQgMzkyLjMgMjIwLjMgMzgyLjJ6Ii8+PC9zdmc+Cg==');
    opacity: 0.5;
    visibility: hidden;
    display: inline-block;
    vertical-align: middle;
  }

  h1:hover > ${u}::before, h2:hover > ${u}::before, ${u}:hover::before {
    visibility: visible;
  }
`, CM = M(function(u) {
          const c = o.useContext(Vp), h = o.useCallback((b) => {
            c && function(E, P, $) {
              P.defaultPrevented || P.button !== 0 || ((V) => !!(V.metaKey || V.altKey || V.ctrlKey || V.shiftKey))(P) || (P.preventDefault(), E.replace(encodeURI($)));
            }(c.menu.history, b, u.to);
          }, [c, u.to]);
          return c ? o.createElement("a", { className: u.className, href: c.menu.history.linkForId(u.to), onClick: h, "aria-label": u.to }, u.children) : null;
        })`
  ${Q1("&")};
`;
        function Fg(u) {
          return o.createElement(CM, { to: u.to });
        }
        const TM = { left: "90deg", right: "-90deg", up: "-180deg", down: "0" }, qi = M((u) => o.createElement("svg", { className: u.className, style: u.style, version: "1.1", viewBox: "0 0 24 24", x: "0", xmlns: "http://www.w3.org/2000/svg", y: "0", "aria-hidden": "true" }, o.createElement("polygon", { points: "17.3 8.3 12 13.6 6.7 8.3 5.3 9.7 12 16.4 18.7 9.7 " })))`
  height: ${(u) => u.size || "18px"};
  width: ${(u) => u.size || "18px"};
  min-width: ${(u) => u.size || "18px"};
  vertical-align: middle;
  float: ${(u) => u.float || ""};
  transition: transform 0.2s ease-out;
  transform: rotateZ(${(u) => TM[u.direction || "down"]});

  polygon {
    fill: ${({ color: u, theme: c }) => u && c.colors.responses[u] && c.colors.responses[u].color || u};
  }
`, Su = M.span`
  display: inline-block;
  padding: 2px 8px;
  margin: 0;
  background-color: ${(u) => u.theme.colors[u.type].main};
  color: ${(u) => u.theme.colors[u.type].contrastText};
  font-size: ${(u) => u.theme.typography.code.fontSize};
  vertical-align: middle;
  line-height: 1.6;
  border-radius: 4px;
  font-weight: ${({ theme: u }) => u.typography.fontWeightBold};
  font-size: 12px;
  + span[type] {
    margin-left: 4px;
  }
`, Wp = ve`
  text-decoration: line-through;
  color: #707070;
`, $M = M.caption`
  text-align: right;
  font-size: 0.9em;
  font-weight: normal;
  color: ${(u) => u.theme.colors.text.secondary};
`, Y1 = M.td`
  border-left: 1px solid ${(u) => u.theme.schema.linesColor};
  box-sizing: border-box;
  position: relative;
  padding: 10px 10px 10px 0;

  ${O.lessThan("small")`
    display: block;
    overflow: hidden;
  `}

  tr:first-of-type > &,
  tr.last > & {
    border-left-width: 0;
    background-position: top left;
    background-repeat: no-repeat;
    background-size: 1px 100%;
  }

  tr:first-of-type > & {
    background-image: linear-gradient(
      to bottom,
      transparent 0%,
      transparent 22px,
      ${(u) => u.theme.schema.linesColor} 22px,
      ${(u) => u.theme.schema.linesColor} 100%
    );
  }

  tr.last > & {
    background-image: linear-gradient(
      to bottom,
      ${(u) => u.theme.schema.linesColor} 0%,
      ${(u) => u.theme.schema.linesColor} 22px,
      transparent 22px,
      transparent 100%
    );
  }

  tr.last + tr > & {
    border-left-color: transparent;
  }

  tr.last:first-child > & {
    background: none;
    border-left-color: transparent;
  }
`, RM = M(Y1)`
  padding: 0;
`, G1 = M(Y1)`
  vertical-align: top;
  line-height: 20px;
  white-space: nowrap;
  font-size: 13px;
  font-family: ${(u) => u.theme.typography.code.fontFamily};

  &.deprecated {
    ${Wp};
  }

  ${({ kind: u }) => u === "patternProperties" && ve`
      > span.property-name {
        display: inline-table;
        white-space: break-spaces;
        margin-right: 20px;

        ::before,
        ::after {
          content: '/';
          filter: opacity(0.2);
        }
      }
    `}

  ${({ kind: u = "" }) => ["field", "additionalProperties", "patternProperties"].includes(u) ? "" : "font-style: italic"};

  ${le("PropertyNameCell")};
`, IM = M.td`
  border-bottom: 1px solid #9fb4be;
  padding: 10px 0;
  width: ${(u) => u.theme.schema.defaultDetailsWidth};
  box-sizing: border-box;

  tr.expanded & {
    border-bottom: none;
  }

  ${O.lessThan("small")`
    padding: 0 20px;
    border-bottom: none;
    border-left: 1px solid ${(u) => u.theme.schema.linesColor};

    tr.last > & {
      border-left: none;
    }
  `}

  ${le("PropertyDetailsCell")};
`, K1 = M.span`
  color: ${(u) => u.theme.schema.linesColor};
  font-family: ${(u) => u.theme.typography.code.fontFamily};
  margin-right: 10px;

  &::before {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 10px;
    height: 1px;
    background: ${(u) => u.theme.schema.linesColor};
  }

  &::after {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 1px;
    background: ${(u) => u.theme.schema.linesColor};
    height: 7px;
  }
`, Wt = M.div`
  padding: ${({ theme: u }) => u.schema.nestingSpacing};
`, zg = M.table`
  border-collapse: separate;
  border-radius: 3px;
  font-size: ${(u) => u.theme.typography.fontSize};

  border-spacing: 0;
  width: 100%;

  > tr {
    vertical-align: middle;
  }

  ${O.lessThan("small")`
    display: block;
    > tr, > tbody > tr {
      display: block;
    }
  `}

  ${O.lessThan("small", !1, " and (-ms-high-contrast:none)")`
    td {
      float: left;
      width: 100%;
    }
  `}

  &
    ${Wt},
    &
    ${Wt}
    ${Wt}
    ${Wt},
    &
    ${Wt}
    ${Wt}
    ${Wt}
    ${Wt}
    ${Wt} {
    margin: ${({ theme: u }) => u.schema.nestingSpacing};
    margin-right: 0;
    background: ${({ theme: u }) => u.schema.nestedBackground};
  }

  &
    ${Wt}
    ${Wt},
    &
    ${Wt}
    ${Wt}
    ${Wt}
    ${Wt},
    &
    ${Wt}
    ${Wt}
    ${Wt}
    ${Wt}
    ${Wt}
    ${Wt} {
    background: #ffffff;
  }
`, jM = M.div`
  margin: 0 0 3px 0;
  display: inline-block;
`, NM = M.span`
  font-size: 0.9em;
  margin-right: 10px;
  color: ${(u) => u.theme.colors.primary.main};
  font-family: ${(u) => u.theme.typography.headings.fontFamily};
}
`, LM = M.button`
  display: inline-block;
  margin-right: 10px;
  margin-bottom: 5px;
  font-size: 0.8em;
  cursor: pointer;
  border: 1px solid ${(u) => u.theme.colors.primary.main};
  padding: 2px 10px;
  line-height: 1.5em;
  outline: none;
  &:focus {
    box-shadow: 0 0 0 1px ${(u) => u.theme.colors.primary.main};
  }

  ${({ $deprecated: u }) => u && Wp || ""};

  ${(u) => u.$active ? `
      color: white;
      background-color: ${u.theme.colors.primary.main};
      &:focus {
        box-shadow: none;
        background-color: ${(0, a.darken)(0.15, u.theme.colors.primary.main)};
      }
      ` : `
        color: ${u.theme.colors.primary.main};
        background-color: white;
      `}
`, MM = M.div`
  font-size: 0.9em;
  font-family: ${(u) => u.theme.typography.code.fontFamily};
  &::after {
    content: ' [';
  }
`, DM = M.div`
  font-size: 0.9em;
  font-family: ${(u) => u.theme.typography.code.fontFamily};
  &::after {
    content: ']';
  }
`;
        var Os = XY;
        const qg = M(Os.Tabs)`
  > ul {
    list-style: none;
    padding: 0;
    margin: 0;
    margin: 0 -5px;

    > li {
      padding: 5px 10px;
      display: inline-block;

      background-color: ${({ theme: u }) => u.codeBlock.backgroundColor};
      border-bottom: 1px solid rgba(0, 0, 0, 0.5);
      cursor: pointer;
      text-align: center;
      outline: none;
      color: ${({ theme: u }) => (0, a.darken)(u.colors.tonalOffset, u.rightPanel.textColor)};
      margin: 0
        ${({ theme: u }) => `${u.spacing.unit}px ${u.spacing.unit}px ${u.spacing.unit}px`};
      border: 1px solid ${({ theme: u }) => (0, a.darken)(0.05, u.codeBlock.backgroundColor)};
      border-radius: 5px;
      min-width: 60px;
      font-size: 0.9em;
      font-weight: bold;

      &.react-tabs__tab--selected {
        color: ${(u) => u.theme.colors.text.primary};
        background: ${({ theme: u }) => u.rightPanel.textColor};
        &:focus {
          outline: auto;
        }
      }

      &:only-child {
        flex: none;
        min-width: 100px;
      }

      &.tab-success {
        color: ${(u) => u.theme.colors.responses.success.tabTextColor};
      }

      &.tab-redirect {
        color: ${(u) => u.theme.colors.responses.redirect.tabTextColor};
      }

      &.tab-info {
        color: ${(u) => u.theme.colors.responses.info.tabTextColor};
      }

      &.tab-error {
        color: ${(u) => u.theme.colors.responses.error.tabTextColor};
      }
    }
  }
  > .react-tabs__tab-panel {
    background: ${({ theme: u }) => u.codeBlock.backgroundColor};
    & > div,
    & > pre {
      padding: ${(u) => 4 * u.theme.spacing.unit}px;
      margin: 0;
    }

    & > div > pre {
      padding: 0;
    }
  }
`, Bg = (M(qg)`
  > ul {
    display: block;
    > li {
      padding: 2px 5px;
      min-width: auto;
      margin: 0 15px 0 0;
      font-size: 13px;
      font-weight: normal;
      border-bottom: 1px dashed;
      color: ${({ theme: u }) => (0, a.darken)(u.colors.tonalOffset, u.rightPanel.textColor)};
      border-radius: 0;
      background: none;

      &:last-child {
        margin-right: 0;
      }

      &.react-tabs__tab--selected {
        color: ${({ theme: u }) => u.rightPanel.textColor};
        background: none;
      }
    }
  }
  > .react-tabs__tab-panel {
    & > div,
    & > pre {
      padding: ${(u) => 2 * u.theme.spacing.unit}px 0;
    }
  }
`, M.div`
  /**
  * Based on prism-dark.css
  */

  code[class*='language-'],
  pre[class*='language-'] {
    /* color: white;
    background: none; */
    text-shadow: 0 -0.1em 0.2em black;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  @media print {
    code[class*='language-'],
    pre[class*='language-'] {
      text-shadow: none;
    }
  }

  /* Code blocks */
  pre[class*='language-'] {
    padding: 1em;
    margin: 0.5em 0;
    overflow: auto;
  }

  .token.comment,
  .token.prolog,
  .token.doctype,
  .token.cdata {
    color: hsl(30, 20%, 50%);
  }

  .token.punctuation {
    opacity: 0.7;
  }

  .namespace {
    opacity: 0.7;
  }

  .token.property,
  .token.tag,
  .token.number,
  .token.constant,
  .token.symbol {
    color: #4a8bb3;
  }

  .token.boolean {
    color: #e64441;
  }

  .token.selector,
  .token.attr-name,
  .token.string,
  .token.char,
  .token.builtin,
  .token.inserted {
    color: #a0fbaa;
    & + a,
    & + a:visited {
      color: #4ed2ba;
      text-decoration: underline;
    }
  }

  .token.property.string {
    color: white;
  }

  .token.operator,
  .token.entity,
  .token.url,
  .token.variable {
    color: hsl(40, 90%, 60%);
  }

  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: hsl(350, 40%, 70%);
  }

  .token.regex,
  .token.important {
    color: #e90;
  }

  .token.important,
  .token.bold {
    font-weight: bold;
  }
  .token.italic {
    font-style: italic;
  }

  .token.entity {
    cursor: help;
  }

  .token.deleted {
    color: red;
  }

  ${le("Prism")};
`), Hp = M.div`
  opacity: 0.7;
  transition: opacity 0.3s ease;
  text-align: right;
  &:focus-within {
    opacity: 1;
  }
  > button {
    background-color: transparent;
    border: 0;
    color: inherit;
    padding: 2px 10px;
    font-family: ${({ theme: u }) => u.typography.fontFamily};
    font-size: ${({ theme: u }) => u.typography.fontSize};
    line-height: ${({ theme: u }) => u.typography.lineHeight};
    cursor: pointer;
    outline: 0;

    :hover,
    :focus {
      background: rgba(255, 255, 255, 0.1);
    }
  }
`, FM = M.div`
  &:hover ${Hp} {
    opacity: 1;
  }
`, X1 = M(Bg).attrs({ as: "pre" })`
  font-family: ${(u) => u.theme.typography.code.fontFamily};
  font-size: ${(u) => u.theme.typography.code.fontSize};
  overflow-x: auto;
  margin: 0;

  white-space: ${({ theme: u }) => u.typography.code.wrap ? "pre-wrap" : "pre"};
`;
        var J1 = pG, zM = i.n(J1), qM = Object.defineProperty, Z1 = Object.getOwnPropertySymbols, BM = Object.prototype.hasOwnProperty, UM = Object.prototype.propertyIsEnumerable, ex = (u, c, h) => c in u ? qM(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        const VM = zM() || J1;
        let Bi = "";
        f && (Bi = i(232), Bi = typeof Bi.toString == "function" && Bi.toString() || "", Bi = Bi === "[object Object]" ? "" : Bi);
        const WM = he`${Bi}`, HM = M.div`
  position: relative;
`;
        class QM extends o.Component {
          constructor() {
            super(...arguments), this.handleRef = (c) => {
              this._container = c;
            };
          }
          componentDidMount() {
            const c = this._container.parentElement && this._container.parentElement.scrollTop || 0;
            this.inst = new VM(this._container, this.props.options || {}), this._container.scrollTo && this._container.scrollTo(0, c);
          }
          componentDidUpdate() {
            this.inst.update();
          }
          componentWillUnmount() {
            this.inst.destroy();
          }
          render() {
            const { children: c, className: h, updateFn: b } = this.props;
            return b && b(this.componentDidUpdate.bind(this)), o.createElement(o.Fragment, null, Bi && o.createElement(WM, null), o.createElement(HM, { className: `scrollbar-container ${h}`, ref: this.handleRef }, c));
          }
        }
        function tx(u) {
          return o.createElement(Ge.Consumer, null, (c) => c.nativeScrollbars ? o.createElement("div", { style: { overflow: "auto", overscrollBehavior: "contain", msOverflowStyle: "-ms-autohiding-scrollbar" } }, u.children) : o.createElement(QM, ((h, b) => {
            for (var E in b || (b = {})) BM.call(b, E) && ex(h, E, b[E]);
            if (Z1) for (var E of Z1(b)) UM.call(b, E) && ex(h, E, b[E]);
            return h;
          })({}, u), u.children));
        }
        const YM = M(({ className: u, style: c }) => o.createElement("svg", { className: u, style: c, xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, o.createElement("polyline", { points: "6 9 12 15 18 9" })))`
  position: absolute;
  pointer-events: none;
  z-index: 1;
  top: 50%;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  transform: translateY(-50%);
  right: 8px;
  margin: auto;
  text-align: center;
  polyline {
    color: ${(u) => u.variant === "dark" && "white"};
  }
`, GM = o.memo((u) => {
          const { options: c, onChange: h, placeholder: b, value: E = "", variant: P, className: $ } = u;
          return o.createElement("div", { className: $ }, o.createElement(YM, { variant: P }), o.createElement("select", { onChange: (V) => {
            const { selectedIndex: ee } = V.target;
            h(c[b ? ee - 1 : ee]);
          }, value: E, className: "dropdown-select" }, b && o.createElement("option", { disabled: !0, hidden: !0, value: b }, b), c.map(({ idx: V, value: ee, title: ie }, ne) => o.createElement("option", { key: V || ee + ne, value: ee }, ie || ee))), o.createElement("label", null, E));
        }), Qp = U()(GM)`
  label {
    box-sizing: border-box;
    min-width: 100px;
    outline: none;
    display: inline-block;
    font-family: ${(u) => u.theme.typography.headings.fontFamily};
    color: ${({ theme: u }) => u.colors.text.primary};
    vertical-align: bottom;
    width: ${({ fullWidth: u }) => u ? "100%" : "auto"};
    text-transform: none;
    padding: 0 22px 0 4px;

    font-size: 0.929em;
    line-height: 1.5em;
    font-family: inherit;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }
  .dropdown-select {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    border: none;
    appearance: none;
    cursor: pointer;

    color: ${({ theme: u }) => u.colors.text.primary};
    line-height: inherit;
    font-family: inherit;
  }
  box-sizing: border-box;
  min-width: 100px;
  outline: none;
  display: inline-block;
  border-radius: 2px;
  border: 1px solid rgba(38, 50, 56, 0.5);
  vertical-align: bottom;
  padding: 2px 0px 2px 6px;
  position: relative;
  width: auto;
  background: white;
  color: #263238;
  font-family: ${(u) => u.theme.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
  cursor: pointer;
  transition: border 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;

  &:hover,
  &:focus-within {
    border: 1px solid ${(u) => u.theme.colors.primary.main};
    color: ${(u) => u.theme.colors.primary.main};
    box-shadow: 0px 0px 0px 1px ${(u) => u.theme.colors.primary.main};
  }
`, rx = U()(Qp)`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.969em;

  font-size: 1em;
  border: none;
  padding: 0 1.2em 0 0;
  background: transparent;

  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    label {
      color: ${(u) => u.theme.colors.primary.main};
      text-shadow: 0px 0px 0px ${(u) => u.theme.colors.primary.main};
    }
  }
`, nx = U().span`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.929em;
  color: black;
`;
        var KM = Object.defineProperty, ix = Object.getOwnPropertySymbols, XM = Object.prototype.hasOwnProperty, JM = Object.prototype.propertyIsEnumerable, ox = (u, c, h) => c in u ? KM(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, ZM = (u, c) => {
          for (var h in c || (c = {})) XM.call(c, h) && ox(u, h, c[h]);
          if (ix) for (var h of ix(c)) JM.call(c, h) && ox(u, h, c[h]);
          return u;
        };
        function $a(u) {
          const { Label: c = nx, Dropdown: h = rx } = u;
          return u.options.length === 1 ? o.createElement(c, null, u.options[0].value) : o.createElement(h, ZM({}, u));
        }
        var e2 = fG();
        const Yp = ve`
  a {
    text-decoration: ${(u) => u.theme.typography.links.textDecoration};
    color: ${(u) => u.theme.typography.links.color};

    &:visited {
      color: ${(u) => u.theme.typography.links.visited};
    }

    &:hover {
      color: ${(u) => u.theme.typography.links.hover};
      text-decoration: ${(u) => u.theme.typography.links.hoverTextDecoration};
    }
  }
`, Ra = M(Bg)`
  font-family: ${(u) => u.theme.typography.fontFamily};
  font-weight: ${(u) => u.theme.typography.fontWeightRegular};
  line-height: ${(u) => u.theme.typography.lineHeight};

  p {
    &:last-child {
      margin-bottom: 0;
    }
  }

  ${({ $compact: u }) => u && `
    p:first-child {
      margin-top: 0;
    }
    p:last-child {
      margin-bottom: 0;
    }
  `}

  ${({ $inline: u }) => u && ` p {
    display: inline-block;
  }`}

  h1 {
    ${bu(1)};
    color: ${(u) => u.theme.colors.primary.main};
    margin-top: 0;
  }

  h2 {
    ${bu(2)};
    color: ${(u) => u.theme.colors.text.primary};
  }

  code {
    color: ${({ theme: u }) => u.typography.code.color};
    background-color: ${({ theme: u }) => u.typography.code.backgroundColor};

    font-family: ${(u) => u.theme.typography.code.fontFamily};
    border-radius: 2px;
    border: 1px solid rgba(38, 50, 56, 0.1);
    padding: 0 ${({ theme: u }) => u.spacing.unit}px;
    font-size: ${(u) => u.theme.typography.code.fontSize};
    font-weight: ${({ theme: u }) => u.typography.code.fontWeight};

    word-break: break-word;
  }

  pre {
    font-family: ${(u) => u.theme.typography.code.fontFamily};
    white-space: ${({ theme: u }) => u.typography.code.wrap ? "pre-wrap" : "pre"};
    background-color: ${({ theme: u }) => u.codeBlock.backgroundColor};
    color: white;
    padding: ${(u) => 4 * u.theme.spacing.unit}px;
    overflow-x: auto;
    line-height: normal;
    border-radius: 0;
    border: 1px solid rgba(38, 50, 56, 0.1);

    code {
      background-color: transparent;
      color: white;
      padding: 0;

      &:before,
      &:after {
        content: none;
      }
    }
  }

  blockquote {
    margin: 0;
    margin-bottom: 1em;
    padding: 0 15px;
    color: #777;
    border-left: 4px solid #ddd;
  }

  img {
    max-width: 100%;
    box-sizing: content-box;
  }

  ul,
  ol {
    padding-left: 2em;
    margin: 0;
    margin-bottom: 1em;

    ul,
    ol {
      margin-bottom: 0;
      margin-top: 0;
    }
  }

  table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
    border-collapse: collapse;
    border-spacing: 0;
    margin-top: 1.5em;
    margin-bottom: 1.5em;
  }

  table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;

    &:nth-child(2n) {
      background-color: ${({ theme: u }) => u.schema.nestedBackground};
    }
  }

  table th,
  table td {
    padding: 6px 13px;
    border: 1px solid #ddd;
  }

  table th {
    text-align: left;
    font-weight: bold;
  }

  ${Q1(".share-link")};

  ${Yp}

  ${le("Markdown")};
`;
        var t2 = Object.defineProperty, r2 = Object.defineProperties, n2 = Object.getOwnPropertyDescriptors, Gp = Object.getOwnPropertySymbols, sx = Object.prototype.hasOwnProperty, ax = Object.prototype.propertyIsEnumerable, lx = (u, c, h) => c in u ? t2(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, ux = (u, c) => {
          for (var h in c || (c = {})) sx.call(c, h) && lx(u, h, c[h]);
          if (Gp) for (var h of Gp(c)) ax.call(c, h) && lx(u, h, c[h]);
          return u;
        };
        const i2 = U()((u) => o.createElement(Ra, ux({}, u)))`
  display: inline;
`;
        function cx(u) {
          var c = u, { inline: h, compact: b } = c, E = (($, V) => {
            var ee = {};
            for (var ie in $) sx.call($, ie) && V.indexOf(ie) < 0 && (ee[ie] = $[ie]);
            if ($ != null && Gp) for (var ie of Gp($)) V.indexOf(ie) < 0 && ax.call($, ie) && (ee[ie] = $[ie]);
            return ee;
          })(c, ["inline", "compact"]);
          const P = h ? i2 : Ra;
          return o.createElement(Et, null, ($) => {
            return o.createElement(P, (V = ux({ className: "redoc-markdown " + (E.className || ""), dangerouslySetInnerHTML: { __html: (ee = $.untrustedSpec, ie = E.html, ee ? e2.sanitize(ie) : ie) }, "data-role": E["data-role"] }, E), r2(V, n2({ $inline: h, $compact: b }))));
            var V, ee, ie;
          });
        }
        class Mr extends o.Component {
          render() {
            const { source: c, inline: h, compact: b, className: E, "data-role": P } = this.props, $ = new Oa();
            return o.createElement(cx, { html: $.renderMd(c), inline: h, compact: b, className: E, "data-role": P });
          }
        }
        const o2 = M.div`
  position: relative;
`, s2 = M.div`
  position: absolute;
  min-width: 80px;
  max-width: 500px;
  background: #fff;
  bottom: 100%;
  left: 50%;
  margin-bottom: 10px;
  transform: translateX(-50%);

  border-radius: 4px;
  padding: 0.3em 0.6em;
  text-align: center;
  box-shadow: 0px 0px 5px 0px rgba(204, 204, 204, 1);
`, a2 = M.div`
  background: #fff;
  color: #000;
  display: inline;
  font-size: 0.85em;
  white-space: nowrap;
`, l2 = M.div`
  position: absolute;
  width: 0;
  height: 0;
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
  border-left: solid transparent 5px;
  border-right: solid transparent 5px;
  border-top: solid #fff 5px;
`, u2 = M.div`
  position: absolute;
  width: 100%;
  height: 20px;
  bottom: -20px;
`;
        class c2 extends o.Component {
          render() {
            const { open: c, title: h, children: b } = this.props;
            return o.createElement(o2, null, b, c && o.createElement(s2, null, o.createElement(a2, null, h), o.createElement(l2, null), o.createElement(u2, null)));
          }
        }
        const p2 = typeof document < "u" && document.queryCommandSupported && document.queryCommandSupported("copy");
        class Ui {
          static isSupported() {
            return p2;
          }
          static selectElement(c) {
            let h, b;
            document.body.createTextRange ? (h = document.body.createTextRange(), h.moveToElementText(c), h.select()) : document.createRange && window.getSelection && (b = window.getSelection(), h = document.createRange(), h.selectNodeContents(c), b.removeAllRanges(), b.addRange(h));
          }
          static deselect() {
            if (document.selection) document.selection.empty();
            else if (window.getSelection) {
              const c = window.getSelection();
              c && c.removeAllRanges();
            }
          }
          static copySelected() {
            let c;
            try {
              c = document.execCommand("copy");
            } catch {
              c = !1;
            }
            return c;
          }
          static copyElement(c) {
            Ui.selectElement(c);
            const h = Ui.copySelected();
            return h && Ui.deselect(), h;
          }
          static copyCustom(c) {
            const h = document.createElement("textarea");
            h.style.position = "fixed", h.style.top = "0", h.style.left = "0", h.style.width = "2em", h.style.height = "2em", h.style.padding = "0", h.style.border = "none", h.style.outline = "none", h.style.boxShadow = "none", h.style.background = "transparent", h.value = c, document.body.appendChild(h), h.select();
            const b = Ui.copySelected();
            return document.body.removeChild(h), b;
          }
        }
        const px = (u) => {
          const [c, h] = o.useState(!1), b = () => {
            const P = typeof u.data == "string" ? u.data : JSON.stringify(u.data, null, 2);
            Ui.copyCustom(P), E();
          }, E = () => {
            h(!0), setTimeout(() => {
              h(!1);
            }, 1500);
          };
          return u.children({ renderCopyButton: () => o.createElement("button", { onClick: b }, o.createElement(c2, { title: Ui.isSupported() ? "Copied" : "Not supported in your browser", open: c }, "Copy")) });
        };
        let Vi = 1;
        function f2(u, c) {
          Vi = 1;
          let h = "";
          return h += '<div class="redoc-json">', h += "<code>", h += Vg(u, c), h += "</code>", h += "</div>", h;
        }
        function Ug(u) {
          return u !== void 0 ? u.toString().replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : "";
        }
        function fx(u) {
          return JSON.stringify(u).slice(1, -1);
        }
        function ks(u, c) {
          return '<span class="' + c + '">' + Ug(u) + "</span>";
        }
        function As(u) {
          return '<span class="token punctuation">' + u + "</span>";
        }
        function Vg(u, c) {
          const h = typeof u;
          let b = "";
          return u == null ? b += ks("null", "token keyword") : u && u.constructor === Array ? (Vi++, b += function(E, P) {
            const $ = Vi > P ? "collapsed" : "";
            let V = `<button class="collapser" aria-label="${Vi > P + 1 ? "expand" : "collapse"}"></button>${As("[")}<span class="ellipsis"></span><ul class="array collapsible">`, ee = !1;
            const ie = E.length;
            for (let ne = 0; ne < ie; ne++) ee = !0, V += '<li><div class="hoverable ' + $ + '">', V += Vg(E[ne], P), ne < ie - 1 && (V += ","), V += "</div></li>";
            return V += `</ul>${As("]")}`, ee || (V = As("[ ]")), V;
          }(u, c), Vi--) : u && u.constructor === Date ? b += ks('"' + u.toISOString() + '"', "token string") : h === "object" ? (Vi++, b += function(E, P) {
            const $ = Vi > P ? "collapsed" : "", V = Object.keys(E), ee = V.length;
            let ie = `<button class="collapser" aria-label="${Vi > P + 1 ? "expand" : "collapse"}"></button>${As("{")}<span class="ellipsis"></span><ul class="obj collapsible">`, ne = !1;
            for (let se = 0; se < ee; se++) {
              const me = V[se];
              ne = !0, ie += '<li><div class="hoverable ' + $ + '">', ie += '<span class="property token string">"' + Ug(me) + '"</span>: ', ie += Vg(E[me], P), se < ee - 1 && (ie += As(",")), ie += "</div></li>";
            }
            return ie += `</ul>${As("}")}`, ne || (ie = As("{ }")), ie;
          }(u, c), Vi--) : h === "number" ? b += ks(u, "token number") : h === "string" ? /^(http|https):\/\/[^\s]+$/.test(u) ? b += ks('"', "token string") + '<a href="' + encodeURI(u) + '">' + Ug(fx(u)) + "</a>" + ks('"', "token string") : b += ks('"' + fx(u) + '"', "token string") : h === "boolean" && (b += ks(u, "token boolean")), b;
        }
        const d2 = ve`
  .redoc-json code > .collapser {
    display: none;
    pointer-events: none;
  }

  font-family: ${(u) => u.theme.typography.code.fontFamily};
  font-size: ${(u) => u.theme.typography.code.fontSize};

  white-space: ${({ theme: u }) => u.typography.code.wrap ? "pre-wrap" : "pre"};
  contain: content;
  overflow-x: auto;

  .callback-function {
    color: gray;
  }

  .collapser:after {
    content: '-';
    cursor: pointer;
  }

  .collapsed > .collapser:after {
    content: '+';
    cursor: pointer;
  }

  .ellipsis:after {
    content: ' … ';
  }

  .collapsible {
    margin-left: 2em;
  }

  .hoverable {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 2px;
    padding-right: 2px;
    border-radius: 2px;
  }

  .hovered {
    background-color: rgba(235, 238, 249, 1);
  }

  .collapser {
    background-color: transparent;
    border: 0;
    color: #fff;
    font-family: ${(u) => u.theme.typography.code.fontFamily};
    font-size: ${(u) => u.theme.typography.code.fontSize};
    padding-right: 6px;
    padding-left: 6px;
    padding-top: 0;
    padding-bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 15px;
    height: 15px;
    position: absolute;
    top: 4px;
    left: -1.5em;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    padding: 2px;
    &:focus {
      outline-color: #fff;
      outline-style: dotted;
      outline-width: 1px;
    }
  }

  ul {
    list-style-type: none;
    padding: 0px;
    margin: 0px 0px 0px 26px;
  }

  li {
    position: relative;
    display: block;
  }

  .hoverable {
    display: inline-block;
  }

  .selected {
    outline-style: solid;
    outline-width: 1px;
    outline-style: dotted;
  }

  .collapsed > .collapsible {
    display: none;
  }

  .ellipsis {
    display: none;
  }

  .collapsed > .ellipsis {
    display: inherit;
  }
`, h2 = M.div`
  &:hover > ${Hp} {
    opacity: 1;
  }
`, dx = M((u) => {
          const [c, h] = o.useState(), b = ({ renderCopyButton: ie }) => {
            const ne = u.data && Object.values(u.data).some((se) => typeof se == "object" && se !== null);
            return o.createElement(h2, null, o.createElement(Hp, null, ie(), ne && o.createElement(o.Fragment, null, o.createElement("button", { onClick: E }, " Expand all "), o.createElement("button", { onClick: P }, " Collapse all "))), o.createElement(Ge.Consumer, null, (se) => o.createElement(Bg, { className: u.className, ref: (me) => h(me), dangerouslySetInnerHTML: { __html: f2(u.data, se.jsonSampleExpandLevel) } })));
          }, E = () => {
            const ie = c == null ? void 0 : c.getElementsByClassName("collapsible");
            for (const ne of Array.prototype.slice.call(ie)) {
              const se = ne.parentNode;
              se.classList.remove("collapsed"), se.querySelector(".collapser").setAttribute("aria-label", "collapse");
            }
          }, P = () => {
            const ie = c == null ? void 0 : c.getElementsByClassName("collapsible"), ne = Array.prototype.slice.call(ie, 1);
            for (const se of ne) {
              const me = se.parentNode;
              me.classList.add("collapsed"), me.querySelector(".collapser").setAttribute("aria-label", "expand");
            }
          }, $ = (ie) => {
            let ne;
            ie.className === "collapser" && (ne = ie.parentElement.getElementsByClassName("collapsible")[0], ne.parentElement.classList.contains("collapsed") ? (ne.parentElement.classList.remove("collapsed"), ie.setAttribute("aria-label", "collapse")) : (ne.parentElement.classList.add("collapsed"), ie.setAttribute("aria-label", "expand")));
          }, V = o.useCallback((ie) => {
            $(ie.target);
          }, []), ee = o.useCallback((ie) => {
            ie.key === "Enter" && $(ie.target);
          }, []);
          return o.useEffect(() => (c == null || c.addEventListener("click", V), c == null || c.addEventListener("focus", ee), () => {
            c == null || c.removeEventListener("click", V), c == null || c.removeEventListener("focus", ee);
          }), [V, ee, c]), o.createElement(px, { data: u.data }, b);
        })`
  ${d2};
`, hx = (u) => {
          const { source: c, lang: h } = u;
          return o.createElement(X1, { dangerouslySetInnerHTML: { __html: uu(c, h) } });
        }, Wg = (u) => {
          const { source: c, lang: h } = u;
          return o.createElement(px, { data: c }, ({ renderCopyButton: b }) => o.createElement(FM, null, o.createElement(Hp, null, b()), o.createElement(hx, { lang: h, source: c })));
        };
        function mx({ value: u, mimeType: c }) {
          return Ii(c) ? o.createElement(dx, { data: u }) : (typeof u == "object" && (u = JSON.stringify(u, null, 2)), o.createElement(Wg, { lang: ds(c), source: u }));
        }
        var m2 = (u, c, h) => new Promise((b, E) => {
          var P = (ee) => {
            try {
              V(h.next(ee));
            } catch (ie) {
              E(ie);
            }
          }, $ = (ee) => {
            try {
              V(h.throw(ee));
            } catch (ie) {
              E(ie);
            }
          }, V = (ee) => ee.done ? b(ee.value) : Promise.resolve(ee.value).then(P, $);
          V((h = h.apply(u, c)).next());
        });
        function Hg({ example: u, mimeType: c }) {
          return u.value === void 0 && u.externalValueUrl ? o.createElement(gx, { example: u, mimeType: c }) : o.createElement(mx, { value: u.value, mimeType: c });
        }
        function gx({ example: u, mimeType: c }) {
          const h = function(b, E) {
            const [, P] = (0, o.useState)(!0), $ = (0, o.useRef)(void 0), V = (0, o.useRef)(void 0);
            return V.current !== b && ($.current = void 0), V.current = b, (0, o.useEffect)(() => {
              m2(this, null, function* () {
                P(!0);
                try {
                  $.current = yield b.getExternalValue(E);
                } catch (ee) {
                  $.current = ee;
                }
                P(!1);
              });
            }, [b, E]), $.current;
          }(u, c);
          return h === void 0 ? o.createElement("span", null, "Loading...") : h instanceof Error ? o.createElement(X1, null, "Error loading external example: ", o.createElement("br", null), o.createElement("a", { className: "token string", href: u.externalValueUrl, target: "_blank", rel: "noopener noreferrer" }, u.externalValueUrl)) : o.createElement(mx, { value: h, mimeType: c });
        }
        const Qg = M.div`
  padding: 0.9em;
  background-color: ${({ theme: u }) => (0, a.transparentize)(0.6, u.rightPanel.backgroundColor)};
  margin: 0 0 10px 0;
  display: block;
  font-family: ${({ theme: u }) => u.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
`, Kp = M.span`
  font-family: ${({ theme: u }) => u.typography.headings.fontFamily};
  font-size: 12px;
  position: absolute;
  z-index: 1;
  top: -11px;
  left: 12px;
  font-weight: ${({ theme: u }) => u.typography.fontWeightBold};
  color: ${({ theme: u }) => (0, a.transparentize)(0.3, u.rightPanel.textColor)};
`, Xp = M.div`
  position: relative;
`, Jp = M(Qp)`
  label {
    color: ${({ theme: u }) => u.rightPanel.textColor};
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    font-size: 1em;
    text-transform: none;
    border: none;
  }
  margin: 0 0 10px 0;
  display: block;
  background-color: ${({ theme: u }) => (0, a.transparentize)(0.6, u.rightPanel.backgroundColor)};
  border: none;
  padding: 0.9em 1.6em 0.9em 0.9em;
  box-shadow: none;
  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    background-color: ${({ theme: u }) => (0, a.transparentize)(0.3, u.rightPanel.backgroundColor)};
  }
`, yx = M.div`
  font-family: ${(u) => u.theme.typography.code.fontFamily};
  font-size: 12px;
  color: #ee807f;
`;
        class vx extends o.Component {
          constructor() {
            super(...arguments), this.state = { activeIdx: 0 }, this.switchMedia = ({ idx: c }) => {
              c !== void 0 && this.setState({ activeIdx: c });
            };
          }
          render() {
            const { activeIdx: c } = this.state, h = this.props.mediaType.examples || {}, b = this.props.mediaType.name, E = o.createElement(yx, null, "No sample"), P = Object.keys(h);
            if (P.length === 0) return E;
            if (P.length > 1) {
              const $ = P.map((ie, ne) => ({ value: h[ie].summary || ie, idx: ne })), V = h[P[c]], ee = V.description;
              return o.createElement(bx, null, o.createElement(Xp, null, o.createElement(Kp, null, "Example"), this.props.renderDropdown({ value: $[c].value, options: $, onChange: this.switchMedia, ariaLabel: "Example" })), o.createElement("div", null, ee && o.createElement(Mr, { source: ee }), o.createElement(Hg, { example: V, mimeType: b })));
            }
            {
              const $ = h[P[0]];
              return o.createElement(bx, null, $.description && o.createElement(Mr, { source: $.description }), o.createElement(Hg, { example: $, mimeType: b }));
            }
          }
        }
        const bx = M.div`
  margin-top: 15px;
`;
        var vt = lK;
        const g2 = M(G1)`
  &.deprecated {
    span.property-name {
      ${Wp}
    }
  }

  button {
    background-color: transparent;
    border: 0;
    outline: 0;
    font-size: 13px;
    font-family: ${(u) => u.theme.typography.code.fontFamily};
    cursor: pointer;
    padding: 0;
    color: ${(u) => u.theme.colors.text.primary};
    &:focus {
      font-weight: ${({ theme: u }) => u.typography.fontWeightBold};
    }
    ${({ kind: u }) => u === "patternProperties" && ve`
        display: inline-flex;
        margin-right: 20px;

        > span.property-name {
          white-space: break-spaces;
          text-align: left;

          ::before,
          ::after {
            content: '/';
            filter: opacity(0.2);
          }
        }

        > svg {
          align-self: center;
        }
      `}
  }
  ${qi} {
    height: ${({ theme: u }) => u.schema.arrow.size};
    width: ${({ theme: u }) => u.schema.arrow.size};
    polygon {
      fill: ${({ theme: u }) => u.schema.arrow.color};
    }
  }
`, En = M.span`
  vertical-align: middle;
  font-size: ${({ theme: u }) => u.typography.code.fontSize};
  line-height: 20px;
`, wx = M(En)`
  color: ${(u) => (0, a.transparentize)(0.1, u.theme.schema.typeNameColor)};
`, Zp = M(En)`
  color: ${(u) => u.theme.schema.typeNameColor};
`, Sx = M(En)`
  color: ${(u) => u.theme.schema.typeTitleColor};
  word-break: break-word;
`, ef = Zp, Yg = M(En).attrs({ as: "div" })`
  color: ${(u) => u.theme.schema.requireLabelColor};
  font-size: ${(u) => u.theme.schema.labelsTextSize};
  font-weight: normal;
  margin-left: 20px;
  line-height: 1;
`, xx = M(Yg)`
  color: ${(u) => u.theme.colors.primary.light};
`, _x = M(En)`
  color: ${({ theme: u }) => u.colors.warning.main};
  font-size: 13px;
`, y2 = M(En)`
  color: #0e7c86;
  &::before,
  &::after {
    font-weight: bold;
  }
`, xu = M(En)`
  border-radius: 2px;
  word-break: break-word;
  ${({ theme: u }) => `
    background-color: ${(0, a.transparentize)(0.95, u.colors.text.primary)};
    color: ${(0, a.transparentize)(0.1, u.colors.text.primary)};

    padding: 0 ${u.spacing.unit}px;
    border: 1px solid ${(0, a.transparentize)(0.9, u.colors.text.primary)};
    font-family: ${u.typography.code.fontFamily};
}`};
  & + & {
    margin-left: 0;
  }
  ${le("ExampleValue")};
`, v2 = M(xu)``, b2 = M(En)`
  border-radius: 2px;
  ${({ theme: u }) => `
    background-color: ${(0, a.transparentize)(0.95, u.colors.primary.light)};
    color: ${(0, a.transparentize)(0.1, u.colors.primary.main)};

    margin: 0 ${u.spacing.unit}px;
    padding: 0 ${u.spacing.unit}px;
    border: 1px solid ${(0, a.transparentize)(0.9, u.colors.primary.main)};
}`};
  & + & {
    margin-left: 0;
  }
  ${le("ConstraintItem")};
`, w2 = M.button`
  background-color: transparent;
  border: 0;
  color: ${({ theme: u }) => u.colors.text.secondary};
  margin-left: ${({ theme: u }) => u.spacing.unit}px;
  border-radius: 2px;
  cursor: pointer;
  outline-color: ${({ theme: u }) => u.colors.text.secondary};
  font-size: 12px;
`, S2 = M.div`
  ${Yp};
  ${({ $compact: u }) => u ? "" : "margin: 1em 0"}
`;
        let Ps = class extends o.Component {
          render() {
            const { externalDocs: u } = this.props;
            return u && u.url ? o.createElement(S2, { $compact: this.props.compact }, o.createElement("a", { href: u.url }, u.description || u.url)) : null;
          }
        };
        Ps = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Ps);
        class Ex extends o.PureComponent {
          constructor() {
            super(...arguments), this.state = { collapsed: !0 };
          }
          toggle() {
            this.setState({ collapsed: !this.state.collapsed });
          }
          render() {
            const { values: c, isArrayType: h } = this.props, { collapsed: b } = this.state, { enumSkipQuotes: E, maxDisplayedEnumValues: P } = this.context;
            if (!c.length) return null;
            const $ = this.state.collapsed && P ? c.slice(0, P) : c, V = !!P && c.length > P, ee = P ? b ? `… ${c.length - P} more` : "Hide" : "";
            return o.createElement("div", null, o.createElement(En, null, h ? z("enumArray") : "", " ", c.length === 1 ? z("enumSingleValue") : z("enum"), ":"), " ", $.map((ie, ne) => {
              const se = E ? String(ie) : JSON.stringify(ie);
              return o.createElement(o.Fragment, { key: ne }, o.createElement(xu, null, se), " ");
            }), V ? o.createElement(x2, { onClick: () => {
              this.toggle();
            } }, ee) : null);
          }
        }
        Ex.contextType = Ge;
        const x2 = M.span`
  color: ${(u) => u.theme.colors.primary.main};
  vertical-align: middle;
  font-size: 13px;
  line-height: 20px;
  padding: 0 5px;
  cursor: pointer;
`, _2 = M(Ra)`
  margin: 2px 0;
`;
        class tf extends o.PureComponent {
          render() {
            const c = this.props.extensions;
            return o.createElement(Ge.Consumer, null, (h) => o.createElement(o.Fragment, null, h.showExtensions && Object.keys(c).map((b) => o.createElement(_2, { key: b }, o.createElement(En, null, " ", b.substring(2), ": "), " ", o.createElement(v2, null, typeof c[b] == "string" ? c[b] : JSON.stringify(c[b]))))));
          }
        }
        function E2({ field: u }) {
          return u.examples ? o.createElement(o.Fragment, null, o.createElement(En, null, " ", z("examples"), ": "), G(u.examples) ? u.examples.map((c, h) => {
            const b = xn(u, c), E = u.in ? String(b) : JSON.stringify(b);
            return o.createElement(o.Fragment, { key: h }, o.createElement(xu, null, E), " ");
          }) : o.createElement(O2, null, Object.values(u.examples).map((c, h) => o.createElement("li", { key: h + c.value }, o.createElement(xu, null, xn(u, c.value)), " -", " ", c.summary || c.description)))) : null;
        }
        const O2 = M.ul`
  margin-top: 1em;
  list-style-position: outside;
`;
        class _u extends o.PureComponent {
          render() {
            return this.props.constraints.length === 0 ? null : o.createElement("span", null, " ", this.props.constraints.map((c) => o.createElement(b2, { key: c }, " ", c, " ")));
          }
        }
        const Gg = o.memo(function({ value: u, label: c, raw: h }) {
          if (u === void 0) return null;
          const b = h ? String(u) : JSON.stringify(u);
          return o.createElement("div", null, o.createElement(En, null, " ", c, " "), " ", o.createElement(xu, null, b));
        }), Kg = 45;
        function Xg(u) {
          const c = u.schema.pattern, { hideSchemaPattern: h } = o.useContext(Ge), [b, E] = o.useState(!1), P = o.useCallback(() => E(!b), [b]);
          return !c || h ? null : o.createElement(o.Fragment, null, o.createElement(y2, null, b || c.length < Kg ? c : `${c.substr(0, Kg)}...`), c.length > Kg && o.createElement(w2, { onClick: P }, b ? "Hide pattern" : "Show pattern"));
        }
        function Ox({ schema: u }) {
          var c;
          const { hideSchemaPattern: h } = o.useContext(Ge);
          return u && (u != null && u.pattern && !h || u.items || u.displayFormat || (c = u.constraints) != null && c.length) ? u.type === "string" && u.pattern ? o.createElement(kx, null, "[", o.createElement(Xg, { schema: u }), "]") : o.createElement(kx, null, "[ items", u.displayFormat && o.createElement(ef, null, " <", u.displayFormat, " >"), o.createElement(_u, { constraints: u.constraints }), o.createElement(Xg, { schema: u }), u.items && o.createElement(Ox, { schema: u.items }), " ]") : null;
        }
        const kx = M(wx)`
  margin: 0 5px;
  vertical-align: text-top;
`;
        var k2 = Object.defineProperty, Ax = Object.getOwnPropertySymbols, A2 = Object.prototype.hasOwnProperty, P2 = Object.prototype.propertyIsEnumerable, Px = (u, c, h) => c in u ? k2(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, Cx = (u, c) => {
          for (var h in c || (c = {})) A2.call(c, h) && Px(u, h, c[h]);
          if (Ax) for (var h of Ax(c)) P2.call(c, h) && Px(u, h, c[h]);
          return u;
        };
        const C2 = (0, vt.observer)((u) => {
          const { enumSkipQuotes: c, hideSchemaTitles: h } = o.useContext(Ge), { showExamples: b, field: E, renderDiscriminatorSwitch: P } = u, { schema: $, description: V, deprecated: ee, extensions: ie, in: ne, const: se } = E, me = $.type === "array", Ie = c || ne === "header", ze = o.useMemo(() => !b || E.example === void 0 && E.examples === void 0 ? null : E.examples !== void 0 ? o.createElement(E2, { field: E }) : o.createElement(Gg, { label: z("example") + ":", value: xn(E, E.example), raw: !!E.in }), [E, b]), yt = R($.default) && E.in ? xn(E, $.default).replace(`${E.name}=`, "") : $.default;
          return o.createElement("div", null, o.createElement("div", null, o.createElement(wx, null, $.typePrefix), o.createElement(Zp, null, $.displayType), $.displayFormat && o.createElement(ef, null, " ", "<", $.displayFormat, ">", " "), $.contentEncoding && o.createElement(ef, null, " ", "<", $.contentEncoding, ">", " "), $.contentMediaType && o.createElement(ef, null, " ", "<", $.contentMediaType, ">", " "), $.title && !h && o.createElement(Sx, null, " (", $.title, ") "), o.createElement(_u, { constraints: $.constraints }), o.createElement(Xg, { schema: $ }), $.isCircular && o.createElement(_x, null, " ", z("recursive"), " "), me && $.items && o.createElement(Ox, { schema: $.items })), ee && o.createElement("div", null, o.createElement(Su, { type: "warning" }, " ", z("deprecated"), " ")), o.createElement(Gg, { raw: Ie, label: z("default") + ":", value: yt }), !P && o.createElement(Ex, { isArrayType: me, values: $.enum }), " ", ze, o.createElement(tf, { extensions: Cx(Cx({}, ie), $.extensions) }), o.createElement("div", null, o.createElement(Mr, { compact: !0, source: V })), $.externalDocs && o.createElement(Ps, { externalDocs: $.externalDocs, compact: !0 }), P && P(u) || null, se && o.createElement(Gg, { label: z("const") + ":", value: se }) || null);
        }), Tx = o.memo(C2);
        var T2 = Object.defineProperty, $x = Object.getOwnPropertySymbols, $2 = Object.prototype.hasOwnProperty, R2 = Object.prototype.propertyIsEnumerable, Rx = (u, c, h) => c in u ? T2(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        let Eu = class extends o.Component {
          constructor() {
            super(...arguments), this.toggle = () => {
              this.props.field.expanded === void 0 && this.props.expandByDefault ? this.props.field.collapse() : this.props.field.toggle();
            }, this.handleKeyPress = (u) => {
              u.key === "Enter" && (u.preventDefault(), this.toggle());
            };
          }
          render() {
            const { className: u = "", field: c, isLast: h, expandByDefault: b } = this.props, { name: E, deprecated: P, required: $, kind: V } = c, ee = !c.schema.isPrimitive && !c.schema.isCircular, ie = c.expanded === void 0 ? b : c.expanded, ne = o.createElement(o.Fragment, null, V === "additionalProperties" && o.createElement(xx, null, "additional property"), V === "patternProperties" && o.createElement(xx, null, "pattern property"), $ && o.createElement(Yg, null, "required")), se = ee ? o.createElement(g2, { className: P ? "deprecated" : "", kind: V, title: E }, o.createElement(K1, null), o.createElement("button", { onClick: this.toggle, onKeyPress: this.handleKeyPress, "aria-label": `expand ${E}` }, o.createElement("span", { className: "property-name" }, E), o.createElement(qi, { direction: ie ? "down" : "right" })), ne) : o.createElement(G1, { className: P ? "deprecated" : void 0, kind: V, title: E }, o.createElement(K1, null), o.createElement("span", { className: "property-name" }, E), ne);
            return o.createElement(o.Fragment, null, o.createElement("tr", { className: h ? "last " + u : u }, se, o.createElement(IM, null, o.createElement(Tx, ((me, Ie) => {
              for (var ze in Ie || (Ie = {})) $2.call(Ie, ze) && Rx(me, ze, Ie[ze]);
              if ($x) for (var ze of $x(Ie)) R2.call(Ie, ze) && Rx(me, ze, Ie[ze]);
              return me;
            })({}, this.props)))), ie && ee && o.createElement("tr", { key: c.name + "inner" }, o.createElement(RM, { colSpan: 2 }, o.createElement(Wt, null, o.createElement(Wi, { schema: c.schema, skipReadOnly: this.props.skipReadOnly, skipWriteOnly: this.props.skipWriteOnly, showTitle: this.props.showTitle, level: this.props.level })))));
          }
        };
        Eu = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Eu);
        let rf = class extends o.Component {
          constructor() {
            super(...arguments), this.changeActiveChild = (u) => {
              u.idx !== void 0 && this.props.parent.activateOneOf(u.idx);
            };
          }
          sortOptions(u, c) {
            if (c.length === 0) return;
            const h = {};
            c.forEach((b, E) => {
              h[b] = E;
            }), u.sort((b, E) => h[b.value] > h[E.value] ? 1 : -1);
          }
          render() {
            const { parent: u, enumValues: c } = this.props;
            if (u.oneOf === void 0) return null;
            const h = u.oneOf.map((E, P) => ({ value: E.title, idx: P })), b = h[u.activeOneOf].value;
            return this.sortOptions(h, c), o.createElement(Qp, { value: b, options: h, onChange: this.changeActiveChild, ariaLabel: "Example" });
          }
        };
        rf = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], rf);
        const nf = (0, vt.observer)(({ schema: { fields: u = [], title: c }, showTitle: h, discriminator: b, skipReadOnly: E, skipWriteOnly: P, level: $ }) => {
          const { expandSingleSchemaField: V, showObjectSchemaExamples: ee, schemaExpansionLevel: ie } = o.useContext(Ge), ne = o.useMemo(() => E || P ? u.filter((me) => !(E && me.schema.readOnly || P && me.schema.writeOnly)) : u, [E, P, u]), se = V && ne.length === 1 || ie >= $;
          return o.createElement(zg, null, h && o.createElement($M, null, c), o.createElement("tbody", null, _(ne, (me, Ie) => o.createElement(Eu, { key: me.name, isLast: Ie, field: me, expandByDefault: se, renderDiscriminatorSwitch: (b == null ? void 0 : b.fieldName) === me.name ? () => o.createElement(rf, { parent: b.parentSchema, enumValues: me.schema.enum }) : void 0, className: me.expanded ? "expanded" : void 0, showExamples: ee, skipReadOnly: E, skipWriteOnly: P, showTitle: h, level: $ }))));
        });
        var I2 = Object.defineProperty, j2 = Object.defineProperties, N2 = Object.getOwnPropertyDescriptors, Ix = Object.getOwnPropertySymbols, L2 = Object.prototype.hasOwnProperty, M2 = Object.prototype.propertyIsEnumerable, jx = (u, c, h) => c in u ? I2(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, Nx = (u, c) => {
          for (var h in c || (c = {})) L2.call(c, h) && jx(u, h, c[h]);
          if (Ix) for (var h of Ix(c)) M2.call(c, h) && jx(u, h, c[h]);
          return u;
        }, Lx = (u, c) => j2(u, N2(c));
        const D2 = M.div`
  padding-left: ${({ theme: u }) => 2 * u.spacing.unit}px;
`;
        class Mx extends o.PureComponent {
          render() {
            const c = this.props.schema, h = c.items, b = c.minItems === void 0 && c.maxItems === void 0 ? "" : `(${Li(c)})`;
            return c.fields ? o.createElement(nf, Lx(Nx({}, this.props), { level: this.props.level })) : !c.displayType || h || b.length ? o.createElement("div", null, o.createElement(MM, null, " Array ", b), o.createElement(D2, null, o.createElement(Wi, Lx(Nx({}, this.props), { schema: h }))), o.createElement(DM, null)) : o.createElement("div", null, o.createElement(Zp, null, c.displayType));
          }
        }
        var F2 = Object.defineProperty, z2 = Object.defineProperties, q2 = Object.getOwnPropertyDescriptors, Dx = Object.getOwnPropertySymbols, B2 = Object.prototype.hasOwnProperty, U2 = Object.prototype.propertyIsEnumerable, Fx = (u, c, h) => c in u ? F2(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, zx = (u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        };
        let of = class extends o.Component {
          constructor() {
            super(...arguments), this.activateOneOf = () => {
              this.props.schema.activateOneOf(this.props.idx);
            };
          }
          render() {
            const { idx: u, schema: c, subSchema: h } = this.props;
            return o.createElement(LM, { $deprecated: h.deprecated, $active: u === c.activeOneOf, onClick: this.activateOneOf }, h.title || h.typePrefix + h.displayType);
          }
        };
        of = zx([vt.observer], of);
        let sf = class extends o.Component {
          render() {
            const { schema: { oneOf: u }, schema: c } = this.props;
            if (u === void 0) return null;
            const h = u[c.activeOneOf];
            return o.createElement("div", null, o.createElement(NM, null, " ", c.oneOfType, " "), o.createElement(jM, null, u.map((E, P) => o.createElement(of, { key: E.pointer, schema: c, subSchema: E, idx: P }))), o.createElement("div", null, u[c.activeOneOf].deprecated && o.createElement(Su, { type: "warning" }, "Deprecated")), o.createElement(_u, { constraints: h.constraints }), o.createElement(Wi, (b = ((E, P) => {
              for (var $ in P || (P = {})) B2.call(P, $) && Fx(E, $, P[$]);
              if (Dx) for (var $ of Dx(P)) U2.call(P, $) && Fx(E, $, P[$]);
              return E;
            })({}, this.props), z2(b, q2({ schema: h })))));
            var b;
          }
        };
        sf = zx([vt.observer], sf);
        const qx = (0, vt.observer)(({ schema: u }) => o.createElement("div", null, o.createElement(Zp, null, u.displayType), u.title && o.createElement(Sx, null, " ", u.title, " "), o.createElement(_x, null, " ", z("recursive"), " ")));
        var V2 = Object.defineProperty, W2 = Object.defineProperties, H2 = Object.getOwnPropertyDescriptors, af = Object.getOwnPropertySymbols, Bx = Object.prototype.hasOwnProperty, Ux = Object.prototype.propertyIsEnumerable, Vx = (u, c, h) => c in u ? V2(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, lf = (u, c) => {
          for (var h in c || (c = {})) Bx.call(c, h) && Vx(u, h, c[h]);
          if (af) for (var h of af(c)) Ux.call(c, h) && Vx(u, h, c[h]);
          return u;
        }, Jg = (u, c) => W2(u, H2(c));
        let Wi = class extends o.Component {
          render() {
            var u;
            const c = this.props, { schema: h } = c, b = ((se, me) => {
              var Ie = {};
              for (var ze in se) Bx.call(se, ze) && me.indexOf(ze) < 0 && (Ie[ze] = se[ze]);
              if (se != null && af) for (var ze of af(se)) me.indexOf(ze) < 0 && Ux.call(se, ze) && (Ie[ze] = se[ze]);
              return Ie;
            })(c, ["schema"]), E = (b.level || 0) + 1;
            if (!h) return o.createElement("em", null, " Schema not provided ");
            const { type: P, oneOf: $, discriminatorProp: V, isCircular: ee } = h;
            if (ee) return o.createElement(qx, { schema: h });
            if (V !== void 0) {
              if (!$ || !$.length) return console.warn(`Looks like you are using discriminator wrong: you don't have any definition inherited from the ${h.title}`), null;
              const se = $[h.activeOneOf];
              return se.isCircular ? o.createElement(qx, { schema: se }) : o.createElement(nf, Jg(lf({}, b), { level: E, schema: se, discriminator: { fieldName: V, parentSchema: h } }));
            }
            if ($ !== void 0) return o.createElement(sf, lf({ schema: h }, b));
            const ie = G(P) ? P : [P];
            if (ie.includes("object")) {
              if ((u = h.fields) != null && u.length) return o.createElement(nf, Jg(lf({}, this.props), { level: E }));
            } else if (ie.includes("array")) return o.createElement(Mx, Jg(lf({}, this.props), { level: E }));
            const ne = { schema: h, name: "", required: !1, description: h.description, externalDocs: h.externalDocs, deprecated: !1, toggle: () => null, expanded: !1 };
            return o.createElement("div", null, o.createElement(Tx, { field: ne }));
          }
        };
        Wi = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Wi);
        var Q2 = Object.defineProperty, Y2 = Object.defineProperties, G2 = Object.getOwnPropertyDescriptors, Wx = Object.getOwnPropertySymbols, K2 = Object.prototype.hasOwnProperty, X2 = Object.prototype.propertyIsEnumerable, Hx = (u, c, h) => c in u ? Q2(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        class uf extends o.PureComponent {
          constructor() {
            super(...arguments), this.renderDropdown = (c) => {
              return o.createElement($a, (h = ((b, E) => {
                for (var P in E || (E = {})) K2.call(E, P) && Hx(b, P, E[P]);
                if (Wx) for (var P of Wx(E)) X2.call(E, P) && Hx(b, P, E[P]);
                return b;
              })({ Label: nx, Dropdown: Jp }, c), Y2(h, G2({ variant: "dark" }))));
              var h;
            };
          }
          static getMediaType(c, h) {
            if (!c) return {};
            const b = { schema: { $ref: c } };
            return h && (b.examples = { example: { $ref: h } }), b;
          }
          get mediaModel() {
            const { parser: c, schemaRef: h, exampleRef: b, options: E } = this.props;
            return this._mediaModel || (this._mediaModel = new Ig(c, "json", !1, uf.getMediaType(h, b), E)), this._mediaModel;
          }
          render() {
            const { showReadOnly: c = !0, showWriteOnly: h = !1, showExample: b = !0 } = this.props;
            return o.createElement(vu, null, o.createElement(Es, null, o.createElement(Eo, null, o.createElement(Wi, { skipWriteOnly: !h, skipReadOnly: !c, schema: this.mediaModel.schema })), b && o.createElement(B1, null, o.createElement(J2, null, o.createElement(vx, { renderDropdown: this.renderDropdown, mediaType: this.mediaModel })))));
          }
        }
        const J2 = M.div`
  background: ${({ theme: u }) => u.codeBlock.backgroundColor};
  & > div,
  & > pre {
    padding: ${(u) => 4 * u.theme.spacing.unit}px;
    margin: 0;
  }

  & > div > pre {
    padding: 0;
  }
`, Z2 = (U().div`
  background-color: #e4e7eb;
`, U().ul`
  display: inline;
  list-style: none;
  padding: 0;

  li {
    display: inherit;

    &:after {
      content: ',';
    }
    &:last-child:after {
      content: none;
    }
  }
`, U().code`
  font-size: ${(u) => u.theme.typography.code.fontSize};
  font-family: ${(u) => u.theme.typography.code.fontFamily};
  margin: 0 3px;
  padding: 0.2em;
  display: inline-block;
  line-height: 1;

  &:after {
    content: ',';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }
`), eD = U().span`
  &:after {
    content: ' and ';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }

  ${Yp};
`, Qx = U().span`
  ${(u) => !u.$expanded && "white-space: nowrap;"}
  &:after {
    content: ' or ';
    ${(u) => u.$expanded && "content: ' or \\a';"}
    white-space: pre;
  }

  &:last-child:after,
  &:only-child:after {
    content: none;
  }

  ${Yp};
`, tD = U().div`
  flex: 1 1 auto;
  cursor: pointer;
`, rD = U().div`
  width: ${(u) => u.theme.schema.defaultDetailsWidth};
  text-overflow: ellipsis;
  border-radius: 4px;
  overflow: hidden;
  ${(u) => u.$expanded && `background: ${u.theme.colors.gray[100]};
     padding: 8px 9.6px;
     margin: 20px 0;
     width: 100%;
    `};
  ${O.lessThan("small")`
    margin-top: 10px;
  `}
`, nD = U()(wu)`
  display: inline-block;
  margin: 0;
`, iD = U().div`
  width: 100%;
  display: flex;
  margin: 1em 0;
  flex-direction: ${(u) => u.$expanded ? "column" : "row"};
  ${O.lessThan("small")`
    flex-direction: column;
  `}
`, mi = U().div`
  margin: 0.5em 0;
`, Yx = U().div`
  border-bottom: 1px solid ${({ theme: u }) => u.colors.border.dark};
  margin-bottom: 1.5em;
  padding-bottom: 0.7em;

  h5 {
    line-height: 1em;
    margin: 0 0 0.6em;
    font-size: ${({ theme: u }) => u.typography.fontSize};
  }

  .redoc-markdown p:first-child {
    display: inline;
  }
`;
        function oD({ children: u, height: c }) {
          const h = o.createRef(), [b, E] = o.useState(!1), [P, $] = o.useState(!1);
          return o.useEffect(() => {
            h.current && h.current.clientHeight + 20 < h.current.scrollHeight && $(!0);
          }, [h]), o.createElement(o.Fragment, null, o.createElement(sD, { ref: h, className: b ? "" : "container", style: { height: b ? "auto" : c } }, u), o.createElement(aD, { $dimmed: !b }, P && o.createElement(lD, { onClick: () => {
            E(!b);
          } }, b ? "See less" : "See more")));
        }
        const sD = U().div`
  overflow-y: hidden;
`, aD = U().div`
  text-align: center;
  line-height: 1.5em;
  ${({ $dimmed: u }) => u && `background-image: linear-gradient(to bottom, transparent,rgb(255 255 255));
     position: relative;
     top: -0.5em;
     padding-top: 0.5em;
     background-position-y: -1em;
    `}
`, lD = U().a`
  cursor: pointer;
`, uD = o.memo(function(u) {
          const { type: c, flow: h, RequiredScopes: b } = u, E = Object.keys((h == null ? void 0 : h.scopes) || {});
          return o.createElement(o.Fragment, null, o.createElement(mi, null, o.createElement("b", null, "Flow type: "), o.createElement("code", null, c, " ")), (c === "implicit" || c === "authorizationCode") && o.createElement(mi, null, o.createElement("strong", null, " Authorization URL: "), o.createElement("code", null, o.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: h.authorizationUrl }, h.authorizationUrl))), (c === "password" || c === "clientCredentials" || c === "authorizationCode") && o.createElement(mi, null, o.createElement("b", null, " Token URL: "), o.createElement("code", null, h.tokenUrl)), h.refreshUrl && o.createElement(mi, null, o.createElement("strong", null, " Refresh URL: "), o.createElement("code", null, h.refreshUrl)), !!E.length && o.createElement(o.Fragment, null, b || null, o.createElement(mi, null, o.createElement("b", null, " Scopes: ")), o.createElement(oD, { height: "4em" }, o.createElement("ul", null, E.map((P) => o.createElement("li", { key: P }, o.createElement("code", null, P), " -", " ", o.createElement(Mr, { className: "redoc-markdown", inline: !0, source: h.scopes[P] || "" })))))));
        });
        function Gx(u) {
          const { RequiredScopes: c, scheme: h } = u;
          return o.createElement(Ra, null, h.apiKey ? o.createElement(o.Fragment, null, o.createElement(mi, null, o.createElement("b", null, re(h.apiKey.in || ""), " parameter name: "), o.createElement("code", null, h.apiKey.name)), c) : h.http ? o.createElement(o.Fragment, null, o.createElement(mi, null, o.createElement("b", null, "HTTP Authorization Scheme: "), o.createElement("code", null, h.http.scheme)), o.createElement(mi, null, h.http.scheme === "bearer" && h.http.bearerFormat && o.createElement(o.Fragment, null, o.createElement("b", null, "Bearer format: "), o.createElement("code", null, h.http.bearerFormat))), c) : h.openId ? o.createElement(o.Fragment, null, o.createElement(mi, null, o.createElement("b", null, "Connect URL: "), o.createElement("code", null, o.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: h.openId.connectUrl }, h.openId.connectUrl))), c) : h.flows ? Object.keys(h.flows).map((b) => o.createElement(uD, { key: b, type: b, RequiredScopes: c, flow: h.flows[b] })) : null);
        }
        const cf = { oauth2: "OAuth2", apiKey: "API Key", http: "HTTP", openIdConnect: "OpenID Connect" };
        class Zg extends o.PureComponent {
          render() {
            return this.props.securitySchemes.schemes.map((c) => o.createElement(vu, { id: c.sectionId, key: c.id }, o.createElement(Es, null, o.createElement(Eo, null, o.createElement(Mg, null, o.createElement(Fg, { to: c.sectionId }), c.displayName), o.createElement(Mr, { source: c.description || "" }), o.createElement(Yx, null, o.createElement(mi, null, o.createElement("b", null, "Security Scheme Type: "), o.createElement("span", null, cf[c.type] || c.type)), o.createElement(Gx, { scheme: c }))))));
          }
        }
        var Kx = (u, c, h) => new Promise((b, E) => {
          var P = (ee) => {
            try {
              V(h.next(ee));
            } catch (ie) {
              E(ie);
            }
          }, $ = (ee) => {
            try {
              V(h.throw(ee));
            } catch (ie) {
              E(ie);
            }
          }, V = (ee) => ee.done ? b(ee.value) : Promise.resolve(ee.value).then(P, $);
          V((h = h.apply(u, c)).next());
        });
        function cD(u, c) {
          return Kx(this, arguments, function* (h, b, E = {}) {
            const P = yield $e(h || b);
            return new Ia(P, b, E);
          });
        }
        class Ia {
          constructor(c, h, b = {}, E = !0) {
            this.marker = new de(), this.disposer = null, this.rawOptions = b, this.options = new X(b, pD), this.scroll = new Lg(this.options), zi.updateOnHistory(Ea.currentId, this.scroll), this.spec = new N1(c, h, this.options), this.menu = new zi(this.spec, this.scroll, Ea), this.options.disableSearch || (this.search = new z1(), E && this.search.indexItems(this.menu.items), this.disposer = (0, D.observe)(this.menu, "activeItemIdx", (P) => {
              this.updateMarkOnMenu(P.newValue);
            }));
          }
          static fromJS(c) {
            const h = new Ia(c.spec.data, c.spec.url, c.options, !1);
            return h.menu.activeItemIdx = c.menu.activeItemIdx || 0, h.menu.activate(h.menu.flatItems[h.menu.activeItemIdx]), h.options.disableSearch || h.search.load(c.searchIndex), h;
          }
          onDidMount() {
            this.menu.updateOnHistory(), this.updateMarkOnMenu(this.menu.activeItemIdx);
          }
          dispose() {
            this.scroll.dispose(), this.menu.dispose(), this.search && this.search.dispose(), this.disposer != null && this.disposer();
          }
          toJS() {
            return Kx(this, null, function* () {
              return { menu: { activeItemIdx: this.menu.activeItemIdx }, spec: { url: this.spec.parser.specUrl, data: this.spec.parser.spec }, searchIndex: this.search ? yield this.search.toJS() : void 0, options: this.rawOptions };
            });
          }
          updateMarkOnMenu(c) {
            const h = Math.max(0, c), b = Math.min(this.menu.flatItems.length, h + 5), E = [];
            for (let P = h; P < b; P++) {
              const $ = this.menu.getElementAt(P);
              $ && E.push($);
            }
            if (c === -1 && f) {
              const P = document.querySelector('[data-role="redoc-description"]'), $ = document.querySelector('[data-role="redoc-summary"]');
              P && E.push(P), $ && E.push($);
            }
            this.marker.addOnly(E), this.marker.mark();
          }
        }
        const pD = { allowedMdComponents: { [lu]: { component: Zg, propsSelector: (u) => ({ securitySchemes: u.spec.securitySchemes }) }, [gs]: { component: Zg, propsSelector: (u) => ({ securitySchemes: u.spec.securitySchemes }) }, [ys]: { component: uf, propsSelector: (u) => ({ parser: u.spec.parser, options: u.options }) } } }, fD = M(kM)`
  margin-top: 0;
  margin-bottom: 0.5em;

  ${le("ApiHeader")};
`, dD = M.a`
  border: 1px solid ${(u) => u.theme.colors.primary.main};
  color: ${(u) => u.theme.colors.primary.main};
  font-weight: normal;
  margin-left: 0.5em;
  padding: 4px 8px 4px;
  display: inline-block;
  text-decoration: none;
  cursor: pointer;

  ${le("DownloadButton")};
`, pf = M.span`
  &::before {
    content: '|';
    display: inline-block;
    opacity: 0.5;
    width: ${15}px;
    text-align: center;
  }

  &:last-child::after {
    display: none;
  }
`, hD = M.div`
  overflow: hidden;
`, mD = M.div`
  display: flex;
  flex-wrap: wrap;
  // hide separator on new lines: idea from https://stackoverflow.com/a/31732902/1749888
  margin-left: -${15}px;
`;
        let ff = class extends o.Component {
          constructor() {
            super(...arguments), this.handleDownloadClick = (u) => {
              u.target.href || (u.target.href = this.props.store.spec.info.downloadLink);
            };
          }
          render() {
            const { store: u } = this.props, { info: c, externalDocs: h } = u.spec, b = u.options.hideDownloadButton, E = c.downloadFileName, P = c.downloadLink, $ = c.license && o.createElement(pf, null, "License:", " ", c.license.identifier ? c.license.identifier : o.createElement("a", { href: c.license.url }, c.license.name)) || null, V = c.contact && c.contact.url && o.createElement(pf, null, "URL: ", o.createElement("a", { href: c.contact.url }, c.contact.url)) || null, ee = c.contact && c.contact.email && o.createElement(pf, null, c.contact.name || "E-mail", ":", " ", o.createElement("a", { href: "mailto:" + c.contact.email }, c.contact.email)) || null, ie = c.termsOfService && o.createElement(pf, null, o.createElement("a", { href: c.termsOfService }, "Terms of Service")) || null, ne = c.version && o.createElement("span", null, "(", c.version, ")") || null;
            return o.createElement(vu, null, o.createElement(Es, null, o.createElement(Eo, { className: "api-info" }, o.createElement(fD, null, c.title, " ", ne), !b && o.createElement("p", null, z("downloadSpecification"), ":", o.createElement(dD, { download: E || !0, target: "_blank", href: P, onClick: this.handleDownloadClick }, z("download"))), o.createElement(Ra, null, (c.license || c.contact || c.termsOfService) && o.createElement(hD, null, o.createElement(mD, null, ee, " ", V, " ", $, " ", ie)) || null), o.createElement(Mr, { source: u.spec.info.summary, "data-role": "redoc-summary" }), o.createElement(Mr, { source: u.spec.info.description, "data-role": "redoc-description" }), h && o.createElement(Ps, { externalDocs: h }))));
          }
        };
        ff = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], ff);
        const gD = M.img`
  max-height: ${(u) => u.theme.logo.maxHeight};
  max-width: ${(u) => u.theme.logo.maxWidth};
  padding: ${(u) => u.theme.logo.gutter};
  width: 100%;
  display: block;
`, yD = M.div`
  text-align: center;
`, vD = M.a`
  display: inline-block;
`;
        let df = class extends o.Component {
          render() {
            const { info: u } = this.props, c = u["x-logo"];
            if (!c || !c.url) return null;
            const h = c.href || u.contact && u.contact.url, b = c.altText ? c.altText : "logo", E = o.createElement(gD, { src: c.url, alt: b });
            return o.createElement(yD, { style: { backgroundColor: c.backgroundColor } }, h ? (P = h, ($) => o.createElement(vD, { href: P }, $))(E) : E);
            var P;
          }
        };
        df = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], df);
        var bD = Object.defineProperty, Xx = Object.getOwnPropertySymbols, wD = Object.prototype.hasOwnProperty, SD = Object.prototype.propertyIsEnumerable, Jx = (u, c, h) => c in u ? bD(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, ey = (u, c) => {
          for (var h in c || (c = {})) wD.call(c, h) && Jx(u, h, c[h]);
          if (Xx) for (var h of Xx(c)) SD.call(c, h) && Jx(u, h, c[h]);
          return u;
        };
        class xD extends o.Component {
          render() {
            return o.createElement(Et, null, (c) => o.createElement(V1, null, (h) => this.renderWithOptionsAndStore(c, h)));
          }
          renderWithOptionsAndStore(c, h) {
            const { source: b, htmlWrap: E = ($) => $ } = this.props;
            if (!h) throw new Error("When using components in markdown, store prop must be provided");
            const P = new Oa(c, this.props.parentId).renderMdWithComponents(b);
            return P.length ? P.map(($, V) => {
              if (typeof $ == "string") return o.cloneElement(E(o.createElement(cx, { html: $, inline: !1, compact: !1 })), { key: V });
              const ee = $.component;
              return o.createElement(ee, ey({ key: V }, ey(ey({}, $.props), $.propsSelector(h))));
            }) : null;
          }
        }
        var _D = uK();
        const Ou = M.span.attrs((u) => ({ className: `operation-type ${u.type}` }))`
  width: 9ex;
  display: inline-block;
  height: ${(u) => u.theme.typography.code.fontSize};
  line-height: ${(u) => u.theme.typography.code.fontSize};
  background-color: #333;
  border-radius: 3px;
  background-repeat: no-repeat;
  background-position: 6px 4px;
  font-size: 7px;
  font-family: Verdana, sans-serif; // web-safe
  color: white;
  text-transform: uppercase;
  text-align: center;
  font-weight: bold;
  vertical-align: middle;
  margin-right: 6px;
  margin-top: 2px;

  &.get {
    background-color: ${({ theme: u }) => u.colors.http.get};
  }

  &.post {
    background-color: ${({ theme: u }) => u.colors.http.post};
  }

  &.put {
    background-color: ${({ theme: u }) => u.colors.http.put};
  }

  &.options {
    background-color: ${({ theme: u }) => u.colors.http.options};
  }

  &.patch {
    background-color: ${({ theme: u }) => u.colors.http.patch};
  }

  &.delete {
    background-color: ${({ theme: u }) => u.colors.http.delete};
  }

  &.basic {
    background-color: ${({ theme: u }) => u.colors.http.basic};
  }

  &.link {
    background-color: ${({ theme: u }) => u.colors.http.link};
  }

  &.head {
    background-color: ${({ theme: u }) => u.colors.http.head};
  }

  &.hook {
    background-color: ${({ theme: u }) => u.colors.primary.main};
  }

  &.schema {
    background-color: ${({ theme: u }) => u.colors.http.basic};
  }
`;
        function hf(u, { theme: c }, h) {
          return u > 1 ? c.sidebar.level1Items[h] : u === 1 ? c.sidebar.groupItems[h] : "";
        }
        const Zx = M.ul`
  margin: 0;
  padding: 0;

  &:first-child {
    padding-bottom: 32px;
  }

  & & {
    font-size: 0.929em;
  }

  ${(u) => u.$expanded ? "" : "display: none;"};
`, e_ = M.li`
  list-style: none inside none;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0;
  ${(u) => u.depth === 0 ? "margin-top: 15px" : ""};
`, t_ = { 0: ve`
    opacity: 0.7;
    text-transform: ${({ theme: u }) => u.sidebar.groupItems.textTransform};
    font-size: 0.8em;
    padding-bottom: 0;
    cursor: default;
  `, 1: ve`
    font-size: 0.929em;
    text-transform: ${({ theme: u }) => u.sidebar.level1Items.textTransform};
  ` }, mf = M.label.attrs((u) => ({ className: _D("-depth" + u.$depth, { active: u.$active }) }))`
  cursor: pointer;
  color: ${(u) => u.$active ? hf(u.$depth, u, "activeTextColor") : u.theme.sidebar.textColor};
  margin: 0;
  padding: 12.5px ${(u) => 4 * u.theme.spacing.unit}px;
  ${({ $depth: u, $type: c, theme: h }) => c === "section" && u > 1 && "padding-left: " + 8 * h.spacing.unit + "px;" || ""}
  display: flex;
  justify-content: space-between;
  font-family: ${(u) => u.theme.typography.headings.fontFamily};
  ${(u) => t_[u.$depth]};
  background-color: ${(u) => u.$active ? hf(u.$depth, u, "activeBackgroundColor") : u.theme.sidebar.backgroundColor};

  ${(u) => u.$deprecated && Wp || ""};

  &:hover {
    color: ${(u) => hf(u.$depth, u, "activeTextColor")};
    background-color: ${(u) => hf(u.$depth, u, "activeBackgroundColor")};
  }

  ${qi} {
    height: ${({ theme: u }) => u.sidebar.arrow.size};
    width: ${({ theme: u }) => u.sidebar.arrow.size};
    polygon {
      fill: ${({ theme: u }) => u.sidebar.arrow.color};
    }
  }
`, ty = M.span`
  display: inline-block;
  vertical-align: middle;
  width: ${(u) => u.width ? u.width : "auto"};
  overflow: hidden;
  text-overflow: ellipsis;
`, r_ = M.div`
  ${({ theme: u }) => ve`
    font-size: 0.8em;
    margin-top: ${2 * u.spacing.unit}px;
    text-align: center;
    position: fixed;
    width: ${u.sidebar.width};
    bottom: 0;
    background: ${u.sidebar.backgroundColor};

    a,
    a:visited,
    a:hover {
      color: ${u.sidebar.textColor} !important;
      padding: ${u.spacing.unit}px 0;
      border-top: 1px solid ${(0, a.darken)(0.1, u.sidebar.backgroundColor)};
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  `};
  img {
    width: 15px;
    margin-right: 5px;
  }

  ${O.lessThan("small")`
    width: 100%;
  `};
`, ED = M.button`
  border: 0;
  width: 100%;
  text-align: left;
  & > * {
    vertical-align: middle;
  }

  ${qi} {
    polygon {
      fill: ${({ theme: u }) => (0, a.darken)(u.colors.tonalOffset, u.colors.gray[100])};
    }
  }
`, OD = M.span`
  text-decoration: ${(u) => u.$deprecated ? "line-through" : "none"};
  margin-right: 8px;
`, kD = M(Ou)`
  margin: 0 5px 0 0;
`, AD = M((u) => {
          const { name: c, opened: h, className: b, onClick: E, httpVerb: P, deprecated: $ } = u;
          return o.createElement(ED, { className: b, onClick: E || void 0 }, o.createElement(kD, { type: P }, vs(P)), o.createElement(qi, { size: "1.5em", direction: h ? "down" : "right", float: "left" }), o.createElement(OD, { $deprecated: $ }, c), $ ? o.createElement(Su, { type: "warning" }, " ", z("deprecated"), " ") : null);
        })`
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  background-color: ${({ theme: u }) => u.colors.gray[100]};
  cursor: pointer;
  outline-color: ${({ theme: u }) => (0, a.darken)(u.colors.tonalOffset, u.colors.gray[100])};
`, PD = M.div`
  padding: 10px 25px;
  background-color: ${({ theme: u }) => u.colors.gray[50]};
  margin-bottom: 5px;
  margin-top: 5px;
`;
        class CD extends o.PureComponent {
          constructor() {
            super(...arguments), this.selectElement = () => {
              Ui.selectElement(this.child);
            };
          }
          render() {
            const { children: c } = this.props;
            return o.createElement("div", { ref: (h) => this.child = h, onClick: this.selectElement, onFocus: this.selectElement, tabIndex: 0, role: "button" }, c);
          }
        }
        const TD = M.div`
  cursor: pointer;
  position: relative;
  margin-bottom: 5px;
`, n_ = M.span`
  font-family: ${(u) => u.theme.typography.code.fontFamily};
  margin-left: 10px;
  flex: 1;
  overflow-x: hidden;
  text-overflow: ellipsis;
`, $D = M.button`
  outline: 0;
  color: inherit;
  width: 100%;
  text-align: left;
  cursor: pointer;
  padding: 10px 30px 10px ${(u) => u.$inverted ? "10px" : "20px"};
  border-radius: ${(u) => u.$inverted ? "0" : "4px 4px 0 0"};
  background-color: ${(u) => u.$inverted ? "transparent" : u.theme.codeBlock.backgroundColor};
  display: flex;
  white-space: nowrap;
  align-items: center;
  border: ${(u) => u.$inverted ? "0" : "1px solid transparent"};
  border-bottom: ${(u) => u.$inverted ? "1px solid #ccc" : "0"};
  transition: border-color 0.25s ease;

  ${(u) => u.$expanded && !u.$inverted && `border-color: ${u.theme.colors.border.dark};` || ""}

  .${n_} {
    color: ${(u) => u.$inverted ? u.theme.colors.text.primary : "#ffffff"};
  }
  &:focus {
    box-shadow: inset 0 2px 2px rgba(0, 0, 0, 0.45), 0 2px 0 rgba(128, 128, 128, 0.25);
  }
`, RD = M.span.attrs((u) => ({ className: `http-verb ${u.type}` }))`
  font-size: ${(u) => u.$compact ? "0.8em" : "0.929em"};
  line-height: ${(u) => u.$compact ? "18px" : "20px"};
  background-color: ${(u) => u.theme.colors.http[u.type] || "#999999"};
  color: #ffffff;
  padding: ${(u) => u.$compact ? "2px 8px" : "3px 10px"};
  text-transform: uppercase;
  font-family: ${(u) => u.theme.typography.headings.fontFamily};
  margin: 0;
`, ID = M.div`
  position: absolute;
  width: 100%;
  z-index: 100;
  background: ${(u) => u.theme.rightPanel.servers.overlay.backgroundColor};
  color: ${(u) => u.theme.rightPanel.servers.overlay.textColor};
  box-sizing: border-box;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.33);
  overflow: hidden;
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
  transition: all 0.25s ease;
  visibility: hidden;
  ${(u) => u.$expanded ? "visibility: visible;" : "transform: translateY(-50%) scaleY(0);"}
`, jD = M.div`
  padding: 10px;
`, ND = M.div`
  padding: 5px;
  border: 1px solid #ccc;
  background: ${(u) => u.theme.rightPanel.servers.url.backgroundColor};
  word-break: break-all;
  color: ${(u) => u.theme.colors.primary.main};
  > span {
    color: ${(u) => u.theme.colors.text.primary};
  }
`;
        class ry extends o.Component {
          constructor(c) {
            super(c), this.toggle = () => {
              this.setState({ expanded: !this.state.expanded });
            }, this.state = { expanded: !1 };
          }
          render() {
            const { operation: c, inverted: h, hideHostname: b } = this.props, { expanded: E } = this.state;
            return o.createElement(Ge.Consumer, null, (P) => o.createElement(TD, null, o.createElement($D, { onClick: this.toggle, $expanded: E, $inverted: h }, o.createElement(RD, { type: c.httpVerb, $compact: this.props.compact }, c.httpVerb), o.createElement(n_, null, c.path), o.createElement(qi, { float: "right", color: h ? "black" : "white", size: "20px", direction: E ? "up" : "down", style: { marginRight: "-25px" } })), o.createElement(ID, { $expanded: E, "aria-hidden": !E }, c.servers.map(($) => {
              const V = P.expandDefaultServerVariables ? au($.url, $.variables) : $.url, ee = Q(V);
              return o.createElement(jD, { key: V }, o.createElement(Mr, { source: $.description || "", compact: !0 }), o.createElement(CD, null, o.createElement(ND, null, o.createElement("span", null, b || P.hideHostname ? ee === "/" ? "" : ee : V), c.path)));
            }))));
          }
        }
        class LD extends o.PureComponent {
          render() {
            const { place: c, parameters: h } = this.props;
            return h && h.length ? o.createElement("div", { key: c }, o.createElement(wu, null, c, " Parameters"), o.createElement(zg, null, o.createElement("tbody", null, _(h, (b, E) => o.createElement(Eu, { key: b.name, isLast: E, field: b, showExamples: !0 }))))) : null;
          }
        }
        let ja = class extends o.Component {
          constructor() {
            super(...arguments), this.switchMedia = ({ idx: u }) => {
              this.props.content && u !== void 0 && this.props.content.activate(u);
            };
          }
          render() {
            const { content: u } = this.props;
            if (!u || !u.mediaTypes || !u.mediaTypes.length) return null;
            const c = u.activeMimeIdx, h = u.mediaTypes.map((E, P) => ({ value: E.name, idx: P })), b = ({ children: E }) => this.props.withLabel ? o.createElement(Xp, null, o.createElement(Kp, null, "Content type"), E) : E;
            return o.createElement(o.Fragment, null, o.createElement(b, null, this.props.renderDropdown({ value: h[c].value, options: h, onChange: this.switchMedia, ariaLabel: "Content type" })), this.props.children(u.active));
          }
        };
        ja = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], ja);
        var MD = Object.defineProperty, gf = Object.getOwnPropertySymbols, i_ = Object.prototype.hasOwnProperty, o_ = Object.prototype.propertyIsEnumerable, s_ = (u, c, h) => c in u ? MD(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, a_ = (u, c) => {
          for (var h in c || (c = {})) i_.call(c, h) && s_(u, h, c[h]);
          if (gf) for (var h of gf(c)) o_.call(c, h) && s_(u, h, c[h]);
          return u;
        }, DD = (u, c) => {
          var h = {};
          for (var b in u) i_.call(u, b) && c.indexOf(b) < 0 && (h[b] = u[b]);
          if (u != null && gf) for (var b of gf(u)) c.indexOf(b) < 0 && o_.call(u, b) && (h[b] = u[b]);
          return h;
        };
        const FD = ["path", "query", "cookie", "header"];
        class ny extends o.PureComponent {
          orderParams(c) {
            const h = {};
            return c.forEach((b) => {
              var E, P, $;
              $ = b, (E = h)[P = b.in] || (E[P] = []), E[P].push($);
            }), h;
          }
          render() {
            const { body: c, parameters: h = [] } = this.props;
            if (c === void 0 && h === void 0) return null;
            const b = this.orderParams(h), E = h.length > 0 ? FD : [], P = c && c.content, $ = c && c.description, V = c && c.required;
            return o.createElement(o.Fragment, null, E.map((ee) => o.createElement(LD, { key: ee, place: ee, parameters: b[ee] })), P && o.createElement(l_, { content: P, description: $, bodyRequired: V }));
          }
        }
        function zD(u) {
          var c = u, { bodyRequired: h } = c, b = DD(c, ["bodyRequired"]);
          const E = typeof h == "boolean" && !!h, P = typeof h == "boolean" && !h;
          return o.createElement(wu, { key: "header" }, "Request Body schema: ", o.createElement($a, a_({}, b)), E && o.createElement(qD, null, "required"), P && o.createElement(BD, null, "optional"));
        }
        function l_(u) {
          const { content: c, description: h, bodyRequired: b } = u, { isRequestType: E } = c;
          return o.createElement(ja, { content: c, renderDropdown: (P) => o.createElement(zD, a_({ bodyRequired: b }, P)) }, ({ schema: P }) => o.createElement(o.Fragment, null, h !== void 0 && o.createElement(Mr, { source: h }), (P == null ? void 0 : P.type) === "object" && o.createElement(_u, { constraints: (P == null ? void 0 : P.constraints) || [] }), o.createElement(Wi, { skipReadOnly: E, skipWriteOnly: !E, key: "schema", schema: P })));
        }
        const u_ = `
  text-transform: lowercase;
  margin-left: 0;
  line-height: 1.5em;
`, qD = M(Yg)`
  ${u_}
`, BD = M("div")`
  ${u_}
  color: ${({ theme: u }) => u.colors.text.secondary};
  font-size: ${(u) => u.theme.schema.labelsTextSize};
`, c_ = o.memo(function({ title: u, type: c, empty: h, code: b, opened: E, className: P, onClick: $ }) {
          return o.createElement("button", { className: P, onClick: !h && $ || void 0, "aria-expanded": E, disabled: h }, !h && o.createElement(qi, { size: "1.5em", color: c, direction: E ? "down" : "right", float: "left" }), o.createElement(HD, null, b, " "), o.createElement(Mr, { compact: !0, inline: !0, source: u }));
        }), UD = M(c_)`
  display: block;
  border: 0;
  width: 100%;
  text-align: left;
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  cursor: pointer;

  color: ${(u) => u.theme.colors.responses[u.type].color};
  background-color: ${(u) => u.theme.colors.responses[u.type].backgroundColor};
  &:focus {
    outline: auto ${(u) => u.theme.colors.responses[u.type].color};
  }
  ${(u) => u.empty ? `
cursor: default;
&::before {
  content: "—";
  font-weight: bold;
  width: 1.5em;
  text-align: center;
  display: inline-block;
  vertical-align: top;
}
&:focus {
  outline: 0;
}
` : ""};
`, VD = M.div`
  padding: 10px;
`, WD = M(wu).attrs({ as: "caption" })`
  text-align: left;
  margin-top: 1em;
  caption-side: top;
`, HD = M.strong`
  vertical-align: top;
`;
        class p_ extends o.PureComponent {
          render() {
            const { headers: c } = this.props;
            return c === void 0 || c.length === 0 ? null : o.createElement(zg, null, o.createElement(WD, null, " Response Headers "), o.createElement("tbody", null, _(c, (h, b) => o.createElement(Eu, { isLast: b, key: h.name, field: h, showExamples: !0 }))));
          }
        }
        var QD = Object.defineProperty, f_ = Object.getOwnPropertySymbols, YD = Object.prototype.hasOwnProperty, GD = Object.prototype.propertyIsEnumerable, d_ = (u, c, h) => c in u ? QD(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        class h_ extends o.PureComponent {
          constructor() {
            super(...arguments), this.renderDropdown = (c) => o.createElement(wu, { key: "header" }, "Response Schema: ", o.createElement($a, ((h, b) => {
              for (var E in b || (b = {})) YD.call(b, E) && d_(h, E, b[E]);
              if (f_) for (var E of f_(b)) GD.call(b, E) && d_(h, E, b[E]);
              return h;
            })({}, c)));
          }
          render() {
            const { description: c, extensions: h, headers: b, content: E } = this.props.response;
            return o.createElement(o.Fragment, null, c && o.createElement(Mr, { source: c }), o.createElement(tf, { extensions: h }), o.createElement(p_, { headers: b }), o.createElement(ja, { content: E, renderDropdown: this.renderDropdown }, ({ schema: P }) => o.createElement(o.Fragment, null, (P == null ? void 0 : P.type) === "object" && o.createElement(_u, { constraints: (P == null ? void 0 : P.constraints) || [] }), o.createElement(Wi, { skipWriteOnly: !0, key: "schema", schema: P }))));
          }
        }
        const m_ = (0, vt.observer)(({ response: u }) => {
          const { extensions: c, headers: h, type: b, summary: E, description: P, code: $, expanded: V, content: ee } = u, ie = o.useMemo(() => ee === void 0 ? [] : ee.mediaTypes.filter((se) => se.schema !== void 0), [ee]), ne = o.useMemo(() => !(c && Object.keys(c).length !== 0 || h.length !== 0 || ie.length !== 0 || P), [c, h, ie, P]);
          return o.createElement("div", null, o.createElement(UD, { onClick: () => u.toggle(), type: b, empty: ne, title: E || "", code: $, opened: V }), V && !ne && o.createElement(VD, null, o.createElement(h_, { response: u })));
        }), KD = M.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: u }) => u.colors.text.primary};
  font-weight: normal;
`;
        class iy extends o.PureComponent {
          render() {
            const { responses: c, isCallback: h } = this.props;
            return c && c.length !== 0 ? o.createElement("div", null, o.createElement(KD, null, z(h ? "callbackResponses" : "responses")), c.map((b) => o.createElement(m_, { key: b.code, response: b }))) : null;
          }
        }
        function XD(u) {
          const { security: c, showSecuritySchemeType: h, expanded: b } = u, E = c.schemes.length > 1;
          return c.schemes.length === 0 ? o.createElement(Qx, { $expanded: b }, "None") : o.createElement(Qx, { $expanded: b }, E && "(", c.schemes.map((P) => o.createElement(eD, { key: P.id }, h && `${cf[P.type] || P.type}: `, o.createElement("i", null, P.displayName), b && P.scopes.length ? [" (", P.scopes.map(($) => o.createElement(Z2, { key: $ }, $)), ") "] : null)), E && ") ");
        }
        const JD = ({ scopes: u }) => u.length ? o.createElement("div", null, o.createElement("b", null, "Required scopes: "), u.map((c, h) => o.createElement(o.Fragment, { key: h }, o.createElement("code", null, c), " "))) : null;
        function g_(u) {
          const c = H1(), h = c == null ? void 0 : c.options.showSecuritySchemeType, [b, E] = (0, o.useState)(!1), { securities: P } = u;
          if (!(P != null && P.length) || c != null && c.options.hideSecuritySection) return null;
          const $ = c == null ? void 0 : c.spec.securitySchemes.schemes.filter(({ id: V }) => P.find((ee) => ee.schemes.find((ie) => ie.id === V)));
          return o.createElement(o.Fragment, null, o.createElement(iD, { $expanded: b }, o.createElement(tD, { onClick: () => E(!b) }, o.createElement(nD, null, "Authorizations:"), o.createElement(qi, { size: "1.3em", direction: b ? "down" : "right" })), o.createElement(rD, { $expanded: b }, P.map((V, ee) => o.createElement(XD, { key: ee, expanded: b, showSecuritySchemeType: h, security: V })))), b && !!($ != null && $.length) && $.map((V, ee) => o.createElement(Yx, { key: ee }, o.createElement("h5", null, o.createElement(ZD, null), " ", cf[V.type] || V.type, ": ", V.id), o.createElement(Mr, { source: V.description || "" }), o.createElement(Gx, { key: V.id, scheme: V, RequiredScopes: o.createElement(JD, { scopes: eF(V.id, P) }) }))));
        }
        const ZD = () => o.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "11", height: "11" }, o.createElement("path", { fill: "currentColor", d: "M18 10V6A6 6 0 0 0 6 6v4H3v14h18V10h-3zM8 6c0-2.206 1.794-4 4-4s4 1.794 4 4v4H8V6zm11 16H5V12h14v10z" }));
        function eF(u, c) {
          const h = [];
          let b = c.length;
          for (; b--; ) {
            const E = c[b];
            let P = E.schemes.length;
            for (; P--; ) {
              const $ = E.schemes[P];
              $.id === u && Array.isArray($.scopes) && h.push(...$.scopes);
            }
          }
          return Array.from(new Set(h));
        }
        let oy = class extends o.Component {
          render() {
            const { operation: u } = this.props, { description: c, externalDocs: h } = u, b = !(!c && !h);
            return o.createElement(PD, null, b && o.createElement(tF, null, c !== void 0 && o.createElement(Mr, { source: c }), h && o.createElement(Ps, { externalDocs: h })), o.createElement(ry, { operation: this.props.operation, inverted: !0, compact: !0 }), o.createElement(tf, { extensions: u.extensions }), o.createElement(g_, { securities: u.security }), o.createElement(ny, { parameters: u.parameters, body: u.requestBody }), o.createElement(iy, { responses: u.responses, isCallback: u.isCallback }));
          }
        };
        oy = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], oy);
        const tF = M.div`
  margin-bottom: ${({ theme: u }) => 3 * u.spacing.unit}px;
`;
        let sy = class extends o.Component {
          constructor() {
            super(...arguments), this.toggle = () => {
              this.props.callbackOperation.toggle();
            };
          }
          render() {
            const { name: u, expanded: c, httpVerb: h, deprecated: b } = this.props.callbackOperation;
            return o.createElement(o.Fragment, null, o.createElement(AD, { onClick: this.toggle, name: u, opened: c, httpVerb: h, deprecated: b }), c && o.createElement(oy, { operation: this.props.callbackOperation }));
          }
        };
        sy = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], sy);
        class rF extends o.PureComponent {
          render() {
            const { callbacks: c } = this.props;
            return c && c.length !== 0 ? o.createElement("div", null, o.createElement(nF, null, " Callbacks "), c.map((h) => h.operations.map((b, E) => o.createElement(sy, { key: `${h.name}_${E}`, callbackOperation: b })))) : null;
          }
        }
        const nF = M.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: u }) => u.colors.text.primary};
  font-weight: normal;
`;
        let ay = class extends o.Component {
          constructor(u) {
            super(u), this.switchItem = ({ idx: c }) => {
              this.props.items && c !== void 0 && this.setState({ activeItemIdx: c });
            }, this.state = { activeItemIdx: 0 };
          }
          render() {
            const { items: u } = this.props;
            if (!u || !u.length) return null;
            const c = ({ children: h }) => this.props.label ? o.createElement(Xp, null, o.createElement(Kp, null, this.props.label), h) : h;
            return o.createElement(o.Fragment, null, o.createElement(c, null, this.props.renderDropdown({ value: this.props.options[this.state.activeItemIdx].value, options: this.props.options, onChange: this.switchItem, ariaLabel: this.props.label || "Callback" })), this.props.children(u[this.state.activeItemIdx]));
          }
        };
        ay = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], ay);
        var iF = Object.defineProperty, oF = Object.defineProperties, sF = Object.getOwnPropertyDescriptors, y_ = Object.getOwnPropertySymbols, aF = Object.prototype.hasOwnProperty, lF = Object.prototype.propertyIsEnumerable, v_ = (u, c, h) => c in u ? iF(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        let Na = class extends o.Component {
          constructor() {
            super(...arguments), this.renderDropdown = (u) => {
              return o.createElement($a, (c = ((h, b) => {
                for (var E in b || (b = {})) aF.call(b, E) && v_(h, E, b[E]);
                if (y_) for (var E of y_(b)) lF.call(b, E) && v_(h, E, b[E]);
                return h;
              })({ Label: Qg, Dropdown: Jp }, u), oF(c, sF({ variant: "dark" }))));
              var c;
            };
          }
          render() {
            const u = this.props.content;
            return u === void 0 ? null : o.createElement(ja, { content: u, renderDropdown: this.renderDropdown, withLabel: !0 }, (c) => o.createElement(vx, { key: "samples", mediaType: c, renderDropdown: this.renderDropdown }));
          }
        };
        Na = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Na);
        class uF extends o.Component {
          render() {
            const c = this.props.callback.codeSamples.find((h) => Ng(h));
            return c ? o.createElement(cF, null, o.createElement(Na, { content: c.requestBodyContent })) : null;
          }
        }
        const cF = M.div`
  margin-top: 15px;
`;
        var pF = Object.defineProperty, fF = Object.defineProperties, dF = Object.getOwnPropertyDescriptors, b_ = Object.getOwnPropertySymbols, hF = Object.prototype.hasOwnProperty, mF = Object.prototype.propertyIsEnumerable, w_ = (u, c, h) => c in u ? pF(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        let yf = class extends o.Component {
          constructor() {
            super(...arguments), this.renderDropdown = (u) => {
              return o.createElement($a, (c = ((h, b) => {
                for (var E in b || (b = {})) hF.call(b, E) && w_(h, E, b[E]);
                if (b_) for (var E of b_(b)) mF.call(b, E) && w_(h, E, b[E]);
                return h;
              })({ Label: Qg, Dropdown: Jp }, u), fF(c, dF({ variant: "dark" }))));
              var c;
            };
          }
          render() {
            const { callbacks: u } = this.props;
            if (!u || u.length === 0) return null;
            const c = u.map((b) => b.operations.map((E) => E)).reduce((b, E) => b.concat(E), []);
            if (!c.some((b) => b.codeSamples.length > 0)) return null;
            const h = c.map((b, E) => ({ value: `${b.httpVerb.toUpperCase()}: ${b.name}`, idx: E }));
            return o.createElement("div", null, o.createElement(Dg, null, " Callback payload samples "), o.createElement(gF, null, o.createElement(ay, { items: c, renderDropdown: this.renderDropdown, label: "Callback", options: h }, (b) => o.createElement(uF, { key: "callbackPayloadSample", callback: b, renderDropdown: this.renderDropdown }))));
          }
        };
        yf.contextType = Ge, yf = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], yf);
        const gF = M.div`
  background: ${({ theme: u }) => u.codeBlock.backgroundColor};
  padding: ${(u) => 4 * u.theme.spacing.unit}px;
`;
        let vf = class extends o.Component {
          render() {
            const { operation: u } = this.props, c = u.codeSamples, h = c.length > 0, b = c.length === 1 && this.context.hideSingleRequestSampleTab;
            return h && o.createElement("div", null, o.createElement(Dg, null, " ", z("requestSamples"), " "), o.createElement(qg, { defaultIndex: 0 }, o.createElement(Os.TabList, { hidden: b }, c.map((E) => o.createElement(Os.Tab, { key: E.lang + "_" + (E.label || "") }, E.label !== void 0 ? E.label : E.lang))), c.map((E) => o.createElement(Os.TabPanel, { key: E.lang + "_" + (E.label || "") }, Ng(E) ? o.createElement("div", null, o.createElement(Na, { content: E.requestBodyContent })) : o.createElement(Wg, { lang: E.lang, source: E.source }))))) || null;
          }
        };
        vf.contextType = Ge, vf = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], vf);
        let bf = class extends o.Component {
          render() {
            const { operation: u } = this.props, c = u.responses.filter((h) => h.content && h.content.hasSample);
            return c.length > 0 && o.createElement("div", null, o.createElement(Dg, null, " ", z("responseSamples"), " "), o.createElement(qg, { defaultIndex: 0 }, o.createElement(Os.TabList, null, c.map((h) => o.createElement(Os.Tab, { className: "tab-" + h.type, key: h.code }, h.code))), c.map((h) => o.createElement(Os.TabPanel, { key: h.code }, o.createElement("div", null, o.createElement(Na, { content: h.content })))))) || null;
          }
        };
        bf = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], bf);
        var yF = Object.defineProperty, vF = Object.defineProperties, bF = Object.getOwnPropertyDescriptors, S_ = Object.getOwnPropertySymbols, wF = Object.prototype.hasOwnProperty, SF = Object.prototype.propertyIsEnumerable, x_ = (u, c, h) => c in u ? yF(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        const xF = M.div`
  margin-bottom: ${({ theme: u }) => 6 * u.spacing.unit}px;
`, __ = (0, vt.observer)(({ operation: u }) => {
          const { name: c, description: h, deprecated: b, externalDocs: E, isWebhook: P, httpVerb: $ } = u, V = !(!h && !E), { showWebhookVerb: ee } = o.useContext(Ge);
          return o.createElement(Ge.Consumer, null, (ie) => {
            return o.createElement(Es, (ne = ((me, Ie) => {
              for (var ze in Ie || (Ie = {})) wF.call(Ie, ze) && x_(me, ze, Ie[ze]);
              if (S_) for (var ze of S_(Ie)) SF.call(Ie, ze) && x_(me, ze, Ie[ze]);
              return me;
            })({}, { [_s]: u.operationHash }), se = { id: u.operationHash }, vF(ne, bF(se))), o.createElement(Eo, null, o.createElement(Mg, null, o.createElement(Fg, { to: u.id }), c, " ", b && o.createElement(Su, { type: "warning" }, " Deprecated "), P && o.createElement(Su, { type: "primary" }, " ", "Webhook ", ee && $ && "| " + $.toUpperCase())), ie.pathInMiddlePanel && !P && o.createElement(ry, { operation: u, inverted: !0 }), V && o.createElement(xF, null, h !== void 0 && o.createElement(Mr, { source: h }), E && o.createElement(Ps, { externalDocs: E })), o.createElement(tf, { extensions: u.extensions }), o.createElement(g_, { securities: u.security }), o.createElement(ny, { parameters: u.parameters, body: u.requestBody }), o.createElement(iy, { responses: u.responses }), o.createElement(rF, { callbacks: u.callbacks })), o.createElement(B1, null, !ie.pathInMiddlePanel && !P && o.createElement(ry, { operation: u }), o.createElement(vf, { operation: u }), o.createElement(bf, { operation: u }), o.createElement(yf, { callbacks: u.callbacks })));
            var ne, se;
          });
        });
        var _F = Object.defineProperty, E_ = Object.getOwnPropertySymbols, EF = Object.prototype.hasOwnProperty, OF = Object.prototype.propertyIsEnumerable, O_ = (u, c, h) => c in u ? _F(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, wf = (u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        };
        let ku = class extends o.Component {
          render() {
            const u = this.props.items;
            return u.length === 0 ? null : u.map((c) => o.createElement(Sf, { key: c.id, item: c }));
          }
        };
        ku = wf([vt.observer], ku);
        let Sf = class extends o.Component {
          render() {
            const u = this.props.item;
            let c;
            const { type: h } = u;
            switch (h) {
              case "group":
                c = null;
                break;
              case "tag":
              case "section":
              default:
                c = o.createElement(xf, ((b, E) => {
                  for (var P in E || (E = {})) EF.call(E, P) && O_(b, P, E[P]);
                  if (E_) for (var P of E_(E)) OF.call(E, P) && O_(b, P, E[P]);
                  return b;
                })({}, this.props));
                break;
              case "operation":
                c = o.createElement(_f, { item: u });
            }
            return o.createElement(o.Fragment, null, c && o.createElement(vu, { id: u.id, $underlined: u.type === "operation" }, c), u.items && o.createElement(ku, { items: u.items }));
          }
        };
        Sf = wf([vt.observer], Sf);
        const kF = (u) => o.createElement(Eo, { $compact: !0 }, u);
        let xf = class extends o.Component {
          render() {
            const { name: u, description: c, externalDocs: h, level: b } = this.props.item, E = b === 2 ? AM : Mg;
            return o.createElement(o.Fragment, null, o.createElement(Es, null, o.createElement(Eo, { $compact: !1 }, o.createElement(E, null, o.createElement(Fg, { to: this.props.item.id }), u))), o.createElement(xD, { parentId: this.props.item.id, source: c || "", htmlWrap: kF }), h && o.createElement(Es, null, o.createElement(Eo, null, o.createElement(Ps, { externalDocs: h }))));
          }
        };
        xf = wf([vt.observer], xf);
        let _f = class extends o.Component {
          render() {
            return o.createElement(__, { operation: this.props.item });
          }
        };
        _f = wf([vt.observer], _f);
        var AF = Object.defineProperty, PF = Object.defineProperties, CF = Object.getOwnPropertyDescriptors, k_ = Object.getOwnPropertySymbols, TF = Object.prototype.hasOwnProperty, $F = Object.prototype.propertyIsEnumerable, A_ = (u, c, h) => c in u ? AF(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        let Au = class extends o.Component {
          constructor() {
            super(...arguments), this.ref = o.createRef(), this.activate = (u) => {
              this.props.onActivate(this.props.item), u.stopPropagation();
            };
          }
          componentDidMount() {
            this.scrollIntoViewIfActive();
          }
          componentDidUpdate() {
            this.scrollIntoViewIfActive();
          }
          scrollIntoViewIfActive() {
            this.props.item.active && this.ref.current && v(this.ref.current);
          }
          render() {
            const { item: u, withoutChildren: c } = this.props;
            return o.createElement(e_, { tabIndex: 0, onClick: this.activate, depth: u.depth, "data-item-id": u.id, role: "menuitem" }, u.type === "operation" ? o.createElement(P_, (h = ((b, E) => {
              for (var P in E || (E = {})) TF.call(E, P) && A_(b, P, E[P]);
              if (k_) for (var P of k_(E)) $F.call(E, P) && A_(b, P, E[P]);
              return b;
            })({}, this.props), PF(h, CF({ item: u })))) : o.createElement(mf, { $depth: u.depth, $active: u.active, $type: u.type, ref: this.ref }, u.type === "schema" && o.createElement(Ou, { type: "schema" }, "schema"), o.createElement(ty, { width: "calc(100% - 38px)", title: u.sidebarLabel }, u.sidebarLabel, this.props.children), u.depth > 0 && u.items.length > 0 && o.createElement(qi, { float: "right", direction: u.expanded ? "down" : "right" }) || null), !c && u.items && u.items.length > 0 && o.createElement(Pu, { expanded: u.expanded, items: u.items, onActivate: this.props.onActivate }));
            var h;
          }
        };
        Au = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Au);
        const P_ = (0, vt.observer)((u) => {
          const { item: c } = u, h = o.createRef(), { showWebhookVerb: b } = o.useContext(Ge);
          return o.useEffect(() => {
            u.item.active && h.current && v(h.current);
          }, [u.item.active, h]), o.createElement(mf, { $depth: c.depth, $active: c.active, $deprecated: c.deprecated, ref: h }, c.isWebhook ? o.createElement(Ou, { type: "hook" }, b ? c.httpVerb : z("webhook")) : o.createElement(Ou, { type: c.httpVerb }, vs(c.httpVerb)), o.createElement(ty, { tabIndex: 0, width: "calc(100% - 38px)" }, c.sidebarLabel, u.children));
        });
        var RF = Object.defineProperty, C_ = Object.getOwnPropertySymbols, IF = Object.prototype.hasOwnProperty, jF = Object.prototype.propertyIsEnumerable, T_ = (u, c, h) => c in u ? RF(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h;
        let Pu = class extends o.Component {
          render() {
            const { items: u, root: c, className: h } = this.props, b = this.props.expanded == null || this.props.expanded;
            return o.createElement(Zx, ((E, P) => {
              for (var $ in P || (P = {})) IF.call(P, $) && T_(E, $, P[$]);
              if (C_) for (var $ of C_(P)) jF.call(P, $) && T_(E, $, P[$]);
              return E;
            })({ className: h, style: this.props.style, $expanded: b }, c ? { role: "menu" } : {}), u.map((E, P) => o.createElement(Au, { key: P, item: E, onActivate: this.props.onActivate })));
          }
        };
        function NF() {
          const [u, c] = (0, o.useState)(!1);
          return (0, o.useEffect)(() => {
            c(!0);
          }, []), u ? o.createElement("img", { alt: "redocly logo", onError: () => c(!1), src: "https://cdn.redoc.ly/redoc/logo-mini.svg" }) : null;
        }
        Pu = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Pu);
        let Cu = class extends o.Component {
          constructor() {
            super(...arguments), this.activate = (u) => {
              if (u && u.active && this.context.menuToggle) return u.expanded ? u.collapse() : u.expand();
              this.props.menu.activateAndScroll(u, !0), setTimeout(() => {
                this._updateScroll && this._updateScroll();
              });
            }, this.saveScrollUpdate = (u) => {
              this._updateScroll = u;
            };
          }
          render() {
            const u = this.props.menu;
            return o.createElement(tx, { updateFn: this.saveScrollUpdate, className: this.props.className, options: { wheelPropagation: !1 } }, o.createElement(Pu, { items: u.items, onActivate: this.activate, root: !0 }), o.createElement(r_, null, o.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: "https://redocly.com/redoc/" }, o.createElement(NF, null), "API docs by Redocly")));
          }
        };
        Cu.contextType = Ge, Cu = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Cu);
        const LF = ({ open: u }) => {
          const c = u ? 8 : -4;
          return o.createElement(MF, null, o.createElement($_, { size: 15, style: { transform: `translate(2px, ${c}px) rotate(180deg)`, transition: "transform 0.2s ease" } }), o.createElement($_, { size: 15, style: { transform: `translate(2px, ${0 - c}px)`, transition: "transform 0.2s ease" } }));
        }, $_ = ({ size: u = 10, className: c = "", style: h }) => o.createElement("svg", { className: c, style: h || {}, viewBox: "0 0 926.23699 573.74994", version: "1.1", x: "0px", y: "0px", width: u, height: u }, o.createElement("g", { transform: "translate(904.92214,-879.1482)" }, o.createElement("path", { d: `
          m -673.67664,1221.6502 -231.2455,-231.24803 55.6165,
          -55.627 c 30.5891,-30.59485 56.1806,-55.627 56.8701,-55.627 0.6894,
          0 79.8637,78.60862 175.9427,174.68583 l 174.6892,174.6858 174.6892,
          -174.6858 c 96.079,-96.07721 175.253196,-174.68583 175.942696,
          -174.68583 0.6895,0 26.281,25.03215 56.8701,
          55.627 l 55.6165,55.627 -231.245496,231.24803 c -127.185,127.1864
          -231.5279,231.248 -231.873,231.248 -0.3451,0 -104.688,
          -104.0616 -231.873,-231.248 z
        `, fill: "currentColor" }))), MF = M.div`
  user-select: none;
  width: 20px;
  height: 20px;
  align-self: center;
  display: flex;
  flex-direction: column;
  color: ${(u) => u.theme.colors.primary.main};
`;
        let ly;
        f && (ly = i(322));
        const Ef = ly && ly(), DF = M.div`
  width: ${(u) => u.theme.sidebar.width};
  background-color: ${(u) => u.theme.sidebar.backgroundColor};
  overflow: hidden;
  display: flex;
  flex-direction: column;

  backface-visibility: hidden;
  /* contain: strict; TODO: breaks layout since Chrome 80*/

  height: 100vh;
  position: sticky;
  position: -webkit-sticky;
  top: 0;

  ${O.lessThan("small")`
    position: fixed;
    z-index: 20;
    width: 100%;
    background: ${({ theme: u }) => u.sidebar.backgroundColor};
    display: ${(u) => u.$open ? "flex" : "none"};
  `};

  @media print {
    display: none;
  }
`, FF = M.div`
  outline: none;
  user-select: none;
  background-color: ${({ theme: u }) => u.fab.backgroundColor};
  color: ${(u) => u.theme.colors.primary.main};
  display: none;
  cursor: pointer;
  position: fixed;
  right: 20px;
  z-index: 100;
  border-radius: 50%;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
  ${O.lessThan("small")`
    display: flex;
  `};

  bottom: 44px;

  width: 60px;
  height: 60px;
  padding: 0 20px;
  svg {
    color: ${({ theme: u }) => u.fab.color};
  }

  @media print {
    display: none;
  }
`;
        let Tu = class extends o.Component {
          constructor() {
            super(...arguments), this.state = { offsetTop: "0px" }, this.toggleNavMenu = () => {
              this.props.menu.toggleSidebar();
            };
          }
          componentDidMount() {
            Ef && Ef.add(this.stickyElement), this.setState({ offsetTop: this.getScrollYOffset(this.context) });
          }
          componentWillUnmount() {
            Ef && Ef.remove(this.stickyElement);
          }
          getScrollYOffset(u) {
            let c;
            return c = this.props.scrollYOffset !== void 0 ? X.normalizeScrollYOffset(this.props.scrollYOffset)() : u.scrollYOffset(), c + "px";
          }
          render() {
            const u = this.props.menu.sideBarOpened, c = this.state.offsetTop;
            return o.createElement(o.Fragment, null, o.createElement(DF, { $open: u, className: this.props.className, style: { top: c, height: `calc(100vh - ${c})` }, ref: (h) => {
              this.stickyElement = h;
            } }, this.props.children), !this.context.hideFab && o.createElement(FF, { onClick: this.toggleNavMenu }, o.createElement(LF, { open: u })));
          }
        };
        Tu.contextType = Ge, Tu = ((u, c, h, b) => {
          for (var E, P = c, $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(P) || P);
          return P;
        })([vt.observer], Tu);
        const R_ = M.div`
  ${({ theme: u }) => `
  font-family: ${u.typography.fontFamily};
  font-size: ${u.typography.fontSize};
  font-weight: ${u.typography.fontWeightRegular};
  line-height: ${u.typography.lineHeight};
  color: ${u.colors.text.primary};
  display: flex;
  position: relative;
  text-align: left;

  -webkit-font-smoothing: ${u.typography.smoothing};
  font-smoothing: ${u.typography.smoothing};
  ${u.typography.optimizeSpeed ? "text-rendering: optimizeSpeed !important" : ""};

  tap-highlight-color: rgba(0, 0, 0, 0);
  text-size-adjust: 100%;

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
  }
`};
`, I_ = M.div`
  z-index: 1;
  position: relative;
  overflow: hidden;
  width: calc(100% - ${(u) => u.theme.sidebar.width});
  ${O.lessThan("small", !0)`
    width: 100%;
  `};

  contain: layout;
`, j_ = M.div`
  background: ${({ theme: u }) => u.rightPanel.backgroundColor};
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: ${({ theme: u }) => {
          if (u.rightPanel.width.endsWith("%")) {
            const c = parseInt(u.rightPanel.width, 10);
            return `calc((100% - ${u.sidebar.width}) * ${c / 100})`;
          }
          return u.rightPanel.width;
        }};
  ${O.lessThan("medium", !0)`
    display: none;
  `};
`, zF = M.div`
  padding: 5px 0;
`, qF = M.input.attrs(() => ({ className: "search-input" }))`
  width: calc(100% - ${(u) => 8 * u.theme.spacing.unit}px);
  box-sizing: border-box;
  margin: 0 ${(u) => 4 * u.theme.spacing.unit}px;
  padding: 5px ${(u) => 2 * u.theme.spacing.unit}px 5px
    ${(u) => 4 * u.theme.spacing.unit}px;
  border: 0;
  border-bottom: 1px solid
    ${({ theme: u }) => ((0, a.getLuminance)(u.sidebar.backgroundColor) > 0.5 ? a.darken : a.lighten)(0.1, u.sidebar.backgroundColor)};
  font-family: ${({ theme: u }) => u.typography.fontFamily};
  font-weight: bold;
  font-size: 13px;
  color: ${(u) => u.theme.sidebar.textColor};
  background-color: transparent;
  outline: none;
`, BF = M((u) => o.createElement("svg", { className: u.className, version: "1.1", viewBox: "0 0 1000 1000", x: "0px", xmlns: "http://www.w3.org/2000/svg", y: "0px" }, o.createElement("path", { d: "M968.2,849.4L667.3,549c83.9-136.5,66.7-317.4-51.7-435.6C477.1-25,252.5-25,113.9,113.4c-138.5,138.3-138.5,362.6,0,501C219.2,730.1,413.2,743,547.6,666.5l301.9,301.4c43.6,43.6,76.9,14.9,104.2-12.4C981,928.3,1011.8,893,968.2,849.4z M524.5,522c-88.9,88.7-233,88.7-321.8,0c-88.9-88.7-88.9-232.6,0-321.3c88.9-88.7,233-88.7,321.8,0C613.4,289.4,613.4,433.3,524.5,522z" }))).attrs({ className: "search-icon" })`
  position: absolute;
  left: ${(u) => 4 * u.theme.spacing.unit}px;
  height: 1.8em;
  width: 0.9em;

  path {
    fill: ${(u) => u.theme.sidebar.textColor};
  }
`, N_ = M.div`
  padding: ${(u) => u.theme.spacing.unit}px 0;
  background-color: ${({ theme: u }) => (0, a.darken)(0.05, u.sidebar.backgroundColor)}};
  color: ${(u) => u.theme.sidebar.textColor};
  min-height: 150px;
  max-height: 250px;
  border-top: ${({ theme: u }) => (0, a.darken)(0.1, u.sidebar.backgroundColor)}};
  border-bottom: ${({ theme: u }) => (0, a.darken)(0.1, u.sidebar.backgroundColor)}};
  margin-top: 10px;
  line-height: 1.4;
  font-size: 0.9em;
  
  li {
    background-color: inherit;
  }

  ${mf} {
    padding-top: 6px;
    padding-bottom: 6px;

    &:hover,
    &.active {
      background-color: ${({ theme: u }) => (0, a.darken)(0.1, u.sidebar.backgroundColor)};
    }

    > svg {
      display: none;
    }
  }
`, UF = M.i`
  position: absolute;
  display: inline-block;
  width: ${(u) => 2 * u.theme.spacing.unit}px;
  text-align: center;
  right: ${(u) => 4 * u.theme.spacing.unit}px;
  line-height: 2em;
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  font-style: normal;
  color: '#666';
`;
        var VF = Object.defineProperty, WF = Object.getOwnPropertyDescriptor;
        class Of extends o.PureComponent {
          constructor(c) {
            super(c), this.activeItemRef = null, this.clear = () => {
              this.setState({ results: [], noResults: !1, term: "", activeItemIdx: -1 }), this.props.marker.unmark();
            }, this.handleKeyDown = (h) => {
              if (h.keyCode === 27 && this.clear(), h.keyCode === 40 && (this.setState({ activeItemIdx: Math.min(this.state.activeItemIdx + 1, this.state.results.length - 1) }), h.preventDefault()), h.keyCode === 38 && (this.setState({ activeItemIdx: Math.max(0, this.state.activeItemIdx - 1) }), h.preventDefault()), h.keyCode === 13) {
                const b = this.state.results[this.state.activeItemIdx];
                if (b) {
                  const E = this.props.getItemById(b.meta);
                  E && this.props.onActivate(E);
                }
              }
            }, this.search = (h) => {
              const { minCharacterLengthToInitSearch: b } = this.context, E = h.target.value;
              E.length < b ? this.clearResults(E) : this.setState({ term: E }, () => this.searchCallback(this.state.term));
            }, this.state = { results: [], noResults: !1, term: "", activeItemIdx: -1 };
          }
          clearResults(c) {
            this.setState({ results: [], noResults: !1, term: c }), this.props.marker.unmark();
          }
          setResults(c, h) {
            this.setState({ results: c, noResults: c.length === 0 }), this.props.marker.mark(h);
          }
          searchCallback(c) {
            this.props.search.search(c).then((h) => {
              this.setResults(h, c);
            });
          }
          render() {
            const { activeItemIdx: c } = this.state, h = this.state.results.filter((b) => this.props.getItemById(b.meta)).map((b) => ({ item: this.props.getItemById(b.meta), score: b.score })).sort((b, E) => E.score - b.score);
            return o.createElement(zF, { role: "search" }, this.state.term && o.createElement(UF, { onClick: this.clear }, "×"), o.createElement(BF, null), o.createElement(qF, { value: this.state.term, onKeyDown: this.handleKeyDown, placeholder: "Search...", "aria-label": "Search", type: "text", onChange: this.search }), h.length > 0 && o.createElement(tx, { options: { wheelPropagation: !1 } }, o.createElement(N_, { "data-role": "search:results" }, h.map((b, E) => o.createElement(Au, { item: Object.create(b.item, { active: { value: E === c } }), onActivate: this.props.onActivate, withoutChildren: !0, key: b.item.id, "data-role": "search:result" })))), this.state.term && this.state.noResults ? o.createElement(N_, { "data-role": "search:results" }, z("noResultsFound")) : null);
          }
        }
        Of.contextType = Ge, ((u, c, h, b) => {
          for (var E, P = WF(c, h), $ = u.length - 1; $ >= 0; $--) (E = u[$]) && (P = E(c, h, P) || P);
          P && VF(c, h, P);
        })([xe.bind, (0, xe.debounce)(400)], Of.prototype, "searchCallback");
        class uy extends o.Component {
          componentDidMount() {
            this.props.store.onDidMount();
          }
          componentWillUnmount() {
            this.props.store.dispose();
          }
          render() {
            const { store: { spec: c, menu: h, options: b, search: E, marker: P } } = this.props, $ = this.props.store;
            return o.createElement(Se, { theme: b.theme }, o.createElement(U1, { value: $ }, o.createElement(Ue, { value: b }, o.createElement(R_, { className: "redoc-wrap" }, o.createElement(Tu, { menu: h, className: "menu-content" }, o.createElement(df, { info: c.info }), !b.disableSearch && o.createElement(Of, { search: E, marker: P, getItemById: h.getItemById, onActivate: h.activateAndScroll }) || null, o.createElement(Cu, { menu: h })), o.createElement(I_, { className: "api-content" }, o.createElement(ff, { store: $ }), o.createElement(ku, { items: h.items })), o.createElement(j_, null)))));
          }
        }
        uy.propTypes = { store: Xe.instanceOf(Ia).isRequired };
        var HF = Object.defineProperty, L_ = Object.getOwnPropertySymbols, QF = Object.prototype.hasOwnProperty, YF = Object.prototype.propertyIsEnumerable, M_ = (u, c, h) => c in u ? HF(u, c, { enumerable: !0, configurable: !0, writable: !0, value: h }) : u[c] = h, GF = (u, c) => {
          for (var h in c || (c = {})) QF.call(c, h) && M_(u, h, c[h]);
          if (L_) for (var h of L_(c)) YF.call(c, h) && M_(u, h, c[h]);
          return u;
        };
        const KF = function(u) {
          const { spec: c, specUrl: h, options: b = {}, onLoaded: E } = u, P = N(b.hideLoading, !1), $ = new X(b);
          if ($.nonce !== void 0) try {
            i.nc = $.nonce;
          } catch {
          }
          return o.createElement(be, null, o.createElement(W1, { spec: c ? GF({}, c) : void 0, specUrl: h, options: b, onLoaded: E }, ({ loading: V, store: ee }) => V ? P ? null : o.createElement(We, { color: $.theme.colors.primary.main }) : o.createElement(uy, { store: ee })));
        };
      }(), s;
    }();
  });
})(gR);
var cK = gR.exports;
const pK = () => {
  const [e, t] = et.useState(null);
  return et.useEffect(() => {
    const r = acquireVsCodeApi();
    window.addEventListener("message", (n) => {
      const i = n.data;
      switch (i.command) {
        case "preview":
          const s = JSON.parse(i.text);
          t(s);
          break;
      }
    }), r.postMessage({ command: "init" });
  }, []), e ? /* @__PURE__ */ p0.jsx(cK.RedocStandalone, { options: { disableSearch: !0, hideDownloadButton: !0 }, spec: e }) : /* @__PURE__ */ p0.jsx("p", { children: "Loading..." });
};
mR.render(/* @__PURE__ */ p0.jsx(pK, {}), document.getElementById("root"));
